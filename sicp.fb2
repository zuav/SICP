<?xml version="1.0" encoding="UTF-8"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:xlink="http://www.w3.org/1999/xlink">
  <description>
    <title-info>
      <genre>comp_programming</genre>
      <author>
        <first-name>Harold</first-name>
        <last-name>Abelson</last-name>
      </author>
      <author>
        <first-name>Gerald</first-name>
        <middle-name>Jay</middle-name>
        <last-name>Sussman</last-name>
      </author>
      <author>
        <first-name>Julie</first-name>
        <last-name>Sussman</last-name>
      </author>
      <book-title>Structure and Interpretation of Computer Programs</book-title>
      <coverpage>
        <image xlink:href="#_0.jpg" />
      </coverpage>
      <lang>eng</lang>
      <keywords>Second Edition</keywords>
    </title-info>
    <document-info>
      <author>
        <nickname>zuav</nickname>
        <email>zuav_at_yandex.ru</email>
      </author>
      <program-used>calibre 0.8.30, Emacs</program-used>
      <date>14.12.2011</date>
      <id>bfb2b9db-2fca-4cce-9b5f-70e6d7219284</id>
      <version>1.0</version>
      <history>
        <p>1.0 - initial fb2 by zuav</p>
      </history>
    </document-info>
  </description>
  <body>
    <section>
      <empty-line /><p> <image xlink:href="#_1.jpg" /></p><empty-line />
    </section>

    <section>
      <empty-line />
      <p><strong>Structure and Interpretation </strong></p>
      <empty-line />
      <p><strong>of Computer Programs</strong></p>

      <p>second edition</p>
      <empty-line />
      <empty-line />
      <empty-line />
      <empty-line />
      <empty-line />
      <p>Harold Abelson and Gerald Jay Sussman</p>
      <empty-line />
      <p>with Julie Sussman</p>
      <empty-line />
      <p>foreword by Alan J. Perlis</p>
      <empty-line />
      <empty-line />
      <empty-line />
      <empty-line />
      <empty-line />
      <empty-line />
      <empty-line />
      <empty-line />
      <p>The MIT Press</p>
      <empty-line />
      <p>Cambridge, Massachusetts     London, England</p>
      <p>McGraw-Hill Book Company</p>
      <empty-line />
      <p>New York     St. Louis     San Francisco    Montreal     Toronto</p>
      <empty-line />
    </section>

    <section>
      <empty-line />
      <p>
        This book is one of a series of texts written by faculty of the
        Electrical Engineering and Computer Science Department at the
        Massachusetts Institute of Technology.  It was edited and produced by
        The MIT Press under a joint production-distribution arrangement with
        the McGraw-Hill Book Company.
      </p>

      <p><strong>Ordering Information:</strong></p>

      <p><emphasis>North America</emphasis></p>
      <empty-line />
      <p>Text orders should be addressed to the McGraw-Hill Book Company.</p>
      <empty-line />
      <p>All other orders should be addressed to The MIT Press.</p>
      <p><emphasis>Outside North America</emphasis></p>
      <empty-line />
      <p>All orders should be addressed to The MIT Press or its local distributor.</p>
      <p>© 1996 by The Massachusetts Institute of Technology</p>
      <empty-line />
      <p>Second edition</p>

      <p>
        All rights reserved.  No part of this book may be reproduced in any
        form or by any electronic or mechanical means (including photocopying,
        recording, or information storage and retrieval) without permission in
        writing from the publisher.
      </p>
      <empty-line />
      <empty-line />
      <p>This work is licensed under a Creative Commons Attribution-Noncommercial 3.0 Unported License.</p>

      <p>
        This book was set by the authors using the LATEX typesetting
        system and was printed and bound in the United States of America.
      </p>

      <p><strong>Library of Congress Cataloging-in-Publication Data</strong></p>

      <p>Abelson, Harold</p>
      <empty-line />
      <p>    Structure and interpretation of computer programs / Harold Abelson</p>
      <empty-line />
      <p>and Gerald Jay Sussman, with Julie Sussman. -- 2nd ed.</p>
      <empty-line />
      <p>    p.   cm. -- (Electrical engineering and computer science</p>
      <empty-line />
      <p>series)</p>
      <empty-line />
      <p>    Includes bibliographical references and index.</p>
      <empty-line />
      <p>    ISBN 0-262-01153-0 (MIT Press hardcover)</p>
      <empty-line />
      <p>    ISBN 0-262-51087-1 (MIT Press paperback)</p>
      <empty-line />
      <p>    ISBN 0-07-000484-6 (McGraw-Hill hardcover)</p>
      <empty-line />
      <p>    1. Electronic digital computers -- Programming.  2. LISP (Computer</p>
      <empty-line />
      <p>program language)    I. Sussman, Gerald Jay.   II. Sussman, Julie.</p>
      <empty-line />
      <p>III. Title.   IV. Series: MIT electrical engineering and computer</p>
      <empty-line />
      <p>science series.</p>
      <empty-line />
      <p>QA76.6.A255          1996</p>
      <empty-line />
      <p>005.13'3 -- dc20              96-17756</p>
      <empty-line />
      <empty-line />
      <p>Fourth printing, 1999</p>
      <empty-line />
      <empty-line />
    </section>

    <section>

      <p>
        This book is dedicated, in respect and admiration, to the spirit
        that lives in the computer.
      </p>
      <empty-line />

      <p>
        "I think that it's extraordinarily important that we in computer
        science keep fun in computing.  When it started out, it was an
        awful lot of fun.  Of course, the paying customers got shafted
        every now and then, and after a while we began to take their
        complaints seriously.  We began to feel as if we really were
        responsible for the successful, error-free perfect use of these
        machines.  I don't think we are.  I think we're responsible for
        stretching them, setting them off in new directions, and keeping
        fun in the house.  I hope the field of computer science never
        loses its sense of fun.  Above all, I hope we don't become
        missionaries.  Don't feel as if you're Bible salesmen.  The
        world has too many of those already.  What you know about
        computing other people will learn.  Don't feel as if the key to
        successful computing is only in your hands.  What's in your
        hands, I think and hope, is intelligence: the ability to see the
        machine as more than when you were first led up to it, that you
        can make it more."
      </p>

      <empty-line />

      <p>Alan J. Perlis (April 1, 1922-February 7, 1990)</p>
    </section>

    <section>
      <title>
        <p>Foreword</p>
      </title>

      <p>
        Educators, generals, dieticians, psychologists, and parents program.
        Armies, students, and some societies are programmed.  An assault on
        large problems employs a succession of programs, most of which spring
        into existence en route.  These programs are rife with issues that
        appear to be particular to the problem at hand.  To appreciate
        programming as an intellectual activity in its own right you must turn
        to computer programming; you must read and write computer
        programs -- many of them.  It doesn't matter much what the programs are
        about or what applications they serve.  What does matter is how well
        they perform and how smoothly they fit with other programs in the
        creation of still greater programs.  The programmer must seek both
        perfection of part and adequacy of collection.  In this book the use
        of "program" is focused on the creation, execution, and study of
        programs written in a dialect of Lisp for execution on a digital
        computer.  Using Lisp we restrict or limit not what we may program,
        but only the notation for our program descriptions.
      </p>

      <p>
        Our traffic with the subject matter of this book involves us with
        three foci of phenomena: the human mind, collections of computer
        programs, and the computer.  Every computer program is a model,
        hatched in the mind, of a real or mental process.  These processes,
        arising from human experience and thought, are huge in number,
        intricate in detail, and at any time only partially understood.  They
        are modeled to our permanent satisfaction rarely by our computer
        programs.  Thus even though our programs are carefully handcrafted
        discrete collections of symbols, mosaics of interlocking functions,
        they continually evolve: we change them as our perception of the model
        deepens, enlarges, generalizes until the model ultimately attains a
        metastable place within still another model with which we struggle.
        The source of the exhilaration associated with computer programming is
        the continual unfolding within the mind and on the computer of
        mechanisms expressed as programs and the explosion of perception they
        generate.  If art interprets our dreams, the computer executes them in
        the guise of programs!
      </p>

      <p>
        For all its power, the computer is a harsh taskmaster.  Its programs
        must be correct, and what we wish to say must be said accurately in
        every detail.  As in every other symbolic activity, we become
        convinced of program truth through argument.  Lisp itself can be
        assigned a semantics (another model, by the way), and if a program's
        function can be specified, say, in the predicate calculus, the proof
        methods of logic can be used to make an acceptable correctness
        argument.  Unfortunately, as programs get large and complicated, as
        they almost always do, the adequacy, consistency, and correctness of
        the specifications themselves become open to doubt, so that complete
        formal arguments of correctness seldom accompany large programs.
        Since large programs grow from small ones, it is crucial that we
        develop an arsenal of standard program structures of whose correctness
        we have become sure -- we call them idioms -- and learn to combine them
        into larger structures using organizational techniques of proven
        value.  These techniques are treated at length in this book, and
        understanding them is essential to participation in the Promethean
        enterprise called programming.  More than anything else, the
        uncovering and mastery of powerful organizational techniques
        accelerates our ability to create large, significant programs.
        Conversely, since writing large programs is very taxing, we are
        stimulated to invent new methods of reducing the mass of function and
        detail to be fitted into large programs.
      </p>

      <p>
        Unlike programs, computers must obey the laws of physics.  If they
        wish to perform rapidly -- a few nanoseconds per state change -- they
        must transmit electrons only small distances (at most 1 <sup>1</sup>/2
        feet).  The heat generated by the huge number of devices so
        concentrated in space has to be removed.  An exquisite engineering art
        has been developed balancing between multiplicity of function and
        density of devices.  In any event, hardware always operates at a level
        more primitive than that at which we care to program.  The processes
        that transform our Lisp programs to "machine" programs are
        themselves abstract models which we program.  Their study and creation
        give a great deal of insight into the organizational programs
        associated with programming arbitrary models.  Of course the computer
        itself can be so modeled.  Think of it: the behavior of the smallest
        physical switching element is modeled by quantum mechanics described
        by differential equations whose detailed behavior is captured by
        numerical approximations represented in computer programs executing on
        computers composed of ...!
      </p>

      <p>
        It is not merely a matter of tactical convenience to separately
        identify the three foci.  Even though, as they say, it's all in the
        head, this logical separation induces an acceleration of symbolic
        traffic between these foci whose richness, vitality, and potential is
        exceeded in human experience only by the evolution of life itself.  At
        best, relationships between the foci are metastable.  The computers
        are never large enough or fast enough.  Each breakthrough in hardware
        technology leads to more massive programming enterprises, new
        organizational principles, and an enrichment of abstract models.
        Every reader should ask himself periodically "Toward what end, toward
        what end?" -- but do not ask it too often lest you pass up the fun of
        programming for the constipation of bittersweet philosophy.
      </p>
      
      <p>
        Among the programs we write, some (but never enough) perform a precise
        mathematical function such as sorting or finding the maximum of a
        sequence of numbers, determining primality, or finding the square
        root.  We call such programs algorithms, and a great deal is known of
        their optimal behavior, particularly with respect to the two important
        parameters of execution time and data storage requirements.  A
        programmer should acquire good algorithms and idioms.  Even though
        some programs resist precise specifications, it is the responsibility
        of the programmer to estimate, and always to attempt to improve, their
        performance.
      </p>
      
      <p>
        Lisp is a survivor, having been in use for about a quarter of a
        century.  Among the active programming languages only Fortran has had
        a longer life.  Both languages have supported the programming needs of
        important areas of application, Fortran for scientific and engineering
        computation and Lisp for artificial intelligence.  These two areas
        continue to be important, and their programmers are so devoted to
        these two languages that Lisp and Fortran may well continue in active
        use for at least another quarter-century.
      </p>
      
      <p>
        Lisp changes.  The Scheme dialect used in this text has evolved from
        the original Lisp and differs from the latter in several important
        ways, including static scoping for variable binding and permitting
        functions to yield functions as values.  In its semantic structure
        Scheme is as closely akin to Algol 60 as to early Lisps.  Algol 60,
        never to be an active language again, lives on in the genes of Scheme
        and Pascal.  It would be difficult to find two languages that are the
        communicating coin of two more different cultures than those gathered
        around these two languages.  Pascal is for building
        pyramids -- imposing, breathtaking, static structures built by armies
        pushing heavy blocks into place.  Lisp is for building
        organisms -- imposing, breathtaking, dynamic structures built by squads
        fitting fluctuating myriads of simpler organisms into place.  The
        organizing principles used are the same in both cases, except for one
        extraordinarily important difference: The discretionary exportable
        functionality entrusted to the individual Lisp programmer is more than
        an order of magnitude greater than that to be found within Pascal
        enterprises.  Lisp programs inflate libraries with functions whose
        utility transcends the application that produced them.  The list,
        Lisp's native data structure, is largely responsible for such growth
        of utility.  The simple structure and natural applicability of lists
        are reflected in functions that are amazingly nonidiosyncratic.  In
        Pascal the plethora of declarable data structures induces a
        specialization within functions that inhibits and penalizes casual
        cooperation.  It is better to have 100 functions operate on one data
        structure than to have 10 functions operate on 10 data structures.  As
        a result the pyramid must stand unchanged for a millennium; the
        organism must evolve or perish.
      </p>
      
      <p>
        To illustrate this difference, compare the treatment of material and
        exercises within this book with that in any first-course text using
        Pascal.  Do not labor under the illusion that this is a text
        digestible at MIT only, peculiar to the breed found there.  It is
        precisely what a serious book on programming Lisp must be, no matter
        who the student is or where it is used.
      </p>

      <p>
        Note that this is a text about programming, unlike most Lisp books,
        which are used as a preparation for work in artificial intelligence.
        After all, the critical programming concerns of software engineering
        and artificial intelligence tend to coalesce as the systems under
        investigation become larger.  This explains why there is such growing
        interest in Lisp outside of artificial intelligence.
      </p>

      <p>
        As one would expect from its goals, artificial intelligence research
        generates many significant programming problems.  In other
        programming cultures this spate of problems spawns new languages.
        Indeed, in any very large programming task a useful organizing
        principle is to control and isolate traffic within the task modules
        via the invention of language.  These languages tend to become less
        primitive as one approaches the boundaries of the system where we
        humans interact most often.  As a result, such systems contain complex
        language-processing functions replicated many times.  Lisp has such a
        simple syntax and semantics that parsing can be treated as an
        elementary task.  Thus parsing technology plays almost no role in Lisp
        programs, and the construction of language processors is rarely an
        impediment to the rate of growth and change of large Lisp systems.
        Finally, it is this very simplicity of syntax and semantics that is
        responsible for the burden and freedom borne by all Lisp programmers.
        No Lisp program of any size beyond a few lines can be written without
        being saturated with discretionary functions.  Invent and fit; have
        fits and reinvent!  We toast the Lisp programmer who pens his thoughts
        within nests of parentheses.
      </p>

      <empty-line />
      <p>Alan J. Perlis</p>
      <empty-line />
      <p>New Haven, Connecticut</p>

    </section>

    <section>
      <title>
        <p>Preface to the Second Edition</p>
      </title>

      <epigraph>
        <p>
          Is it possible that software is not like anything else, that
          it is meant to be discarded: that the whole point is to always
          see it as a soap bubble?
        </p>
        <text-author>Alan J. Perlis</text-author>
      </epigraph>

      <p>
        The material in this book has been the basis of MIT's entry-level
        computer science subject since 1980.  We had been teaching this
        material for four years when the first edition was published, and
        twelve more years have elapsed until the appearance of this second
        edition.  We are pleased that our work has been widely adopted and
        incorporated into other texts.  We have seen our students take the
        ideas and programs in this book and build them in as the core of new
        computer systems and languages.  In literal realization of an ancient
        Talmudic pun, our students have become our builders.  We are lucky to
      have such capable students and such accomplished builders.</p>

      <p>
        In preparing this edition, we have incorporated hundreds of 
        clarifications suggested by our own teaching experience and the
        comments of colleagues at MIT and elsewhere.  We have redesigned
        most of the major programming systems in the book, including
        the generic-arithmetic system, the interpreters, the register-machine
        simulator, and the compiler; and we have rewritten all the program
        examples to ensure that any Scheme implementation conforming to
      the IEEE Scheme standard (IEEE 1990) will be able to run the code.</p>

      <p>
        This edition emphasizes several new themes.  The most important
        of these is the central role played by different approaches to
        dealing with time in computational models: objects with state,
        concurrent programming, functional programming, lazy evaluation,
        and nondeterministic programming.  We have included new sections on 
        concurrency and nondeterminism, and we have tried to integrate this
      theme throughout the book.</p>

      <p>
        The first edition of the book closely followed the syllabus of our MIT
        one-semester subject.  With all the new material in the second
        edition, it will not be possible to cover everything in a single
        semester, so the instructor will have to pick and choose.  In our own
        teaching, we sometimes skip the section on logic programming
        (section 4.4), we have students use the
        register-machine simulator but we do not cover its implementation
        (section 5.2), and we give only a cursory overview of
        the compiler (section 5.5).  Even so, this is still
        an intense course.  Some instructors may wish to cover only the first
        three or four chapters, leaving the other material for subsequent
      courses.</p>

      <p>
        The World-Wide-Web site www-mitpress.mit.edu/sicp
        provides support for users of this book.
        This includes programs from the book,
        sample programming assignments, supplementary materials,
        and downloadable implementations of the Scheme dialect of Lisp.
      </p>

    </section>

    <section>
      <title>
        <p>Preface to the First Edition</p>
      </title>

      <epigraph>
        <p>
          A computer is like a violin.  You can imagine a novice trying first a
          phonograph and then a violin.  The latter, he says, sounds terrible.
          That is the argument we have heard from our humanists and most of our
          computer scientists.  Computer programs are good, they say, for
          particular purposes, but they aren't flexible.  Neither is a violin,
          or a typewriter, until you learn how to use it.
        </p>

        <text-author>
          Marvin Minsky, "Why Programming Is a Good
          Medium for Expressing Poorly-Understood and Sloppily-Formulated
          Ideas"
        </text-author>
      </epigraph>

      <p>
        "The Structure and Interpretation of Computer Programs" is the
        entry-level subject in computer science at the Massachusetts Institute
        of Technology.  It is required of all students at MIT who major
        in electrical engineering or in computer science, as one-fourth of the
        "common core curriculum", which also includes two subjects on
        circuits and linear systems and a subject on the design of digital
        systems.  We have been involved in the development of this subject
        since 1978, and we have taught this material in its present form since
        the fall of 1980 to between 600 and 700 students each year.  Most of
        these students have had little or no prior formal training in
        computation, although many have played with computers a bit and a few
      have had extensive programming or hardware-design experience.</p>

      <p>
        Our design of this introductory computer-science subject reflects two
        major concerns.  First, we want to establish the idea that a computer
        language is not just a way of getting a computer to perform operations
        but rather that it is a novel formal medium for expressing ideas about
        methodology.  Thus, programs must be written for people to read, and
        only incidentally for machines to execute.  Second, we believe that
        the essential material to be addressed by a subject at this level is
        not the syntax of particular programming-language constructs, nor
        clever algorithms for computing particular functions efficiently, nor
        even the mathematical analysis of algorithms and the foundations of
        computing, but rather the techniques used to control the intellectual
      complexity of large software systems.</p>

      <p>
        Our goal is that students who complete this subject should have a good
        feel for the elements of style and the aesthetics of programming.
        They should have command of the major techniques for controlling
        complexity in a large system. They should be capable of reading a
        50-page-long program, if it is written in an exemplary style. They
        should know what not to read, and what they need not understand at any
        moment.  They should feel secure about modifying a program, retaining
      the spirit and style of the original author.</p>

      <p>
        These skills are by no means unique to computer programming.  The
        techniques we teach and draw upon are common to all of engineering
        design.  We control complexity by building abstractions that hide
        details when appropriate.  We control complexity by establishing
        conventional interfaces that enable us to construct systems by
        combining standard, well-understood pieces in a "mix and match" way.
        We control complexity by establishing new languages for describing a
        design, each of which emphasizes particular aspects of the design and
      deemphasizes others.</p>

      <p>
        Underlying our approach to this subject is our conviction that
        "computer science" is not a science and that its significance has
        little to do with computers.  The computer revolution is a revolution
        in the way we think and in the way we express what we think.  The
        essence of this change is the emergence of what might best be called
        <emphasis>procedural epistemology</emphasis> -- the study of the structure of
        knowledge from an imperative point of view, as opposed to the more
        declarative point of view taken by classical mathematical subjects.
        Mathematics provides a framework for dealing precisely with notions of
        "what is."  Computation provides a framework for dealing precisely
      with notions of "how to."</p>

      <p>
        In teaching our material we use a dialect of the programming language
        Lisp.  We never formally teach the language, because we don't have to.
        We just use it, and students pick it up in a few days.  This is one
        great advantage of Lisp-like languages: They have very few ways of
        forming compound expressions, and almost no syntactic structure.  All
        of the formal properties can be covered in an hour, like the rules of
        chess.  After a short time we forget about syntactic details of the
        language (because there are none) and get on with the real
        issues -- figuring out what we want to compute, how we will decompose
        problems into manageable parts, and how we will work on the parts.
        Another advantage of Lisp is that it supports (but does not enforce)
        more of the large-scale strategies for modular decomposition of
        programs than any other language we know.  We can make procedural and
        data abstractions, we can use higher-order functions to capture common
        patterns of usage, we can model local state using assignment and data
        mutation, we can link parts of a program with streams and delayed
        evaluation, and we can easily implement embedded languages.  All of
        this is embedded in an interactive environment with excellent support
        for incremental program design, construction, testing, and debugging.
        We thank all the generations of Lisp wizards, starting with John
        McCarthy, who have fashioned a fine tool of unprecedented power and
      elegance.</p>

      <p>
        Scheme, the dialect of Lisp that we use, is an attempt to bring
        together the power and elegance of Lisp and Algol.  From Lisp we take
        the metalinguistic power that derives from the simple syntax, the
        uniform representation of programs as data objects, and the
        garbage-collected heap-allocated data.  From Algol we take lexical
        scoping and block structure, which are gifts from the pioneers of
        programming-language design who were on the Algol committee.  We wish
        to cite John Reynolds and Peter Landin for their insights into the
        relationship of Church's lambda calculus to the structure of
        programming languages.  We also recognize our debt to the
        mathematicians who scouted out this territory decades before computers
        appeared on the scene.  These pioneers include Alonzo Church, Barkley
        Rosser, Stephen Kleene, and Haskell Curry.
      </p>
        
    </section>

    <section>
      <title>
        <p>Acknowledgments</p>
      </title>

      <p>
        We would like to thank the many people who have helped us develop thise
        book and this curriculum.
      </p>

      <p>
        Our subject is a clear intellectual descendant of "6.231", a
        wonderful subject on programming linguistics and the lambda calculus
        taught at MIT in the late 1960s by Jack Wozencraft and Arthur Evans,
      Jr.</p>

      <p>
        We owe a great debt to Robert Fano, who reorganized MIT's introductory
        curriculum in electrical engineering and computer science to emphasize
        the principles of engineering design.  He led us in starting out on
        this enterprise and wrote the first set of subject notes from which
      this book evolved.</p>

      <p>
        Much of the style and aesthetics of programming that we try to teach
        were developed in conjunction with Guy Lewis Steele Jr., who
        collaborated with Gerald Jay Sussman in the initial development of the
        Scheme language.  In addition, David Turner, Peter Henderson, Dan
        Friedman, David Wise, and Will Clinger have taught us many of the
        techniques of the functional programming community that appear in this
      book.</p>

      <p>
        Joel Moses taught us about structuring large systems.  His experience
        with the Macsyma system for symbolic computation provided the insight
        that one should avoid complexities of control and concentrate on
        organizing the data to reflect the real structure of the world being
      modeled.</p>

      <p>
        Marvin Minsky and Seymour Papert formed many of our attitudes about
        programming and its place in our intellectual lives.  To them we owe
        the understanding that computation provides a means of expression for
        exploring ideas that would otherwise be too complex to deal with
        precisely.  They emphasize that a student's ability to write and
        modify programs provides a powerful medium in which exploring becomes
      a natural activity.</p>

      <p>
        We also strongly agree with Alan Perlis that programming is lots of
        fun and we had better be careful to support the joy of programming.
        Part of this joy derives from observing great masters at work.  We are
        fortunate to have been apprentice programmers at the feet of Bill
      Gosper and Richard Greenblatt.</p>

      <p>
        It is difficult to identify all the people who have contributed to the
        development of our curriculum.  We thank all the lecturers, recitation
        instructors, and tutors who have worked with us over the past fifteen
        years and put in many extra hours on our subject, especially Bill
        Siebert, Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric
        Grimson, Rod Brooks, Lynn Stein, and Peter Szolovits.
        We would like to specially acknowledge the outstanding teaching
        contributions of Franklyn Turbak, now at Wellesley; his work
        in undergraduate instruction set a standard that we can
        all aspire to.
        We are grateful to Jerry Saltzer and Jim Miller for
        helping us grapple with the mysteries of concurrency, and to
        Peter Szolovits and David McAllester for their contributions
      to the exposition of nondeterministic evaluation in chapter 4.</p>

      <p>
        Many people have put in significant effort presenting this material at
        other universities.  Some of the people we have worked closely with
        are Jacob Katzenelson at the Technion, Hardy Mayer at the University
        of California at Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue,
        and Jan Komorowski at the Norwegian University of Science and
        Technology.  We are exceptionally proud of our colleagues who have
        received major teaching awards for their adaptations of this subject
        at other universities, including Kenneth Yip at Yale, Brian Harvey at
        the University of California at Berkeley, and Dan Huttenlocher at
      Cornell.</p>

      <p>
        Al Moyé arranged for us to teach this material to engineers at
        Hewlett-Packard, and for the production of videotapes of these
        lectures.
        We would like to thank the talented instructors -- in
        particular Jim Miller, Bill Siebert, and Mike Eisenberg -- who have
        designed continuing education courses incorporating these tapes and
      taught them at universities and industry all over the world.</p>

      <p>
        Many educators in other countries have put in significant
        work translating the first edition.
        Michel Briand, Pierre Chamard, and André Pic produced a French edition;
        Susanne Daniels-Herold produced a German
        edition; and Fumio Motoyoshi produced a Japanese edition.
        We do not know who produced the Chinese edition,
        but we consider it an honor to have been selected as the
      subject of an "unauthorized" translation.</p>

      <p>
        It is hard to enumerate all the people who have made technical
        contributions to the development of the Scheme systems we use for
        instructional purposes.  In addition to Guy Steele, principal wizards
        have included Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas,
        and Stephen Adams.  Others who have put in significant time are
        Richard Stallman, Alan Bawden, Kent Pitman, Jon Taft, Neil Mayle, John
        Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma
        Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss,
        Todd Cass, Patrick O'Donnell, Kevin Theobald, Daniel Weise, Kenneth
        Sinclair, Anthony Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth
      Shyu.</p>

      <p>
        Beyond the MIT implementation, we would like to thank the many people
        who worked on the IEEE Scheme standard, including William Clinger and
        Jonathan Rees, who edited the R<sup>4</sup>RS, and Chris Haynes, David
      Bartley, Chris Hanson, and Jim Miller, who prepared the IEEE standard.</p>

      <p>
        Dan Friedman has been a long-time leader of the Scheme community.
        The community's broader work goes beyond issues of language design to
        encompass significant educational innovations, such as the high-school
        curriculum based on EdScheme by Schemer's Inc., and the wonderful
      books by Mike Eisenberg and by Brian Harvey and Matthew Wright.</p>

      <p>
        We appreciate the work of those who contributed to making this a real
        book, especially Terry Ehling, Larry Cohen, and Paul Bethge at the MIT
        Press.  Ella Mazel found the wonderful cover image.  For the second
        edition we are particularly grateful to Bernard and Ella Mazel for
        help with the book design, and to David Jones, TEX wizard
        extraordinaire.  We also are indebted to those readers who made
        penetrating comments on the new draft: Jacob Katzenelson, Hardy
        Mayer, Jim Miller, and especially Brian Harvey, who did unto this book
      as Julie did unto his book <emphasis>Simply Scheme</emphasis>.</p>

      <p> Finally, we would like to acknowledge the support of the organizations that 
      have encouraged this work over the years, including support from Hewlett-Packard, 
      made possible by Ira Goldstein and Joel Birnbaum, and support from DARPA, made 
      possible by Bob Kahn.</p>
    </section>

    <section>
      <title>
        <p>Chapter 1</p>
        <p>Building Abstractions with Procedures</p>
      </title>

      <epigraph>
        <p>
          The acts of the mind, wherein it exerts its power over simple ideas,
          are chiefly these three: 1. Combining several simple ideas into one
          compound one, and thus all complex ideas are made.  2. The second is
          bringing two ideas, whether simple or complex, together, and setting
          them by one another so as to take a view of them at once, without
          uniting them into one, by which it gets all its ideas of relations.
          3.  The third is separating them from all other ideas that accompany
          them in their real existence: this is called abstraction, and thus all
          its general ideas are made.
        </p>
       
        <text-author>
          Marvin>John Locke, <emphasis>An Essay Concerning Human
          Understanding</emphasis> (1690)
        </text-author>
      </epigraph>

      <p>
        We are about to study the idea of a <emphasis>computational process</emphasis>.
        Computational processes are abstract beings that inhabit computers.
        As they evolve, processes manipulate other abstract things called <emphasis>data</emphasis>.  The evolution of a process is directed by a pattern of rules
        called a <emphasis>program</emphasis>.  People create programs to direct processes.
      In effect, we conjure the spirits of the computer with our spells.</p>

      <p>
        A computational process is indeed much like a sorcerer's idea of a
        spirit.  It cannot be seen or touched.  It is not composed of matter
        at all.  However, it is very real.  It can perform intellectual work.
        It can answer questions.  It can affect the world by disbursing money
        at a bank or by controlling a robot arm in a factory.  The programs we
        use to conjure processes are like a sorcerer's spells.  They are
        carefully composed from symbolic expressions in arcane and esoteric
        <emphasis>programming languages</emphasis> that prescribe the tasks we want our
      processes to perform.</p>

      <p>
        A computational process, in a correctly working computer, executes
        programs precisely and accurately.  Thus, like the sorcerer's
        apprentice, novice programmers must learn to understand and to
        anticipate the consequences of their conjuring.  Even small errors
        (usually called <emphasis>bugs</emphasis> or <emphasis>glitches</emphasis>) in programs can have
      complex and unanticipated consequences.</p>

      <p>
        Fortunately, learning to program is considerably less dangerous than
        learning sorcery, because the spirits we deal with are conveniently
        contained in a secure way.  Real-world programming, however,
        requires care, expertise, and wisdom.  A small bug in a computer-aided
        design program, for example, can lead to the catastrophic collapse of
      an airplane or a dam or the self-destruction of an industrial robot.</p>

      <p>
        Master software engineers have the ability to organize programs so
        that they can be reasonably sure that the resulting processes will
        perform the tasks intended.  They can visualize the behavior of their
        systems in advance.  They know how to structure programs so that
        unanticipated problems do not lead to catastrophic consequences, and
        when problems do arise, they can <emphasis>debug</emphasis> their programs.  Well-designed
        computational systems, like well-designed automobiles or nuclear
        reactors, are designed in a modular manner, so that the parts can be
      constructed, replaced, and debugged separately.</p>

      <subtitle>Programming in Lisp</subtitle>

      <p>
        We need an appropriate language for describing processes, and we will
        use for this purpose the programming language Lisp.  Just as our
        everyday thoughts are usually expressed in our natural language (such
        as English, French, or Japanese), and descriptions of quantitative
        phenomena are expressed with mathematical notations, our procedural
        thoughts will be expressed in Lisp.  Lisp was invented in the late
        1950s as a formalism for reasoning about the use of certain kinds of
        logical expressions, called <emphasis>recursion equations</emphasis>, as a model for
        computation.  The language was conceived by John McCarthy and is based
        on his paper "Recursive Functions of Symbolic Expressions and Their
      Computation by Machine" (McCarthy 1960).</p>

      <p>
        Despite its inception as a mathematical formalism, Lisp is a practical
        programming language.  A Lisp <emphasis>interpreter</emphasis> is a machine that
        carries out processes described in the Lisp language.  The first Lisp
        interpreter was implemented by McCarthy with the help of colleagues
        and students in the Artificial Intelligence Group of the MIT Research
        Laboratory of Electronics and in the MIT Computation
        Center.<sup>1</sup> Lisp, whose name is an acronym for LISt Processing,
        was designed to provide symbol-manipulating capabilities for
        attacking programming problems such as the symbolic differentiation
        and integration of algebraic expressions.  It included for this
        purpose new data objects known as atoms and lists, which most
      strikingly set it apart from all other languages of the period.</p>

      <p>
        Lisp was not the product of a concerted design effort.  Instead, it
        evolved informally in an experimental manner in response to users'
        needs and to pragmatic implementation considerations.  Lisp's informal
        evolution has continued through the years, and the community of Lisp
        users has traditionally resisted attempts to promulgate any
        "official" definition of the language.  This evolution, together
        with the flexibility and elegance of the initial conception, has
        enabled Lisp, which is the second oldest language in widespread use
        today (only Fortran is older), to continually adapt to encompass the
        most modern ideas about program design.  Thus, Lisp is by now a family
        of dialects, which, while sharing most of the original features, may
        differ from one another in significant ways.  The dialect of Lisp used
      in this book is called Scheme.<sup>2</sup></p>

      <p>
        Because of its experimental character and its emphasis on symbol
        manipulation, Lisp was at first very inefficient for numerical
        computations, at least in comparison with Fortran.  Over the years,
        however, Lisp compilers have been developed that translate programs
        into machine code that can perform numerical computations reasonably
        efficiently.  And for special applications, Lisp has been used with
        great effectiveness.<sup>3</sup>  Although Lisp has not yet overcome its old reputation
        as hopelessly inefficient, Lisp is now used in many applications where
        efficiency is not the central concern.  For example, Lisp has become
        a language of choice for operating-system shell languages and for
      extension languages for editors and computer-aided design systems.</p>

      <p>
        If Lisp is not a mainstream language, why are we using it as the
        framework for our discussion of programming?  Because the language
        possesses unique features that make it an excellent medium for
        studying important programming constructs and data structures and for
        relating them to the linguistic features that support them.  The most
        significant of these features is the fact that Lisp descriptions of
        processes, called <emphasis>procedures</emphasis>, can
        themselves be represented and manipulated as Lisp data.  The
        importance of this is that there are powerful program-design
        techniques that rely on the ability to blur the traditional
        distinction between "passive" data and "active" processes.  As we
        shall discover, Lisp's flexibility in handling procedures as data
        makes it one of the most convenient languages in existence for
        exploring these techniques.  The ability to represent procedures as
        data also makes Lisp an excellent language for writing programs that
        must manipulate other programs as data, such as the interpreters and
        compilers that support computer languages.  Above and beyond these
        considerations, programming in Lisp is great fun.</p><empty-line /><empty-line /><empty-line /><p><sup>1</sup> The <emphasis>Lisp 1 Programmer's Manual</emphasis> appeared in
        1960, and the <emphasis>Lisp 1.5 Programmer's Manual</emphasis> (McCarthy 1965)
        was published in 1962.  The early history of Lisp is described in
        McCarthy 1978.</p>

        <p><sup>2</sup> The two dialects in which most
        major Lisp programs of the 1970s were written are MacLisp (Moon 1978;
        Pitman 1983), developed at the MIT Project MAC, and Interlisp
        (Teitelman 1974), developed at Bolt Beranek and Newman Inc. and the
        Xerox Palo Alto Research Center.  Portable Standard Lisp (Hearn 1969;
        Griss 1981) was a Lisp dialect designed to be easily portable
        between different machines.  MacLisp spawned a number of subdialects,
        such as Franz Lisp, which was developed at the University of
        California at Berkeley, and Zetalisp (Moon 1981), which was based on a
        special-purpose processor designed at the MIT Artificial Intelligence
        Laboratory to run Lisp very efficiently.  The Lisp dialect used in
        this book, called Scheme (Steele 1975), was invented in 1975 by Guy
        Lewis Steele Jr. and Gerald Jay Sussman of the MIT Artificial
        Intelligence Laboratory and later reimplemented for instructional use
        at MIT.  Scheme became an IEEE standard in 1990 (IEEE 1990).  The
        Common Lisp dialect (Steele 1982, Steele 1990) was developed by the
        Lisp community to combine features from the earlier Lisp dialects
        to make an industrial standard for Lisp.  Common Lisp became an ANSI
        standard in 1994 (ANSI 1994).</p>

        <p>
          <sup>3</sup> One such special application was a
          breakthrough computation of scientific importance -- an integration of
          the motion of the Solar System that extended previous results by
          nearly two orders of magnitude, and demonstrated that the dynamics of
          the Solar System is chaotic.  This computation was made possible by
          new integration algorithms, a special-purpose compiler, and a
          special-purpose computer all implemented with the aid of software
          tools written in Lisp (Abelson et al. 1992; Sussman and
          Wisdom 1992).
        </p>
        
        <section>
         <title>
           <p>1.1 The Elements of Programming</p>
         </title>

<p>
A powerful programming language is more than just a means for
instructing a computer to perform tasks.  The language also serves as
a framework within which we organize our ideas about processes.  Thus,
when we describe a language, we should pay particular attention to the
means that the language provides for combining simple ideas to form
more complex ideas.  Every powerful language has three mechanisms for
accomplishing this:</p>

<p><strong>primitive expressions</strong>, which represent the simplest
entities the language is concerned with,</p>

<p><strong>means of combination</strong>, by which compound
elements are built from simpler ones, and</p>

<p><strong>means of abstraction</strong>, by
which compound elements can be named and manipulated as units.</p>

<p>
In programming, we deal with two kinds of elements: procedures and
data. (Later we will discover that they are really not so distinct.)
Informally, data is "stuff" that we want to manipulate, and
procedures are descriptions of the rules for manipulating the data.
Thus, any powerful programming language should be able to describe
primitive data and primitive procedures and should have methods for
combining and abstracting procedures and data.</p>

<p>
In this chapter we will deal only with simple numerical data so that
we can focus on the rules for building procedures.<sup>4</sup> In later chapters we will see that
these same rules allow us to build procedures to manipulate compound
data as well.</p>

<section>
  <title>
    <p>1.1.1 Expressions</p>
  </title>

<p>
One easy way to get started at programming is to examine some typical
interactions with an interpreter for the Scheme dialect of Lisp.
Imagine that you are sitting at a computer terminal.  You type an
<emphasis>expression</emphasis>, and the interpreter responds by displaying the result of
its <emphasis>evaluating</emphasis> that expression.</p>

<p>
One kind of primitive expression you might type is a number.  (More
precisely, the expression that you type consists of the numerals that
represent the number in base 10.)  If you present Lisp with
a number</p>

<p>486</p>

<empty-line />

<p>the interpreter will respond by printing<sup>5</sup></p>

<p><emphasis>486</emphasis></p>
<empty-line />
<empty-line />

<p>
Expressions representing numbers may be combined with an expression
representing a primitive procedure (such as + or *) to form a
compound expression that represents the
application of the procedure to those numbers.  For example:</p>

<p>(+ 137 349)</p>
<empty-line />
<p><emphasis>486</emphasis></p>
<empty-line />
<p>(- 1000 334)</p>
<empty-line />
<p><emphasis>666</emphasis></p>
<empty-line />
<p>(* 5 99)</p>
<empty-line />
<p><emphasis>495</emphasis></p>
<empty-line />
<p>(/ 10 5)</p>
<empty-line />
<p><emphasis>2</emphasis></p>
<empty-line />
<p>(+ 2.7 10)</p>
<empty-line />
<p><emphasis>12.7</emphasis></p>
<empty-line />
<empty-line />

<p>
Expressions such as these, formed by delimiting a list of expressions
within parentheses in order to denote procedure application,
are called <emphasis>combinations</emphasis>.  The leftmost
element in the list is called the <emphasis>operator</emphasis>, and the other
elements are called <emphasis>operands</emphasis>.  The value of a combination is
obtained by applying the procedure specified by the operator to the
<emphasis>arguments</emphasis> that are the values of the operands.</p>

<p>
The convention of placing the operator to the left of the operands is
known as <emphasis>prefix notation</emphasis>, and it may be somewhat confusing at
first because it departs significantly from the customary mathematical
convention.  Prefix notation has several advantages, however.  One of
them is that it can accommodate procedures that may take an arbitrary
number of arguments, as in the following examples:</p>

<p>(+ 21 35 12 7)</p><empty-line /><p><emphasis>75</emphasis></p><empty-line /><empty-line /><p>
(* 25 4 12)</p><empty-line /><p><emphasis>1200</emphasis></p><empty-line /><p>
No ambiguity can arise, because the operator is always the leftmost
element and the entire combination is delimited by the
parentheses.</p>

<p>
A second advantage of prefix notation is that it extends in a
straightforward way to allow combinations to be <emphasis>nested</emphasis>, that is,
to have combinations whose elements are themselves
combinations:</p>

<p>(+ (* 3 5) (- 10 6))</p><empty-line /><p><emphasis>19</emphasis></p><empty-line /><empty-line /><p>

There is no limit (in principle) to the depth of such nesting and to
the overall complexity of the expressions that the Lisp interpreter
can evaluate.
It is we humans who get confused by still relatively
simple expressions such as</p>

<p>(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))</p><empty-line /><p>
which the interpreter would readily evaluate to be 57.  We can help
ourselves by writing such an expression in the form</p>

<p>(+ (* 3</p><empty-line /><p>
      (+ (* 2 4)</p><empty-line /><p>
         (+ 3 5)))</p><empty-line /><p>
   (+ (- 10 7)</p><empty-line /><p>
      6))</p>
<empty-line />

<p>
following a formatting convention known as <emphasis>pretty-printing</emphasis>, in
which each long combination is written so that the operands are
aligned vertically.  The resulting indentations display clearly the
structure of the expression.<sup>6</sup></p>

<p>
Even with complex expressions, the interpreter always operates in the
same basic cycle: It reads an expression from the terminal, 
evaluates the expression, and prints the result.
This mode of operation is often expressed by saying that the
interpreter runs in a <emphasis>read-eval-print loop</emphasis>.
Observe in particular that it is not necessary to explicitly
instruct the interpreter to print the value of the expression.<sup>7</sup></p>

</section>

<section>
  <title>
    <p>1.1.2 Naming and the Environment</p>
  </title>

  <p>
A critical aspect of a programming language is the means it provides
for using names to refer to computational objects.  We say that the
name identifies a <emphasis>variable</emphasis> whose <emphasis>value</emphasis> is the object.</p>

<p>
In the Scheme dialect of Lisp, we
name things with define.  Typing</p>

<p>(define size 2)</p><empty-line /><p>
causes the interpreter to associate the value 2 with the
name size.<sup>8</sup>
Once the name size has been associated with the number 2, we can 
refer to the value 2 by name:</p>

<p>size</p><empty-line /><p><emphasis>2</emphasis></p><empty-line /><p>
(* 5 size)</p><empty-line /><p><emphasis>10</emphasis></p><empty-line /><empty-line /><p>

Here are further examples of the use of define:</p>

<p>(define pi 3.14159)</p><empty-line /><p>
(define radius 10)</p><empty-line /><p>
(* pi (* radius radius))</p><empty-line /><p><emphasis>314.159</emphasis></p><empty-line /><p>
(define circumference (* 2 pi radius))</p><empty-line /><p>
circumference</p><empty-line /><p><emphasis>62.8318</emphasis></p><empty-line /><empty-line /><p>

Define is our language's
simplest means of abstraction, for it allows us to use simple names to
refer to the results of compound operations, such as the
circumference computed above.
In general, computational objects may have very complex
structures, and it would be extremely inconvenient to have to remember
and repeat their details each time we want to use them.  Indeed,
complex programs are constructed by building, step by step,
computational objects of increasing complexity. The
interpreter makes this step-by-step program construction particularly
convenient because name-object associations can be created
incrementally in successive interactions.  This feature encourages the
incremental development and testing of programs and is largely
responsible for the fact that a Lisp program usually consists of a large
number of relatively simple procedures.</p>

<p>

It should be clear that the possibility of associating values with
symbols and later retrieving them means that the interpreter must
maintain some sort of memory that keeps track of the name-object
pairs.  This memory is called the <emphasis>environment</emphasis> (more precisely
the <emphasis>global environment</emphasis>, since we will see later that a
computation may involve a number of different
environments).<sup>9</sup></p>

</section>

<section>
  <title>
    <p>1.1.3 Evaluating Combinations</p>
  </title>

<p>
One of our goals in this chapter is to isolate issues about thinking
procedurally.  As a case in point, let us consider that, in evaluating
combinations, the interpreter is itself following a procedure.</p>

<p>To evaluate a combination, do the following:</p><empty-line /><p>1.  Evaluate the subexpressions of the combination.</p>

<p>2.  Apply the procedure that is the value of the leftmost 
subexpression (the operator) to the arguments that are the values of
the other subexpressions (the operands).</p>

<p>

Even this simple rule illustrates some important points about
processes in general.  First, observe that the first step dictates
that in order to accomplish the evaluation process for a combination
we must first perform the evaluation process on each element of the
combination.  Thus, the evaluation rule is <emphasis>recursive</emphasis> in nature;
that is, it includes, as one of its steps, the need to invoke the rule
itself.<sup>10</sup></p>

<p>

Notice how succinctly the idea of recursion can be used to express
what, in the case of a deeply nested combination, would otherwise be
viewed as a rather complicated process.  For example, evaluating</p>

<p>(* (+ 2 (* 4 6))</p><empty-line /><p>
   (+ 3 5 7))</p><empty-line /><p>
requires that the evaluation rule be applied to four different
combinations.  We can obtain a picture of this process by representing
the combination in the form of a tree, as shown in
figure 1.1.  Each combination is represented by a
node with branches corresponding to the operator and the
operands of the combination stemming from it.
The terminal nodes (that is, nodes with
no branches stemming from them) represent either operators or numbers.
Viewing evaluation in terms of the tree, we can imagine that the
values of the operands percolate upward, starting from the terminal
nodes and then combining at higher and higher levels.  In general, we
shall see that recursion is a very powerful technique for dealing with
hierarchical, treelike objects.  In fact, the "percolate values
upward" form of the evaluation rule is an example of a general kind
of process known as <emphasis>tree accumulation</emphasis>.</p>

<p><image xlink:href="#_2.jpg" /></p>

<p><strong>Figure 1.1:</strong>  Tree representation, showing the value of each subcombination.</p>

<p>

Next, observe that the repeated application of the first step brings
us to the point where we need to evaluate, not combinations, but
primitive expressions such as numerals, built-in operators, or other
names.  We take care of the primitive cases by stipulating that</p>

<p>the values of numerals are the numbers that they name,</p>

<p>the values of built-in operators are the machine
instruction sequences that carry out the corresponding operations, and</p>

<p>the values of other names are the objects associated 
with those names in the environment.</p>

<p>

We may regard the second rule as a special case of the third one by
stipulating that symbols such as + and * are also included
in the global environment, and are associated with the sequences of
machine instructions that are their "values."  The key point to
notice is the role of the environment in determining the meaning of
the symbols in expressions.  In an interactive language such as
Lisp, it is meaningless to speak of the value of an expression such as
(+ x 1) without specifying any information about the environment
that would provide a meaning for the symbol x (or even for the
symbol +).  As we shall see in chapter 3, the general notion of
the environment as providing a context in which evaluation takes place
will play an important role in our understanding of program execution.</p>

<p>

Notice that the
evaluation rule given above does not handle definitions.
For instance, evaluating
(define x 3) does not apply define to two arguments, one
of which is the value of the symbol x and the other of which is
3, since the purpose of the define is precisely to associate
x with a value.
(That is, (define x 3) is not a combination.)</p>

<p>

Such exceptions to the general evaluation rule are called <emphasis>special
forms</emphasis>.  Define is the only example of a special form that we
have seen so far, but we will meet others shortly.  Each special form
has its own evaluation rule. The various kinds of expressions (each
with its associated evaluation rule) constitute the syntax of the
programming language.  In comparison with most other programming
languages, Lisp has a very simple syntax; that is, the evaluation rule
for expressions can be described by a simple general rule together
with specialized rules for a small number of special
forms.<sup>11</sup></p>

</section>

<section>
  <title>
    <p>1.1.4 Compound Procedures</p>
  </title>

<p>

We have identified in Lisp some of the elements that must appear in
any powerful programming language:</p>

<p>Numbers and arithmetic operations are 
primitive data and procedures.</p>

<p>Nesting of combinations provides a means of 
combining operations.</p>

<p>Definitions that associate names with values provide a
limited means of abstraction.</p>

<p>

Now we will learn about
<emphasis>procedure definitions</emphasis>, a much more powerful abstraction
technique by which a compound operation can be given a name and then
referred to as a unit.</p>

<p>

We begin by examining how to express the idea of "squaring."  We
might say, "To square something, multiply it by itself."  This is
expressed in our language as</p>

<p>(define (square x) (* x x))</p><empty-line /><empty-line /><p>

We can understand this in the following way:</p>

<p>(define (square  x)        (*         x     x))</p><empty-line /><p>
   <image xlink:href="#_3.jpg" />        <image xlink:href="#_3.jpg" />     <image xlink:href="#_3.jpg" />          <image xlink:href="#_3.jpg" />         <image xlink:href="#_3.jpg" />    <image xlink:href="#_3.jpg" /></p><empty-line /><p>
 To      square something, multiply   it by itself.</p><empty-line /><p>
We have here a <emphasis>compound procedure</emphasis>, which has been given the name
square.  The procedure represents the operation of multiplying
something by itself.  The thing to be multiplied is given a local
name, x, which plays the same role that a pronoun plays in
natural language.  Evaluating the definition creates this
compound procedure and associates it with the name square.<sup>12</sup></p>

<p>

The general form of a procedure definition is</p>

<p>(define (&lt;<emphasis>name</emphasis>&gt; &lt;<emphasis>formal parameters</emphasis>&gt;) &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
The &lt;<emphasis>name</emphasis>&gt; is a symbol to be associated with the procedure
definition in the environment.<sup>13</sup>
The &lt;<emphasis>formal parameters</emphasis>&gt; are
the names used within the body of the procedure to refer to the
corresponding arguments of the procedure.  The
&lt;<emphasis>body</emphasis>&gt; is an expression that will yield the value of
the procedure application when the formal parameters are replaced by
the actual arguments to which the procedure is applied.<sup>14</sup>
The &lt;<emphasis>name</emphasis>&gt;
and the &lt;<emphasis>formal parameters</emphasis>&gt;
are grouped within parentheses, just as they
would be in an actual call to the procedure being defined.</p>

<p>

Having defined square, we can now use it:</p>

<p>(square 21)</p><empty-line /><p><emphasis>441</emphasis></p><empty-line /><empty-line /><p>
(square (+ 2 5))</p><empty-line /><p><emphasis>49</emphasis></p><empty-line /><empty-line /><p>
(square (square 3))</p><empty-line /><p><emphasis>81</emphasis></p><empty-line /><empty-line /><p>

We can also use square as a building block in defining other
procedures.  For example, <emphasis>x</emphasis><sup>2</sup>  + <emphasis>y</emphasis><sup>2</sup> can be expressed as</p>

<p>(+ (square x) (square y))</p><empty-line /><p>
We can easily define a procedure
sum-of-squares that, given any two numbers as arguments, produces the
sum of their squares:</p>

<p>(define (sum-of-squares x y)</p><empty-line /><p>
  (+ (square x) (square y)))</p><empty-line /><empty-line /><p>
(sum-of-squares 3 4)</p><empty-line /><p><emphasis>25</emphasis></p><empty-line /><p>
Now we can use sum-of-squares as a building block in constructing
further procedures:</p>

<p>(define (f a)</p><empty-line /><p>
  (sum-of-squares (+ a 1) (* a 2)))</p><empty-line /><empty-line /><p>
(f 5)</p><empty-line /><p><emphasis>136</emphasis></p><empty-line /><p>
Compound procedures are used in exactly the same way as primitive
procedures.  Indeed, one could not tell by looking at the definition
of sum-of-squares given above whether square was built into
the interpreter, like + and *, or defined as a compound procedure.</p>
</section>

<section>
  <title>
    <p>1.1.5 The Substitution Model for Procedure Application</p>
  </title>

<p>
To evaluate a combination whose operator names a compound procedure, the
interpreter follows much the same process as for combinations whose
operators name primitive procedures, which we described in
section 1.1.3.  That is, the interpreter
evaluates the elements of the combination and applies the procedure
(which is the value of the operator of the combination) to the
arguments (which are the values of the operands of the combination).</p>

<p>

We can assume that the mechanism for applying primitive procedures to
arguments is built into the interpreter.  For compound procedures, the
application process is as follows:</p>

<p>To apply a compound procedure to arguments, evaluate the body of the
procedure with each formal parameter replaced by the corresponding
argument.</p>

<p>

To illustrate this process, let's evaluate the combination</p>

<p>(f 5)</p><empty-line /><p>
where f is the procedure defined in
section 1.1.4.  We begin by retrieving the
body of f:</p>

<p>(sum-of-squares (+ a 1) (* a 2))</p><empty-line /><p>
Then we replace the formal parameter a by the argument 5:</p>

<p>(sum-of-squares (+ 5 1) (* 5 2))</p><empty-line /><p>
Thus the problem reduces to the evaluation of a combination with two
operands and an operator sum-of-squares.  Evaluating this
combination involves three subproblems.  We must evaluate the
operator to get the procedure to be applied, and we must evaluate the
operands to get the arguments.  Now (+ 5 1) produces 6 and
(* 5 2) produces 10, so we must apply the
sum-of-squares procedure to 6 and 10.  These values are substituted
for the formal parameters x and y in the body of sum-of-squares,
reducing the expression to</p>

<p>(+ (square 6) (square 10))</p><empty-line /><p>
If we use the definition of square, this reduces to</p>

<p>(+ (* 6 6) (* 10 10))</p><empty-line /><p>
which reduces by multiplication to</p>

<p>(+ 36 100)</p><empty-line /><p>
and finally to</p>

<p>136</p><empty-line /><empty-line /><p>

The process we have just described is called the <emphasis>substitution
model</emphasis> for procedure application.  It can be taken as a model that
determines the "meaning" of procedure application, insofar as the
procedures in this chapter are concerned.  However, there are two
points that should be stressed:</p>

<p>The purpose of the substitution is to help us think about
procedure application, not to provide a description of how
the interpreter really works.  Typical interpreters do not evaluate
procedure applications by manipulating the text of a procedure to
substitute values for the formal parameters.  In practice, the
"substitution" is accomplished by using a local environment for the
formal parameters.  We will discuss this more fully in chapters 3 and
4 when we examine the implementation of an interpreter in detail.</p>

<p>Over the course of this book, we will present a sequence of
increasingly elaborate models of how interpreters work, culminating
with a complete implementation of an interpreter and compiler in
chapter 5.  The substitution model is only the first of these
models -- a way to get started thinking formally about the evaluation
process.  In general, when modeling phenomena in science and
engineering, we begin with simplified, incomplete models.  As we
examine things in greater detail, these simple models become
inadequate and must be replaced by more refined models.  The
substitution model is no exception.  In particular, when we address in
chapter 3 the use of procedures with "mutable data", we will see that
the substitution model breaks down and must be replaced by a more
complicated model of procedure application.<sup>15</sup></p>

<p><strong>Applicative order versus normal order</strong></p>

<p>

According to the description of evaluation given in
section 1.1.3, the interpreter first
evaluates the operator and operands and then applies the resulting procedure
to the resulting arguments.  This is not the only way to perform
evaluation.  An alternative evaluation model would not evaluate the
operands until their values were needed.  Instead it would first substitute
operand expressions for parameters until
it obtained an expression involving only primitive operators, and
would then perform the evaluation.  If we used this method, the
evaluation of</p>

<p>(f 5)</p><empty-line /><p>
would proceed according to the sequence of expansions</p>

<p>(sum-of-squares (+ 5 1) (* 5 2))</p><empty-line /><empty-line /><p>
(+    (square (+ 5 1))      (square (* 5 2))  )</p><empty-line /><empty-line /><p>
(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))</p><empty-line /><p>
followed by the reductions</p>

<p>(+         (* 6 6)             (* 10 10))</p><empty-line /><empty-line /><p>
(+           36                   100)</p><empty-line /><empty-line /><p>
                    136</p><empty-line /><p>
This gives the same answer as our previous evaluation model, but the
process is different.  In particular, the evaluations
of (+ 5 1) and (* 5 2) are each performed twice here,
corresponding to the reduction of the expression</p>

<p>(* x x)</p><empty-line /><p>
with x replaced respectively by (+ 5 1) and (* 5 2).</p>

<p>

This alternative "fully expand and then reduce" evaluation method is
known as <emphasis>normal-order evaluation</emphasis>, in contrast to the "evaluate
the arguments and then apply" method that the interpreter actually
uses, which is called <emphasis>applicative-order evaluation</emphasis>.  It can be
shown that, for procedure applications that can be modeled using
substitution (including all the procedures in the first two chapters
of this book) and that yield legitimate values, normal-order and
applicative-order evaluation produce the same value.  (See
exercise 1.5 for an instance of
an "illegitimate" value where normal-order and applicative-order
evaluation do not give the same result.)</p>

<p>

Lisp uses applicative-order evaluation, partly because of the
additional efficiency obtained from avoiding multiple evaluations of
expressions such as those illustrated with (+ 5 1) and (* 5
2) above and, more significantly, because normal-order evaluation
becomes much more complicated to deal with when we leave the realm of
procedures that can be modeled by substitution.  On the other hand,
normal-order evaluation can be an extremely valuable tool, and we will
investigate some of its implications in chapters 3 and 4.<sup>16</sup></p>
</section>

<section>
  <title>
    <p>1.1.6 Conditional Expressions and Predicates</p>
  </title>

<p>
The expressive power of the class of procedures that we can define at
this point is very limited, because we have no way to make tests and
to perform different operations depending on the result of a test.
For instance, we cannot define a procedure that computes the absolute
value of a number by testing whether the number is positive, negative,
or zero and taking different actions in the different cases according
to the rule</p>

<p><image xlink:href="#_4.jpg" /></p>

<p>

This construct is called a <emphasis>case analysis</emphasis>, and
there is a special form in Lisp for notating such a case
analysis.  It is called cond (which stands for
"conditional"), and it is used as follows:</p>

<p>(define (abs x)</p><empty-line /><p>
  (cond ((&gt; x 0) x)</p><empty-line /><p>
        ((= x 0) 0)</p><empty-line /><p>
        ((&lt; x 0) (- x))))</p><empty-line /><p>
The general form of a conditional expression is</p>

<p>(cond (&lt;<emphasis>p<sub>1</sub></emphasis>&gt; &lt;<emphasis>e<sub>1</sub></emphasis>&gt;)</p><empty-line /><p>
      (&lt;<emphasis>p<sub>2</sub></emphasis>&gt; &lt;<emphasis>e<sub>2</sub></emphasis>&gt;)</p><empty-line /><p>
      <image xlink:href="#_5.jpg" /></p><empty-line /><p>
      (&lt;<emphasis>p<sub>n</sub></emphasis>&gt; &lt;<emphasis>e<sub>n</sub></emphasis>&gt;))</p><empty-line /><p>
consisting of the symbol cond followed by
parenthesized pairs of expressions (&lt;<emphasis>p</emphasis>&gt; &lt;<emphasis>e</emphasis>&gt;)
called <emphasis>clauses</emphasis>. The first expression in each pair is a <emphasis>predicate</emphasis> -- that is, an expression whose value is interpreted as
either true or false.<sup>17</sup></p>

<p>

Conditional expressions are evaluated as follows.  The predicate
&lt;<emphasis>p<sub>1</sub></emphasis>&gt; is evaluated first.  If its value is false, then
&lt;<emphasis>p<sub>2</sub></emphasis>&gt; is evaluated.  If &lt;<emphasis>p<sub>2</sub></emphasis>&gt;'s value is also false, then
&lt;<emphasis>p<sub>3</sub></emphasis>&gt; is evaluated.  This process continues until a predicate is
found whose value is true, in which case the interpreter returns the
value of the corresponding <emphasis>consequent expression</emphasis> &lt;<emphasis>e</emphasis>&gt; of the
clause as the value of the conditional expression.  If none of the
&lt;<emphasis>p</emphasis>&gt;'s is found to be true, the value of the cond is
undefined.</p>

<p>

The word <emphasis>predicate</emphasis> is used for procedures that return true
or false, as well as for expressions that evaluate to true or false.
The absolute-value procedure abs makes use of the primitive
predicates &gt;, &lt;, and =.<sup>18</sup> These take two
numbers as arguments and test whether the first number is,
respectively, greater than, less than, or equal to the second number,
returning true or false accordingly.</p>

<p>

Another way to write the absolute-value procedure is</p>

<p>(define (abs x)</p><empty-line /><p>
  (cond ((&lt; x 0) (- x))</p><empty-line /><p>
        (else x)))</p><empty-line /><p>
which could be expressed in English as "If <emphasis>x</emphasis> is less than zero
return  - <emphasis>x</emphasis>; otherwise return <emphasis>x</emphasis>."  Else is a special symbol
that can be used in place of the &lt;<emphasis>p</emphasis>&gt; in the final clause of a cond.  This causes the cond to return as its value the value of
the corresponding &lt;<emphasis>e</emphasis>&gt; whenever all previous clauses have been
bypassed.  In fact, any expression that always evaluates to a true
value could be used as the &lt;<emphasis>p</emphasis>&gt; here.</p>

<p>

Here is yet another way to write the absolute-value procedure:</p>

<p>(define (abs x)</p><empty-line /><p>
  (if (&lt; x 0)</p><empty-line /><p>
      (- x)</p><empty-line /><p>
      x))</p><empty-line /><p>
This uses the special form if, a restricted type of conditional
that can be used when there are precisely two cases in the case
analysis.  The general form of an if expression is</p>

<p>(if &lt;<emphasis>predicate</emphasis>&gt; &lt;<emphasis>consequent</emphasis>&gt; &lt;<emphasis>alternative</emphasis>&gt;)</p><empty-line /><p>
To evaluate an if expression, the interpreter starts by evaluating
the &lt;<emphasis>predicate</emphasis>&gt; part of the expression.  If the &lt;<emphasis>predicate</emphasis>&gt;
evaluates to a true value, the interpreter then evaluates
the &lt;<emphasis>consequent</emphasis>&gt; and returns its value.  Otherwise it evaluates
the &lt;<emphasis>alternative</emphasis>&gt; and returns its value.<sup>19</sup></p>

<p>

In addition to primitive
predicates such as &lt;, =, and &gt;, there are logical
composition operations, which enable us to construct compound
predicates.  The three most frequently used are these:</p>

<p>(and &lt;<emphasis>e<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>e<sub>n</sub></emphasis>&gt;)</p>

<p>

The interpreter
evaluates the expressions &lt;<emphasis>e</emphasis>&gt; one at a time, in left-to-right order.  If
any &lt;<emphasis>e</emphasis>&gt; evaluates to false, the value of the and
expression is false, and the rest of the &lt;<emphasis>e</emphasis>&gt;'s are not evaluated.
If all &lt;<emphasis>e</emphasis>&gt;'s evaluate to true values, the value of the and
expression is the value of the last one.</p>

<p>(or &lt;<emphasis>e<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>e<sub>n</sub></emphasis>&gt;)</p>

<p>

The interpreter
evaluates the expressions &lt;<emphasis>e</emphasis>&gt; one at a time, in left-to-right order.  If
any &lt;<emphasis>e</emphasis>&gt; evaluates to a true value, that value is
returned as the value of the or expression,
and the rest of the &lt;<emphasis>e</emphasis>&gt;'s are not evaluated.
If all &lt;<emphasis>e</emphasis>&gt;'s evaluate to false,
the value of the or expression is false.</p>

<p>(not &lt;<emphasis>e</emphasis>&gt;)</p>

<p>

The value of a not expression is true
when the expression &lt;<emphasis>e</emphasis>&gt; evaluates to false, and false otherwise.</p>

<p>

Notice that and and or are special forms, not procedures,
because the subexpressions are not necessarily all evaluated.
Not is an ordinary procedure.</p>

<p>

As an example of how these are used, the condition that a number <emphasis>x</emphasis>
be in the range 5 &lt; <emphasis>x</emphasis> &lt; 10 may be expressed as</p>

<p>(and (&gt; x 5) (&lt; x 10))</p><empty-line /><p>
As another example, we can define a predicate to test whether one
number is greater than or equal to another as</p>

<p>(define (&gt;= x y)</p><empty-line /><p>
  (or (&gt; x y) (= x y)))</p><empty-line /><p>
or alternatively as</p>

<p>(define (&gt;= x y)</p><empty-line /><p>
  (not (&lt; x y)))</p><empty-line /><empty-line /><p>
<strong>Exercise 1.1.</strong>  Below is a sequence of expressions.  
What is the result printed by the interpreter in response to each
expression?  Assume that the sequence is to be evaluated in the order
in which it is presented.</p>

<p>10</p><empty-line /><p>
(+ 5 3 4)</p><empty-line /><p>
(- 9 1)</p><empty-line /><p>
(/ 6 2)</p><empty-line /><p>
(+ (* 2 4) (- 4 6))</p><empty-line /><p>
(define a 3)</p><empty-line /><p>
(define b (+ a 1))</p><empty-line /><p>
(+ a b (* a b))</p><empty-line /><p>
(= a b)</p><empty-line /><p>
(if (and (&gt; b a) (&lt; b (* a b)))</p><empty-line /><p>
    b</p><empty-line /><p>
    a)</p><empty-line /><p>
(cond ((= a 4) 6)</p><empty-line /><p>
      ((= b 4) (+ 6 7 a))</p><empty-line /><p>
      (else 25))</p><empty-line /><p>
(+ 2 (if (&gt; b a) b a))</p><empty-line /><p>
(* (cond ((&gt; a b) a)</p><empty-line /><p>
         ((&lt; a b) b)</p><empty-line /><p>
         (else -1))</p><empty-line /><p>
   (+ a 1))</p><empty-line /><empty-line /><p>
<strong>Exercise 1.2.</strong>  Translate the following expression into prefix form</p>

<p><image xlink:href="#_6.jpg" /></p><empty-line /><p>
<strong>Exercise 1.3.</strong>  Define a procedure that takes three numbers as arguments and returns
the sum of the squares of the two larger numbers.</p>

<p>
<strong>Exercise 1.4.</strong>  Observe that our model of evaluation allows for combinations whose
operators are compound expressions.  Use this observation to
describe the behavior of the following procedure:</p>

<p>(define (a-plus-abs-b a b)</p><empty-line /><p>
  ((if (&gt; b 0) + -) a b))</p><empty-line /><empty-line /><p>
<strong>Exercise 1.5.</strong>  Ben Bitdiddle has invented a test to determine whether the interpreter
he is faced with is using applicative-order evaluation or normal-order
evaluation.  He defines the following two procedures:</p>

<p>(define (p) (p))</p><empty-line /><empty-line /><p>
(define (test x y)</p><empty-line /><p>
  (if (= x 0)</p><empty-line /><p>
      0</p><empty-line /><p>
      y))</p><empty-line /><p>
Then he evaluates the expression</p>

<p>(test 0 (p))</p><empty-line /><p>
What behavior will Ben observe with an interpreter that uses
applicative-order evaluation?  What behavior will he observe with an
interpreter that uses normal-order evaluation?  Explain your answer.
(Assume that the evaluation rule for the special form if is the
same whether the interpreter is using normal or applicative order:
The predicate expression is evaluated first, and the result
determines whether to evaluate
the consequent or the alternative expression.)</p>
</section>

<section>
  <title>
    <p>1.1.7 Example: Square Roots by Newton's Method</p>
  </title>

<p>
Procedures, as introduced above, are much like ordinary mathematical
functions.  They specify a value that is determined by one or more
parameters.  But there is an important difference between
mathematical functions and computer procedures.  Procedures must be
effective.</p>

<p>

As a case in point, consider the problem of computing square
roots.  We can define the square-root function as</p>

<p><image xlink:href="#_7.jpg" /></p>

<p>

This describes a perfectly legitimate mathematical function.  We could
use it to recognize whether one number is the square root of another, or
to derive facts about square roots in general.  On the other hand, the
definition does not describe a procedure.  Indeed, it tells us almost
nothing about how to actually find the square root of a given number.  It
will not help matters to rephrase this definition in pseudo-Lisp:</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (the y (and (&gt;= y 0)</p><empty-line /><p>
              (= (square y) x))))</p><empty-line /><p>
This only begs the question.</p>

<p>

The contrast between function and procedure is a reflection of the
general distinction between describing properties of things and
describing how to do things, or, as it is sometimes referred to, the
distinction between declarative knowledge and imperative knowledge.
In mathematics we are usually concerned with declarative (what is)
descriptions, whereas in computer science we are usually concerned
with imperative (how to) descriptions.<sup>20</sup></p>

<p>

How does one compute square roots?  The most common way is to use
Newton's method of successive approximations, which says that whenever
we have a guess <emphasis>y</emphasis> for the value of the square root of a number <emphasis>x</emphasis>,
we can perform a simple manipulation to get a better guess (one closer
to the actual square root) by averaging <emphasis>y</emphasis> with
<emphasis>x</emphasis>/<emphasis>y</emphasis>.<sup>21</sup> For example, we can compute
the square root of 2 as follows.  Suppose our initial guess is 1:</p>

<p>Guess</p>

<p>Quotient</p>

<p>Average</p>

<p>1</p>

<p> (2/1)  =  2</p>

<p>
((2 + 1)/2)  =  1.5</p>

<p>1.5</p>

<p> (2/1.5)  =  1.3333</p>

<p>
((1.3333 + 1.5)/2)  =  1.4167</p>

<p>1.4167</p>

<p> (2/1.4167)  =  1.4118</p>

<p>
((1.4167 + 1.4118)/2)  =  1.4142</p>

<p>1.4142</p>

<p>...</p>

<p>...</p>

<p>

Continuing this process, we obtain better and better
approximations to the square root.</p>

<p>

Now let's formalize the process in terms of procedures.  We start with
a value for the radicand (the number whose square root we are trying
to compute) and a value for the guess.  If the guess is good enough
for our purposes, we are done; if not, we must repeat the process with an
improved guess.  We write this basic strategy as a procedure:</p>

<p>(define (sqrt-iter guess x)</p><empty-line /><p>
  (if (good-enough? guess x)</p><empty-line /><p>
      guess</p><empty-line /><p>
      (sqrt-iter (improve guess x)</p><empty-line /><p>
                 x)))</p><empty-line /><p>
A guess is improved by averaging
it with the quotient of the radicand and the old guess:</p>

<p>(define (improve guess x)</p><empty-line /><p>
  (average guess (/ x guess)))</p><empty-line /><p>
where</p>

<p>(define (average x y)</p><empty-line /><p>
  (/ (+ x y) 2))</p><empty-line /><p>
We also have to say what we mean by "good enough."  The
following will do for illustration, but it is not really a very good
test.  (See exercise 1.7.)
The idea is to improve the answer until it is close enough so that its
square differs from the radicand by less than a predetermined
tolerance (here 0.001):<sup>22</sup></p>

<p>(define (good-enough? guess x)</p><empty-line /><p>
  (&lt; (abs (- (square guess) x)) 0.001))</p><empty-line /><p>
Finally, we need a way to get started.  For instance, we can
always guess that the square root of any number is 1:<sup>23</sup></p>

<p>(define (sqrt x)</p><empty-line /><p>
  (sqrt-iter 1.0 x))</p><empty-line /><p>
If we type these definitions to the interpreter, we can use sqrt
just as we can use any procedure:</p>

<p>(sqrt 9)</p><empty-line /><p><emphasis>3.00009155413138</emphasis></p><empty-line /><p>
(sqrt (+ 100 37))</p><empty-line /><p><emphasis>11.704699917758145</emphasis></p><empty-line /><p>
(sqrt (+ (sqrt 2) (sqrt 3)))</p><empty-line /><p><emphasis>1.7739279023207892</emphasis></p><empty-line /><p>
(square (sqrt 1000))</p><empty-line /><p><emphasis>1000.000369924366</emphasis></p><empty-line /><empty-line /><p>

The sqrt program also illustrates that the simple procedural
language we have introduced so far is sufficient for writing any
purely numerical program that one could write in, say, C or
Pascal.  This might seem surprising, since we have not included in
our language any iterative (looping) constructs that direct the
computer to do something over and over again.  Sqrt-iter, on the
other hand, demonstrates how iteration can be accomplished using no
special construct other than the ordinary ability to call a
procedure.<sup>24</sup></p>

<p>
<strong>Exercise 1.6.</strong>  Alyssa P. Hacker doesn't see why if needs
to be provided as a special form.  "Why can't I just define it as an
ordinary procedure in terms of cond?" she asks.
Alyssa's friend Eva Lu Ator claims this can indeed be done, and
she defines a new version of if:</p>

<p>(define (new-if predicate then-clause else-clause)</p><empty-line /><p>
  (cond (predicate then-clause)</p><empty-line /><p>
        (else else-clause)))</p><empty-line /><p>
Eva demonstrates the program for Alyssa:</p>

<p>(new-if (= 2 3) 0 5)</p><empty-line /><p><emphasis>5</emphasis></p><empty-line /><empty-line /><p>
(new-if (= 1 1) 0 5)</p><empty-line /><p><emphasis>0</emphasis></p><empty-line /><p>
Delighted, Alyssa uses new-if to rewrite the square-root
program:</p>

<p>(define (sqrt-iter guess x)</p><empty-line /><p>
  (new-if (good-enough? guess x)</p><empty-line /><p>
          guess</p><empty-line /><p>
          (sqrt-iter (improve guess x)</p><empty-line /><p>
                     x)))</p><empty-line /><p>
What happens when Alyssa attempts to use this to compute square roots?
Explain.</p>

<p>
<strong>Exercise 1.7.</strong>  The good-enough? test used in computing square roots will not be
very effective for finding the square roots of very small numbers.
Also, in real computers, arithmetic operations are almost always
performed with limited precision.  This makes our test inadequate for
very large numbers.  Explain these statements, with examples showing
how the test fails for small and large numbers.  An alternative
strategy for implementing good-enough? is to watch how guess changes from one iteration to the next and to stop when the
change is a very small fraction of the guess.  Design a square-root
procedure that uses this kind of end test.  Does this work better for
small and large numbers?</p>

<p>
<strong>Exercise 1.8.</strong>  Newton's method for cube roots is based on the fact that if <emphasis>y</emphasis> is an
approximation to the cube root of <emphasis>x</emphasis>, then a better approximation is
given by the value</p>

<p><image xlink:href="#_8.jpg" /></p>

<p>
Use this formula to implement a cube-root procedure analogous to the
square-root procedure.  (In section 1.3.4 we
will see how to implement Newton's method in general as an abstraction
of these square-root and cube-root procedures.)</p>
</section>

<section>
  <title>
    <p>1.1.8 Procedures as Black-Box Abstractions</p>
  </title>

<p>
Sqrt is our first example of a process defined by a set of
mutually defined procedures.  Notice that the definition of sqrt-iter is <emphasis>recursive</emphasis>; that is, the procedure is defined in
terms of itself.  The idea of being able to define a procedure in
terms of itself may be disturbing; it may seem unclear how such a
"circular" definition could make sense at all, much less specify a
well-defined process to be carried out by a computer.  This will be
addressed more carefully in
section 1.2.  But first let's consider
some other important points illustrated by the sqrt example.</p>

<p>

Observe that the problem of computing square roots breaks up naturally
into a number of subproblems: how to tell whether a guess is good
enough, how to improve a guess, and so on.  Each of these tasks is
accomplished by a separate procedure.  The entire sqrt program
can be viewed as a cluster of procedures (shown in
figure 1.2) that mirrors the decomposition of
the problem into subproblems.</p>

<p><image xlink:href="#_9.jpg" /></p>

<p><strong>Figure 1.2:</strong>  Procedural decomposition of the sqrt program.</p>

<p>

The importance of this decomposition strategy is not simply that one
is dividing the program into parts.  After all, we could take any
large program and divide it into parts -- the first ten lines, the next
ten lines, the next ten lines, and so on.  Rather, it is crucial that
each procedure accomplishes an identifiable task that can be used as a
module in defining other procedures.  For example, when we define the
good-enough? procedure in terms of square, we are able to
regard the square procedure as a "black box."  We are not at
that moment concerned with <emphasis>how</emphasis> the procedure computes its
result, only with the fact that it computes the square.  The details
of how the square is computed can be suppressed, to be considered at a
later time.  Indeed, as far as the good-enough? procedure is
concerned, square is not quite a procedure but rather an
abstraction of a procedure, a so-called <emphasis>procedural abstraction</emphasis>.
At this level of abstraction, any procedure that computes the square
is equally good.</p>

<p>

Thus, considering only the values they return, the following two procedures for
squaring a number should be indistinguishable.  Each takes a numerical
argument and produces the square of that number as the
value.<sup>25</sup></p>

<p>(define (square x) (* x x))</p><empty-line /><empty-line /><p>
(define (square x)</p><empty-line /><p>
  (exp (double (log x))))</p><empty-line /><empty-line /><p>
(define (double x) (+ x x))</p><empty-line /><empty-line /><p>

So a procedure definition should be able to suppress detail.  The
users of the procedure may not have written the procedure themselves,
but may have obtained it from another programmer as a black box.  A
user should not need to know how the procedure is implemented in order
to use it.</p>

<p><strong>Local names</strong></p>

<p>


One detail of a procedure's implementation that should not matter to
the user of the procedure is the implementer's choice of names for the
procedure's formal parameters.  Thus, the following procedures should
not be distinguishable:</p>

<p>(define (square x) (* x x))</p><empty-line /><empty-line /><p>
(define (square y) (* y y))</p><empty-line /><p>
This principle -- that the meaning of a procedure should be independent
of the parameter names used by its author -- seems on the surface to be
self-evident, but its consequences are profound.  The simplest
consequence is that the parameter names of a procedure must be local
to the body of the procedure.  For example, we used square in
the definition of good-enough? in our square-root procedure:</p>

<p>(define (good-enough? guess x)</p><empty-line /><p>
  (&lt; (abs (- (square guess) x)) 0.001))</p><empty-line /><p>
The intention of the author of good-enough? is to determine if
the square of the first argument is within a given tolerance of the
second argument.  We see that the author of good-enough? used
the name guess to refer to the first argument and x to
refer to the second argument.  The argument of square is guess.  If the author of square used x (as above)
to refer to that argument, we see that the x in good-enough? must be a different x than the one in square.  Running the procedure square must not affect the value
of x that is used by good-enough?, because that value of
x may be needed by good-enough? after square is done
computing.</p>

<p>

If the parameters were not local to the bodies of their respective
procedures, then the parameter x in square could be
confused with the parameter x in good-enough?, and the
behavior of good-enough? would depend upon which version of
square we used.  Thus, square would not be the black box
we desired.</p>

<p>

A formal parameter of a procedure has a very special role in the
procedure definition, in that it doesn't matter what name the formal
parameter has.  Such a name is called a <emphasis>bound variable</emphasis>, and we
say that the procedure definition <emphasis>binds</emphasis> its formal parameters.
The meaning of a procedure definition is unchanged if a bound variable
is consistently renamed throughout the definition.<sup>26</sup>  If a variable is not bound, we say that it is <emphasis>free</emphasis>.  The
set of expressions for which a binding defines a name is called the
<emphasis>scope</emphasis> of that name.
In a procedure definition, the bound variables
declared as the formal parameters of the procedure have the body of
the procedure as their scope.</p>

<p>

In the definition of good-enough? above, guess and x are
bound variables but &lt;, -, abs, and square are free.
The meaning of good-enough? should be independent of the names we
choose for guess and x so long as they are distinct and
different from &lt;, -, abs, and square.  (If we renamed
guess to abs we would have introduced a bug by <emphasis>capturing</emphasis>
the variable abs.  It would have changed from free to bound.)  The
meaning of good-enough? is not independent of the names of its
free variables, however.  It surely depends upon the fact (external to
this definition) that the symbol abs names a procedure for
computing the absolute value of a number.  Good-enough? will
compute a different function if we substitute cos for abs in
its definition.</p>

<p><strong>Internal definitions and block structure</strong></p>

<p>

We have one kind of name isolation available to us so far: The formal
parameters of a procedure are local to the body of the procedure.  The
square-root program illustrates another way in which we would like to
control the use of names.  The existing program consists of
separate procedures:</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (sqrt-iter 1.0 x))</p><empty-line /><p>
(define (sqrt-iter guess x)</p><empty-line /><p>
  (if (good-enough? guess x)</p><empty-line /><p>
      guess</p><empty-line /><p>
      (sqrt-iter (improve guess x) x)))</p><empty-line /><p>
(define (good-enough? guess x)</p><empty-line /><p>
  (&lt; (abs (- (square guess) x)) 0.001))</p><empty-line /><p>
(define (improve guess x)</p><empty-line /><p>
  (average guess (/ x guess)))</p><empty-line /><empty-line /><p>

The problem with this program is that the only procedure that is
important to users of sqrt is sqrt.  The other
procedures (sqrt-iter, good-enough?, and improve)
only clutter up their minds.  They may not define any other procedure
called good-enough? as part of another program to work together
with the square-root program, because sqrt needs it.  The
problem is especially severe in the construction of large systems by
many separate programmers.  For example, in the construction of a
large library of numerical procedures, many numerical functions are
computed as successive approximations and thus might have procedures
named good-enough? and improve as auxiliary procedures.
We would like to localize the subprocedures, hiding them inside sqrt so that sqrt could coexist with other successive
approximations, each having its own private
good-enough? procedure.  To make this possible, we allow a
procedure to have
internal definitions that are local to that procedure.  For example,
in the square-root problem we can write</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (define (good-enough? guess x)</p><empty-line /><p>
    (&lt; (abs (- (square guess) x)) 0.001))</p><empty-line /><p>
  (define (improve guess x)</p><empty-line /><p>
    (average guess (/ x guess)))</p><empty-line /><p>
  (define (sqrt-iter guess x)</p><empty-line /><p>
    (if (good-enough? guess x)</p><empty-line /><p>
        guess</p><empty-line /><p>
        (sqrt-iter (improve guess x) x)))</p><empty-line /><p>
  (sqrt-iter 1.0 x))</p><empty-line /><empty-line /><p>

Such nesting of definitions, called <emphasis>block structure</emphasis>,
is basically the right solution to the simplest 
name-packaging problem.  But there is a better idea lurking here.  In
addition to internalizing the definitions of the auxiliary procedures,
we can simplify them.  Since x is bound in the definition of
sqrt, the procedures good-enough?, improve, and
sqrt-iter, which are defined internally to sqrt, are in the
scope of x.  Thus, it is not necessary to pass x explicitly to
each of these procedures.  Instead, we allow x to be a free
variable in the internal definitions, as shown below. Then x
gets its value from the argument with which the enclosing
procedure sqrt is called.  This discipline is called <emphasis>lexical
scoping</emphasis>.<sup>27</sup></p>

<p>(define (sqrt x)</p><empty-line /><p>
  (define (good-enough? guess)</p><empty-line /><p>
    (&lt; (abs (- (square guess) x)) 0.001))</p><empty-line /><p>
  (define (improve guess)</p><empty-line /><p>
    (average guess (/ x guess)))</p><empty-line /><p>
  (define (sqrt-iter guess)</p><empty-line /><p>
    (if (good-enough? guess)</p><empty-line /><p>
        guess</p><empty-line /><p>
        (sqrt-iter (improve guess))))</p><empty-line /><p>
  (sqrt-iter 1.0))</p><empty-line /><empty-line /><p>

We will use block structure extensively to help us break
up large programs into tractable pieces.<sup>28</sup>
The idea of block structure originated with the
programming language Algol 60.  It appears in most advanced
programming languages and is an important tool for helping to organize
the construction of large programs.</p><empty-line /><empty-line /><empty-line /><p><sup>4</sup> The
characterization of numbers as "simple data" is a barefaced bluff.
In fact, the treatment of numbers is one of the trickiest and most
confusing aspects of any programming language.  Some typical issues
involved are these:
Some computer systems distinguish <emphasis>integers</emphasis>, such as 2, from
<emphasis>real numbers</emphasis>, such as 2.71.  Is the real number 2.00 different
from the integer 2?
Are the arithmetic operations used
for integers the same as the operations used for real numbers?  Does 6
divided by 2 produce 3, or 3.0?  How large a number can we represent?
How many decimal places of accuracy can we represent?  Is the range of
integers the same as the range of real numbers?  Above and beyond
these questions, of course, lies a collection of issues concerning
roundoff and truncation errors -- the entire science of numerical
analysis.  Since our focus in this book is on large-scale program
design rather than on numerical techniques, we are going to ignore
these problems.  The numerical examples in this chapter will exhibit
the usual roundoff behavior that one observes when using arithmetic
operations that preserve a limited number of decimal places of
accuracy in noninteger operations.</p>

<p><sup>5</sup> Throughout this book,
when we wish to emphasize the distinction between the input typed by
the user and the response printed by the interpreter, we will show the
latter in slanted characters.</p>

<p><sup>6</sup> Lisp systems typically provide
features to aid the user in formatting expressions.  Two especially
useful features are one that automatically indents to the proper
pretty-print position whenever a new line is started and one that
highlights the matching left parenthesis whenever a right parenthesis
is typed.</p>

<p><sup>7</sup> Lisp obeys the convention that every
expression has a value. This convention, together with the old
reputation of Lisp as an inefficient language, is the source of the
quip by Alan Perlis (paraphrasing Oscar Wilde)
that "Lisp programmers know the value of
everything but the cost of nothing."</p>

<p><sup>8</sup> In this book, we do not show the interpreter's response to
evaluating definitions, since this is highly
implementation-dependent.</p>

<p><sup>9</sup> Chapter 3 will show that this notion of
environment is crucial, both for understanding how the interpreter
works and for implementing interpreters.</p>

<p><sup>10</sup> It may seem strange that the evaluation rule says, as
part of the first step, that we should evaluate the leftmost element
of a combination, since at this point that can only be an operator
such as + or *
representing a built-in primitive procedure such as addition or
multiplication.  We will see later that it is useful to be able to work with
combinations whose operators are themselves compound expressions.</p>

<p><sup>11</sup> Special syntactic forms that are simply convenient
alternative surface structures for things that can be written in more
uniform ways are sometimes called <emphasis>syntactic sugar</emphasis>, to use a
phrase coined by Peter Landin.  In comparison with users of other
languages, Lisp programmers, as a rule, are less concerned with
matters of syntax.  (By contrast, examine any Pascal manual and notice
how much of it is devoted to descriptions of syntax.)  This disdain
for syntax is due partly to the flexibility of Lisp, which makes it
easy to change surface syntax, and partly to the observation that many
"convenient" syntactic constructs, which make the language less
uniform, end up causing more trouble than they are worth when programs
become large and complex.  In the words of Alan Perlis, "Syntactic
sugar causes cancer of the semicolon."</p>

<p><sup>12</sup> Observe that there are two different operations
being combined here: we are creating the procedure, and we are giving
it the name square.  It is possible, indeed important, to be
able to separate these two notions -- to create procedures without
naming them, and to give names to procedures that have already been
created.  We will see how to do this in section 1.3.2.</p>

<p><sup>13</sup> Throughout this book, we will
describe the general syntax of expressions by using italic symbols
delimited by angle brackets -- e.g., &lt;<emphasis>name</emphasis>&gt; -- to denote the
"slots" in the expression to be filled in when such an expression is
actually used.</p>

<p><sup>14</sup> More
generally, the body of the procedure can be a sequence of expressions.
In this case, the interpreter evaluates each expression in the
sequence in turn and returns the value of the final expression as the
value of the procedure application.</p>

<p><sup>15</sup> Despite the
simplicity of the substitution idea, it turns out to be surprisingly
complicated to give a rigorous mathematical definition of the
substitution process.  The problem arises from the possibility of
confusion between the names used for the formal parameters of a
procedure and the (possibly identical) names used in the expressions
to which the procedure may be applied.  Indeed, there is a long
history of erroneous definitions of <emphasis>substitution</emphasis> in the
literature of logic and programming semantics.  See Stoy 1977 for a
careful discussion of substitution.</p>

<p><sup>16</sup> In
chapter 3 we will introduce <emphasis>stream processing</emphasis>, which is a way of
handling apparently "infinite" data structures by incorporating a
limited form of normal-order evaluation.  In
section 4.2 we will modify the Scheme
interpreter to produce a normal-order variant of Scheme.</p>

<p><sup>17</sup> "Interpreted as either true or false"
means this: In Scheme, there are two distinguished values that are
denoted by the constants #t and #f.  When the interpreter
checks a predicate's value, it interprets #f as false.  Any other value
is treated as true.  (Thus, providing #t is logically
unnecessary, but it is convenient.)  In this book we will use
names true and false, which are associated
with the values #t and #f respectively.</p>

<p><sup>18</sup> Abs also uses
the "minus" operator -, which, when used with a single
operand, as in (- x), indicates negation.</p>

<p><sup>19</sup> A minor difference
between if and cond is that the
&lt;<emphasis>e</emphasis>&gt; part of each cond clause may be a sequence of expressions.
If the corresponding &lt;<emphasis>p</emphasis>&gt; is found to be true, the expressions
&lt;<emphasis>e</emphasis>&gt; are evaluated in sequence and the value of the final
expression in the sequence is returned as the value of the cond.
In an if expression, however, the &lt;<emphasis>consequent</emphasis>&gt; and
&lt;<emphasis>alternative</emphasis>&gt; must be single expressions.</p>

<p><sup>20</sup> Declarative and
imperative descriptions are intimately related, as indeed are
mathematics and computer science.  For instance, to say that the
answer produced by a program is "correct" is to make a declarative
statement about the program.  There is a large amount of research
aimed at establishing techniques for proving that programs are
correct, and much of the technical difficulty of this subject has to
do with negotiating the transition between imperative statements (from
which programs are constructed) and declarative statements (which can
be used to deduce things).  In a related vein, an important current
area in programming-language design is the exploration of so-called
very high-level languages, in which one actually programs in terms of
declarative statements.  The idea is to make interpreters
sophisticated enough so that, given "what is" knowledge specified by
the programmer, they can generate "how to" knowledge automatically.
This cannot be done in general, but there are important areas where
progress has been made.  We shall revisit this idea in chapter 4.</p>

<p><sup>21</sup> This square-root algorithm is actually a special case
of Newton's method, which is a general technique for finding roots of
equations.  The square-root algorithm itself was developed by Heron of
Alexandria in the first century A.D.  We will see how to express
the general Newton's method as a Lisp procedure in
section 1.3.4.</p>

<p><sup>22</sup> We will usually give
predicates names ending with question marks, to help us
remember that they are predicates.  This
is just a stylistic convention.  As far as the interpreter is
concerned, the question mark is just an ordinary character.</p>

<p><sup>23</sup> Observe that we express our initial guess as 1.0 rather than
1.  This would not make any difference in many Lisp implementations.
MIT Scheme, however, distinguishes between exact integers and decimal
values, and dividing two integers produces a rational number rather
than a decimal.  For example, dividing 10 by 6 yields 5/3, while
dividing 10.0 by 6.0 yields 1.6666666666666667.  (We will learn how to
implement arithmetic on rational numbers in
section 2.1.1.)  If we start with an initial guess of 1
in our square-root program, and <emphasis>x</emphasis> is an exact integer, all
subsequent values produced in the square-root computation will be
rational numbers rather than decimals.  Mixed operations on rational
numbers and decimals always yield decimals, so starting with an
initial guess of 1.0 forces all subsequent values to be decimals.</p>

<p><sup>24</sup> Readers who are worried about the efficiency
issues involved in using procedure calls to implement iteration should
note the remarks on "tail recursion" in
section 1.2.1.</p>

<p><sup>25</sup> It is not even clear which of these procedures is a
more efficient implementation.  This depends upon the hardware
available.  There are machines for which the "obvious"
implementation is the less efficient one.  Consider a machine that has
extensive tables of logarithms and antilogarithms stored in a very
efficient manner.</p>

<p><sup>26</sup> The
concept of consistent renaming is actually subtle and difficult to
define formally.  Famous logicians have made embarrassing errors
here.</p>

<p><sup>27</sup> Lexical
scoping dictates that free variables in a procedure are taken to refer to
bindings made by enclosing procedure definitions;
that is, they are looked up in
the environment in which the procedure was defined.  We will see how
this works in detail in chapter 3 when we study environments and the
detailed behavior of the interpreter.</p>

<p><sup>28</sup> Embedded definitions
must come first in a procedure body.  The management is not responsible
for the consequences of running programs that intertwine definition
and use.</p>
</section>

</section>

<section>


<p><strong>1.2  Procedures and the Processes They Generate</strong></p>

<p>


We have now considered the elements of programming: We have used
primitive arithmetic operations, we have combined these operations, and
we have abstracted these composite operations by defining them as compound
procedures.  But that is not enough to enable us to say that we know
how to program.  Our situation is analogous to that of someone who has
learned the rules for how the pieces move in chess but knows nothing
of typical openings, tactics, or strategy.  Like the novice chess
player, we don't yet know the common patterns of usage in the domain.
We lack the knowledge of which moves are worth making (which
procedures are worth defining).  We lack the experience to predict the
consequences of making a move (executing a procedure).</p>

<p>

The ability to visualize the consequences of the actions under
consideration is crucial to becoming an expert programmer, just as it
is in any synthetic, creative activity.  In becoming an expert
photographer, for example, one must learn how to look at a scene and
know how dark each region will appear on a print for each possible
choice of exposure and development conditions.  Only then can one
reason backward, planning framing, lighting, exposure, and development
to obtain the desired effects.  So it is with programming, where we
are planning the course of action to be taken by a process and where
we control the process by means of a program.  To become experts, we
must learn to visualize the processes generated by various types of
procedures.  Only after we have developed such a skill can we learn
to reliably construct programs that exhibit the desired behavior.</p>

<p>

A procedure is a pattern for the <emphasis>local evolution</emphasis> of a
computational process.  It specifies how each stage of the process is
built upon the previous stage.  We would like to be able to make
statements about the overall, or <emphasis>global</emphasis>, behavior of a
process whose local evolution has been specified by a procedure.  This
is very difficult to do in general, but we can at least try to
describe some typical patterns of process evolution.</p>

<p>

In this section we will examine some common "shapes" for processes
generated by simple procedures.  We will also investigate the
rates at which these processes consume the important computational
resources of time and space.  The procedures we will consider
are very simple.  Their role is like that played by test patterns in
photography: as oversimplified prototypical patterns, rather than
practical examples in their own right.</p>

<p><strong>1.2.1  Linear Recursion and Iteration</strong></p>

<p><image xlink:href="#_10.jpg" /></p>

<p><strong>Figure 1.3:</strong>  A linear recursive process for computing 6!.</p>

<p>

We begin by considering the factorial function, defined by</p>

<p><image xlink:href="#_11.jpg" /></p>

<p>

There are many ways to compute factorials.  One way is to make use of
the observation that <emphasis>n</emphasis>! is equal to <emphasis>n</emphasis> times (<emphasis>n</emphasis> - 1)! for
any positive integer <emphasis>n</emphasis>:</p>

<p><image xlink:href="#_12.jpg" /></p>

<p>

Thus, we can compute <emphasis>n</emphasis>! by computing (<emphasis>n</emphasis> - 1)! and multiplying the
result by <emphasis>n</emphasis>.  If we add the stipulation that 1! is equal to 1,
this observation translates directly into a procedure:</p>

<p>(define (factorial n)</p><empty-line /><p>
  (if (= n 1)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* n (factorial (- n 1)))))</p><empty-line /><p>
We can use the substitution model of
section 1.1.5 to watch this procedure in action
computing 6!, as shown in figure 1.3.</p>

<p>


Now let's take a different perspective on computing factorials.  We
could describe a rule for computing <emphasis>n</emphasis>! by specifying that we
first multiply 1 by 2, then multiply the result by 3, then by 4,
and so on until we reach <emphasis>n</emphasis>.
More formally, we maintain a running product, together with a counter
that counts from 1 up to <emphasis>n</emphasis>.  We can describe the computation by
saying that the counter and the product simultaneously change from one
step to the next according to the rule</p>

<p>product  <image xlink:href="#_13.jpg" />  counter  ·  product</p>

<p>counter  <image xlink:href="#_13.jpg" />  counter  +  1</p><empty-line /><p>

and stipulating that <emphasis>n</emphasis>! is the value of the product when
the counter exceeds <emphasis>n</emphasis>.</p>

<p><image xlink:href="#_14.jpg" /></p>

<p><strong>Figure 1.4:</strong>  A linear iterative process for computing 6!.</p>

<p>

Once again, we can recast our description as a procedure for computing
factorials:<sup>29</sup></p>

<p>(define (factorial n)</p><empty-line /><p>
  (fact-iter 1 1 n))</p><empty-line /><empty-line /><p>
(define (fact-iter product counter max-count)</p><empty-line /><p>
  (if (&gt; counter max-count)</p><empty-line /><p>
      product</p><empty-line /><p>
      (fact-iter (* counter product)</p><empty-line /><p>
                 (+ counter 1)</p><empty-line /><p>
                 max-count)))</p><empty-line /><empty-line /><p>


As before, we can use the substitution model to visualize the process
of computing 6!, as shown in figure 1.4.</p>

<p>

Compare the two processes.  From one point of view, they seem hardly
different at all.  Both compute the same mathematical function on the
same domain, and each requires a number of steps proportional to <emphasis>n</emphasis>
to compute <emphasis>n</emphasis>!.  Indeed, both processes even carry out the same
sequence of multiplications, obtaining the same sequence of partial
products.  On the other hand, when we consider the "shapes" of the
two processes, we find that they evolve quite differently.</p>

<p>

Consider the first process.  The substitution model reveals a shape of
expansion followed by contraction, indicated by the arrow in
figure 1.3.  The expansion occurs as the
process builds up a chain of <emphasis>deferred operations</emphasis> (in this case,
a chain of multiplications).  The contraction occurs as 
the operations are
actually performed.  This type of process, characterized by a chain of
deferred operations, is called a <emphasis>recursive process</emphasis>.  Carrying
out this process requires that the interpreter keep track of the
operations to be performed later on.  In the computation of <emphasis>n</emphasis>!,
the length of the chain of deferred multiplications, and hence the amount
of information needed to keep track of it, grows linearly with <emphasis>n</emphasis>
(is proportional to <emphasis>n</emphasis>), just like the number of steps.
Such a process is called a <emphasis>linear recursive process</emphasis>.</p>

<p>

By contrast, the second process does not grow and shrink.  At each
step, all we need to keep track of, for any <emphasis>n</emphasis>, are the current
values of the variables product, counter, and max-count.  We call this an <emphasis>iterative process</emphasis>.  In general, an
iterative process is one whose state can be summarized by a fixed
number of <emphasis>state variables</emphasis>, together with a fixed rule that
describes how the state variables should be updated as the process
moves from state to state and an (optional) end test that specifies
conditions under which the process should terminate.  In computing
<emphasis>n</emphasis>!, the number of steps required grows linearly with <emphasis>n</emphasis>.  Such a process is
called a <emphasis>linear iterative process</emphasis>.</p>

<p>

The contrast between the two processes can be seen in another way.  In
the iterative case, the program variables provide a complete
description of the state of the process at any point.  If we stopped
the computation between steps, all we would need to do to resume the
computation is to supply the interpreter with the values of the three
program variables.  Not so with the recursive process.  In this case
there is some additional "hidden" information, maintained by the
interpreter and not contained in the program variables, which
indicates "where the process is" in negotiating the chain of
deferred operations.  The longer the chain, the more information must
be maintained.<sup>30</sup></p>

<p>

In contrasting iteration and recursion, we must be careful not to
confuse the notion of a recursive <emphasis>process</emphasis> with the notion of a
recursive <emphasis>procedure</emphasis>.  When we describe a procedure as recursive,
we are referring to the syntactic fact that the procedure definition
refers (either directly or indirectly) to the procedure itself.  But
when we describe a process as following a pattern that is, say,
linearly recursive, we are speaking about how the process evolves, not
about the syntax of how a procedure is written.  It may seem
disturbing that we refer to a recursive procedure such as fact-iter as generating an iterative process.  However, the process
really is iterative: Its state is captured completely by its three
state variables, and an interpreter need keep track of only three
variables in order to execute the process.</p>

<p>

One reason that the distinction between process and procedure may be
confusing is that most implementations of common languages (including
Ada, Pascal, and C) are designed in such a way that the
interpretation of any recursive procedure consumes an amount of memory
that grows with the number of procedure calls, even when the process
described is, in principle, iterative.  As a consequence, these
languages can describe iterative processes only by resorting to
special-purpose "looping constructs" such as do, repeat,
until, for, and while.  The implementation of Scheme
we shall consider in chapter 5 does not share this defect.  It will
execute an iterative process in constant space, even if the iterative
process is described by a recursive procedure.  An implementation with
this property is called <emphasis>tail-recursive</emphasis>.  With a tail-recursive
implementation, iteration can be expressed using the ordinary
procedure call mechanism, so that special iteration constructs are
useful only as syntactic sugar.<sup>31</sup></p>

<p>
<strong>Exercise 1.9.</strong>  Each of the following two procedures defines a method for adding two
positive integers in terms of the procedures inc,
which increments its argument by 1, and dec, which decrements
its argument by 1.</p>

<p>(define (+ a b)</p><empty-line /><p>
  (if (= a 0)</p><empty-line /><p>
      b</p><empty-line /><p>
      (inc (+ (dec a) b))))</p><empty-line /><empty-line /><p>
(define (+ a b)</p><empty-line /><p>
  (if (= a 0)</p><empty-line /><p>
      b</p><empty-line /><p>
      (+ (dec a) (inc b))))</p><empty-line /><p>
Using the substitution model, illustrate the process generated by each
procedure in evaluating (+ 4 5).  Are these processes
iterative or recursive?</p>

<p>
<strong>Exercise 1.10.</strong>  The following procedure computes a mathematical function called
Ackermann's function.</p>

<p>(define (A x y)</p><empty-line /><p>
  (cond ((= y 0) 0)</p><empty-line /><p>
        ((= x 0) (* 2 y))</p><empty-line /><p>
        ((= y 1) 2)</p><empty-line /><p>
        (else (A (- x 1)</p><empty-line /><p>
                 (A x (- y 1))))))</p><empty-line /><p>
What are the values of the following expressions?</p>

<p>(A 1 10)</p><empty-line /><empty-line /><p>
(A 2 4)</p><empty-line /><empty-line /><p>
(A 3 3)</p><empty-line /><p>
Consider the following procedures, where A is the procedure  
defined above:</p>

<p>(define (f n) (A 0 n))</p><empty-line /><empty-line /><p>
(define (g n) (A 1 n))</p><empty-line /><empty-line /><p>
(define (h n) (A 2 n))</p><empty-line /><empty-line /><p>
(define (k n) (* 5 n n))</p><empty-line /><p>
Give concise mathematical definitions for the functions computed by
the procedures f, g, and h for positive integer
values of <emphasis>n</emphasis>.  For example, (k n) computes 5<emphasis>n</emphasis><sup>2</sup>.</p>

<p><strong>1.2.2  Tree Recursion</strong></p>

<p>



Another common pattern of computation is called <emphasis>tree recursion</emphasis>.
As an example, consider computing the sequence of Fibonacci numbers,
in which each number is the sum of the preceding two:</p>

<p><image xlink:href="#_15.jpg" /></p>

<p>

In general, the Fibonacci numbers can be defined by the rule</p>

<p><image xlink:href="#_16.jpg" /></p>

<p>
We can immediately translate this definition into a recursive
procedure for computing Fibonacci numbers:</p>

<p>(define (fib n)</p><empty-line /><p>
  (cond ((= n 0) 0)</p><empty-line /><p>
        ((= n 1) 1)</p><empty-line /><p>
        (else (+ (fib (- n 1))</p><empty-line /><p>
                 (fib (- n 2))))))</p><empty-line /><empty-line /><p><image xlink:href="#_17.jpg" /></p>

<p><strong>Figure 1.5:</strong>  The tree-recursive process generated in computing (fib 5).</p>

<p>

Consider the pattern of this computation.  To compute (fib 5),
we compute (fib 4) and (fib 3).  To compute (fib 4),
we compute (fib 3) and (fib 2).  In general, the evolved
process looks like a tree, as shown in figure 1.5.
Notice that the branches split into two at each level (except at the
bottom); this reflects the fact that the fib procedure calls
itself twice each time it is invoked.</p>

<p>


This procedure is instructive as a prototypical tree recursion, but it
is a terrible way to compute Fibonacci numbers because it does so much
redundant computation.  Notice in figure 1.5 that
the entire computation of (fib 3) -- almost half the work -- is
duplicated.  In fact, it is not hard to show that the number of times
the procedure will compute (fib 1) or (fib 0) (the number
of leaves in the above tree, in general) is precisely 
<emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis> + 1).  To get an idea of how bad this is, one can show that the
value of  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>) grows exponentially with <emphasis>n</emphasis>.  More precisely
(see exercise 1.13),  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>) is the closest
integer to <image xlink:href="#_18.jpg" /><sup><emphasis>n</emphasis></sup> /<image xlink:href="#_19.jpg" />5, where</p>

<p><image xlink:href="#_20.jpg" /></p>

<p>
is the <emphasis>golden ratio</emphasis>, which satisfies the equation</p>

<p><image xlink:href="#_21.jpg" /></p>

<p>

Thus, the process uses a number of steps that grows exponentially
with the input.  On the other hand, the space required grows only
linearly with the input, because we need keep track only of which
nodes are above us in the tree at any point in the computation.  In
general, the number of steps required by a tree-recursive process will be
proportional to the number of nodes in the tree, while the space
required will be proportional to the maximum depth of the tree.</p>

<p>

We can also formulate an iterative process for computing the
Fibonacci numbers.  The idea is to use a pair of integers <emphasis>a</emphasis> and
<emphasis>b</emphasis>, initialized to  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(1) = 1 and  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(0) = 0,
and to repeatedly apply the simultaneous
transformations</p>

<p><image xlink:href="#_22.jpg" /></p>

<p>
It is not hard to show that, after applying this transformation <emphasis>n</emphasis>
times, <emphasis>a</emphasis> and <emphasis>b</emphasis> will be equal, respectively, to  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis> + 1) and
 <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>).  Thus, we can compute Fibonacci numbers iteratively using
the procedure</p>

<p>(define (fib n)</p><empty-line /><p>
  (fib-iter 1 0 n))</p><empty-line /><empty-line /><p>
(define (fib-iter a b count)</p><empty-line /><p>
  (if (= count 0)</p><empty-line /><p>
      b</p><empty-line /><p>
      (fib-iter (+ a b) a (- count 1))))</p><empty-line /><p>
This second method for computing  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>) is a linear iteration.  The
difference in number of steps required by the two methods -- one linear in <emphasis>n</emphasis>,
one growing as fast as  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>) itself -- is enormous, even for
small inputs.</p>

<p>

One should not conclude from this that tree-recursive processes are
useless.  When we consider processes that operate on hierarchically
structured data rather than numbers, we will find that tree recursion
is a natural and powerful tool.<sup>32</sup> But even in numerical operations,
tree-recursive processes can be useful in helping us to understand and
design programs.  For instance, although the first fib procedure
is much less efficient than the second one, it is more
straightforward, being little more than a translation into Lisp of the
definition of the Fibonacci sequence.  To formulate the iterative
algorithm required noticing that the computation could be recast as an
iteration with three state variables.</p>

<p><strong>Example: Counting change</strong></p>

<p>


It takes only a bit of cleverness to come up with the iterative
Fibonacci algorithm.  In contrast, consider the
following problem: How many different ways can we make change of $ 1.00,
given half-dollars, quarters, dimes, nickels, and pennies?  More
generally, can we write a procedure to compute the number of ways to
change any given amount of money?</p>

<p>

This problem has a simple solution as a recursive procedure.  Suppose
we think of the types of coins available as arranged in some order.
Then the following relation holds:</p>

<p>The number of ways to change amount <emphasis>a</emphasis> using <emphasis>n</emphasis> kinds of coins equals</p>

<p>the number of ways to change amount <emphasis>a</emphasis> using all but the first
kind of coin, plus</p>

<p>the number of ways to change amount <emphasis>a</emphasis> - <emphasis>d</emphasis> using all <emphasis>n</emphasis> kinds of
coins, where <emphasis>d</emphasis> is the denomination of the first kind of coin.</p>

<p>

To see why this is true, observe that the ways to make change can be
divided into two groups: those that do not use any of the first kind
of coin, and those that do.  Therefore, the total number of ways to
make change for some amount is equal to the number of ways to make
change for the amount without using any of the first kind of coin,
plus the number of ways to make change assuming that we do use the
first kind of coin.  But the latter number is equal to the number of
ways to make change for the amount that remains after using a coin of
the first kind.</p>

<p>

Thus, we can recursively reduce the problem of changing a given amount
to the problem of changing smaller amounts using fewer kinds of coins.
Consider this reduction rule carefully, and convince yourself that we
can use it to describe an algorithm if we specify the following
degenerate cases:<sup>33</sup></p>

<p>If <emphasis>a</emphasis> is exactly 0, we should count that as 1 way to make change.</p>

<p>If <emphasis>a</emphasis> is less than 0, we should count that as 0 ways to make change.</p>

<p>If <emphasis>n</emphasis> is 0, we should count that as 0 ways to make change.</p>

<p>

We can easily translate this description into a recursive
procedure:</p>

<p>(define (count-change amount)</p><empty-line /><p>
  (cc amount 5))</p><empty-line /><p>
(define (cc amount kinds-of-coins)</p><empty-line /><p>
  (cond ((= amount 0) 1)</p><empty-line /><p>
        ((or (&lt; amount 0) (= kinds-of-coins 0)) 0)</p><empty-line /><p>
        (else (+ (cc amount</p><empty-line /><p>
                     (- kinds-of-coins 1))</p><empty-line /><p>
                 (cc (- amount</p><empty-line /><p>
                        (first-denomination kinds-of-coins))</p><empty-line /><p>
                     kinds-of-coins)))))</p><empty-line /><p>
(define (first-denomination kinds-of-coins)</p><empty-line /><p>
  (cond ((= kinds-of-coins 1) 1)</p><empty-line /><p>
        ((= kinds-of-coins 2) 5)</p><empty-line /><p>
        ((= kinds-of-coins 3) 10)</p><empty-line /><p>
        ((= kinds-of-coins 4) 25)</p><empty-line /><p>
        ((= kinds-of-coins 5) 50)))</p><empty-line /><p>
(The first-denomination procedure takes as input the number of
kinds of coins available and returns the denomination of the first
kind.  Here we are thinking of the coins as arranged in order from
largest to smallest, but any order would do as well.)  We can now
answer our original question about changing a dollar:</p>

<p>(count-change 100)</p><empty-line /><p><emphasis>292</emphasis></p><empty-line /><empty-line /><p>

Count-change generates a tree-recursive process with
redundancies similar to those in our first implementation of fib.  (It will take quite a while for that 292 to be computed.)  On
the other hand, it is not obvious how to design a better algorithm
for computing the result, and we leave this problem as a challenge.
The observation that a tree-recursive process may be highly
inefficient but often easy to specify and understand has led people to
propose that one could get the best of both worlds by designing a
"smart compiler" that could transform tree-recursive procedures into
more efficient procedures that compute the same result.<sup>34</sup></p>

<p>
<strong>Exercise 1.11.</strong>  A function <emphasis>f</emphasis> is defined by the rule that <emphasis>f</emphasis>(<emphasis>n</emphasis>) = <emphasis>n</emphasis> if <emphasis>n</emphasis>&lt;3 and
<emphasis>f</emphasis>(<emphasis>n</emphasis>) = <emphasis>f</emphasis>(<emphasis>n</emphasis> - 1) + 2<emphasis>f</emphasis>(<emphasis>n</emphasis> - 2) + 3<emphasis>f</emphasis>(<emphasis>n</emphasis> - 3) if <emphasis>n</emphasis>&gt; 3.  Write a procedure that
computes <emphasis>f</emphasis> by means of a recursive process.  Write a procedure that
computes <emphasis>f</emphasis> by means of an iterative process.</p>

<p>
<strong>Exercise 1.12.</strong>  The following pattern of numbers is called
<emphasis>Pascal's triangle</emphasis>.</p>

<p><image xlink:href="#_23.jpg" /></p>

<p>
The numbers at the edge of the triangle are all 1, and
each number inside the triangle is the sum of the two numbers above it.<sup>35</sup>
Write a procedure that computes elements of Pascal's triangle by means
of a recursive process.</p>

<p>
<strong>Exercise 1.13.</strong>  Prove that  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>) is the closest integer to <image xlink:href="#_18.jpg" /><sup><emphasis>n</emphasis></sup>/<image xlink:href="#_19.jpg" />5,
where <image xlink:href="#_18.jpg" /> =  (1 + <image xlink:href="#_19.jpg" />5)/2.  Hint: Let <image xlink:href="#_24.jpg" /> =  (1 - <image xlink:href="#_19.jpg" />5)/2.  Use
induction and the definition of the Fibonacci numbers (see
section 1.2.2) to prove that  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>) = (<image xlink:href="#_18.jpg" /><sup><emphasis>n</emphasis></sup>
 - <image xlink:href="#_24.jpg" /><sup><emphasis>n</emphasis></sup>)/<image xlink:href="#_19.jpg" />5.</p>

<p><strong>1.2.3  Orders of Growth</strong></p>

<p>



The previous examples illustrate that processes can differ
considerably in the rates at which they consume computational
resources.  One convenient way to describe this difference is to use
the notion of <emphasis>order of growth</emphasis> to obtain a gross measure of the
resources required by a process as the inputs become larger.</p>

<p>


Let <emphasis>n</emphasis> be a parameter that measures the size of the problem, and let
<emphasis>R</emphasis>(<emphasis>n</emphasis>) be the amount of resources the process requires for a problem
of size <emphasis>n</emphasis>.  In our previous examples we took <emphasis>n</emphasis> to be the number
for which a given function is to be computed, but there are other
possibilities.  For instance, if our goal is to compute an
approximation to the square root of a number, we might take <emphasis>n</emphasis> to be
the number of digits accuracy required.  For matrix multiplication we
might take <emphasis>n</emphasis> to be the number of rows in the matrices.  In general
there are a number of properties of the problem with respect to which
it will be desirable to analyze a given process.  Similarly, <emphasis>R</emphasis>(<emphasis>n</emphasis>)
might measure the number of internal storage registers used, the
number of elementary machine operations performed, and so on.  In
computers that do only a fixed number of operations at a time, the
time required will be proportional to the number of elementary machine
operations performed.</p>

<p>

We say that <emphasis>R</emphasis>(<emphasis>n</emphasis>) has order of growth <image xlink:href="#_25.jpg" />(<emphasis>f</emphasis>(<emphasis>n</emphasis>)), written
<emphasis>R</emphasis>(<emphasis>n</emphasis>) = <image xlink:href="#_25.jpg" />(<emphasis>f</emphasis>(<emphasis>n</emphasis>)) (pronounced "theta of <emphasis>f</emphasis>(<emphasis>n</emphasis>)"), if there are
positive constants <emphasis>k</emphasis><sub>1</sub> and <emphasis>k</emphasis><sub>2</sub> independent of <emphasis>n</emphasis> such that</p>

<p><image xlink:href="#_26.jpg" /></p>

<p>
for any sufficiently large value of <emphasis>n</emphasis>.  (In other
words, for large <emphasis>n</emphasis>, the value <emphasis>R</emphasis>(<emphasis>n</emphasis>) is sandwiched between <emphasis>k</emphasis><sub>1</sub><emphasis>f</emphasis>(<emphasis>n</emphasis>)
and <emphasis>k</emphasis><sub>2</sub><emphasis>f</emphasis>(<emphasis>n</emphasis>).)</p>

<p>

For instance, with the linear recursive process for computing
factorial described in section 1.2.1 the
number of steps grows proportionally to the input <emphasis>n</emphasis>.  Thus, the
steps required for this process grows as <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>).  We also saw
that the space required grows as <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>).  For the iterative
factorial, the number of steps is still <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) but the space is
<image xlink:href="#_25.jpg" />(1) -- that is, constant.<sup>36</sup> The tree-recursive Fibonacci computation requires
<image xlink:href="#_25.jpg" />(<image xlink:href="#_18.jpg" /><sup><emphasis>n</emphasis></sup>) steps and space <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>), where <image xlink:href="#_18.jpg" /> is the
golden ratio described in section 1.2.2.</p>

<p>


Orders of growth provide only a crude description of the behavior of a
process.  For example, a process requiring <emphasis>n</emphasis><sup>2</sup> steps and a process
requiring 1000<emphasis>n</emphasis><sup>2</sup> steps and a process requiring 3<emphasis>n</emphasis><sup>2</sup> + 10<emphasis>n</emphasis> + 17 steps
all have <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis><sup>2</sup>) order of growth.  On the other hand, order of
growth provides a useful indication of how we may expect the behavior
of the process to change as we change the size of the problem.  For a
<image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) (linear) process, doubling the size will roughly double the amount
of resources used.  For an exponential process, each increment in
problem size will multiply the resource utilization by a constant
factor.  In the remainder of section 1.2
we will examine two
algorithms whose order of growth is logarithmic, so that doubling the
problem size increases the resource requirement by a constant amount.</p>

<p>
<strong>Exercise 1.14.</strong>  Draw the tree illustrating the process generated by the count-change procedure of section 1.2.2 in making
change for 11 cents.  What are the orders of growth of the space and
number of steps used by this process as the amount to be changed
increases?</p>

<p>
<strong>Exercise 1.15.</strong>  The sine of an angle (specified in
radians) can be computed by making use of the approximation
sin <emphasis>x</emphasis> <image xlink:href="#_27.jpg" /><emphasis>x</emphasis>
if <emphasis>x</emphasis> is
sufficiently small, and the trigonometric identity</p>

<p><image xlink:href="#_28.jpg" /></p>

<p> 
to reduce the size of the argument of sin.  (For
purposes of this exercise an angle is considered "sufficiently
small" if its magnitude is not greater than 0.1 radians.) These
ideas are incorporated in the following procedures:</p>

<p>(define (cube x) (* x x x))</p><empty-line /><p>
(define (p x) (- (* 3 x) (* 4 (cube x))))</p><empty-line /><p>
(define (sine angle)</p><empty-line /><p>
   (if (not (&gt; (abs angle) 0.1))</p><empty-line /><p>
       angle</p><empty-line /><p>
       (p (sine (/ angle 3.0)))))</p><empty-line /><empty-line /><p>

a.  How many times is the procedure p 
applied when (sine 12.15) is evaluated?</p>

<p>

b.  What is the order of growth in space and number of steps (as a
function of <emphasis>a</emphasis>) used by the process generated by the sine
procedure when (sine a) is evaluated?</p>

<p><strong>1.2.4  Exponentiation</strong></p>

<p>




Consider the problem of computing the exponential of a given number.
We would like a procedure that takes as arguments a base <emphasis>b</emphasis> and a
positive integer exponent <emphasis>n</emphasis> and computes <emphasis>b</emphasis><sup><emphasis>n</emphasis></sup>.  One way to do this
is via the recursive definition</p>

<p><image xlink:href="#_29.jpg" /></p>

<p>
which translates readily into the procedure</p>

<p>(define (expt b n)</p><empty-line /><p>
  (if (= n 0)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* b (expt b (- n 1)))))</p><empty-line /><p>
This is a linear recursive process, which requires <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) steps
and <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) space.  Just as with factorial, we can readily
formulate an equivalent linear iteration:</p>

<p>(define (expt b n)</p><empty-line /><p>
  (expt-iter b n 1))</p><empty-line /><empty-line /><p>
(define (expt-iter b counter product)</p><empty-line /><p>
  (if (= counter 0)</p><empty-line /><p>
      product</p><empty-line /><p>
      (expt-iter b</p><empty-line /><p>
                (- counter 1)</p><empty-line /><p>
                (* b product))))</p><empty-line /><p>
This version requires <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) steps and <image xlink:href="#_25.jpg" />(1) space.</p>

<p>

We can compute exponentials in fewer steps by using successive
squaring.  For instance, rather than computing <emphasis>b</emphasis><sup>8</sup> as</p>

<p><image xlink:href="#_30.jpg" /></p>

<p>
we can compute it using three multiplications:</p>

<p><image xlink:href="#_31.jpg" /></p>

<p>

This method works fine for exponents that are powers of 2.  We can
also take advantage of successive squaring in computing exponentials
in general if we use the rule</p>

<p><image xlink:href="#_32.jpg" /></p>

<p>
We can express this method as a procedure:</p>

<p>(define (fast-expt b n)</p><empty-line /><p>
  (cond ((= n 0) 1)</p><empty-line /><p>
        ((even? n) (square (fast-expt b (/ n 2))))</p><empty-line /><p>
        (else (* b (fast-expt b (- n 1))))))</p><empty-line /><p>
where the predicate to test whether an integer is even is defined in terms of
the primitive procedure remainder by</p>

<p>(define (even? n)</p><empty-line /><p>
  (= (remainder n 2) 0))</p><empty-line /><p>
The process evolved by fast-expt grows logarithmically with <emphasis>n</emphasis>
in both space and number of steps.  To see this, observe that
computing <emphasis>b</emphasis><sup>2<emphasis>n</emphasis></sup> using fast-expt requires only one more
multiplication than computing <emphasis>b</emphasis><sup><emphasis>n</emphasis></sup>.  The size of the exponent we can
compute therefore doubles (approximately) with every new
multiplication we are allowed.  Thus, the number of multiplications
required for an exponent of <emphasis>n</emphasis> grows about as fast as the logarithm
of <emphasis>n</emphasis> to the base 2.  The process has <image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>)
growth.<sup>37</sup></p>

<p>

The difference between <image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>) growth and <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) growth
becomes striking as <emphasis>n</emphasis> becomes large.  For example, fast-expt
for <emphasis>n</emphasis> = 1000 requires only 14 multiplications.<sup>38</sup> It is also possible to use the idea of
successive squaring to devise an iterative algorithm that computes
exponentials with a logarithmic number of steps
(see exercise 1.16), although, as is often
the case with iterative algorithms, this is not written down so
straightforwardly as the recursive algorithm.<sup>39</sup></p>

<p>
<strong>Exercise 1.16.</strong>  Design a procedure that evolves an iterative exponentiation process
that uses successive squaring and uses a logarithmic number of steps,
as does fast-expt.  (Hint: Using the observation that
(<emphasis>b</emphasis><sup><emphasis>n</emphasis>/2</sup>)<sup>2</sup>  = (<emphasis>b</emphasis><sup>2</sup>)<sup><emphasis>n</emphasis>/2</sup>, keep, along with the exponent <emphasis>n</emphasis> and the
base <emphasis>b</emphasis>, an additional state variable <emphasis>a</emphasis>, and define the state
transformation in such a way that the product <emphasis>a</emphasis> <emphasis>b</emphasis><sup><emphasis>n</emphasis></sup> is unchanged
from state to state.  At the beginning of the process <emphasis>a</emphasis> is taken to
be 1, and the answer is given by the value of <emphasis>a</emphasis> at the end of the
process.  In general, the technique of defining an <emphasis>invariant
quantity</emphasis> that remains unchanged from state to state is a powerful way
to think about the design of iterative algorithms.)</p>

<p>
<strong>Exercise 1.17.</strong>  The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication.  In a similar way,
one can perform integer multiplication by means of repeated addition.
The following multiplication procedure (in which it is assumed that
our language can only add, not multiply) is analogous to the expt procedure:</p>

<p>(define (* a b)</p><empty-line /><p>
  (if (= b 0)</p><empty-line /><p>
      0</p><empty-line /><p>
      (+ a (* a (- b 1)))))</p><empty-line /><p>

This algorithm takes a number of steps that is linear in b.
Now suppose we include, together with addition, operations double,
which doubles an integer, and halve, which divides an (even)
integer by 2.  Using these, design a multiplication procedure analogous
to fast-expt that uses a logarithmic number of steps.</p>

<p>
<strong>Exercise 1.18.</strong>  Using the results of exercises 1.16
and 1.17, devise a procedure that generates an iterative
process for multiplying two integers in terms of adding, doubling, and
halving and uses a logarithmic number of steps.<sup>40</sup></p>

<p>
<strong>Exercise 1.19.</strong>  
There is a clever algorithm for computing the Fibonacci numbers in
a logarithmic number of steps.
Recall the transformation of the state variables
<emphasis>a</emphasis> and <emphasis>b</emphasis> in the fib-iter process of
section 1.2.2: <emphasis>a</emphasis> <image xlink:href="#_13.jpg" /><emphasis>a</emphasis> + <emphasis>b</emphasis> and <emphasis>b</emphasis> <image xlink:href="#_13.jpg" /><emphasis>a</emphasis>.  Call this transformation <emphasis>T</emphasis>, and observe that applying <emphasis>T</emphasis> over
and over again <emphasis>n</emphasis> times, starting with 1 and 0, produces the pair
 <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis> + 1) and  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>).  In other words, the Fibonacci
numbers are produced by applying <emphasis>T</emphasis><sup><emphasis>n</emphasis></sup>, the <emphasis>n</emphasis>th power of the
transformation <emphasis>T</emphasis>, starting with the pair (1,0).  Now consider <emphasis>T</emphasis>
to be the special case of <emphasis>p</emphasis> = 0 and <emphasis>q</emphasis> = 1 in a family of
transformations <emphasis>T</emphasis><sub><emphasis>p</emphasis><emphasis>q</emphasis></sub>, where <emphasis>T</emphasis><sub><emphasis>p</emphasis><emphasis>q</emphasis></sub> transforms the pair (<emphasis>a</emphasis>,<emphasis>b</emphasis>)
according to <emphasis>a</emphasis> <image xlink:href="#_13.jpg" /><emphasis>b</emphasis><emphasis>q</emphasis> + <emphasis>a</emphasis><emphasis>q</emphasis> + <emphasis>a</emphasis><emphasis>p</emphasis> and <emphasis>b</emphasis> <image xlink:href="#_13.jpg" /><emphasis>b</emphasis><emphasis>p</emphasis> + <emphasis>a</emphasis><emphasis>q</emphasis>.  Show
that if we apply such a transformation <emphasis>T</emphasis><sub><emphasis>p</emphasis><emphasis>q</emphasis></sub> twice, the effect is
the same as using a single transformation <emphasis>T</emphasis><sub><emphasis>p</emphasis>'<emphasis>q</emphasis>'</sub> of the same form,
and compute <emphasis>p</emphasis>' and <emphasis>q</emphasis>' in terms of <emphasis>p</emphasis> and <emphasis>q</emphasis>.  This gives us an
explicit way to square these transformations, and thus we can compute
<emphasis>T</emphasis><sup><emphasis>n</emphasis></sup> using successive squaring, as in the fast-expt
procedure.  Put this all together to complete the following procedure,
which runs in a logarithmic number of steps:<sup>41</sup></p>

<p>(define (fib n)</p><empty-line /><p>
  (fib-iter 1 0 0 1 n))</p><empty-line /><p>
(define (fib-iter a b p q count)</p><empty-line /><p>
  (cond ((= count 0) b)</p><empty-line /><p>
        ((even? count)</p><empty-line /><p>
         (fib-iter a</p><empty-line /><p>
                   b</p><empty-line /><p>
                   &lt;<emphasis>??</emphasis>&gt;      <emphasis>; compute p'</emphasis></p><empty-line /><p>
                   &lt;<emphasis>??</emphasis>&gt;      <emphasis>; compute q'</emphasis></p><empty-line /><p>
                   (/ count 2)))</p><empty-line /><p>
        (else (fib-iter (+ (* b q) (* a q) (* a p))</p><empty-line /><p>
                        (+ (* b p) (* a q))</p><empty-line /><p>
                        p</p><empty-line /><p>
                        q</p><empty-line /><p>
                        (- count 1)))))</p><empty-line /><empty-line /><p><strong>1.2.5  Greatest Common Divisors</strong></p>

<p>



The greatest common divisor (GCD) of two integers <emphasis>a</emphasis> and <emphasis>b</emphasis> is
defined to be the largest integer that divides both <emphasis>a</emphasis> and
<emphasis>b</emphasis> with no remainder.  For example, the GCD of 16 and 28 is 4.  In chapter 2,
when we investigate how to implement rational-number arithmetic, we
will need to be able to compute GCDs in order to reduce
rational numbers to lowest terms.  (To reduce a rational number to
lowest terms, we must divide both the numerator and the denominator by their
GCD.  For example, 16/28 reduces to 4/7.)  One way to find the
GCD of two integers is to factor them and search for common
factors, but there is a famous algorithm that is much more efficient.</p>

<p>

The idea of the algorithm is based on the observation that, if <emphasis>r</emphasis> is
the remainder when <emphasis>a</emphasis> is divided by <emphasis>b</emphasis>, then the common divisors of
<emphasis>a</emphasis> and <emphasis>b</emphasis> are precisely the same as the common divisors of <emphasis>b</emphasis> and
<emphasis>r</emphasis>.  Thus, we can use the equation</p>

<p><image xlink:href="#_33.jpg" /></p>

<p>
to successively reduce the problem of computing a GCD to the
problem of computing the GCD of smaller and smaller pairs of
integers.  For example,</p>

<p><image xlink:href="#_34.jpg" /></p>

<p>
reduces GCD(206,40) to GCD(2,0), which is 2.  It is
possible to show that starting with any two positive integers and
performing repeated reductions will always eventually produce a pair
where the second number is 0.  Then the GCD is the other
number in the pair.  This method for computing the GCD is
known as <emphasis>Euclid's Algorithm</emphasis>.<sup>42</sup></p>

<p>

It is easy to express Euclid's Algorithm as a procedure:</p>

<p>(define (gcd a b)</p><empty-line /><p>
  (if (= b 0)</p><empty-line /><p>
      a</p><empty-line /><p>
      (gcd b (remainder a b))))</p><empty-line /><p>
This generates an iterative process, whose number of steps grows as
the logarithm of the numbers involved.</p>

<p>

The fact that the number of steps required by Euclid's Algorithm has
logarithmic growth bears an interesting relation to the Fibonacci
numbers:</p>

<p><strong>Lamé's Theorem:</strong> If Euclid's Algorithm requires <emphasis>k</emphasis> steps to
compute the GCD of some pair, then the smaller number in the pair
must be greater than or equal to the <emphasis>k</emphasis>th Fibonacci
number.<sup>43</sup></p><empty-line /><p>

We can use this theorem to get an order-of-growth estimate for Euclid's
Algorithm.  Let <emphasis>n</emphasis> be the smaller of the two inputs to the
procedure.  If the process takes <emphasis>k</emphasis> steps, then we must have 
<emphasis>n</emphasis>&gt;  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis> (<emphasis>k</emphasis>) <image xlink:href="#_27.jpg" /><image xlink:href="#_18.jpg" /><sup><emphasis>k</emphasis></sup>/<image xlink:href="#_19.jpg" />5.  Therefore
the number of steps <emphasis>k</emphasis> grows as the logarithm (to the base
<image xlink:href="#_18.jpg" />) of <emphasis>n</emphasis>.  Hence, the order of growth is <image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>).</p>

<p>
<strong>Exercise 1.20.</strong>  The process that a procedure generates is of course dependent on the
rules used by the interpreter.  As an example, consider the iterative
gcd procedure given above.
Suppose we were to interpret this procedure using normal-order
evaluation, as discussed in section 1.1.5.
(The normal-order-evaluation rule for if is described in
exercise 1.5.)  Using the
substitution method (for normal order), illustrate the process
generated in evaluating (gcd 206 40) and indicate the
remainder operations that are actually performed.
How many remainder operations are actually performed
in the normal-order evaluation of (gcd 206 40)?
In the applicative-order evaluation?</p>

<p><strong>1.2.6  Example: Testing for Primality</strong></p>

<p>



This section describes two methods for checking the primality of an
integer <emphasis>n</emphasis>, one with order of growth <image xlink:href="#_25.jpg" />(<image xlink:href="#_19.jpg" /><emphasis>n</emphasis>), and a
"probabilistic" algorithm with order of growth <image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>).  The
exercises at the end of this section suggest programming
projects based on these algorithms.</p>

<p><strong>Searching for divisors</strong></p>

<p>

Since ancient times, mathematicians have been fascinated by problems
concerning prime numbers, and many people have worked on the problem
of determining ways to test if numbers are prime.  One way
to test if a number is prime is to find the number's divisors.  The
following program finds the smallest integral divisor (greater than 1)
of a given number <emphasis>n</emphasis>.  It does this in a straightforward way, by
testing <emphasis>n</emphasis> for divisibility by successive integers starting with 2.</p>

<p>(define (smallest-divisor n)</p><empty-line /><p>
  (find-divisor n 2))</p><empty-line /><p>(define (find-divisor n test-divisor)</p><empty-line /><p>
  (cond ((&gt; (square test-divisor) n) n)</p><empty-line /><p>
        ((divides? test-divisor n) test-divisor)</p><empty-line /><p>
        (else (find-divisor n (+ test-divisor 1)))))</p><empty-line /><p>(define (divides? a b)</p><empty-line /><p>
  (= (remainder b a) 0))</p><empty-line /><empty-line /><p>

We can test whether a number is prime as follows: <emphasis>n</emphasis> is prime if
and only if <emphasis>n</emphasis> is its own smallest divisor.</p>

<p>(define (prime? n)</p><empty-line /><p>
  (= n (smallest-divisor n)))</p><empty-line /><empty-line /><p>

The end test for find-divisor is based on the fact that if <emphasis>n</emphasis>
is not prime it must have a divisor less than or equal to
<image xlink:href="#_19.jpg" /><emphasis>n</emphasis>.<sup>44</sup>  This
means that the algorithm need only test divisors between 1 and
<image xlink:href="#_19.jpg" /><emphasis>n</emphasis>.  Consequently, the number of steps required to identify
<emphasis>n</emphasis> as prime will have order of growth <image xlink:href="#_25.jpg" />(<image xlink:href="#_19.jpg" /><emphasis>n</emphasis>).</p>

<p><strong>The Fermat test</strong></p>

<p>

The <image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>) primality test is based on a result from number
theory known as Fermat's Little Theorem.<sup>45</sup></p>

<p><strong>Fermat's Little Theorem:</strong> If <emphasis>n</emphasis> is a prime number and 
<emphasis>a</emphasis> is any positive integer less than <emphasis>n</emphasis>, then <emphasis>a</emphasis> raised to the
<emphasis>n</emphasis>th power is congruent to <emphasis>a</emphasis> modulo <emphasis>n</emphasis>.</p>

<p>(Two numbers are said to be <emphasis>congruent modulo</emphasis> <emphasis>n</emphasis> if
they both have the same remainder when divided by <emphasis>n</emphasis>.  The
remainder of a number <emphasis>a</emphasis> when divided by <emphasis>n</emphasis> is also referred to as
the <emphasis>remainder of</emphasis> <emphasis>a</emphasis> <emphasis>modulo</emphasis> <emphasis>n</emphasis>, or simply as <emphasis>a</emphasis> 
<emphasis>modulo</emphasis> <emphasis>n</emphasis>.)</p>

<p>

If <emphasis>n</emphasis> is not prime, then, in general, most of the numbers <emphasis>a</emphasis>&lt; <emphasis>n</emphasis> will not
satisfy the above relation.  This leads to the following algorithm for
testing primality: Given a number <emphasis>n</emphasis>, pick a random number <emphasis>a</emphasis> &lt; <emphasis>n</emphasis> and
compute the remainder of <emphasis>a</emphasis><sup><emphasis>n</emphasis></sup> modulo <emphasis>n</emphasis>.  If the result is not equal to
<emphasis>a</emphasis>, then <emphasis>n</emphasis> is certainly not prime.  If it is <emphasis>a</emphasis>, then chances are good
that <emphasis>n</emphasis> is prime.  Now pick another random number <emphasis>a</emphasis> and test it with the
same method.  If it also satisfies the equation, then we can be even more
confident that <emphasis>n</emphasis> is prime.  By trying more and more values of <emphasis>a</emphasis>, we can
increase our confidence in the result.  This algorithm is known as the
Fermat test.</p>

<p>

To implement the Fermat test, we need a procedure that computes the
exponential of a number modulo another number:</p>

<p>(define (expmod base exp m)</p><empty-line /><p>
  (cond ((= exp 0) 1)</p><empty-line /><p>
        ((even? exp)</p><empty-line /><p>
         (remainder (square (expmod base (/ exp 2) m))</p><empty-line /><p>
                    m))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (remainder (* base (expmod base (- exp 1) m))</p><empty-line /><p>
                    m))))</p><empty-line /><p>
This is very similar to the fast-expt procedure of
section 1.2.4.  It uses successive squaring, so
that the number of steps grows logarithmically with the
exponent.<sup>46</sup></p>

<p>

The Fermat test is performed by choosing at random a number <emphasis>a</emphasis>
between 1 and <emphasis>n</emphasis> - 1 inclusive and checking whether the remainder
modulo <emphasis>n</emphasis> of the <emphasis>n</emphasis>th power of <emphasis>a</emphasis> is equal to <emphasis>a</emphasis>.  The random
number <emphasis>a</emphasis> is chosen using the procedure random, which we assume is
included as a primitive in Scheme. Random returns a
nonnegative integer less than its integer input.  Hence, to obtain a random
number between 1 and <emphasis>n</emphasis> - 1, we call random with an input of
<emphasis>n</emphasis> - 1 and add 1 to the result:</p>

<p>(define (fermat-test n)</p><empty-line /><p>
  (define (try-it a)</p><empty-line /><p>
    (= (expmod a n n) a))</p><empty-line /><p>
  (try-it (+ 1 (random (- n 1)))))</p><empty-line /><empty-line /><p>

The following procedure runs the test a given number of times, as
specified by a parameter.  Its value is true if the test succeeds
every time, and false otherwise.</p>

<p>(define (fast-prime? n times)</p><empty-line /><p>
  (cond ((= times 0) true)</p><empty-line /><p>
        ((fermat-test n) (fast-prime? n (- times 1)))</p><empty-line /><p>
        (else false)))</p><empty-line /><empty-line /><p><strong>Probabilistic methods</strong></p>

<p>


The Fermat test differs in character from most familiar algorithms, in
which one computes an answer that is guaranteed to be correct.  Here,
the answer obtained is only probably correct.  More precisely, if <emphasis>n</emphasis>
ever fails the Fermat test, we can be certain that <emphasis>n</emphasis> is not prime.
But the fact that <emphasis>n</emphasis> passes the test, while an extremely strong
indication, is still not a guarantee that <emphasis>n</emphasis> is prime.  What we would
like to say is that for any number <emphasis>n</emphasis>, if we perform the test enough
times and find that <emphasis>n</emphasis> always passes the test, then the probability
of error in our primality test can be made as small as we like.</p>

<p>


Unfortunately, this assertion is not quite correct.  There do exist
numbers that fool the Fermat test: numbers <emphasis>n</emphasis> that are not prime and
yet have the property that <emphasis>a</emphasis><sup><emphasis>n</emphasis></sup> is congruent to <emphasis>a</emphasis> modulo <emphasis>n</emphasis> for
all integers <emphasis>a</emphasis> &lt; <emphasis>n</emphasis>.  Such numbers are extremely rare, so the Fermat
test is quite reliable in practice.<sup>47</sup>
There are variations of the Fermat test that cannot be fooled.  In
these tests, as with the Fermat method, one tests the primality of an
integer <emphasis>n</emphasis> by choosing a random integer <emphasis>a</emphasis>&lt;<emphasis>n</emphasis> and checking some
condition that depends upon <emphasis>n</emphasis> and <emphasis>a</emphasis>.  (See
exercise 1.28 for an example of such a test.)  On the
other hand, in contrast to the Fermat test, one can prove that, for
any <emphasis>n</emphasis>, the condition does not hold for most of the integers <emphasis>a</emphasis>&lt;<emphasis>n</emphasis>
unless <emphasis>n</emphasis> is prime.  Thus, if <emphasis>n</emphasis> passes the test for some random
choice of <emphasis>a</emphasis>, the chances are better than even that <emphasis>n</emphasis> is prime.  If
<emphasis>n</emphasis> passes the test for two random choices of <emphasis>a</emphasis>, the chances are better
than 3 out of 4 that <emphasis>n</emphasis> is prime. By running the test with more and
more randomly chosen values of <emphasis>a</emphasis> we can make the probability of
error as small as we like.</p>

<p>

The existence of tests for which one can prove that the chance of
error becomes arbitrarily small has sparked interest in algorithms of
this type, which have come to be known as <emphasis>probabilistic
algorithms</emphasis>.  There is a great deal of research activity in this area,
and probabilistic algorithms have been fruitfully applied to many
fields.<sup>48</sup></p>

<p>
<strong>Exercise 1.21.</strong>  Use the smallest-divisor procedure to find the smallest divisor
of each of the following numbers: 199, 1999, 19999.</p>

<p>
<strong>Exercise 1.22.</strong>  Most Lisp implementations include a primitive called runtime
that returns an integer that specifies the amount of time the system
has been running (measured, for example, in microseconds).  The
following timed-prime-test procedure, when called with an
integer <emphasis>n</emphasis>, prints <emphasis>n</emphasis> and checks to see if <emphasis>n</emphasis> is prime.  If <emphasis>n</emphasis> is
prime, the procedure prints three asterisks followed by the amount of time
used in performing the test.</p>

<p>(define (timed-prime-test n)</p><empty-line /><p>
  (newline)</p><empty-line /><p>
  (display n)</p><empty-line /><p>
  (start-prime-test n (runtime)))</p><empty-line /><p>
(define (start-prime-test n start-time)</p><empty-line /><p>
  (if (prime? n)</p><empty-line /><p>
      (report-prime (- (runtime) start-time))))</p><empty-line /><p>
(define (report-prime elapsed-time)</p><empty-line /><p>
  (display " *** ")</p><empty-line /><p>
  (display elapsed-time))</p><empty-line /><p>
Using this procedure, write a procedure search-for-primes that
checks the primality of consecutive odd integers in a specified range.
Use your procedure to find the three smallest primes larger than 1000;
larger than 10,000; larger than 100,000; larger than 1,000,000.  Note
the time needed to test each prime.  Since the testing algorithm has
order of growth of <image xlink:href="#_25.jpg" />(<image xlink:href="#_19.jpg" /><emphasis>n</emphasis>), you should expect that testing
for primes around 10,000 should take about <image xlink:href="#_19.jpg" />10 times as long
as testing for primes around 1000.  Do your timing data bear this out?
How well do the data for 100,000 and 1,000,000 support the <image xlink:href="#_19.jpg" /><emphasis>n</emphasis>
prediction?  Is your result compatible with the notion that programs
on your machine run in time proportional to the number of steps
required for the computation?</p>

<p>
<strong>Exercise 1.23.</strong>  The smallest-divisor procedure shown at the start of this section
does lots of needless testing: After it checks to see if the
number is divisible by 2 there is no point in checking to see if
it is divisible by any larger even numbers.  This suggests that the
values used for test-divisor should not be 2, 3, 4, 5, 6,
..., but rather 2, 3, 5, 7, 9, ....  To implement this
change, define a procedure next that returns 3 if its input is
equal to 2 and otherwise returns its input plus 2.  Modify the smallest-divisor procedure to use (next test-divisor) instead
of (+ test-divisor 1).  With timed-prime-test
incorporating this modified version of smallest-divisor, run the
test for each of the 12 primes found in
exercise 1.22.  Since this modification halves the
number of test steps, you should expect it to run about twice as fast.
Is this expectation confirmed?  If not, what is the observed ratio of
the speeds of the two algorithms, and how do you explain the fact that
it is different from 2?</p>

<p>
<strong>Exercise 1.24.</strong>  Modify the timed-prime-test procedure of
exercise 1.22 to use fast-prime? (the
Fermat method), and test each of the 12 primes you found in that
exercise.  Since the Fermat test has <image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>) growth, how
would you expect the time to test primes near 1,000,000 to compare
with the time needed to test primes near 1000?  Do your data bear this
out?  Can you explain any discrepancy you find?</p>

<p>
<strong>Exercise 1.25.</strong>  Alyssa P. Hacker complains that we went to a lot of extra work in
writing expmod.  After all, she says, since we already know how
to compute exponentials, we could have simply written</p>

<p>(define (expmod base exp m)</p><empty-line /><p>
  (remainder (fast-expt base exp) m))</p><empty-line /><p>
Is she correct?  Would this procedure serve as well for our fast prime
tester?  Explain.</p>

<p>
<strong>Exercise 1.26.</strong>  Louis Reasoner is having great difficulty doing
exercise 1.24.  His fast-prime? test
seems to run more slowly than his prime? test.  Louis calls his
friend Eva Lu Ator over to help.  When they examine Louis's code, they
find that he has rewritten the expmod procedure to use an
explicit multiplication, rather than calling square:</p>

<p>(define (expmod base exp m)</p><empty-line /><p>
  (cond ((= exp 0) 1)</p><empty-line /><p>
        ((even? exp)</p><empty-line /><p>
         (remainder (* (expmod base (/ exp 2) m)</p><empty-line /><p>
                       (expmod base (/ exp 2) m))</p><empty-line /><p>
                    m))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (remainder (* base (expmod base (- exp 1) m))</p><empty-line /><p>
                    m))))</p><empty-line /><p>
"I don't see what difference that could make", says Louis.  "I
do."  says Eva.  "By writing the procedure like that, you have
transformed the <image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>) process into a <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) process."
Explain.</p>

<p>
<strong>Exercise 1.27.</strong>  Demonstrate that the Carmichael numbers listed in
footnote 47 really do fool
the Fermat test.  That is, write a procedure that takes an integer <emphasis>n</emphasis>
and tests whether <emphasis>a</emphasis><sup><emphasis>n</emphasis></sup> is congruent to <emphasis>a</emphasis> modulo <emphasis>n</emphasis> for every
<emphasis>a</emphasis>&lt;<emphasis>n</emphasis>, and try your procedure on the given Carmichael numbers.</p>

<p>
<strong>Exercise 1.28.</strong>  One variant of the Fermat test that cannot be fooled is called the
<emphasis>Miller-Rabin test</emphasis> (Miller 1976; Rabin 1980).  This starts from
an alternate form of Fermat's Little Theorem, which states that if <emphasis>n</emphasis>
is a prime number and <emphasis>a</emphasis> is any positive integer less than <emphasis>n</emphasis>, then
<emphasis>a</emphasis> raised to the (<emphasis>n</emphasis> - 1)st power is congruent to 1 modulo <emphasis>n</emphasis>.  To test
the primality of a number <emphasis>n</emphasis> by the Miller-Rabin test, we pick a
random number <emphasis>a</emphasis>&lt;<emphasis>n</emphasis> and raise <emphasis>a</emphasis> to the (<emphasis>n</emphasis> - 1)st power modulo <emphasis>n</emphasis>
using the expmod procedure.  However, whenever we perform the
squaring step in expmod, we check to see if we have discovered a
"nontrivial square root of 1 modulo <emphasis>n</emphasis>", that is, a number not
equal to 1 or <emphasis>n</emphasis> - 1 whose square is equal to 1 modulo <emphasis>n</emphasis>.  It is
possible to prove that if such a nontrivial square root of 1 exists,
then <emphasis>n</emphasis> is not prime.  It is also possible to prove that if <emphasis>n</emphasis> is an
odd number that is not prime, then, for at least half the numbers
<emphasis>a</emphasis>&lt;<emphasis>n</emphasis>, computing <emphasis>a</emphasis><sup><emphasis>n</emphasis>-1</sup> in this way will reveal a nontrivial
square root of 1 modulo <emphasis>n</emphasis>.  (This is why the Miller-Rabin test
cannot be fooled.)  Modify the expmod procedure to signal if it
discovers a nontrivial square root of 1, and use this to implement
the Miller-Rabin test with a procedure analogous to fermat-test.
Check your procedure by testing various known primes and non-primes.
Hint: One convenient way to make expmod signal is to have it
return 0.</p><empty-line /><empty-line /><empty-line /><p><sup>29</sup> In a real program we would probably use the
block structure introduced in the last section to hide the definition
of fact-iter:</p>

<p>(define (factorial n)</p><empty-line /><p>
  (define (iter product counter)</p><empty-line /><p>
    (if (&gt; counter n)</p><empty-line /><p>
        product</p><empty-line /><p>
        (iter (* counter product)</p><empty-line /><p>
              (+ counter 1))))</p><empty-line /><p>
  (iter 1 1))</p><empty-line /><p>
We avoided doing this here so as to minimize the number of things to
think about at once.</p>

<p><sup>30</sup> When we discuss the implementation of
procedures on register machines in chapter 5, we will see that any
iterative process can be realized "in hardware" as a machine that
has a fixed set of registers and no auxiliary memory.  In contrast,
realizing a recursive process requires a machine that uses an
auxiliary data structure known as a <emphasis>stack</emphasis>.</p>

<p><sup>31</sup> Tail recursion has long been
known as a compiler optimization trick.  A coherent semantic basis for
tail recursion was provided by Carl Hewitt (1977), who explained it in
terms of the "message-passing" model of computation that we shall
discuss in chapter 3. Inspired by this, Gerald Jay Sussman and Guy
Lewis Steele Jr. (see Steele 1975) constructed a tail-recursive
interpreter for Scheme.  Steele later showed how tail recursion is a
consequence of the natural way to compile procedure calls (Steele
1977).  The IEEE standard for Scheme requires that Scheme implementations
be tail-recursive.</p>

<p><sup>32</sup> An example of this was hinted
at in section 1.1.3:
The interpreter itself evaluates expressions
using a tree-recursive process.</p>

<p><sup>33</sup> For example, work through in detail how the
reduction rule applies to the problem of making change for 10 cents
using pennies and nickels.</p>

<p><sup>34</sup> One
approach to coping with redundant computations is to arrange matters
so that we automatically construct a table of values as they
are computed.  Each time we are asked to apply the procedure to some
argument, we first look to see if the value is already stored in the
table, in which case we avoid performing the redundant computation.
This strategy, known as <emphasis>tabulation</emphasis> or <emphasis>memoization</emphasis>, can be
implemented in a straightforward way.  Tabulation can sometimes be
used to transform processes that require an exponential number of
steps (such as count-change) into processes whose space and time
requirements grow linearly with the input.  See
exercise 3.27.</p>

<p><sup>35</sup> The elements of Pascal's triangle are called the <emphasis>binomial
coefficients</emphasis>, because the <emphasis>n</emphasis>th row consists of
the coefficients of the terms in the
expansion of (<emphasis>x</emphasis> + <emphasis>y</emphasis>)<sup><emphasis>n</emphasis></sup>.  This pattern for computing the coefficients
appeared in Blaise Pascal's 1653 seminal work on probability theory, <emphasis>Traité du triangle arithmétique</emphasis>.  According to
Knuth (1973), the same pattern appears in the <emphasis>Szu-yuen
Yü-chien</emphasis> ("The Precious Mirror of the Four Elements"), published
by the Chinese mathematician Chu Shih-chieh in 1303, in the
works of the twelfth-century Persian poet and mathematician Omar
Khayyam, and in the works of the twelfth-century Hindu mathematician
Bháscara Áchárya.</p>

<p><sup>36</sup> These statements mask a
great deal of oversimplification.  For instance, if we count process
steps as "machine operations" we are making the assumption that the
number of machine operations needed to perform, say, a multiplication
is independent of the size of the numbers to be multiplied, which is
false if the numbers are sufficiently large.  Similar remarks hold for
the estimates of space.  Like the design and description of a process,
the analysis of a process can be carried out at various levels of
abstraction.</p>

<p><sup>37</sup> More precisely, the number of multiplications
required is equal to 1 less than the log base 2 of <emphasis>n</emphasis> plus the number
of ones in the binary representation of <emphasis>n</emphasis>.  This total is always
less than twice the log base 2 of <emphasis>n</emphasis>.  The arbitrary constants
<emphasis>k</emphasis><sub>1</sub> and <emphasis>k</emphasis><sub>2</sub> in
the definition of order notation imply that, for a logarithmic
process, the base to which logarithms are taken does not matter, so
all such processes are described as <image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>).</p>

<p><sup>38</sup> You may wonder
why anyone would care about raising numbers to the 1000th power.  See
section 1.2.6.</p>

<p><sup>39</sup> This iterative
algorithm is ancient.  It appears in the <emphasis>Chandah-sutra</emphasis> by
Áchárya Pingala, written before 200 B.C. See Knuth 1981, section
4.6.3, for a full discussion and analysis of this and other methods of
exponentiation.</p>

<p><sup>40</sup> This
algorithm, which is sometimes known as the "Russian peasant method"
of multiplication, is ancient.  Examples of its use are found in the
Rhind Papyrus, one of the two oldest mathematical documents in
existence, written about 1700 B.C. (and copied from an even
older document) by an Egyptian scribe named A'h-mose.</p>

<p><sup>41</sup> This exercise was
suggested to us by Joe Stoy, based on an example in Kaldewaij 1990.</p>

<p><sup>42</sup> Euclid's Algorithm is so
called because it appears in Euclid's <emphasis>Elements</emphasis> (Book 7, ca. 300
B.C.).  According to Knuth (1973), it can be considered the
oldest known nontrivial algorithm.  The ancient Egyptian method of
multiplication (exercise 1.18) is surely older,
but, as Knuth explains, Euclid's algorithm is the oldest known to have
been presented as a general algorithm, rather than as a set of
illustrative examples.</p>

<p><sup>43</sup> This theorem was proved in 1845 by Gabriel Lamé, a
French mathematician and engineer known chiefly for his contributions
to mathematical physics.  To prove the theorem, we consider pairs
(<emphasis>a</emphasis><sub><emphasis>k</emphasis></sub> ,<emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>), where <emphasis>a</emphasis><sub><emphasis>k</emphasis></sub>&gt; <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>, for which Euclid's Algorithm
terminates in <emphasis>k</emphasis> steps.  The proof is based on the claim that, if
(<emphasis>a</emphasis><sub><emphasis>k</emphasis>+1</sub>, <emphasis>b</emphasis><sub><emphasis>k</emphasis>+1</sub>)  <image xlink:href="#_35.jpg" />  (<emphasis>a</emphasis><sub><emphasis>k</emphasis></sub>, <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>)
 <image xlink:href="#_35.jpg" />  (<emphasis>a</emphasis><sub><emphasis>k</emphasis>-1</sub>, <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub>) are three successive pairs in the
reduction process, then we must have <emphasis>b</emphasis><sub><emphasis>k</emphasis>+1</sub>&gt; <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>  +  <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub>.
To verify the claim, consider that a reduction step is defined by
applying the transformation <emphasis>a</emphasis><sub><emphasis>k</emphasis>-1</sub>  =  <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>, <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub>  = 
 remainder of  <emphasis>a</emphasis><sub><emphasis>k</emphasis></sub> divided by <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>.  
The second equation means that <emphasis>a</emphasis><sub><emphasis>k</emphasis></sub>  =  <emphasis>q</emphasis><emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>  +  <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub> for some
positive integer <emphasis>q</emphasis>.  And since <emphasis>q</emphasis> must be at least 1 we have <emphasis>a</emphasis><sub><emphasis>k</emphasis></sub>
 =  <emphasis>q</emphasis><emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>  +  <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub>&gt; <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>  +  <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub>.  But in the previous
reduction step we have <emphasis>b</emphasis><sub><emphasis>k</emphasis>+1</sub> =  <emphasis>a</emphasis><sub><emphasis>k</emphasis></sub>.  Therefore, <emphasis>b</emphasis><sub><emphasis>k</emphasis>+1</sub>  = 
<emphasis>a</emphasis><sub><emphasis>k</emphasis></sub>&gt; <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>  +  <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub>.  This verifies the claim.  Now we can
prove the theorem by induction on <emphasis>k</emphasis>, the number of steps that the
algorithm requires to terminate.  The result is true for <emphasis>k</emphasis> = 1, since
this merely requires that <emphasis>b</emphasis> be at least as large as 
<emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(1) = 1.  Now, assume that the result is true for all integers less
than or equal to <emphasis>k</emphasis> and establish the result for <emphasis>k</emphasis> + 1.  Let
(<emphasis>a</emphasis><sub><emphasis>k</emphasis>+1</sub>, <emphasis>b</emphasis><sub><emphasis>k</emphasis>+1</sub>) <image xlink:href="#_35.jpg" /> (<emphasis>a</emphasis><sub><emphasis>k</emphasis></sub>, <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>)
 <image xlink:href="#_35.jpg" /> (<emphasis>a</emphasis><sub><emphasis>k</emphasis>-1</sub>, <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub>) be successive pairs in the
reduction process.  By our induction hypotheses, we have <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub>&gt;
 <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>k</emphasis> - 1) and <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>&gt;  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>k</emphasis>).  Thus, applying the claim we just
proved together with the definition of the Fibonacci numbers gives
<emphasis>b</emphasis><sub><emphasis>k</emphasis>+1</sub>&gt; <emphasis>b</emphasis><sub><emphasis>k</emphasis></sub>  +  <emphasis>b</emphasis><sub><emphasis>k</emphasis>-1</sub>&gt;  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>k</emphasis>)  +   <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>k</emphasis> - 1)  =  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>k</emphasis> + 1), which
completes the proof of Lamé's Theorem.</p>

<p><sup>44</sup> If <emphasis>d</emphasis> is a divisor of <emphasis>n</emphasis>, then so is <emphasis>n</emphasis>/<emphasis>d</emphasis>.
But <emphasis>d</emphasis> and <emphasis>n</emphasis>/<emphasis>d</emphasis> cannot both be greater than <image xlink:href="#_19.jpg" /><emphasis>n</emphasis>.</p>

<p><sup>45</sup> Pierre de Fermat (1601-1665) is considered to be the founder of
modern number theory.  He obtained many important number-theoretic
results, but he usually announced just the results, without providing
his proofs.  Fermat's Little Theorem was stated in a letter he wrote in
1640.  The first published proof was given by Euler in 1736 (and an
earlier, identical proof was discovered in the unpublished manuscripts
of Leibniz).  The most famous of Fermat's results -- known as Fermat's
Last Theorem -- was jotted down in 1637 in his copy of the book <emphasis>Arithmetic</emphasis> (by the third-century Greek mathematician Diophantus) with the
remark "I have discovered a truly remarkable proof, but this margin is
too small to contain it."  Finding a proof of Fermat's Last Theorem
became one of the most famous challenges in number theory.  A complete
solution was finally given in 1995 by Andrew Wiles of Princeton University.</p>

<p><sup>46</sup> The reduction steps in the cases where the exponent
<emphasis>e</emphasis> is greater than 1 are based on the fact that, for any integers
<emphasis>x</emphasis>, <emphasis>y</emphasis>, and <emphasis>m</emphasis>, we can find the remainder of <emphasis>x</emphasis> times <emphasis>y</emphasis> modulo
<emphasis>m</emphasis> by computing separately the remainders of <emphasis>x</emphasis> modulo <emphasis>m</emphasis> and <emphasis>y</emphasis>
modulo <emphasis>m</emphasis>, multiplying these, and then taking the remainder of the
result modulo <emphasis>m</emphasis>.  For instance, in the case where <emphasis>e</emphasis> is even, we
compute the remainder of <emphasis>b</emphasis><sup><emphasis>e</emphasis>/2</sup> modulo <emphasis>m</emphasis>, square this, and take
the remainder modulo <emphasis>m</emphasis>.  This technique is useful because it means
we can perform our computation without ever having to deal with
numbers much larger than <emphasis>m</emphasis>.  (Compare
exercise 1.25.)</p>

<p><sup>47</sup> Numbers that fool the
Fermat test are called <emphasis>Carmichael numbers</emphasis>, and little is known
about them other than that they are extremely rare.  There are 255
Carmichael numbers below 100,000,000.  The smallest few are 561, 1105,
1729, 2465, 2821, and 6601.  In testing primality of very large
numbers chosen at random, the chance of stumbling upon a value that
fools the Fermat test is less than the chance that cosmic radiation
will cause the computer to make an error in carrying out a "correct"
algorithm.  Considering an algorithm to be inadequate for the first
reason but not for the second illustrates the difference between
mathematics and engineering.</p>

<p><sup>48</sup> One of the most striking applications of
probabilistic prime testing has been to the field of cryptography.
Although it is now computationally infeasible to factor an arbitrary
200-digit number, the primality of such a number can be checked in a
few seconds with the Fermat test.  This fact forms the basis of a
technique for constructing "unbreakable codes" suggested by Rivest,
Shamir, and Adleman (1977).  The resulting <emphasis>RSA algorithm</emphasis> has
become a widely used technique for enhancing the security of
electronic communications.  Because of this and related developments,
the study of prime numbers, once considered the epitome of a topic in
"pure" mathematics to be studied only for its own sake, now turns
out to have important practical applications to cryptography,
electronic funds transfer, and information retrieval.</p>


</section>

<section>


<p><strong>1.3  Formulating Abstractions with Higher-Order Procedures</strong></p>

<p>


We have seen that procedures are, in effect, abstractions that describe
compound operations on numbers independent of the particular numbers.
For example, when we</p>

<p>(define (cube x) (* x x x))</p><empty-line /><p>
we are not talking about the cube of a particular number, but rather
about a method for obtaining the cube of any number.  Of course we
could get along without ever defining this procedure, by
always writing expressions such as</p>

<p>(* 3 3 3)</p><empty-line /><p>
(* x x x)</p><empty-line /><p>
(* y y y)</p><empty-line /><p>
and never mentioning cube explicitly.  This would place us at a
serious disadvantage, forcing us to work always at the level of the
particular operations that happen to be primitives in the language
(multiplication, in this case) rather than in terms of higher-level
operations.  Our programs would be able to compute cubes, but our
language would lack the ability to express the concept of cubing.  One
of the things we should demand from a powerful programming language is
the ability to build abstractions by assigning names to common
patterns and then to work in terms of the abstractions directly.
Procedures provide this ability.  This is why all but the most
primitive programming languages include mechanisms for defining
procedures.</p>

<p>

Yet even in numerical processing we will be severely limited in our
ability to create abstractions if we are restricted to procedures
whose parameters must be numbers.  Often the same programming pattern
will be used with a number of different procedures.  To express such
patterns as concepts, we will need to construct procedures that can
accept procedures as arguments or return procedures as values.
Procedures that manipulate procedures are called <emphasis>higher-order
procedures</emphasis>.  This section shows how higher-order procedures can serve
as powerful abstraction mechanisms, vastly increasing the expressive
power of our language.</p>

<p><strong>1.3.1  Procedures as Arguments</strong></p>

<p>




Consider the following three procedures.  The first computes the sum
of the integers from a through b:</p>

<p>(define (sum-integers a b)</p><empty-line /><p>
  (if (&gt; a b)</p><empty-line /><p>
      0</p><empty-line /><p>
      (+ a (sum-integers (+ a 1) b))))</p><empty-line /><p>
The second computes the sum of the cubes of the integers in the given range:</p>

<p>(define (sum-cubes a b)</p><empty-line /><p>
  (if (&gt; a b)</p><empty-line /><p>
      0</p><empty-line /><p>
      (+ (cube a) (sum-cubes (+ a 1) b))))</p><empty-line /><p>
The third computes the sum of a sequence of terms in the
series</p>

<p><image xlink:href="#_36.jpg" /></p>

<p>
which converges to <image xlink:href="#_37.jpg" />/8 (very slowly):<sup>49</sup></p>

<p>(define (pi-sum a b)</p><empty-line /><p>
  (if (&gt; a b)</p><empty-line /><p>
      0</p><empty-line /><p>
      (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))</p><empty-line /><empty-line /><p>

These three procedures clearly share a common underlying pattern.
They are for the most part identical, differing only in the name of
the procedure, the function of a used to compute the term to be added,
and the function that provides the next value of a.  We could generate
each of the procedures by filling in slots in the same template:</p>

<p>(define (&lt;<emphasis>name</emphasis>&gt; a b)</p><empty-line /><p>
  (if (&gt; a b)</p><empty-line /><p>
      0</p><empty-line /><p>
      (+ (&lt;<emphasis>term</emphasis>&gt; a)</p><empty-line /><p>
         (&lt;<emphasis>name</emphasis>&gt; (&lt;<emphasis>next</emphasis>&gt; a) b))))</p><empty-line /><empty-line /><p>

The presence of such a common pattern is strong evidence that there is
a useful abstraction waiting to be brought to the surface.  Indeed,
mathematicians long ago identified the abstraction of
<emphasis>summation of a series</emphasis> and invented "sigma
notation", for example</p>

<p><image xlink:href="#_38.jpg" /></p>

<p>

to express this concept.  The power of sigma notation is that it
allows mathematicians to deal with the concept of summation
itself rather than only with particular sums -- for example, to
formulate general results about sums that are independent of the
particular series being summed.</p>

<p>

Similarly, as program designers, we would like our language to
be powerful enough so that we can write a procedure that expresses the
concept of summation itself rather than only procedures
that compute particular sums.  We can do so readily in our
procedural language by taking the common template shown above and
transforming the "slots" into formal parameters:</p>

<p>(define (sum term a next b)</p><empty-line /><p>
  (if (&gt; a b)</p><empty-line /><p>
      0</p><empty-line /><p>
      (+ (term a)</p><empty-line /><p>
         (sum term (next a) next b))))</p><empty-line /><p>
Notice that sum takes as its arguments the lower and upper bounds
a and b together with the procedures term and next.
We can use sum just as we would any procedure.  For example, we can
use it (along with a procedure inc that increments its argument by 1)
to define sum-cubes:</p>

<p>(define (inc n) (+ n 1))</p><empty-line /><p>(define (sum-cubes a b)</p><empty-line /><p>
  (sum cube a inc b))</p><empty-line /><p>
Using this, we can compute the sum of the cubes of the integers from 1
to 10:</p>

<p>(sum-cubes 1 10)</p><empty-line /><p><emphasis>3025</emphasis></p><empty-line /><p>
With the aid of an identity procedure to compute the term, we can define
sum-integers in terms of sum:</p>

<p>(define (identity x) x)</p><empty-line /><empty-line /><p>(define (sum-integers a b)</p><empty-line /><p>
  (sum identity a inc b))</p><empty-line /><p>
Then we can add up the integers from 1 to 10:</p>

<p>(sum-integers 1 10)</p><empty-line /><p><emphasis>55</emphasis></p><empty-line /><p>
We can also define pi-sum in the same way:<sup>50</sup></p>

<p>(define (pi-sum a b)</p><empty-line /><p>
  (define (pi-term x)</p><empty-line /><p>
    (/ 1.0 (* x (+ x 2))))</p><empty-line /><p>
  (define (pi-next x)</p><empty-line /><p>
    (+ x 4))</p><empty-line /><p>
  (sum pi-term a pi-next b))</p><empty-line /><p>
Using these procedures, we can compute an approximation to 
<image xlink:href="#_37.jpg" />:</p>

<p>(* 8 (pi-sum 1 1000))</p><empty-line /><p><emphasis>3.139592655589783</emphasis></p><empty-line /><empty-line /><p>


Once we have sum, we can use it as a building block in
formulating further concepts.  For instance, the definite integral of a
function <emphasis>f</emphasis> between the limits <emphasis>a</emphasis> and <emphasis>b</emphasis> can be approximated
numerically using the formula</p>

<p><image xlink:href="#_39.jpg" /></p>

<p>
for small values of <emphasis>d</emphasis><emphasis>x</emphasis>.  We can express this directly as a
procedure:</p>

<p>(define (integral f a b dx)</p><empty-line /><p>
  (define (add-dx x) (+ x dx))</p><empty-line /><p>
  (* (sum f (+ a (/ dx 2.0)) add-dx b)</p><empty-line /><p>
     dx))</p><empty-line /><p>
(integral cube 0 1 0.01)</p><empty-line /><p><emphasis>.24998750000000042</emphasis></p><empty-line /><p>
(integral cube 0 1 0.001)</p><empty-line /><p><emphasis>.249999875000001</emphasis></p><empty-line /><p>
(The exact value of the integral of cube between 0 and 1 is 1/4.)</p>

<p>
<strong>Exercise 1.29.</strong>  Simpson's Rule is a more accurate method of numerical integration than
the method illustrated above.  Using Simpson's Rule, the integral of a
function <emphasis>f</emphasis> between <emphasis>a</emphasis> and <emphasis>b</emphasis> is approximated as</p>

<p><image xlink:href="#_40.jpg" /></p>

<p>

where <emphasis>h</emphasis> = (<emphasis>b</emphasis> - <emphasis>a</emphasis>)/<emphasis>n</emphasis>, for some even integer <emphasis>n</emphasis>, and <emphasis>y</emphasis><sub><emphasis>k</emphasis></sub>  = <emphasis>f</emphasis>(<emphasis>a</emphasis> + <emphasis>k</emphasis><emphasis>h</emphasis>).
(Increasing <emphasis>n</emphasis> increases the accuracy of the approximation.)  Define
a procedure that takes as arguments <emphasis>f</emphasis>, <emphasis>a</emphasis>, <emphasis>b</emphasis>, and <emphasis>n</emphasis> and returns
the value of the integral, computed using Simpson's Rule.
Use your procedure to integrate cube between 0 and 1
(with <emphasis>n</emphasis> = 100 and <emphasis>n</emphasis> = 1000), and compare the results to those of the
integral procedure shown above.</p>

<p>
<strong>Exercise 1.30.</strong>  The sum procedure above generates a linear recursion.  The
procedure can be rewritten so that the sum is performed iteratively.
Show how to do this by filling in the missing expressions in the
following definition:</p>

<p>(define (sum term a next b)</p><empty-line /><p>
  (define (iter a result)</p><empty-line /><p>
    (if &lt;<emphasis>??</emphasis>&gt;</p><empty-line /><p>
        &lt;<emphasis>??</emphasis>&gt;</p><empty-line /><p>
        (iter &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt;)))</p><empty-line /><p>
  (iter &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt;))</p><empty-line /><empty-line /><p>
<strong>Exercise 1.31.</strong></p><empty-line /><p>a.  The sum procedure is only the simplest of a vast number of
similar abstractions that can be captured as higher-order procedures.<sup>51</sup>  Write an analogous procedure
called product that returns the product of the values of a
function at points over a given range.
Show how to define factorial in terms of
product.  Also use product to compute approximations to
<image xlink:href="#_37.jpg" /> using the formula<sup>52</sup></p>

<p><image xlink:href="#_41.jpg" /></p>

<p>

b.  If your product
procedure generates a recursive process, write one that generates
an iterative process.
If it generates an iterative process, write one that generates
a recursive process.</p>

<p>
<strong>Exercise 1.32.</strong>  a. Show that sum and product
(exercise 1.31) are both special cases of a still more
general notion called accumulate that combines a collection of
terms, using some general accumulation function:</p>

<p>(accumulate combiner null-value term a next b)</p><empty-line /><p>
Accumulate takes as arguments the same term and range
specifications as sum and product, together with a combiner
procedure (of two arguments) that specifies how the current
term is to be combined with the accumulation of the preceding terms
and a null-value that specifies what base value to use
when the terms run out.  Write accumulate
and show how sum and product can both
be defined as simple calls to accumulate.</p>

<p>b. If your accumulate
procedure generates a recursive process, write one that generates
an iterative process.
If it generates an iterative process, write one that generates
a recursive process.</p>

<p>
<strong>Exercise 1.33.</strong>  You can obtain an even more general version of accumulate
(exercise 1.32) by introducing the notion of a <emphasis>filter</emphasis> on the terms to be combined.  That is, combine only those
terms derived from values in the range that satisfy a specified
condition.  The resulting filtered-accumulate abstraction takes
the same arguments as accumulate, together with an additional
predicate of one argument that specifies the filter.  Write filtered-accumulate as a procedure.  Show how to express the
following using filtered-accumulate:</p>

<p>a. the sum of the squares of the prime numbers in the interval <emphasis>a</emphasis> to
<emphasis>b</emphasis> (assuming that you have a prime? predicate already written)</p>

<p>b. the product of all the positive integers less than <emphasis>n</emphasis>
that are relatively prime to <emphasis>n</emphasis> (i.e., all positive integers
<emphasis>i</emphasis> &lt; <emphasis>n</emphasis> such that  <emphasis>G</emphasis><emphasis>C</emphasis><emphasis>D</emphasis>(<emphasis>i</emphasis>,<emphasis>n</emphasis>) = 1).</p>

<p><strong>1.3.2  Constructing Procedures Using Lambda</strong></p>

<p>

In using sum as in section 1.3.1,
it seems terribly awkward to have to define trivial procedures such as
pi-term and pi-next just so we can use them as arguments to
our higher-order procedure.  Rather than define pi-next and pi-term, it would be more convenient
to have a way to directly specify "the procedure that returns its
input incremented by 4" and "the procedure that returns the
reciprocal of its input times its input plus 2."  We can do this by
introducing the special form lambda, which creates procedures.
Using lambda we can describe what we want as</p>

<p>(lambda (x) (+ x 4))</p><empty-line /><p>
and</p>

<p>(lambda (x) (/ 1.0 (* x (+ x 2))))</p><empty-line /><p>
Then our pi-sum procedure can be expressed without defining any
auxiliary procedures as</p>

<p>(define (pi-sum a b)</p><empty-line /><p>
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))</p><empty-line /><p>
       a</p><empty-line /><p>
       (lambda (x) (+ x 4))</p><empty-line /><p>
       b))</p><empty-line /><empty-line /><p>

Again using lambda, we can write the integral procedure
without having to define the auxiliary procedure add-dx:</p>

<p>(define (integral f a b dx)</p><empty-line /><p>
  (* (sum f</p><empty-line /><p>
          (+ a (/ dx 2.0))</p><empty-line /><p>
          (lambda (x) (+ x dx))</p><empty-line /><p>
          b)</p><empty-line /><p>
     dx))</p><empty-line /><empty-line /><p>

In general, lambda is used to create procedures in the same way as
define, except that no name is specified for the procedure:</p>

<p>(lambda (&lt;<emphasis>formal-parameters</emphasis>&gt;) &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
The resulting procedure is just as much a procedure as one that is
created using define.  The only difference is that it has not
been associated with any name in the environment.  In fact,</p>

<p>(define (plus4 x) (+ x 4))</p><empty-line /><p>
is equivalent to</p>

<p>(define plus4 (lambda (x) (+ x 4)))</p><empty-line /><p>
We can read a lambda expression as follows:</p>

<p>    (lambda             (x)             (+    x     4))</p><empty-line /><p>
        <image xlink:href="#_3.jpg" />                 <image xlink:href="#_3.jpg" />               <image xlink:href="#_3.jpg" />    <image xlink:href="#_3.jpg" />    <image xlink:href="#_3.jpg" /></p><empty-line /><p>
 the procedure   of an argument x  that adds  x and 4</p><empty-line /><p>

Like any expression that has a procedure as its value, a
lambda expression can be used as the operator in a combination such as</p>

<p>((lambda (x y z) (+ x y (square z))) 1 2 3)</p><empty-line /><p><emphasis>12</emphasis></p><empty-line /><p>
or, more generally, in any context where we would normally use a
procedure name.<sup>53</sup></p>

<p><strong>Using let to create local variables</strong></p>

<p>



Another use of lambda is in creating local variables.
We often need local variables in our procedures other than those that have
been bound as formal parameters.  For example, suppose we wish to
compute the function</p>

<p><image xlink:href="#_42.jpg" /></p>

<p>

which we could also express as</p>

<p><image xlink:href="#_43.jpg" /></p>

<p>
In writing a procedure to compute <emphasis>f</emphasis>, we would like to include as
local variables not only <emphasis>x</emphasis> and <emphasis>y</emphasis>  but also the names of
intermediate quantities like <emphasis>a</emphasis> and <emphasis>b</emphasis>.  One way to
accomplish this is to
use an auxiliary procedure to bind the local variables:</p>

<p>(define (f x y)</p><empty-line /><p>
  (define (f-helper a b)</p><empty-line /><p>
    (+ (* x (square a))</p><empty-line /><p>
       (* y b)</p><empty-line /><p>
       (* a b)))</p><empty-line /><p>
  (f-helper (+ 1 (* x y))</p><empty-line /><p>
            (- 1 y)))</p><empty-line /><empty-line /><p>

Of course, we could use a lambda expression to specify an
anonymous procedure for binding our local variables.  The body of
f then becomes a single call to that procedure:</p>

<p>(define (f x y)</p><empty-line /><p>
  ((lambda (a b)</p><empty-line /><p>
     (+ (* x (square a))</p><empty-line /><p>
        (* y b)</p><empty-line /><p>
        (* a b)))</p><empty-line /><p>
   (+ 1 (* x y))</p><empty-line /><p>
   (- 1 y)))</p><empty-line /><p>
This construct is so useful that there is a special form called
let to make its use more convenient.  Using let, the f
procedure could be written as</p>

<p>(define (f x y)</p><empty-line /><p>
  (let ((a (+ 1 (* x y)))</p><empty-line /><p>
        (b (- 1 y)))</p><empty-line /><p>
    (+ (* x (square a))</p><empty-line /><p>
       (* y b)</p><empty-line /><p>
       (* a b))))</p><empty-line /><p>
The general form of a let expression is</p>

<p>(let ((&lt;<emphasis>var<sub>1</sub></emphasis>&gt; &lt;<emphasis>exp<sub>1</sub></emphasis>&gt;)</p><empty-line /><p>
      (&lt;<emphasis>var<sub>2</sub></emphasis>&gt; &lt;<emphasis>exp<sub>2</sub></emphasis>&gt;)</p><empty-line /><p>
      <image xlink:href="#_5.jpg" /></p><empty-line /><p>
      (&lt;<emphasis>var<sub>n</sub></emphasis>&gt; &lt;<emphasis>exp<sub>n</sub></emphasis>&gt;))</p><empty-line /><p>
   &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
which can be thought of as saying</p>

<p>let</p>

<p>&lt;</p>

<p><emphasis>var<sub>1</sub></emphasis></p>

<p>&gt; have the value &lt;</p>

<p><emphasis>exp<sub>1</sub></emphasis></p>

<p>&gt; and</p>

<p>&lt;</p>

<p><emphasis>var<sub>2</sub></emphasis></p>

<p>&gt; have the value &lt;</p>

<p><emphasis>exp<sub>2</sub></emphasis></p>

<p>&gt; and</p>

<p><image xlink:href="#_5.jpg" /></p>

<p>&lt;</p>

<p><emphasis>var<sub>n</sub></emphasis></p>

<p>&gt; have the value &lt;</p>

<p><emphasis>exp<sub>n</sub></emphasis></p>

<p>&gt;</p>

<p>in</p>

<p>&lt;</p>

<p><emphasis>body</emphasis></p>

<p>&gt;</p>

<p>

The first part of the let expression is a list of
name-expression pairs.  When the let is evaluated, each name is
associated with the value of the corresponding expression.  The body
of the let is evaluated with
these names bound as local variables.  The way this happens is that the let expression is interpreted as an alternate syntax for</p>

<p>((lambda (&lt;<emphasis>var<sub>1</sub></emphasis>&gt; ...&lt;<emphasis>var<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
    &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
 &lt;<emphasis>exp<sub>1</sub></emphasis>&gt;</p><empty-line /><p>
 <image xlink:href="#_5.jpg" /></p><empty-line /><p>
 &lt;<emphasis>exp<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
No new mechanism is required in the interpreter in order to
provide local variables.  A let expression is simply syntactic sugar for
the underlying lambda application.</p>

<p>

We can see from this equivalence that
the scope of a variable specified by a let expression is the body of
the let.
This implies that:</p>

<p>Let allows one to
bind variables as locally as possible to where they
are to be used.  For example, if the value of x is 5,
the value of the expression</p>

<p>(+ (let ((x 3))</p><empty-line /><p>
     (+ x (* x 10)))</p><empty-line /><p>
   x)</p><empty-line /><empty-line /><p>

is 38.  Here, the x in the body of the let is 3,
so the value of the let expression is 33.  On the other hand, the
x that is the second argument to the outermost + is still 5.</p>

<p>The variables' values are computed outside the let.
This matters when the expressions that
provide the values for the local variables depend upon
variables having the same names as the local variables themselves.
For example, if the value of x is 2, the expression</p>

<p>(let ((x 3)</p><empty-line /><p>
      (y (+ x 2)))</p><empty-line /><p>
  (* x y))</p><empty-line /><p>
will have the value 12 because, inside the body of the let,
x will be 3 and y will be 4 (which is the
outer x plus 2).</p>

<p>


Sometimes we can use internal definitions to get the same effect as
with let.  For example, we could have defined the procedure f above as</p>

<p>(define (f x y)</p><empty-line /><p>
  (define a (+ 1 (* x y)))</p><empty-line /><p>
  (define b (- 1 y))</p><empty-line /><p>
  (+ (* x (square a))</p><empty-line /><p>
     (* y b)</p><empty-line /><p>
     (* a b)))</p><empty-line /><p>
We prefer, however, to use let in situations like this
and to use internal define only for internal procedures.<sup>54</sup></p>

<p>
<strong>Exercise 1.34.</strong>  Suppose we define the procedure</p>

<p>(define (f g)</p><empty-line /><p>
  (g 2))</p><empty-line /><p>
Then we have</p>

<p>(f square)</p><empty-line /><p><emphasis>4</emphasis></p><empty-line /><empty-line /><p>
(f (lambda (z) (* z (+ z 1))))</p><empty-line /><p><emphasis>6</emphasis></p><empty-line /><p>
What happens if we (perversely) ask the interpreter to evaluate the
combination (f f)?  Explain.</p>

<p><strong>1.3.3  Procedures as General Methods</strong></p>

<p>



We introduced compound procedures in
section 1.1.4 as a mechanism for abstracting
patterns of numerical operations so as to make them independent of the
particular numbers involved.  With higher-order procedures, such as
the integral procedure of
section 1.3.1, we began to see a more
powerful kind of abstraction: procedures used to express general
methods of computation, independent of the particular functions
involved.  In this section we discuss two more elaborate
examples -- general methods for finding zeros and fixed points of
functions -- and show how these methods can be expressed directly as
procedures.</p>

<p><strong>Finding roots of equations by the half-interval method</strong></p>

<p>


The <emphasis>half-interval method</emphasis> is a simple but powerful technique for
finding roots of an equation <emphasis>f</emphasis>(<emphasis>x</emphasis>) = 0, where <emphasis>f</emphasis> is a continuous
function.  The idea is that, if we are given points <emphasis>a</emphasis> and <emphasis>b</emphasis> such
that <emphasis>f</emphasis>(<emphasis>a</emphasis>) &lt; 0 &lt; <emphasis>f</emphasis>(<emphasis>b</emphasis>), then <emphasis>f</emphasis> must have at least one zero between
<emphasis>a</emphasis> and <emphasis>b</emphasis>.  To locate a zero, let <emphasis>x</emphasis> be the average of <emphasis>a</emphasis> and <emphasis>b</emphasis>
and compute <emphasis>f</emphasis>(<emphasis>x</emphasis>).  If <emphasis>f</emphasis>(<emphasis>x</emphasis>) &gt; 0, then <emphasis>f</emphasis> must have a zero between
<emphasis>a</emphasis> and <emphasis>x</emphasis>.  If <emphasis>f</emphasis>(<emphasis>x</emphasis>) &lt; 0, then <emphasis>f</emphasis> must have a zero between <emphasis>x</emphasis> and
<emphasis>b</emphasis>.  Continuing in this way, we can identify smaller and smaller
intervals on which <emphasis>f</emphasis> must have a zero.  When we reach a point where
the interval is small enough, the process stops.  Since the interval
of uncertainty is reduced by half at each step of the process, the
number of steps required grows as <image xlink:href="#_25.jpg" />(log( <emphasis>L</emphasis>/<emphasis>T</emphasis>)), where <emphasis>L</emphasis> is the
length of the original interval and <emphasis>T</emphasis> is the error tolerance
(that is, the size of the interval we will consider "small enough").
Here is a procedure that implements this strategy:</p>

<p>(define (search f neg-point pos-point)</p><empty-line /><p>
  (let ((midpoint (average neg-point pos-point)))</p><empty-line /><p>
    (if (close-enough? neg-point pos-point)</p><empty-line /><p>
        midpoint</p><empty-line /><p>
        (let ((test-value (f midpoint)))</p><empty-line /><p>
          (cond ((positive? test-value)</p><empty-line /><p>
                 (search f neg-point midpoint))</p><empty-line /><p>
                ((negative? test-value)</p><empty-line /><p>
                 (search f midpoint pos-point))</p><empty-line /><p>
                (else midpoint))))))</p><empty-line /><empty-line /><p>

We assume that we are initially given the function <emphasis>f</emphasis> together with
points at which its values are negative and positive.  We first
compute the midpoint of the two given points.  Next we check to see if
the given interval is small enough, and if so we simply return the
midpoint as our answer.  Otherwise, we compute as a test value the
value of <emphasis>f</emphasis> at the midpoint.  If the test value is positive, then
we continue the process with a new interval running from the original
negative point to the midpoint.  If the test value is negative, we
continue with the interval from the midpoint to the positive point.
Finally, there is the possibility that the test value is 0, in which
case the midpoint is itself the root we are searching for.</p>

<p>


To test whether the endpoints are "close enough" we can use a
procedure similar to the one used in section 1.1.7 for
computing square roots:<sup>55</sup></p>

<p>(define (close-enough? x y)</p><empty-line /><p>
  (&lt; (abs (- x y)) 0.001))</p><empty-line /><empty-line /><p>

Search is awkward to use directly, because
we can accidentally give it points at which <emphasis>f</emphasis>'s
values do not have the required sign, in which case we get a wrong answer.
Instead we will use search via the following procedure, which
checks to see which of the endpoints has a negative function value and
which has a positive value, and calls the search procedure
accordingly.  If the function has the same sign on the two given
points, the half-interval method cannot be used, in which case the
procedure signals an error.<sup>56</sup></p>

<p>(define (half-interval-method f a b)</p><empty-line /><p>
  (let ((a-value (f a))</p><empty-line /><p>
        (b-value (f b)))</p><empty-line /><p>
    (cond ((and (negative? a-value) (positive? b-value))</p><empty-line /><p>
           (search f a b))</p><empty-line /><p>
          ((and (negative? b-value) (positive? a-value))</p><empty-line /><p>
           (search f b a))</p><empty-line /><p>
          (else</p><empty-line /><p>
           (error "Values are not of opposite sign" a b)))))</p><empty-line /><empty-line /><p>

The following example uses the half-interval method to approximate <image xlink:href="#_37.jpg" />
as the root between 2 and 4 of sin  <emphasis>x</emphasis>  =  0:</p>

<p>(half-interval-method sin 2.0 4.0)</p><empty-line /><p><emphasis>3.14111328125</emphasis></p><empty-line /><empty-line /><p>

Here is another example, using the half-interval method
to search for a root of the equation <emphasis>x</emphasis><sup>3</sup>  -  2<emphasis>x</emphasis>  -  3  =  0
between 1 and 2:</p>

<p>(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))</p><empty-line /><p>
                      1.0</p><empty-line /><p>
                      2.0)</p><empty-line /><p><emphasis>1.89306640625</emphasis></p><empty-line /><empty-line /><p><strong>Finding fixed points of functions</strong></p>

<p>


A number <emphasis>x</emphasis> is called a <emphasis>fixed point</emphasis> of a function <emphasis>f</emphasis> if <emphasis>x</emphasis>
satisfies the equation <emphasis>f</emphasis>(<emphasis>x</emphasis>) = <emphasis>x</emphasis>.  For some functions <emphasis>f</emphasis> we can locate
a fixed point by beginning with an initial guess and applying <emphasis>f</emphasis>
repeatedly,</p>

<p><image xlink:href="#_44.jpg" /></p>

<p>

until the value does not change very much.  Using this idea, we can
devise a procedure fixed-point that takes as inputs a function
and an initial guess and produces an approximation to a fixed point of
the function.  We apply the function repeatedly until we find two
successive values whose difference is less than some prescribed
tolerance:</p>

<p>(define tolerance 0.00001)</p><empty-line /><p>(define (fixed-point f first-guess)</p><empty-line /><p>
  (define (close-enough? v1 v2)</p><empty-line /><p>
    (&lt; (abs (- v1 v2)) tolerance))</p><empty-line /><p>
  (define (try guess)</p><empty-line /><p>
    (let ((next (f guess)))</p><empty-line /><p>
      (if (close-enough? guess next)</p><empty-line /><p>
          next</p><empty-line /><p>
          (try next))))</p><empty-line /><p>
  (try first-guess))</p><empty-line /><p>
For example, we can use this method to approximate the fixed point of
the cosine function, starting with 1 as an initial approximation:<sup>57</sup></p>

<p>(fixed-point cos 1.0)</p><empty-line /><p><emphasis>.7390822985224023</emphasis></p><empty-line /><p>
Similarly, we can find a solution to the equation
<emphasis>y</emphasis> = sin <emphasis>y</emphasis>  +  cos <emphasis>y</emphasis>:</p>

<p>(fixed-point (lambda (y) (+ (sin y) (cos y)))</p><empty-line /><p>
             1.0)</p><empty-line /><p><emphasis>1.2587315962971173</emphasis></p><empty-line /><empty-line /><p>


The fixed-point process is reminiscent of the process we used for
finding square roots in section 1.1.7.  Both are based on the
idea of repeatedly improving a guess until the result satisfies some
criterion.  In fact, we can readily formulate the square-root
computation as a fixed-point search.  Computing the square root of
some number <emphasis>x</emphasis> requires finding a <emphasis>y</emphasis> such that <emphasis>y</emphasis><sup>2</sup>  =  <emphasis>x</emphasis>.  Putting
this equation into the equivalent form <emphasis>y</emphasis>  =  <emphasis>x</emphasis>/<emphasis>y</emphasis>, we recognize that we
are looking for a fixed point of the function<sup>58</sup> <emphasis>y</emphasis>  <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis>, and we
can therefore try to compute square roots as</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (fixed-point (lambda (y) (/ x y))</p><empty-line /><p>
               1.0))</p><empty-line /><empty-line /><p>

Unfortunately, this fixed-point search does not converge.  Consider an
initial guess <emphasis>y</emphasis><sub>1</sub>.  The next guess is <emphasis>y</emphasis><sub>2</sub>  =  <emphasis>x</emphasis>/<emphasis>y</emphasis><sub>1</sub> and the next
guess is <emphasis>y</emphasis><sub>3</sub>  =  <emphasis>x</emphasis>/<emphasis>y</emphasis><sub>2</sub>  =  <emphasis>x</emphasis>/(<emphasis>x</emphasis>/<emphasis>y</emphasis><sub>1</sub>)  =  <emphasis>y</emphasis><sub>1</sub>.  This results in an infinite
loop in which the two guesses <emphasis>y</emphasis><sub>1</sub> and <emphasis>y</emphasis><sub>2</sub> repeat over and over,
oscillating about the answer.</p>

<p>

One way to control such oscillations is to prevent the guesses from
changing so much.
Since the answer is always between our guess <emphasis>y</emphasis>
and <emphasis>x</emphasis>/<emphasis>y</emphasis>, we can make a new guess that is not as far from <emphasis>y</emphasis> as <emphasis>x</emphasis>/<emphasis>y</emphasis>
by averaging <emphasis>y</emphasis> with <emphasis>x</emphasis>/<emphasis>y</emphasis>, so that the next guess after
<emphasis>y</emphasis> is (1/2)(<emphasis>y</emphasis> + <emphasis>x</emphasis>/<emphasis>y</emphasis>) instead of <emphasis>x</emphasis>/<emphasis>y</emphasis>.
The process of making such a sequence of guesses is simply the process
of looking for a fixed point of <emphasis>y</emphasis>  <image xlink:href="#_45.jpg" />  (1/2)(<emphasis>y</emphasis> + <emphasis>x</emphasis>/<emphasis>y</emphasis>):</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (fixed-point (lambda (y) (average y (/ x y)))</p><empty-line /><p>
               1.0))</p><empty-line /><p>
(Note that <emphasis>y</emphasis> = (1/2)(<emphasis>y</emphasis> + <emphasis>x</emphasis>/<emphasis>y</emphasis>) is a simple transformation of the
equation <emphasis>y</emphasis> = <emphasis>x</emphasis>/<emphasis>y</emphasis>; to derive it, add <emphasis>y</emphasis> to both sides of the equation
and divide by 2.)</p>

<p>

With this modification, the square-root procedure works.  In fact, if
we unravel the definitions, we can see that the sequence of
approximations to the square root generated here is precisely the
same as the one generated by our original square-root procedure of
section 1.1.7.  This approach of averaging
successive approximations to a solution, a technique we that we call
<emphasis>average damping</emphasis>, often aids the convergence of fixed-point
searches.</p>

<p>
<strong>Exercise 1.35.</strong>  Show that the golden ratio <image xlink:href="#_18.jpg" /> (section 1.2.2)
is a fixed point of the transformation <emphasis>x</emphasis>  <image xlink:href="#_45.jpg" />  1  +  1/<emphasis>x</emphasis>, and use
this fact to compute <image xlink:href="#_18.jpg" /> by means of the fixed-point
procedure.</p>

<p>
<strong>Exercise 1.36.</strong>  Modify fixed-point so that it prints the sequence of
approximations it generates, using
the newline and display primitives shown in
exercise 1.22.  Then find a solution to <emphasis>x</emphasis><sup><emphasis>x</emphasis></sup>  = 
1000 by finding a fixed point of <emphasis>x</emphasis>  <image xlink:href="#_45.jpg" />log(1000)/log(<emphasis>x</emphasis>).  (Use
Scheme's primitive log procedure, which computes natural
logarithms.)  Compare the number of steps this takes with and without
average damping.  (Note that you cannot start fixed-point with a
guess of 1, as this would cause division by log(1) = 0.)</p>

<p>
<strong>Exercise 1.37.</strong>  a. An infinite <emphasis>continued fraction</emphasis> is an expression of the form</p>

<p><image xlink:href="#_46.jpg" /></p>

<p> 
As an example, one can show that the infinite continued fraction
expansion with the <emphasis>N</emphasis><sub><emphasis>i</emphasis></sub> and the <emphasis>D</emphasis><sub><emphasis>i</emphasis></sub> all equal to 1 produces
1/<image xlink:href="#_18.jpg" />, where <image xlink:href="#_18.jpg" /> is the golden ratio (described in
section 1.2.2).
One way to approximate an
infinite continued fraction is to truncate the expansion after a given
number of terms.  Such a truncation -- a so-called <emphasis>k-term finite
continued fraction</emphasis> -- has the form</p>

<p><image xlink:href="#_47.jpg" /></p>

<p> 
Suppose that n and d are procedures of one argument (the
term index <emphasis>i</emphasis>) that return the <emphasis>N</emphasis><sub><emphasis>i</emphasis></sub> and <emphasis>D</emphasis><sub><emphasis>i</emphasis></sub> of the terms of the
continued fraction.  Define a procedure cont-frac
such that evaluating (cont-frac n d k)
computes the value of the <emphasis>k</emphasis>-term finite
continued fraction.  Check your procedure by approximating 1/<image xlink:href="#_18.jpg" /> using</p>

<p>(cont-frac (lambda (i) 1.0)</p><empty-line /><p>
           (lambda (i) 1.0)</p><empty-line /><p>
           k)</p><empty-line /><p>
for successive values of k.  How large must you make k
in order to get an approximation that is accurate to 4 decimal places?</p>

<p>b. If your cont-frac
procedure generates a recursive process, write one that generates
an iterative process.
If it generates an iterative process, write one that generates
a recursive process.</p>

<p>
<strong>Exercise 1.38.</strong>  In 1737, the Swiss mathematician Leonhard Euler published a memoir
<emphasis>De Fractionibus Continuis</emphasis>, which included a continued fraction
expansion for <emphasis>e</emphasis> - 2, where <emphasis>e</emphasis> is the base of the natural logarithms.
In this fraction, the <emphasis>N</emphasis><sub><emphasis>i</emphasis></sub> are all 1, and the <emphasis>D</emphasis><sub><emphasis>i</emphasis></sub> are successively
1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ....  Write a program that uses
your cont-frac procedure from
exercise 1.37 to approximate <emphasis>e</emphasis>, based on
Euler's expansion.</p>

<p>
<strong>Exercise 1.39.</strong>  A continued fraction representation of the tangent function was
published in 1770 by the German mathematician J.H. Lambert:</p>

<p><image xlink:href="#_48.jpg" /></p>

<p> 
where <emphasis>x</emphasis> is in radians.
Define a procedure (tan-cf x k) that computes an approximation
to the tangent function based on Lambert's
formula.  K specifies the number of terms to compute, as in
exercise 1.37.</p>

<p><strong>1.3.4  Procedures as Returned Values</strong></p>

<p>



The above examples demonstrate how
the ability to pass procedures as arguments significantly enhances
the expressive power of our programming language.  We can achieve even
more expressive power by creating procedures whose returned values are
themselves procedures.</p>

<p>

We can illustrate this idea by looking again at the fixed-point
example described at the end of
section 1.3.3.  We formulated a new version
of the square-root procedure as a fixed-point search, starting with
the observation that <image xlink:href="#_19.jpg" /><emphasis>x</emphasis> is a fixed-point of the function
<emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis>.  Then we used average damping to make the
approximations converge.  Average damping is a useful general
technique in itself.  Namely, given a function <emphasis>f</emphasis>, we consider the
function whose value at <emphasis>x</emphasis> is equal to the average of <emphasis>x</emphasis> and <emphasis>f</emphasis>(<emphasis>x</emphasis>).</p>

<p>


We can express the idea of average damping by means of the
following procedure:</p>

<p>(define (average-damp f)</p><empty-line /><p>
  (lambda (x) (average x (f x))))</p><empty-line /><p>
Average-damp is a procedure that takes as its argument a
procedure f and returns as its value a procedure (produced by
the lambda) that, when applied to a number x, produces the
average of x and (f x).  For example, applying average-damp to the square procedure produces a procedure whose
value at some number <emphasis>x</emphasis> is the average of <emphasis>x</emphasis> and <emphasis>x</emphasis><sup>2</sup>.  Applying
this resulting procedure to 10 returns the average of 10 and 100, or
55:<sup>59</sup></p>

<p>((average-damp square) 10)</p><empty-line /><p><emphasis>55</emphasis></p><empty-line /><empty-line /><p>

Using average-damp, we can reformulate the square-root procedure
as follows:</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (fixed-point (average-damp (lambda (y) (/ x y)))</p><empty-line /><p>
               1.0))</p><empty-line /><p>
Notice how this formulation makes explicit the three ideas in the
method: fixed-point search, average damping, and the function
<emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis>.  It is instructive to compare this formulation of the
square-root method with the original version given in
section 1.1.7.  Bear in mind that these procedures express
the same process, and notice how much clearer the idea becomes when we
express the process in terms of these abstractions.  In general, there
are many ways to formulate a process as a procedure.  Experienced
programmers know how to choose procedural formulations that are
particularly perspicuous, and where useful elements of the process are
exposed as separate entities that can be reused in other applications.
As a simple example of reuse, notice that the cube root of <emphasis>x</emphasis> is a
fixed point of the function <emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis><sup>2</sup>, so we can immediately
generalize our square-root procedure to one that extracts cube
roots:<sup>60</sup></p>

<p>(define (cube-root x)</p><empty-line /><p>
  (fixed-point (average-damp (lambda (y) (/ x (square y))))</p><empty-line /><p>
               1.0))</p><empty-line /><empty-line /><p><strong>Newton's method</strong></p>

<p>


When we first introduced the square-root procedure, in
section 1.1.7, we mentioned that this was a special case of
<emphasis>Newton's method</emphasis>.  
If <emphasis>x</emphasis> <image xlink:href="#_45.jpg" /><emphasis>g</emphasis>(<emphasis>x</emphasis>) is a differentiable function, then a solution of
the equation <emphasis>g</emphasis>(<emphasis>x</emphasis>) = 0 is a fixed point of the function <emphasis>x</emphasis> <image xlink:href="#_45.jpg" /><emphasis>f</emphasis>(<emphasis>x</emphasis>)
where</p>

<p><image xlink:href="#_49.jpg" /></p>

<p>
and
<emphasis>D</emphasis><emphasis>g</emphasis>(<emphasis>x</emphasis>) is the derivative of <emphasis>g</emphasis> evaluated at <emphasis>x</emphasis>.  Newton's
method is the use of the fixed-point method we saw above to
approximate a solution of the equation by finding a fixed point of
the function <emphasis>f</emphasis>.<sup>61</sup>
For many functions <emphasis>g</emphasis> and for sufficiently good initial guesses for
<emphasis>x</emphasis>, Newton's method converges very rapidly to a solution of
<emphasis>g</emphasis>(<emphasis>x</emphasis>) = 0.<sup>62</sup></p>

<p>

In order to implement Newton's method as a procedure, we must first
express the idea of derivative.  Note that "derivative", like
average damping, is something that transforms a function into another
function.  For instance, the derivative of the function <emphasis>x</emphasis> <image xlink:href="#_45.jpg" /><emphasis>x</emphasis><sup>3</sup> is the function <emphasis>x</emphasis>  <image xlink:href="#_45.jpg" />  3<emphasis>x</emphasis><sup>2</sup>.  In general, if <emphasis>g</emphasis> is a
function and <emphasis>d</emphasis><emphasis>x</emphasis> is a small number, then the derivative <emphasis>D</emphasis><emphasis>g</emphasis> of <emphasis>g</emphasis> is
the function whose value at any number <emphasis>x</emphasis> is given (in the limit of
small <emphasis>d</emphasis><emphasis>x</emphasis>) by</p>

<p><image xlink:href="#_50.jpg" /></p>

<p>
Thus, we can express the idea of derivative (taking <emphasis>d</emphasis><emphasis>x</emphasis> to be, say,
0.00001) as the procedure</p>

<p>(define (deriv g)</p><empty-line /><p>
  (lambda (x)</p><empty-line /><p>
    (/ (- (g (+ x dx)) (g x))</p><empty-line /><p>
       dx)))</p><empty-line /><p>
along with the definition</p>

<p>(define dx 0.00001)</p><empty-line /><empty-line /><p>

Like average-damp, deriv is a procedure that takes a
procedure as argument and returns a procedure as value.  For example,
to approximate the derivative of <emphasis>x</emphasis>  <image xlink:href="#_45.jpg" /><emphasis>x</emphasis><sup>3</sup> at 5 (whose exact
value is 75) we can evaluate</p>

<p>(define (cube x) (* x x x))</p><empty-line /><p>
((deriv cube) 5)</p><empty-line /><p><emphasis>75.00014999664018</emphasis></p><empty-line /><empty-line /><p>

With the aid of deriv, we can express Newton's method as a
fixed-point process:</p>

<p>(define (newton-transform g)</p><empty-line /><p>
  (lambda (x)</p><empty-line /><p>
    (- x (/ (g x) ((deriv g) x)))))</p><empty-line /><p>(define (newtons-method g guess)</p><empty-line /><p>
  (fixed-point (newton-transform g) guess))</p><empty-line /><p>
The newton-transform procedure expresses the formula at the
beginning of this section, and newtons-method is readily defined
in terms of this.  It takes as arguments a procedure that computes the
function for which we want to find a zero, together with an initial
guess.  For instance, to find the square root of <emphasis>x</emphasis>, we can use
Newton's method to find a zero of the function <emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>y</emphasis><sup>2</sup> - <emphasis>x</emphasis> starting with
an initial guess of 1.<sup>63</sup>
This provides yet another form of the square-root
procedure:</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (newtons-method (lambda (y) (- (square y) x))</p><empty-line /><p>
                  1.0))</p><empty-line /><empty-line /><p><strong>Abstractions and first-class procedures</strong></p>

<p>

We've seen two ways to express the square-root
computation as an instance of a more general method, once as a fixed-point
search and once using Newton's method.  Since Newton's method
was itself expressed as a fixed-point process,
we actually saw two ways to compute square roots as fixed points.
Each method begins with a function and finds a fixed
point of some transformation of the function.  We can express this
general idea itself as a procedure:</p>

<p>(define (fixed-point-of-transform g transform guess)</p><empty-line /><p>
  (fixed-point (transform g) guess))</p><empty-line /><p>
This very general procedure takes as its arguments a procedure g
that computes some function, a procedure that transforms g, and
an initial guess.  The returned result is a fixed point of the
transformed function.</p>

<p>

Using this abstraction, we can recast the first square-root
computation from this section (where we look for
a fixed point of the average-damped version of <emphasis>y</emphasis>  <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis>)
as an instance of this general method:</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (fixed-point-of-transform (lambda (y) (/ x y))</p><empty-line /><p>
                            average-damp</p><empty-line /><p>
                            1.0))</p><empty-line /><p>
Similarly, we can express the second square-root computation from this section
(an instance
of Newton's method that finds a fixed point of the
Newton transform of <emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>y</emphasis><sup>2</sup> - <emphasis>x</emphasis>) as</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (fixed-point-of-transform (lambda (y) (- (square y) x))</p><empty-line /><p>
                            newton-transform</p><empty-line /><p>
                            1.0))</p><empty-line /><empty-line /><p>

We began section 1.3 with the observation
that compound procedures
are a crucial abstraction mechanism, because they permit us to
express general methods of computing as explicit elements in our
programming language.  Now we've seen how higher-order
procedures permit us to manipulate these general methods
to create further abstractions.</p>

<p>

As programmers, we should be alert to opportunities to identify the
underlying abstractions in our programs and to build upon them and
generalize them to create more powerful abstractions.  This is not to
say that one should always write programs in the most abstract way
possible; expert programmers know how to choose the level of
abstraction appropriate to their task.  But it is important to be able
to think in terms of these abstractions, so that we can be ready to
apply them in new contexts.  The significance of higher-order
procedures is that they enable us to represent these abstractions
explicitly as elements in our programming language, so that they can
be handled just like other computational elements.</p>

<p>

In general, programming languages impose restrictions on the ways in
which computational elements can be manipulated.  Elements with the
fewest restrictions are said to have <emphasis>first-class</emphasis> status.  Some
of the "rights and privileges" of first-class elements are:<sup>64</sup></p>

<p>They may be named by variables.</p>

<p>They may be passed as arguments to procedures.</p>

<p>They may be returned as the results of procedures.</p>

<p>They may be included in data structures.<sup>65</sup></p>

<p>
Lisp, unlike other common programming languages, awards procedures
full first-class status.  This poses challenges for efficient
implementation, but the resulting gain in expressive power is
enormous.<sup>66</sup></p>

<p>
<strong>Exercise 1.40.</strong>  Define a procedure cubic that can be used together with the newtons-method procedure in expressions of the form</p>

<p>(newtons-method (cubic a b c) 1)</p><empty-line /><p>
to approximate zeros of the cubic <emphasis>x</emphasis><sup>3</sup>  + <emphasis>a</emphasis><emphasis>x</emphasis><sup>2</sup>  + <emphasis>b</emphasis><emphasis>x</emphasis>  + <emphasis>c</emphasis>.</p>

<p>
<strong>Exercise 1.41.</strong>  Define a procedure double that takes a procedure of one
argument as argument and
returns a procedure that applies the original procedure twice.  For
example, if inc is a procedure that adds 1 to its argument,
then (double inc) should be a procedure that adds 2.  What
value is returned by</p>

<p>(((double (double double)) inc) 5)</p><empty-line /><empty-line /><p>
<strong>Exercise 1.42.</strong>  Let <emphasis>f</emphasis> and <emphasis>g</emphasis> be two one-argument functions.  The <emphasis>composition</emphasis>
<emphasis>f</emphasis> after <emphasis>g</emphasis> is defined to be the function <emphasis>x</emphasis> <image xlink:href="#_45.jpg" /><emphasis>f</emphasis>(<emphasis>g</emphasis>(<emphasis>x</emphasis>)).
Define a procedure compose that implements composition.  For
example, if inc is a procedure that adds 1 to its argument,</p>

<p>((compose square inc) 6)</p><empty-line /><p><emphasis>49</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 1.43.</strong>  If <emphasis>f</emphasis> is a numerical function and <emphasis>n</emphasis> is a positive integer, then we
can form the <emphasis>n</emphasis>th repeated application of <emphasis>f</emphasis>, which is defined to be
the function whose value at <emphasis>x</emphasis> is <emphasis>f</emphasis>(<emphasis>f</emphasis>(...(<emphasis>f</emphasis>(<emphasis>x</emphasis>))...)).  For
example, if <emphasis>f</emphasis> is the function <emphasis>x</emphasis>  <image xlink:href="#_45.jpg" /><emphasis>x</emphasis> + 1,
then the <emphasis>n</emphasis>th repeated application of <emphasis>f</emphasis> is
the function <emphasis>x</emphasis>  <image xlink:href="#_45.jpg" /><emphasis>x</emphasis> + <emphasis>n</emphasis>.  If <emphasis>f</emphasis> is the operation of
squaring a number, then the <emphasis>n</emphasis>th repeated application of <emphasis>f</emphasis> is the
function that raises its argument to the 2<sup><emphasis>n</emphasis></sup>th power.  Write a
procedure that takes as inputs a procedure that computes <emphasis>f</emphasis> and a
positive integer <emphasis>n</emphasis> and returns the procedure that computes the <emphasis>n</emphasis>th
repeated application of <emphasis>f</emphasis>.  Your procedure should be able to be used
as follows:</p>

<p>((repeated square 2) 5)</p><empty-line /><p><emphasis>625</emphasis></p><empty-line /><p>
Hint: You may find it convenient to use compose from
exercise 1.42.</p>

<p>
<strong>Exercise 1.44.</strong>  The idea of <emphasis>smoothing</emphasis> a function is an important concept in
signal processing.  If <emphasis>f</emphasis> is a function and <emphasis>d</emphasis><emphasis>x</emphasis> is some small number,
then the smoothed version of <emphasis>f</emphasis> is the function whose value at a
point <emphasis>x</emphasis> is the average of <emphasis>f</emphasis>(<emphasis>x</emphasis> - <emphasis>d</emphasis><emphasis>x</emphasis>), <emphasis>f</emphasis>(<emphasis>x</emphasis>), and <emphasis>f</emphasis>(<emphasis>x</emphasis> + <emphasis>d</emphasis><emphasis>x</emphasis>).  Write a
procedure smooth that takes as input a procedure that computes
<emphasis>f</emphasis> and returns a procedure that computes the smoothed <emphasis>f</emphasis>.  It is
sometimes valuable to repeatedly smooth a function (that is, smooth
the smoothed function, and so on) to obtained the <emphasis>n-fold
smoothed function</emphasis>.  Show how to generate the <emphasis>n</emphasis>-fold smoothed
function of any given function using smooth and repeated
from exercise 1.43.</p>

<p>
<strong>Exercise 1.45.</strong>  We saw in section 1.3.3
that attempting to compute square roots by naively finding a
fixed point of <emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis> does not converge, and that this can be
fixed by average damping.  The same method works for finding cube
roots as fixed points of the average-damped <emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis><sup>2</sup>.
Unfortunately, the process does not work for fourth roots -- a single
average damp is not enough to make a fixed-point search for <emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis><sup>3</sup> converge.  On the other hand, if we average damp twice (i.e.,
use the average damp of the average damp of <emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis><sup>3</sup>) the
fixed-point search does converge.  Do some experiments to determine
how many average damps are required to compute <emphasis>n</emphasis>th roots as a
fixed-point search based upon repeated average damping of <emphasis>y</emphasis> <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis><sup><emphasis>n</emphasis>-1</sup>.  Use this to implement a simple procedure for computing
<emphasis>n</emphasis>th roots using fixed-point, average-damp, and the repeated procedure of exercise 1.43.
Assume that any arithmetic operations you need are available as primitives.</p>

<p>
<strong>Exercise 1.46.</strong>  Several of the numerical methods described in this chapter are instances
of an extremely general computational strategy known as <emphasis>iterative
improvement</emphasis>.  Iterative improvement says that, to compute something,
we start with an initial guess for the answer, test if the guess is
good enough, and otherwise improve the guess and continue the process
using the improved guess as the new guess.  Write a procedure iterative-improve that takes two procedures as arguments: a method
for telling whether a guess is good enough and a method for improving
a guess.  Iterative-improve should return as its value a
procedure that takes a guess as argument and keeps improving the guess
until it is good enough.  Rewrite the sqrt procedure of
section 1.1.7 and the fixed-point procedure of
section 1.3.3 in terms of iterative-improve.</p><empty-line /><empty-line /><empty-line /><p><sup>49</sup> This series,
usually written in the equivalent form (<image xlink:href="#_37.jpg" />/4)  =  1 - (1/3) + (1/5) - (1/7) + ···, is due to Leibniz.  We'll see how
to use this as the basis for some fancy numerical tricks in
section 3.5.3.</p>

<p><sup>50</sup> Notice
that we have used block structure (section 1.1.8) to
embed the definitions of pi-next and pi-term within pi-sum, since these procedures are unlikely to be useful for any
other purpose.  We will see how to get rid of them altogether in
section 1.3.2.</p>

<p><sup>51</sup> The intent of
exercises 1.31-1.33 is to
demonstrate the expressive power that is attained by using an
appropriate abstraction to consolidate many seemingly disparate
operations.  However, though accumulation and filtering are elegant
ideas, our hands are somewhat tied in using them at this point since
we do not yet have data structures to provide suitable means of
combination for these abstractions.  We will return to these ideas in
section 2.2.3 when we show how
to use <emphasis>sequences</emphasis> as interfaces for combining filters and
accumulators to build even more powerful abstractions.  We will see
there how these methods really come into their own as a powerful and
elegant approach to designing programs.</p>

<p><sup>52</sup> This formula was discovered by the seventeenth-century
English mathematician John Wallis.</p>

<p><sup>53</sup> It would be clearer and less intimidating to
people learning Lisp if a name more obvious than lambda, such as
make-procedure, were used.  But the convention is firmly
entrenched.  The notation is adopted from the <image xlink:href="#_51.jpg" /> calculus, a
mathematical formalism introduced by the mathematical logician Alonzo
Church (1941).  Church developed the <image xlink:href="#_51.jpg" /> calculus to provide a
rigorous foundation for studying the notions of function and function
application.  The <image xlink:href="#_51.jpg" /> calculus has become a basic tool for
mathematical investigations of the semantics of programming
languages.</p>

<p><sup>54</sup> Understanding internal definitions well enough to be sure a
program means what we intend it to mean requires a more elaborate
model of the evaluation process than we have presented in this
chapter.  The subtleties do not arise with internal definitions of
procedures, however.  We will return to this issue in
section 4.1.6, after we learn more about
evaluation.</p>

<p><sup>55</sup> We have used 0.001 as a representative "small" number to indicate a
tolerance for the acceptable error in a calculation.  The appropriate
tolerance for a real calculation depends upon the problem to be solved
and the limitations of the computer and the algorithm.  This is often
a very subtle consideration, requiring help from a numerical analyst
or some other kind of magician.</p>

<p><sup>56</sup> This
can be accomplished using error, which takes as
arguments a number of items that are printed as error
messages.</p>

<p><sup>57</sup> Try this during a boring lecture: Set your calculator to
radians mode and then repeatedly press the cos button until you
obtain the fixed point.</p>

<p><sup>58</sup>  <image xlink:href="#_45.jpg" />(pronounced "maps to") is
the mathematician's way of writing lambda.
<emphasis>y</emphasis>  <image xlink:href="#_45.jpg" /><emphasis>x</emphasis>/<emphasis>y</emphasis> means (lambda(y) (/ x y)), that is, the
function whose value at <emphasis>y</emphasis> is <emphasis>x</emphasis>/<emphasis>y</emphasis>.</p>

<p><sup>59</sup> Observe that this is a combination whose operator is itself
a combination.  Exercise 1.4 already demonstrated
the ability to form such combinations, but that was only a toy
example.  Here we begin to see the real need for such
combinations -- when applying a procedure that is obtained as the value
returned by a higher-order procedure.</p>

<p><sup>60</sup> See exercise 1.45 for a further
generalization.</p>

<p><sup>61</sup> Elementary calculus books usually describe Newton's
method in terms of the sequence of approximations
<emphasis>x</emphasis><sub><emphasis>n</emphasis>+1</sub> = <emphasis>x</emphasis><sub><emphasis>n</emphasis></sub> - <emphasis>g</emphasis>(<emphasis>x</emphasis><sub><emphasis>n</emphasis></sub>)/<emphasis>D</emphasis><emphasis>g</emphasis>(<emphasis>x</emphasis><sub><emphasis>n</emphasis></sub>).  Having language for talking about
processes and using the idea of fixed points simplifies the description
of the method.</p>

<p><sup>62</sup> Newton's method does not always converge to an answer, but
it can be shown that in favorable cases each iteration doubles the
number-of-digits accuracy of the approximation to the solution.
In such cases, Newton's method will converge much more
rapidly than the half-interval method.</p>

<p><sup>63</sup> For finding square roots, Newton's method converges rapidly to the
correct solution from any starting point.</p>

<p><sup>64</sup> The notion of first-class status of programming-language
elements is due to the British computer scientist Christopher
Strachey (1916-1975).</p>

<p><sup>65</sup> We'll see
examples of this after we introduce data structures in chapter 2.</p>

<p><sup>66</sup> The major implementation cost of first-class
procedures is that allowing procedures to be returned as values
requires reserving storage for a procedure's free variables even while
the procedure is not executing.  In the Scheme implementation we will
study in section 4.1, these variables are stored in the
procedure's environment.</p>


</section>
</section>

<section>


<p><strong>
</strong></p>

<p><strong>Chapter 2</strong></p>

<p>
Building Abstractions with Data</p><empty-line /><p>

We now come to the decisive step of mathematical abstraction: we
forget about what the symbols stand for. ...[The mathematician]
need not be idle; there are many operations which he may carry out
with these symbols, without ever having to look at the things they
stand for.</p>

<p>

Hermann Weyl, <emphasis>The Mathematical Way of Thinking</emphasis></p><empty-line /><p>

We concentrated in chapter 1 on computational processes and on the
role of procedures in program design.  We saw how to use primitive
data (numbers) and primitive operations (arithmetic operations), how to
combine procedures to form compound procedures through composition,
conditionals, and the use of parameters, and how to abstract
procedures by using define.  We saw that a procedure can be
regarded as a pattern for the local evolution of a process, and we
classified, reasoned about, and performed simple algorithmic analyses
of some common patterns for processes as embodied in procedures.  We
also saw that higher-order procedures enhance the power of our
language by enabling us to manipulate, and thereby to reason in terms
of, general methods of computation.  This is much of the essence of
programming.</p>

<p>

In this chapter we are going to look at more complex data.  All the
procedures in chapter 1 operate on simple numerical data, and simple
data are not sufficient for many of the problems we wish to address
using computation.  Programs are typically designed to model complex
phenomena, and more often than not one must construct computational
objects that have several parts in order to model real-world phenomena
that have several aspects.  Thus, whereas our focus in chapter 1 was
on building abstractions by combining procedures to form compound
procedures, we turn in this chapter to another key aspect of any
programming language: the means it provides for building abstractions
by combining data objects to form <emphasis>compound data</emphasis>.</p>

<p>

Why do we want compound data in a programming language?  For the same
reasons that we want compound procedures: to elevate the conceptual
level at which we can design our programs, to increase the modularity
of our designs, and to enhance the expressive power of our language.
Just as the ability to define procedures enables us to deal with
processes at a higher conceptual level than that of the primitive
operations of the language, the ability to construct compound data
objects enables us to deal with data at a higher conceptual level than
that of the primitive data objects of the language.</p>

<p>

Consider the task of designing a system to perform arithmetic with
rational numbers.  We could imagine an operation add-rat that takes
two rational numbers and produces their sum.  In terms of
simple data, a rational number can be thought of as two integers: a
numerator and a denominator.  Thus, we could design a program in which
each rational number would be represented by two integers (a numerator
and a denominator) and where add-rat would be implemented by two
procedures (one producing the numerator of the sum and one producing
the denominator).  But this would be awkward, because we would then
need to explicitly keep track of which numerators corresponded to
which denominators.  In a system intended to perform many operations
on many rational numbers, such bookkeeping details would clutter the
programs substantially, to say nothing of what they would do to our
minds.  It would be much better if we could "glue together" a
numerator and denominator to form a pair -- a <emphasis>compound data
object</emphasis> -- that our programs could manipulate in a way that would be
consistent with regarding a rational number as a single conceptual
unit.</p>

<p>

The use of compound data also enables us to increase the modularity of
our programs.  If we can manipulate rational numbers directly as
objects in their own right, then we can separate the part of our
program that deals with rational numbers per se from the details of
how rational numbers may be represented as pairs of integers.  The
general technique of isolating the parts of a program that deal with
how data objects are represented from the parts of a program that deal
with how data objects are used is a powerful design methodology called
<emphasis>data abstraction</emphasis>.  We will see how data abstraction makes
programs much easier to design, maintain, and modify.</p>

<p>

The use of compound data leads to a real increase in the expressive
power of our programming language.  Consider the idea of forming a
"linear combination" <emphasis>a</emphasis><emphasis>x</emphasis> + <emphasis>b</emphasis><emphasis>y</emphasis>.  We might like to write a procedure
that would accept <emphasis>a</emphasis>, <emphasis>b</emphasis>, <emphasis>x</emphasis>, and <emphasis>y</emphasis> as arguments and return the
value of <emphasis>a</emphasis><emphasis>x</emphasis> + <emphasis>b</emphasis><emphasis>y</emphasis>.  This presents no difficulty if the arguments are to
be numbers, because we can readily define the procedure</p>

<p>(define (linear-combination a b x y)</p><empty-line /><p>
  (+ (* a x) (* b y)))</p><empty-line /><p>
But suppose we are not concerned only with numbers.  Suppose we would
like to express, in procedural terms, the idea that one can form
linear combinations whenever addition and multiplication are
defined -- for rational numbers, complex numbers, polynomials, or
whatever.  We could express this as a procedure of the form</p>

<p>(define (linear-combination a b x y)</p><empty-line /><p>
  (add (mul a x) (mul b y)))</p><empty-line /><p>
where add and mul are not the primitive procedures +
and * but rather more complex things that will perform the
appropriate operations for whatever kinds of data we pass in as the
arguments a, b, x, and y. The key point is
that the only thing linear-combination should need to know about
a, b, x, and y is that the procedures add
and mul will perform the appropriate manipulations.  From the
perspective of the procedure linear-combination, it is
irrelevant what a, b, x, and y are and even
more irrelevant how they might happen to be represented in terms of
more primitive data.  This same example shows why it is important that
our programming language provide the ability to manipulate compound
objects directly: Without this, there is no way for a procedure such
as linear-combination to pass its arguments along to add
and mul without having to know their detailed
structure.<sup>1</sup>

We begin this chapter by implementing the rational-number arithmetic
system mentioned above.  This will form the background for our
discussion of compound data and data abstraction.  As with compound
procedures, the main issue to be addressed is that of abstraction as a
technique for coping with complexity, and we will see how data
abstraction enables us to erect suitable <emphasis>abstraction barriers</emphasis>
between different parts of a program.</p>

<p>

We will see that the key to forming compound data is that a
programming language should provide some kind of "glue" so that data
objects can be combined to form more complex data objects.  There are
many possible kinds of glue.  Indeed, we will discover how to form
compound data using no special "data" operations at all, only
procedures.  This will further blur the distinction between
"procedure" and "data", which was already becoming tenuous toward
the end of chapter 1.  We will also explore some conventional
techniques for representing sequences and trees.  One key idea in
dealing with compound data is the notion of <emphasis>closure</emphasis> -- that the
glue we use for combining data objects should allow us to combine not
only primitive data objects, but compound data objects as well.
Another key idea is that compound data objects can serve as <emphasis>conventional interfaces</emphasis> for combining program modules in
mix-and-match ways.  We illustrate some of these ideas by presenting a
simple graphics language that exploits closure.</p>

<p>

We will then augment the representational power of our language by
introducing <emphasis>symbolic expressions</emphasis> -- data whose elementary parts
can be arbitrary symbols rather than only numbers.  We explore various
alternatives for representing sets of objects.  We will find that,
just as a given numerical function can be computed by many different
computational processes, there are many ways in which a given data
structure can be represented in terms of simpler objects, and the
choice of representation can have significant impact on the time and
space requirements of processes that manipulate the data.  We will
investigate these ideas in the context of symbolic differentiation,
the representation of sets, and the encoding of information.</p>

<p>

Next we will take up the problem of working with data that may be
represented differently by different parts of a program.  This leads
to the need to implement <emphasis>generic operations</emphasis>, which must handle
many different types of data.  Maintaining modularity in the
presence of generic operations requires more powerful abstraction
barriers than can be erected with simple data abstraction alone.  In
particular, we introduce <emphasis>data-directed programming</emphasis> as a
technique that allows individual data representations to be designed
in isolation and then combined <emphasis>additively</emphasis> (i.e., without
modification).  To illustrate the power of this approach to system
design, we close the chapter by applying what we have learned to the
implementation of a package for performing symbolic arithmetic on
polynomials, in which the coefficients of the polynomials can be
integers, rational numbers, complex numbers, and even other
polynomials.</p><empty-line /><empty-line /><empty-line /><p><sup>1</sup> The ability to directly manipulate procedures
provides an analogous increase in the expressive power of a
programming language.  For example, in
section 1.3.1 we introduced the sum
procedure, which takes a procedure term as an argument and
computes the sum of the values of term over some specified
interval.  In order to define sum, it is crucial that we be able
to speak of a procedure such as term as an entity in its own
right, without regard for how term might be expressed with more
primitive operations.  Indeed, if we did not have the notion of "a
procedure", it is doubtful that we would ever even think of the
possibility of defining an operation such as sum.  Moreover,
insofar as performing the summation is concerned, the details of how
term may be constructed from more primitive operations are
irrelevant.</p>


</section>

<section>


<p><strong>2.1  Introduction to Data Abstraction</strong></p>

<p>

In section 1.1.8, we noted
that a procedure used as an element in creating a more complex
procedure could be regarded not only as a collection of particular
operations but also as a procedural abstraction.  That is, the details
of how the procedure was implemented could be suppressed, and the
particular procedure itself could be replaced by any other procedure
with the same overall behavior.  In other words, we could make an
abstraction that would separate the way the procedure would be used
from the details of how the procedure would be implemented in terms of
more primitive procedures.  The analogous notion for compound data is
called <emphasis>data abstraction</emphasis>.  Data abstraction is a methodology that
enables us to isolate how a compound data object is used from the
details of how it is constructed from more primitive data objects.</p>

<p>

The basic idea of data abstraction is to structure the programs that
are to use compound data objects so that they operate on "abstract
data." That is, our programs should use data in such a way as to make
no assumptions about the data that are not strictly necessary for
performing the task at hand.  At the same time, a "concrete" data
representation is defined independent of the programs that use
the data.  The interface between these two parts of our system will be
a set of procedures, called <emphasis>selectors</emphasis> and <emphasis>constructors</emphasis>,
that implement the abstract data in terms of the concrete
representation.  To illustrate this technique, we will consider how to
design a set of procedures for manipulating rational numbers.</p>

<p><strong>2.1.1  Example: Arithmetic Operations for Rational Numbers</strong></p>

<p>

Suppose we want to do arithmetic with rational numbers.  We want to be
able to add, subtract, multiply, and divide them and to test whether
two rational numbers are equal.</p>

<p>

Let us begin by assuming that we already have a way of constructing a
rational number from a numerator and a denominator.  We also assume
that, given a rational number, we have a way of extracting (or
selecting) its numerator and its denominator.  Let us further assume
that the constructor and selectors are available as procedures:</p>

<p>(make-rat &lt;<emphasis>n</emphasis>&gt; &lt;<emphasis>d</emphasis>&gt;) returns the
rational number whose  numerator is the integer &lt;<emphasis>n</emphasis>&gt;
and whose denominator is the integer &lt;<emphasis>d</emphasis>&gt;.</p>

<p>(numer &lt;<emphasis>x</emphasis>&gt;) returns the numerator of the rational 
number &lt;<emphasis>x</emphasis>&gt;.</p>

<p>(denom &lt;<emphasis>x</emphasis>&gt;) returns the denominator of the 
rational number &lt;<emphasis>x</emphasis>&gt;.</p>

<p>

We are using here a powerful strategy of synthesis: <emphasis>wishful thinking</emphasis>.
We haven't yet said how a rational number is represented, or how the
procedures numer, denom, and make-rat should be
implemented.  Even so, if we did have these three procedures, we could
then add, subtract, multiply, divide, and test equality by using the
following relations:</p>

<p><image xlink:href="#_52.jpg" /></p><empty-line /><p><image xlink:href="#_53.jpg" /></p><empty-line /><p><image xlink:href="#_54.jpg" /></p><empty-line /><p><image xlink:href="#_55.jpg" /></p><empty-line /><p><image xlink:href="#_56.jpg" /></p>

<p>

We can express these rules as procedures:</p>

<p>(define (add-rat x y)</p><empty-line /><p>
  (make-rat (+ (* (numer x) (denom y))</p><empty-line /><p>
               (* (numer y) (denom x)))</p><empty-line /><p>
            (* (denom x) (denom y))))</p><empty-line /><p>(define (sub-rat x y)</p><empty-line /><p>
  (make-rat (- (* (numer x) (denom y))</p><empty-line /><p>
               (* (numer y) (denom x)))</p><empty-line /><p>
            (* (denom x) (denom y))))</p><empty-line /><p>(define (mul-rat x y)</p><empty-line /><p>
  (make-rat (* (numer x) (numer y))</p><empty-line /><p>
            (* (denom x) (denom y))))</p><empty-line /><p>(define (div-rat x y)</p><empty-line /><p>
  (make-rat (* (numer x) (denom y))</p><empty-line /><p>
            (* (denom x) (numer y))))</p><empty-line /><p>(define (equal-rat? x y)</p><empty-line /><p>
  (= (* (numer x) (denom y))</p><empty-line /><p>
     (* (numer y) (denom x))))</p><empty-line /><empty-line /><p>

Now we have the operations on rational numbers defined in terms of the
selector and constructor procedures
numer, denom, and make-rat.
But we haven't yet defined these.
What we need is some way to glue together a numerator and a
denominator to form a rational
number.</p>

<p><strong>Pairs</strong></p>

<p>

To enable us to implement the concrete level of our data
abstraction, our language provides a compound structure called a <emphasis>pair</emphasis>, which can be constructed with the primitive procedure cons.  This procedure takes two arguments and returns a compound data
object that contains the two arguments as parts.  Given a pair, we can
extract the parts using the primitive procedures car and cdr.<sup>2</sup> Thus, we can use cons, car, and cdr as follows:</p>

<p>(define x (cons 1 2))</p><empty-line /><empty-line /><p>
(car x)</p><empty-line /><p><emphasis>1</emphasis></p><empty-line /><empty-line /><p>
(cdr x)</p><empty-line /><p><emphasis>2</emphasis></p><empty-line /><p>
Notice that a pair is a data object that can be given a name and
manipulated, just like a primitive data object.  Moreover, cons
can be used to form pairs whose elements are pairs, and so on:</p>

<p>(define x (cons 1 2))</p><empty-line /><empty-line /><p>
(define y (cons 3 4))</p><empty-line /><empty-line /><p>
(define z (cons x y))</p><empty-line /><empty-line /><p>
(car (car z))</p><empty-line /><p><emphasis>1</emphasis></p><empty-line /><empty-line /><p>
(car (cdr z))</p><empty-line /><p><emphasis>3</emphasis></p><empty-line /><p>
In section 2.2 we will see how this ability to
combine pairs means that pairs can be used as general-purpose building
blocks to create all sorts of complex data structures.  The single
compound-data primitive <emphasis>pair</emphasis>, implemented by the procedures cons, car, and cdr, is the only glue we need.  Data
objects constructed from pairs are called <emphasis>list-structured</emphasis> data.</p>

<p><strong>Representing rational numbers</strong></p>

<p>

Pairs offer a natural way to complete the rational-number system.
Simply represent a rational number as a pair of two integers: a
numerator and a denominator.  Then make-rat, numer, and
denom are readily implemented as follows:<sup>3</sup></p>

<p>(define (make-rat n d) (cons n d))</p><empty-line /><empty-line /><p>(define (numer x) (car x))</p><empty-line /><empty-line /><p>(define (denom x) (cdr x))</p><empty-line /><p>
Also, in order to display the results of our computations,
we can print rational numbers by printing the numerator, a
slash, and the denominator:<sup>4</sup></p>

<p>(define (print-rat x)</p><empty-line /><p>
  (newline)</p><empty-line /><p>
  (display (numer x))</p><empty-line /><p>
  (display "/")</p><empty-line /><p>
  (display (denom x)))</p><empty-line /><p>
Now we can try our rational-number procedures:</p>

<p>(define one-half (make-rat 1 2))</p><empty-line /><empty-line /><p>
(print-rat one-half)</p><empty-line /><p><emphasis>1/2</emphasis></p><empty-line /><empty-line /><p>
(define one-third (make-rat 1 3))</p><empty-line /><p>
(print-rat (add-rat one-half one-third))</p><empty-line /><p><emphasis>5/6</emphasis></p><empty-line /><empty-line /><p>
(print-rat (mul-rat one-half one-third))</p><empty-line /><p><emphasis>1/6</emphasis></p><empty-line /><empty-line /><p>
(print-rat (add-rat one-third one-third))</p><empty-line /><p><emphasis>6/9</emphasis></p><empty-line /><empty-line /><p>

As the final example shows, our rational-number implementation does
not reduce rational numbers to lowest terms.  We can remedy this by
changing make-rat. If we have a gcd procedure like the one
in section 1.2.5 that produces the greatest common divisor of two
integers, we can use gcd to reduce the numerator and the
denominator to lowest terms before constructing the pair:</p>

<p>(define (make-rat n d)</p><empty-line /><p>
  (let ((g (gcd n d)))</p><empty-line /><p>
    (cons (/ n g) (/ d g))))</p><empty-line /><p>
Now we have</p>

<p>(print-rat (add-rat one-third one-third))</p><empty-line /><p><emphasis>2/3</emphasis></p><empty-line /><p>
as desired.  This modification was accomplished by changing the
constructor make-rat without changing any of the procedures
(such as add-rat and mul-rat)
that implement the actual operations.</p>

<p>
<strong>Exercise 2.1.</strong>  Define a better version of make-rat that
handles both positive and negative arguments.  Make-rat should
normalize the sign so that if the rational number is positive, both
the numerator and denominator are positive, and if the rational number
is negative, only the numerator is negative.</p>

<p><strong>2.1.2  Abstraction Barriers</strong></p>

<p>

Before continuing with more examples of compound data and data
abstraction, let us consider some of the issues raised by the
rational-number example.  We defined the rational-number operations in
terms of a constructor make-rat and selectors numer and
denom.  In general, the underlying idea of data abstraction is
to identify for each type of data object a basic set of operations in
terms of which all manipulations of data objects of that type will be
expressed, and then to use only those operations in manipulating the
data.</p>

<p>

We can envision the structure of the rational-number system as
shown in figure 2.1.  The
horizontal lines represent <emphasis>abstraction barriers</emphasis> that isolate
different "levels" of the system.  At each level, the barrier
separates the programs (above) that use the data abstraction from the
programs (below) that implement the data abstraction.  Programs that
use rational numbers manipulate them solely in terms of the procedures
supplied "for public use" by the rational-number package: add-rat, sub-rat, mul-rat, div-rat, and equal-rat?. These, in turn, are implemented solely in terms of the
constructor and selectors make-rat, numer, and denom, which themselves are implemented in terms of pairs.  The
details of how pairs are implemented are irrelevant to the rest of the
rational-number package so long as pairs can be manipulated by the use
of cons, car, and cdr.  In effect, procedures at
each level are the interfaces that define the abstraction barriers and
connect the different levels.</p><empty-line /><p><image xlink:href="#_57.jpg" /></p>

<p><strong>Figure 2.1:</strong>  Data-abstraction barriers in the rational-number package.</p>

<p>

This simple idea has many advantages.  One advantage is that it makes
programs much easier to maintain and to modify.  Any complex data
structure can be represented in a variety of ways with the primitive
data structures provided by a programming language.  Of course, the
choice of representation influences the programs that operate on it;
thus, if the representation were to be changed at some later time, all
such programs might have to be modified accordingly.  This task could
be time-consuming and expensive in the case of large programs unless
the dependence on the representation were to be confined by design to
a very few program modules.</p>

<p>

For example, an alternate way to address the problem of reducing rational
numbers to lowest terms is to perform the reduction whenever we
access the parts of a rational number, rather than when we construct
it.  This leads to different constructor and selector procedures:</p>

<p>(define (make-rat n d)</p><empty-line /><p>
  (cons n d))</p><empty-line /><p>(define (numer x)</p><empty-line /><p>
  (let ((g (gcd (car x) (cdr x))))</p><empty-line /><p>
    (/ (car x) g)))</p><empty-line /><p>(define (denom x)</p><empty-line /><p>
  (let ((g (gcd (car x) (cdr x))))</p><empty-line /><p>
    (/ (cdr x) g)))</p><empty-line /><p>
The difference between this implementation and the previous one lies
in when we compute the gcd.
If in our typical use of rational numbers we access the
numerators and denominators of the same rational numbers many
times, it would be preferable
to compute the gcd when the rational numbers are constructed.
If not, we may be better off waiting until access
time to compute the gcd.  In any case, when
we change from one representation to the other, the procedures add-rat, sub-rat, and so on do not have to be modified at all.</p>

<p>


Constraining the dependence on the representation to a few interface
procedures helps us design programs as well as modify them,
because it allows us to maintain the flexibility to consider alternate
implementations.  To continue with our simple example, suppose we are
designing a rational-number package and we can't decide initially
whether to perform the gcd at construction time or at selection
time.  The data-abstraction methodology gives us a way to defer that
decision without losing the ability to make progress on the rest of
the system.</p>

<p>
<strong>Exercise 2.2.</strong>  Consider the problem of representing 
line segments in a plane.  Each segment is
represented as a pair of points: a starting point and an ending point.
Define a constructor make-segment and selectors start-segment
and end-segment that define the representation of segments in
terms of points.  Furthermore, a point can be represented as a pair
of numbers: the <emphasis>x</emphasis> coordinate and the <emphasis>y</emphasis> coordinate.  Accordingly,
specify a constructor make-point and selectors x-point and
y-point that define this representation.  Finally, using your
selectors and constructors, define a procedure midpoint-segment
that takes a line segment as argument and returns its midpoint (the
point whose coordinates are the average of the coordinates of the
endpoints).
To try your procedures, you'll need a way to print points:</p>

<p>(define (print-point p)</p><empty-line /><p>
  (newline)</p><empty-line /><p>
  (display "(")</p><empty-line /><p>
  (display (x-point p))</p><empty-line /><p>
  (display ",")</p><empty-line /><p>
  (display (y-point p))</p><empty-line /><p>
  (display ")"))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.3.</strong>  Implement a representation for rectangles in a plane.
(Hint: You may want to make use of exercise 2.2.)
In terms of
your constructors and selectors, create procedures that compute the
perimeter and the area of a given rectangle.  Now implement a
different representation for rectangles.  Can you design your system
with suitable abstraction barriers, so that the same perimeter and
area procedures will work using either representation?</p>

<p><strong>2.1.3  What Is Meant by Data?</strong></p>

<p>



We began the rational-number implementation in
section 2.1.1 by implementing the rational-number
operations add-rat, sub-rat, and so on in terms of three
unspecified procedures: make-rat, numer, and denom.
At that point, we could think of the operations as being defined in
terms of data objects -- numerators, denominators, and rational
numbers -- whose behavior was specified by the latter three procedures.</p>

<p>

But exactly what is meant by <emphasis>data</emphasis>?  It is not enough to say
"whatever is implemented by the given selectors and constructors."
Clearly, not every arbitrary set of three procedures can serve as an
appropriate basis for the rational-number implementation.  We need to
guarantee that, if we construct a rational number x from a pair
of integers n and d, then extracting the numer and the
denom of x and dividing them should yield the same result
as dividing n by d.  In other words, make-rat,
numer, and denom must satisfy the condition that, for any
integer n and any non-zero integer d, if x is
(make-rat n d), then</p>

<p><image xlink:href="#_58.jpg" /></p>

<p>

In fact, this is the only condition make-rat, numer, and
denom must fulfill in order to form a suitable basis for a
rational-number representation.  In general, we can think of data as
defined by some collection of selectors and constructors, together
with specified conditions that these procedures must fulfill in order
to be a valid representation.<sup>5</sup></p>

<p>


This point of view can serve to define not only "high-level" data
objects, such as rational numbers, but lower-level objects as well.
Consider the notion of a pair, which we used in order to define our
rational numbers.  We never actually said what a pair was, only that
the language supplied procedures cons, car, and cdr
for operating on pairs.  But the only thing we need to know about
these three operations is that if we glue two objects together using
cons we can retrieve the objects using car and cdr.
That is, the operations satisfy the condition that, for any objects
x and y, if z is (cons x y) then (car z)
is x and (cdr z) is y.  Indeed, we mentioned that
these three procedures are included as primitives in our language.
However, any triple of procedures that satisfies the above condition
can be used as the basis for implementing pairs.  This point is
illustrated strikingly by the fact that we could implement cons,
car, and cdr without using any data structures at all but
only using procedures.  Here are the definitions:</p>

<p>(define (cons x y)</p><empty-line /><p>
  (define (dispatch m)</p><empty-line /><p>
    (cond ((= m 0) x)</p><empty-line /><p>
          ((= m 1) y)</p><empty-line /><p>
          (else (error "Argument not 0 or 1 -- CONS" m))))</p><empty-line /><p>
  dispatch)</p><empty-line /><empty-line /><p>(define (car z) (z 0))</p><empty-line /><empty-line /><p>(define (cdr z) (z 1))</p><empty-line /><p>
This use of procedures corresponds to nothing like our intuitive
notion of what data should be.  Nevertheless, all we need to do to
show that this is a valid way to represent pairs is to verify that
these procedures satisfy the condition given above.</p>

<p>

The subtle point to notice is that the value returned by (cons x
y) is a procedure -- namely the internally defined procedure dispatch, which takes one argument and returns either x or y depending on whether the argument is 0 or 1.  Correspondingly, (car z) is defined to apply z to 0.  Hence, if z is the
procedure formed by (cons x y), then z applied to 0 will
yield x. Thus, we have shown that (car (cons x y)) yields
x, as desired.  Similarly, (cdr (cons x y)) applies the
procedure returned by (cons x y) to 1, which returns y.
Therefore, this procedural implementation of pairs is a valid
implementation, and if we access pairs using only cons, car, and cdr we cannot distinguish this implementation from one
that uses "real" data structures.</p>

<p>

The point of exhibiting the procedural representation of pairs is not
that our language works this way (Scheme, and Lisp systems in general,
implement pairs directly, for efficiency reasons) but that it could
work this way.  The procedural representation, although obscure, is a
perfectly adequate way to represent pairs, since it fulfills the only
conditions that pairs need to fulfill.  This example also demonstrates
that the ability to manipulate procedures as objects automatically
provides the ability to represent compound data.  This may seem a
curiosity now, but procedural representations of data will play a
central role in our programming repertoire.  This style of programming
is often called <emphasis>message passing</emphasis>, and we will be using it as a
basic tool in chapter 3 when we address the issues of modeling and
simulation.</p>

<p>
<strong>Exercise 2.4.</strong>  Here is an alternative procedural representation of pairs.  For this
representation, verify that (car (cons x y)) yields x for
any objects x and y.</p>

<p>(define (cons x y)</p><empty-line /><p>
  (lambda (m) (m x y)))</p><empty-line /><empty-line /><p>(define (car z)</p><empty-line /><p>
  (z (lambda (p q) p)))</p><empty-line /><p>
What is the corresponding definition of cdr? (Hint: To verify
that this works, make use of the substitution model of
section 1.1.5.)</p>

<p>
<strong>Exercise 2.5.</strong>  Show that we can represent pairs of nonnegative integers using only
numbers and arithmetic operations if we represent the pair <emphasis>a</emphasis> and <emphasis>b</emphasis>
as the integer that is the product 2<sup><emphasis>a</emphasis></sup> 3<sup><emphasis>b</emphasis></sup>.  Give the corresponding
definitions of the procedures cons, car, and cdr.</p>

<p>
<strong>Exercise 2.6.</strong>  In case representing pairs as procedures wasn't mind-boggling enough,
consider that, in a language that can manipulate procedures, we can
get by without numbers (at least insofar as nonnegative integers are
concerned) by implementing 0 and the operation of adding 1 as</p>

<p>(define zero (lambda (f) (lambda (x) x)))</p><empty-line /><empty-line /><p>
(define (add-1 n)</p><empty-line /><p>
  (lambda (f) (lambda (x) (f ((n f) x)))))</p><empty-line /><p>
This representation is known as <emphasis>Church numerals</emphasis>, after its
inventor, Alonzo Church, the logician who invented the <image xlink:href="#_51.jpg" />
calculus.</p>

<p>

Define one and two directly (not in terms of zero
and add-1).  (Hint: Use substitution to evaluate (add-1 zero)).
Give a direct definition of the addition procedure + (not in
terms of repeated application of add-1).</p>

<p><strong>2.1.4  Extended Exercise: Interval Arithmetic</strong></p>

<p>


Alyssa P. Hacker is designing a system to help people solve
engineering problems.  One feature she wants to provide in her system
is the ability to manipulate inexact quantities (such as measured
parameters of physical devices) with known precision, so that when
computations are done with such approximate quantities the results
will be numbers of known precision.</p>

<p>

Electrical engineers will be using Alyssa's system to compute
electrical quantities.  It is sometimes necessary for them to compute
the value of a parallel equivalent resistance <emphasis>R</emphasis><sub><emphasis>p</emphasis></sub> of two
resistors <emphasis>R</emphasis><sub>1</sub> and <emphasis>R</emphasis><sub>2</sub> using the formula</p>

<p><image xlink:href="#_59.jpg" /></p>

<p>

Resistance values are usually known only up to some tolerance
guaranteed by the manufacturer of the resistor.  For example, if you
buy a resistor labeled "6.8 ohms with 10% tolerance" you can only
be sure that the resistor has a resistance between 6.8 - 0.68 = 6.12 and
6.8 + 0.68 = 7.48 ohms.  Thus, if you have a 6.8-ohm 10% resistor in
parallel with a 4.7-ohm 5% resistor, the resistance of the
combination can range from about 2.58 ohms (if the two resistors are
at the lower bounds) to about 2.97 ohms (if the two resistors are at
the upper bounds).</p>

<p>

Alyssa's idea is to implement "interval arithmetic" as a set of
arithmetic operations for combining "intervals" (objects
that represent the range of possible values of an inexact quantity).
The result of adding, subtracting, multiplying, or dividing two
intervals is itself an interval, representing the range of the
result.</p>

<p>

Alyssa postulates the existence of an abstract object called an
"interval" that has two endpoints: a lower bound and an upper bound.
She also presumes that, given the endpoints of an interval, she can
construct the interval using the data constructor make-interval.
Alyssa first writes a procedure for adding two intervals.  She
reasons that the minimum value the sum could be is the sum of the two
lower bounds and the maximum value it could be is the sum of the two
upper bounds:</p>

<p>(define (add-interval x y)</p><empty-line /><p>
  (make-interval (+ (lower-bound x) (lower-bound y))</p><empty-line /><p>
                 (+ (upper-bound x) (upper-bound y))))</p><empty-line /><p>
Alyssa also works out the product of two intervals by finding the
minimum and the maximum of the products of the bounds and using them
as the bounds of the resulting interval.  (Min and max are
primitives that find the minimum or maximum of any number of
arguments.)</p>

<p>(define (mul-interval x y)</p><empty-line /><p>
  (let ((p1 (* (lower-bound x) (lower-bound y)))</p><empty-line /><p>
        (p2 (* (lower-bound x) (upper-bound y)))</p><empty-line /><p>
        (p3 (* (upper-bound x) (lower-bound y)))</p><empty-line /><p>
        (p4 (* (upper-bound x) (upper-bound y))))</p><empty-line /><p>
    (make-interval (min p1 p2 p3 p4)</p><empty-line /><p>
                   (max p1 p2 p3 p4))))</p><empty-line /><p>
To divide two intervals, Alyssa multiplies the first by the reciprocal of
the second.  Note that the bounds of the reciprocal interval are
the reciprocal of the upper bound and the reciprocal of the lower bound, in
that order.</p>

<p>(define (div-interval x y)</p><empty-line /><p>
  (mul-interval x</p><empty-line /><p>
                (make-interval (/ 1.0 (upper-bound y))</p><empty-line /><p>
                               (/ 1.0 (lower-bound y)))))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.7.</strong>  Alyssa's program is incomplete because she has not specified the
implementation of the interval abstraction.  Here is a definition of
the interval constructor:</p>

<p>(define (make-interval a b) (cons a b))</p><empty-line /><p>
Define selectors upper-bound and lower-bound to complete
the implementation.</p>

<p>
<strong>Exercise 2.8.</strong>  Using reasoning analogous to Alyssa's, describe how the difference
of two intervals may be computed.  Define a corresponding subtraction
procedure, called sub-interval.</p>

<p>
<strong>Exercise 2.9.</strong>  The <emphasis>width</emphasis> of an interval is half of the difference between its
upper and lower bounds.  The width is a measure of the uncertainty of
the number specified by the interval.  For some arithmetic operations
the width of the result of combining two intervals is a function only
of the widths of the argument intervals, whereas for others the width
of the combination is not a function of the widths of the argument
intervals.  Show that the width of the sum (or difference) of two
intervals is a function only of the widths of the intervals being
added (or subtracted).  Give examples to show that this is not true
for multiplication or division.</p>

<p>
<strong>Exercise 2.10.</strong>  Ben Bitdiddle, an expert systems programmer, looks over Alyssa's
shoulder and comments that it is not clear what it means to
divide by an interval that spans zero.  Modify Alyssa's code to
check for this condition and to signal an error if it occurs.</p>

<p>
<strong>Exercise 2.11.</strong>  In passing, Ben also cryptically comments: "By testing the signs of
the endpoints of the intervals, it is possible to break mul-interval into nine cases, only one of which requires more than
two multiplications."  Rewrite this procedure using Ben's
suggestion.</p><empty-line /><p>
After debugging her program, Alyssa shows it to a potential user,
who complains that her program solves the wrong problem.  He
wants a program that can deal with numbers represented as a center
value and an additive tolerance; for example, he wants to work with
intervals such as 3.5± 0.15 rather than [3.35, 3.65].  Alyssa 
returns to her desk and fixes this problem by supplying an alternate
constructor and alternate selectors:</p>

<p>(define (make-center-width c w)</p><empty-line /><p>
  (make-interval (- c w) (+ c w)))</p><empty-line /><p>(define (center i)</p><empty-line /><p>
  (/ (+ (lower-bound i) (upper-bound i)) 2))</p><empty-line /><p>(define (width i)</p><empty-line /><p>
  (/ (- (upper-bound i) (lower-bound i)) 2))</p><empty-line /><empty-line /><p>

Unfortunately, most of Alyssa's users are engineers.  Real engineering
situations usually involve measurements with only a small uncertainty,
measured as the ratio of the width of the interval to the midpoint of
the interval.  Engineers usually specify percentage tolerances on the
parameters of devices, as in the resistor specifications given
earlier.</p>

<p>
<strong>Exercise 2.12.</strong>  Define a constructor make-center-percent that takes a center and
a percentage tolerance and produces the desired interval.  You must
also define a selector percent that produces the
percentage tolerance for a given interval.  The center selector
is the same as the one shown above.</p>

<p>
<strong>Exercise 2.13.</strong>  Show that under the assumption of small percentage tolerances there is
a simple formula for the approximate percentage tolerance of the
product of two intervals in terms of the tolerances of the factors.
You may simplify the problem by assuming that all numbers are
positive.</p><empty-line /><p>After considerable work, Alyssa P. Hacker delivers her finished
system.  Several years later, after she has forgotten all about it, she
gets a frenzied call from an irate user,  Lem E. Tweakit.
It seems that Lem has
noticed that the formula for parallel resistors can be written in two
algebraically equivalent ways:</p>

<p><image xlink:href="#_60.jpg" /></p>

<p>

and</p>

<p><image xlink:href="#_61.jpg" /></p>

<p>

He has written the following two programs, each of which computes the
parallel-resistors formula differently:</p>

<p>(define (par1 r1 r2)</p><empty-line /><p>
  (div-interval (mul-interval r1 r2)</p><empty-line /><p>
                (add-interval r1 r2)))</p><empty-line /><p>
(define (par2 r1 r2)</p><empty-line /><p>
  (let ((one (make-interval 1 1)))</p><empty-line /><p>
    (div-interval one</p><empty-line /><p>
                  (add-interval (div-interval one r1)</p><empty-line /><p>
                                (div-interval one r2)))))</p><empty-line /><p>
Lem complains that Alyssa's program gives different answers for
the two ways of computing. This is a serious complaint.</p>

<p>
<strong>Exercise 2.14.</strong>  Demonstrate that Lem is right. Investigate the behavior of the
system on a variety of arithmetic expressions. Make some intervals <emphasis>A</emphasis> and <emphasis>B</emphasis>,
and use them in computing the expressions <emphasis>A</emphasis>/<emphasis>A</emphasis> and <emphasis>A</emphasis>/<emphasis>B</emphasis>.  You will
get the most insight by using intervals whose width is a small
percentage of the center value. Examine the results of the computation
in center-percent form (see exercise 2.12).</p>

<p>
<strong>Exercise 2.15.</strong>  Eva Lu Ator, another user, has also noticed the different intervals
computed by different but algebraically equivalent expressions. She
says that a formula to compute with intervals using Alyssa's system
will produce tighter error bounds if it can be written in such a form
that no variable that represents an uncertain number is repeated.
Thus, she says, par2 is a "better" program for parallel
resistances than par1.  Is she right?  Why?</p>

<p>
<strong>Exercise 2.16.</strong>  Explain, in general, why equivalent algebraic expressions may lead to
different answers.  Can you devise an interval-arithmetic package that
does not have this shortcoming, or is this task impossible?  (Warning:
This problem is very difficult.)</p><empty-line /><empty-line /><empty-line /><p><sup>2</sup> The name cons stands for "construct."  The
names car and cdr derive from the original implementation of
Lisp on the IBM 704.  That machine had an addressing scheme that
allowed one to reference the "address" and "decrement" parts of a
memory location.  Car stands for "Contents of Address part of
Register" and cdr (pronounced "could-er") stands for
"Contents of Decrement part of Register."</p>

<p><sup>3</sup> Another way to define the selectors and constructor is</p>

<p>(define make-rat cons)</p><empty-line /><p>
(define numer car)</p><empty-line /><p>
(define denom cdr)</p><empty-line /><p>
The first definition associates the name make-rat
with the value of the expression cons, which is the primitive
procedure that constructs pairs.  Thus make-rat and cons
are names for the same primitive constructor.</p>

<p>

Defining selectors and constructors in this way is efficient:
Instead of make-rat <emphasis>calling</emphasis> cons, make-rat
<emphasis>is</emphasis> cons, so there is only one procedure called, not two,
when make-rat is called.  On the other hand, doing this defeats debugging
aids that trace procedure calls or put breakpoints on procedure calls:
You may want to watch make-rat being called, but you certainly
don't want to watch every call to cons.</p>

<p>

We have chosen not to use this style of definition in this book.</p>

<p><sup>4</sup> Display is
the Scheme primitive for printing data.  The Scheme primitive
newline starts a new line for printing.
Neither of these procedures returns a useful value, so in the uses of
print-rat below, we show only what print-rat prints,
not what the interpreter prints as the value returned by print-rat.</p>

<p><sup>5</sup> Surprisingly, this idea is very
difficult to formulate rigorously. There are two approaches to giving
such a formulation.  One, pioneered by C. A. R. Hoare (1972), is known
as the method of <emphasis>abstract models</emphasis>.  It formalizes the
"procedures plus conditions" specification as outlined in the
rational-number example above.  Note that the condition on the
rational-number representation was stated in terms of facts about
integers (equality and division).  In general, abstract models define
new kinds of data objects in terms of previously defined types of data
objects.  Assertions about data objects can therefore be checked by
reducing them to assertions about previously defined data objects.
Another approach, introduced by Zilles at MIT, by Goguen, Thatcher,
Wagner, and Wright at IBM (see Thatcher, Wagner, and Wright 1978), and by Guttag at Toronto (see Guttag 1977),
is called <emphasis>algebraic specification</emphasis>.  It regards the "procedures"
as elements of an abstract algebraic system whose behavior is
specified by axioms that correspond to our "conditions", and uses
the techniques of abstract algebra to check assertions about data
objects.  Both methods are surveyed in the paper by Liskov and Zilles
(1975).</p>


</section>

<section>


<p><strong>2.2  Hierarchical Data and the Closure Property</strong></p>

<p>

As we have seen, pairs provide a primitive "glue" that we can use to
construct compound data objects.
Figure 2.2 shows a standard way to
visualize a pair -- in this case, the pair formed by (cons 1 2).
In this representation, which is called <emphasis>box-and-pointer
notation</emphasis>, each object is shown as a <emphasis>pointer</emphasis> to a box.  The box
for a primitive object contains a representation of the object.  For
example, the box for a number contains a numeral.  The box for a pair
is actually a double box, the left part containing (a pointer to) the
car of the pair and the right part containing the cdr.</p>

<p>


We have already seen that cons can be used to combine not
only numbers but pairs as well.  (You made use of this fact, or
should have, in doing exercises 2.2
and 2.3.)  As a consequence, pairs provide a universal
building block from which we can construct all sorts of data
structures.  Figure 2.3 shows two ways
to use pairs to combine the numbers 1, 2, 3, and 4.</p>

<p><image xlink:href="#_62.jpg" /></p>

<p><strong>Figure 2.2:</strong>  Box-and-pointer representation of (cons 1 2).</p><empty-line /><p><image xlink:href="#_63.jpg" /></p>

<p><strong>Figure 2.3:</strong>  Two ways to combine 1, 2, 3, and 4 using pairs.</p>

<p>

The ability to create pairs whose elements are pairs is the essence of
list structure's importance as a representational tool.  We refer to
this ability as the <emphasis>closure property</emphasis> of cons.  In general,
an operation for combining data objects satisfies the closure property
if the results of combining things with that operation can themselves
be combined using the same operation.<sup>6</sup>
Closure is the key to power in
any means of combination because it permits us to create <emphasis>hierarchical</emphasis> structures -- structures made up of parts, which
themselves are made up of parts, and so on.</p>

<p>

From the outset of chapter 1, we've made essential use of closure in
dealing with procedures, because all but the very simplest programs
rely on the fact that the elements of a combination can themselves be
combinations.  In this section, we take up the consequences of closure
for compound data.  We describe some conventional techniques for using
pairs to represent sequences and trees, and we exhibit a graphics
language that illustrates closure in a vivid way.<sup>7</sup></p>

<p><strong>2.2.1  Representing Sequences</strong></p><empty-line /><p><image xlink:href="#_64.jpg" /></p>

<p><strong>Figure 2.4:</strong>  The sequence 1, 2, 3, 4 represented as a chain of pairs.</p>

<p>

One of the useful structures we can build with pairs is a <emphasis>sequence</emphasis> -- an ordered collection of data objects.  There are, of
course, many ways to represent sequences in terms of pairs.  One
particularly straightforward representation is illustrated in
figure 2.4, where the sequence 1, 2, 3, 4 is
represented as a chain of pairs.  The car of each pair is the
corresponding item in the chain, and the cdr of the pair is
the next pair in the chain.  The cdr of the final pair
signals the end of the sequence by pointing to a distinguished
value that is not a pair,
represented in box-and-pointer diagrams as a diagonal line
and in programs as the value of the variable nil.
The entire sequence is constructed by nested cons operations:</p>

<p>(cons 1</p><empty-line /><p>
      (cons 2</p><empty-line /><p>
            (cons 3</p><empty-line /><p>
                  (cons 4 nil))))</p><empty-line /><empty-line /><p>


Such a sequence of pairs, formed by nested conses, is called a
<emphasis>list</emphasis>, and Scheme provides a
primitive called list to help in constructing lists.<sup>8</sup>
The above sequence could be produced by (list 1 2 3 4).  In
general,</p>

<p>(list &lt;<emphasis>a<sub>1</sub></emphasis>&gt; &lt;<emphasis>a<sub>2</sub></emphasis>&gt; ... &lt;<emphasis>a<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
is equivalent to</p>

<p>(cons &lt;<emphasis>a<sub>1</sub></emphasis>&gt; (cons &lt;<emphasis>a<sub>2</sub></emphasis>&gt; (cons ... (cons &lt;<emphasis>a<sub>n</sub></emphasis>&gt; nil) ...)))</p><empty-line /><p>
Lisp systems conventionally print lists by printing the sequence of
elements, enclosed in parentheses.  Thus, the data object in
figure 2.4 is printed as (1 2 3 4):</p>

<p>(define one-through-four (list 1 2 3 4))</p><empty-line /><empty-line /><p>
one-through-four</p><empty-line /><p><emphasis>(1 2 3 4)</emphasis></p><empty-line /><p>
Be careful not to confuse the expression (list 1 2 3 4) with the
list (1 2 3 4), which is the result obtained when the expression
is evaluated.  Attempting to evaluate the expression (1 2 3 4) will
signal an error when the interpreter tries to apply the procedure 1 to arguments 2, 3, and 4.</p>

<p>


We can think of car as selecting the first item in the list, and
of cdr as selecting the sublist consisting of all but the first
item.  Nested applications of car and cdr can be used to
extract the second, third, and subsequent items in the
list.<sup>9</sup>
The constructor cons makes a list like the original one,
but with an additional item at the beginning.</p>

<p>(car one-through-four)</p><empty-line /><p><emphasis>1</emphasis></p><empty-line /><empty-line /><p>
(cdr one-through-four)</p><empty-line /><p><emphasis>(2 3 4)</emphasis></p><empty-line /><p>
(car (cdr one-through-four))</p><empty-line /><p><emphasis>2</emphasis></p><empty-line /><empty-line /><p>
(cons 10 one-through-four)</p><empty-line /><p><emphasis>(10 1 2 3 4)</emphasis></p><empty-line /><empty-line /><p>
(cons 5 one-through-four)</p><empty-line /><p><emphasis>(5 1 2 3 4)</emphasis></p><empty-line /><p>
The value of nil, used to terminate the chain of pairs, can be
thought of as a sequence of no elements, the <emphasis>empty list</emphasis>.  The
word <emphasis>nil</emphasis> is a contraction of the Latin word <emphasis>nihil</emphasis>, which
means "nothing."<sup>10</sup></p>

<p><strong>List operations</strong></p>

<p>


The use of pairs to represent sequences of elements as lists is
accompanied by conventional programming techniques for manipulating
lists by successively "cdring down" the lists.  For example,
the procedure list-ref takes as arguments a list and a number
<emphasis>n</emphasis> and returns the <emphasis>n</emphasis>th item of the list.  It is customary to
number the elements of the list beginning with 0.  The method for
computing list-ref is the following:</p>

<p>For <emphasis>n</emphasis> = 0, list-ref should return the car of the list.</p>

<p>Otherwise, list-ref should return  the (<emphasis>n</emphasis> - 1)st item of the
cdr of the list.</p><empty-line /><p>(define (list-ref items n)</p><empty-line /><p>
  (if (= n 0)</p><empty-line /><p>
      (car items)</p><empty-line /><p>
      (list-ref (cdr items) (- n 1))))</p><empty-line /><p>
(define squares (list 1 4 9 16 25))</p><empty-line /><empty-line /><p>
(list-ref squares 3)</p><empty-line /><p><emphasis>16</emphasis></p><empty-line /><empty-line /><p>

Often we cdr down the whole list.  To aid in this, Scheme includes
a primitive predicate null?, which tests whether its argument is
the empty list.  The procedure length, which
returns the number of items in a list, illustrates this typical
pattern of use:</p>

<p>(define (length items)</p><empty-line /><p>
  (if (null? items)</p><empty-line /><p>
      0</p><empty-line /><p>
      (+ 1 (length (cdr items)))))</p><empty-line /><p>
(define odds (list 1 3 5 7))</p><empty-line /><empty-line /><p>
(length odds)</p><empty-line /><p><emphasis>4</emphasis></p><empty-line /><p>
The length procedure implements a simple recursive plan. The
reduction step is:</p>

<p>The length of any list is 1 plus the length of the
cdr of the list.</p>

<p>

This is applied successively until we reach the base case:</p>

<p>The length of the empty list is 0.</p>

<p>

We could also compute length in an iterative style:</p>

<p>(define (length items)</p><empty-line /><p>
  (define (length-iter a count)</p><empty-line /><p>
    (if (null? a)</p><empty-line /><p>
        count</p><empty-line /><p>
        (length-iter (cdr a) (+ 1 count))))</p><empty-line /><p>
  (length-iter items 0))</p><empty-line /><empty-line /><p>

Another conventional programming technique is to "cons up" an
answer list while cdring down a list, as in the procedure append, which takes two lists as arguments and combines their
elements to make a new list:</p>

<p>(append squares odds)</p><empty-line /><p><emphasis>(1 4 9 16 25 1 3 5 7)</emphasis></p><empty-line /><empty-line /><p>
(append odds squares)</p><empty-line /><p><emphasis>(1 3 5 7 1 4 9 16 25)</emphasis></p><empty-line /><p>
Append is also implemented using a recursive plan.  To append
lists list1 and list2, do the following:</p>

<p>If list1 is the empty list, then the result is just list2.</p>

<p>Otherwise, append the cdr of list1 and 
list2, and cons the car of list1 onto the result:</p><empty-line /><p>(define (append list1 list2)</p><empty-line /><p>
  (if (null? list1)</p><empty-line /><p>
      list2</p><empty-line /><p>
      (cons (car list1) (append (cdr list1) list2))))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.17.</strong>  Define a procedure last-pair that returns the list that contains only
the last element of a given (nonempty) list:</p>

<p>(last-pair (list 23 72 149 34))</p><empty-line /><p><emphasis>(34)</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 2.18.</strong>  Define a procedure reverse that takes a list as argument and
returns a list of the same elements in reverse order:</p>

<p>(reverse (list 1 4 9 16 25))</p><empty-line /><p><emphasis>(25 16 9 4 1)</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 2.19.</strong>  Consider the change-counting program of
section 1.2.2.  It would be nice to be able to
easily change the currency used by the program, so that we could
compute the number of ways to change a British pound, for example.  As
the program is written, the knowledge of the currency is distributed
partly into the procedure first-denomination and partly into the
procedure count-change (which knows that there are five
kinds of U.S. coins).  It would be nicer to be able to
supply a list of coins to be used for making change.</p>

<p>

We want to rewrite the procedure cc so that its
second argument is a list of the values of the
coins to use rather than an integer specifying which coins to use.  We
could then have lists that defined each kind of currency:</p>

<p>(define us-coins (list 50 25 10 5 1))</p><empty-line /><p>
(define uk-coins (list 100 50 20 10 5 2 1 0.5))</p><empty-line /><p>
We could then call cc as follows:</p>

<p>(cc 100 us-coins)</p><empty-line /><p><emphasis>292</emphasis></p><empty-line /><p>
To do this will require changing the program cc somewhat.  It will
still have the same form, but it will access its second argument
differently, as follows:</p>

<p>(define (cc amount coin-values)</p><empty-line /><p>
  (cond ((= amount 0) 1)</p><empty-line /><p>
        ((or (&lt; amount 0) (no-more? coin-values)) 0)</p><empty-line /><p>
        (else</p><empty-line /><p>
         (+ (cc amount</p><empty-line /><p>
                (except-first-denomination coin-values))</p><empty-line /><p>
            (cc (- amount</p><empty-line /><p>
                   (first-denomination coin-values))</p><empty-line /><p>
                coin-values)))))</p><empty-line /><p>
Define the procedures first-denomination, except-first-denomination, and no-more? in terms of primitive
operations on list structures.  Does the order of the list coin-values affect the answer produced by cc?  Why or why not?</p>

<p>
<strong>Exercise 2.20.</strong>  The procedures +, *, and list take arbitrary numbers
of arguments. One way to define such procedures is to use define
with <emphasis>dotted-tail notation</emphasis>.  In a procedure definition, a parameter
list that has a dot before the last parameter name indicates that, when the
procedure is called, the initial parameters (if any) will have as values
the initial arguments,
as usual, but the final parameter's value will be a <emphasis>list</emphasis> of
any remaining arguments.
For instance, given the definition</p>

<p>(define (f x y . z) <emphasis>&lt;body&gt;</emphasis>)</p><empty-line /><p>
the procedure f can be called with two or more arguments.
If we evaluate</p>

<p>(f 1 2 3 4 5 6)</p><empty-line /><p>
then in the body of f, x will be 1, y will be
2, and z will be the list (3 4 5 6).
Given the definition</p>

<p>(define (g . w) <emphasis>&lt;body&gt;</emphasis>)</p><empty-line /><p>
the procedure g can be called with zero or more arguments.
If we evaluate</p>

<p>(g 1 2 3 4 5 6)</p><empty-line /><p>
then in the body of g, w will be the
list (1 2 3 4 5 6).<sup>11</sup></p>

<p>

Use this notation
to write a procedure same-parity that takes one or more integers
and returns a list of all the arguments that have the same even-odd
parity as the first argument.  For example,</p>

<p>(same-parity 1 2 3 4 5 6 7)</p><empty-line /><p><emphasis>(1 3 5 7)</emphasis></p><empty-line /><empty-line /><p>
(same-parity 2 3 4 5 6 7)</p><empty-line /><p><emphasis>(2 4 6)</emphasis></p><empty-line /><empty-line /><p><strong>Mapping over lists</strong></p>

<p>


One extremely useful operation is to apply some transformation
to each element in a list and generate the list of results.
For instance, the following procedure scales each number in a list by
a given factor:</p>

<p>(define (scale-list items factor)</p><empty-line /><p>
  (if (null? items)</p><empty-line /><p>
      nil</p><empty-line /><p>
      (cons (* (car items) factor)</p><empty-line /><p>
            (scale-list (cdr items) factor))))</p><empty-line /><p>
(scale-list (list 1 2 3 4 5) 10)</p><empty-line /><p><emphasis>(10 20 30 40 50)</emphasis></p><empty-line /><empty-line /><p>

We can abstract this general idea and capture it as a common pattern
expressed as a higher-order procedure, just as in
section 1.3.  The higher-order procedure
here is called map.  Map takes as arguments a procedure
of one argument
and a list, and returns a list of the results produced by
applying the procedure to each element in the list:<sup>12</sup></p>

<p>(define (map proc items)</p><empty-line /><p>
  (if (null? items)</p><empty-line /><p>
      nil</p><empty-line /><p>
      (cons (proc (car items))</p><empty-line /><p>
            (map proc (cdr items)))))</p><empty-line /><p>
(map abs (list -10 2.5 -11.6 17))</p><empty-line /><p><emphasis>(10 2.5 11.6 17)</emphasis></p><empty-line /><p>
(map (lambda (x) (* x x))</p><empty-line /><p>
     (list 1 2 3 4))</p><empty-line /><p><emphasis>(1 4 9 16)</emphasis></p><empty-line /><p>
Now we can give a new definition of scale-list in terms of map:</p>

<p>(define (scale-list items factor)</p><empty-line /><p>
  (map (lambda (x) (* x factor))</p><empty-line /><p>
       items))</p><empty-line /><empty-line /><p>

Map is an important construct, not only because it captures a
common pattern, but because it establishes a higher level of
abstraction in dealing with lists.  In the original definition of scale-list, the recursive structure of the program draws attention to
the element-by-element processing of the list.  Defining scale-list in terms of map suppresses that level of detail and
emphasizes that scaling transforms a list of elements to a list of
results.  The difference between the two definitions is not that the
computer is performing a different process (it isn't) but that we
think about the process differently.  In effect, map helps
establish an abstraction barrier that isolates the implementation of
procedures that transform lists from the details of how the
elements of the list are extracted and combined.  Like the barriers
shown in figure 2.1, this abstraction gives
us the flexibility to change the low-level details of how sequences
are implemented, while preserving the conceptual framework of
operations that transform sequences to sequences.
Section 2.2.3 expands on this use
of sequences as a framework for organizing programs.</p>

<p>
<strong>Exercise 2.21.</strong>  The procedure square-list takes a list of
numbers as argument and returns a list of the squares of those
numbers.</p>

<p>(square-list (list 1 2 3 4))</p><empty-line /><p><emphasis>(1 4 9 16)</emphasis></p><empty-line /><p>
Here are two different definitions of square-list.  Complete
both of them by filling in the missing expressions:</p>

<p>(define (square-list items)</p><empty-line /><p>
  (if (null? items)</p><empty-line /><p>
      nil</p><empty-line /><p>
      (cons &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt;)))</p><empty-line /><p>
(define (square-list items)</p><empty-line /><p>
  (map &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt;))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.22.</strong>  Louis Reasoner tries to rewrite the first square-list procedure of
exercise 2.21 so that it evolves an iterative
process:</p>

<p>(define (square-list items)</p><empty-line /><p>
  (define (iter things answer)</p><empty-line /><p>
    (if (null? things)</p><empty-line /><p>
        answer</p><empty-line /><p>
        (iter (cdr things)</p><empty-line /><p>
              (cons (square (car things))</p><empty-line /><p>
                    answer))))</p><empty-line /><p>
  (iter items nil))</p><empty-line /><p>
Unfortunately, defining square-list this way produces the answer
list in the reverse order of the one desired.  Why?</p>

<p>

Louis then tries to fix his bug by interchanging the arguments to
cons:</p>

<p>(define (square-list items)</p><empty-line /><p>
  (define (iter things answer)</p><empty-line /><p>
    (if (null? things)</p><empty-line /><p>
        answer</p><empty-line /><p>
        (iter (cdr things)</p><empty-line /><p>
              (cons answer</p><empty-line /><p>
                    (square (car things))))))</p><empty-line /><p>
  (iter items nil))</p><empty-line /><p>
This doesn't work either.  Explain.</p>

<p>
<strong>Exercise 2.23.</strong>  The procedure for-each is similar to map.  It takes as
arguments a procedure and a list of elements.  However, rather than
forming a list of the  results, for-each just applies the procedure
to each of the elements in turn, from left to right.  The values
returned by applying the procedure to the elements are not used at
all -- for-each is used with procedures that perform an action,
such as printing.  For example,</p>

<p>(for-each (lambda (x) (newline) (display x))</p><empty-line /><p>
          (list 57 321 88))</p><empty-line /><p><emphasis>57</emphasis></p><empty-line /><p><emphasis>321</emphasis></p><empty-line /><p><emphasis>88</emphasis></p><empty-line /><p>
The value returned by the call to for-each (not illustrated above)
can be something arbitrary, such as true.  Give an
implementation of for-each.</p>

<p><strong>2.2.2  Hierarchical Structures</strong></p>

<p>



The representation of sequences in terms of lists generalizes
naturally to represent sequences whose elements may
themselves be sequences.  For example, we can regard the object
((1 2) 3 4) constructed by</p>

<p>(cons (list 1 2) (list 3 4))</p><empty-line /><p>
as a list of three items, the first of which is itself a list, (1 2).  Indeed, this is suggested by the form in which the result is
printed by the interpreter.  Figure 2.5 shows
the representation of this structure in terms of pairs.</p>

<p><image xlink:href="#_65.jpg" /></p>

<p><strong>Figure 2.5:</strong>  Structure formed by (cons (list 1 2) (list 3 4)).</p>

<p>

Another way to think of sequences whose elements are sequences is as
<emphasis>trees</emphasis>.  The elements of the sequence are the branches of the
tree, and elements that are themselves sequences are subtrees.
Figure 2.6 shows the structure in
figure 2.5 viewed as a tree.</p>

<p><image xlink:href="#_66.jpg" /></p>

<p><strong>Figure 2.6:</strong>  The list structure in figure 2.5 viewed as a tree.</p>

<p>


Recursion is a natural tool for dealing with tree structures, since
we can often reduce operations on trees to operations on their
branches, which reduce in turn to operations on the branches of the
branches, and so on, until we reach the leaves of the tree.
As an example, compare the length procedure of
section 2.2.1 with the count-leaves procedure, which
returns the total number of leaves of a tree:</p>

<p>(define x (cons (list 1 2) (list 3 4)))</p><empty-line /><empty-line /><p>
(length x)</p><empty-line /><p><emphasis>3</emphasis></p><empty-line /><p>
(count-leaves x)</p><empty-line /><p><emphasis>4</emphasis></p><empty-line /><empty-line /><p>
(list x x)</p><empty-line /><p><emphasis>(((1 2) 3 4) ((1 2) 3 4))</emphasis></p><empty-line /><empty-line /><p>
(length (list x x))</p><empty-line /><p><emphasis>2</emphasis></p><empty-line /><empty-line /><p>
(count-leaves (list x x))</p><empty-line /><p><emphasis>8</emphasis></p><empty-line /><empty-line /><p>


To implement count-leaves, recall the recursive plan for computing
length:</p>

<p>Length of a list x is 1 plus length of the
cdr of x.</p>

<p>Length of the empty list is 0.</p>

<p>

Count-leaves is similar.  The value for the empty list is the same:</p>

<p>Count-leaves of the empty list is 0.</p>

<p>

But in the reduction step, where we strip off the car of the
list, we must take into account that the car may itself be a
tree whose leaves we need to count.  Thus, the appropriate reduction
step is</p>

<p>Count-leaves of a tree x is count-leaves of the car of x plus count-leaves of the
cdr of x.</p>

<p>

Finally, by taking cars we reach
actual leaves, so we need another base case:</p>

<p>Count-leaves of a leaf is 1.</p>

<p>

To aid
in writing recursive procedures on trees, Scheme provides the primitive
predicate pair?, which tests whether its argument is a pair.
Here is the complete procedure:<sup>13</sup></p>

<p>(define (count-leaves x)</p><empty-line /><p>
  (cond ((null? x) 0)</p><empty-line /><p>
        ((not (pair? x)) 1)</p><empty-line /><p>
        (else (+ (count-leaves (car x))</p><empty-line /><p>
                 (count-leaves (cdr x))))))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.24.</strong>  Suppose we evaluate the expression (list 1 (list 2 (list 3 4))).
Give the result printed by the interpreter, the corresponding
box-and-pointer structure, and the interpretation of this as a tree
(as in figure 2.6).</p>

<p>
<strong>Exercise 2.25.</strong>  Give combinations of cars and cdrs that will pick 7 from
each of the following lists:</p>

<p>(1 3 (5 7) 9)</p><empty-line /><empty-line /><p>
((7))</p><empty-line /><empty-line /><p>
(1 (2 (3 (4 (5 (6 7))))))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.26.</strong>  Suppose we define x and y to be two lists:</p>

<p>(define x (list 1 2 3))</p><empty-line /><p>
(define y (list 4 5 6))</p><empty-line /><p>
What result is printed by the interpreter in response to evaluating
each of the following expressions:</p>

<p>(append x y)</p><empty-line /><empty-line /><p>
(cons x y)</p><empty-line /><empty-line /><p>
(list x y)</p><empty-line /><empty-line /><p>
<strong>Exercise 2.27.</strong>  Modify your reverse procedure of exercise 2.18 to
produce a deep-reverse procedure that takes a list as argument
and returns as its value the list with its elements reversed and with
all sublists deep-reversed as well.  For example,</p>

<p>(define x (list (list 1 2) (list 3 4)))</p><empty-line /><empty-line /><p>
x</p><empty-line /><p><emphasis>((1 2) (3 4))</emphasis></p><empty-line /><empty-line /><p>
(reverse x)</p><empty-line /><p><emphasis>((3 4) (1 2))</emphasis></p><empty-line /><empty-line /><p>
(deep-reverse x)</p><empty-line /><p><emphasis>((4 3) (2 1))</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 2.28.</strong>  Write a procedure fringe that takes as argument a tree
(represented as a list) and returns a list whose elements are all the
leaves of the tree arranged in left-to-right order.  For example,</p>

<p>(define x (list (list 1 2) (list 3 4)))</p><empty-line /><empty-line /><p>
(fringe x)</p><empty-line /><p><emphasis>(1 2 3 4)</emphasis></p><empty-line /><empty-line /><p>
(fringe (list x x))</p><empty-line /><p><emphasis>(1 2 3 4 1 2 3 4)</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 2.29.</strong>  A binary mobile consists of two branches, a left branch and a right
branch.  Each branch is a rod of a certain length, from which hangs
either a weight or another binary mobile.  We can represent a binary
mobile using compound data by constructing it from two branches (for
example, using list):</p>

<p>(define (make-mobile left right)</p><empty-line /><p>
  (list left right))</p><empty-line /><p>
A branch is constructed from a length (which must be a number)
together with a structure, which may be either a number
(representing a simple weight) or another mobile:</p>

<p>(define (make-branch length structure)</p><empty-line /><p>
  (list length structure))</p><empty-line /><empty-line /><p>

a.  Write the corresponding selectors left-branch and
right-branch, which return the branches of a mobile, and
branch-length and branch-structure, which return 
the components of a branch.</p>

<p>

b.  Using your selectors, define a procedure total-weight 
that returns the total weight of a mobile.</p>

<p>

c.  A mobile is said to be <emphasis>balanced</emphasis> if the torque applied
by its top-left branch is equal to that applied by its top-right
branch (that is, if the length of the left rod multiplied by the
weight hanging from that rod is equal to the corresponding product for
the right side) and if each of the submobiles hanging off its branches
is balanced. Design a predicate that tests whether a binary mobile is
balanced.</p>

<p>

d.  Suppose we change the representation of mobiles so that the
constructors are</p>

<p>(define (make-mobile left right)</p><empty-line /><p>
  (cons left right))</p><empty-line /><p>
(define (make-branch length structure)</p><empty-line /><p>
  (cons length structure))</p><empty-line /><p>
How much do you need to change your programs to convert to the new
representation?</p>

<p><strong>Mapping over trees</strong></p>

<p>


Just as map is a powerful abstraction for dealing with sequences,
map together with recursion is a powerful abstraction for
dealing with trees.  For instance, the scale-tree
procedure, analogous to scale-list of
section 2.2.1, takes as arguments a numeric factor and a
tree whose leaves are numbers.  It returns a tree of the same shape,
where each number is multiplied by the factor.
The recursive plan for scale-tree is similar to the one for
count-leaves:</p>

<p>(define (scale-tree tree factor)</p><empty-line /><p>
  (cond ((null? tree) nil)</p><empty-line /><p>
        ((not (pair? tree)) (* tree factor))</p><empty-line /><p>
        (else (cons (scale-tree (car tree) factor)</p><empty-line /><p>
                    (scale-tree (cdr tree) factor)))))</p><empty-line /><p>
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))</p><empty-line /><p>
            10)</p><empty-line /><p><emphasis>(10 (20 (30 40) 50) (60 70))</emphasis></p><empty-line /><empty-line /><p>

Another way to implement scale-tree is to regard the
tree as a sequence of sub-trees and use map.  We map
over the sequence, scaling each sub-tree in turn, and return the list
of results.  In the base case, where the tree is a leaf, we simply
multiply by the factor:</p>

<p>(define (scale-tree tree factor)</p><empty-line /><p>
  (map (lambda (sub-tree)</p><empty-line /><p>
         (if (pair? sub-tree)</p><empty-line /><p>
             (scale-tree sub-tree factor)</p><empty-line /><p>
             (* sub-tree factor)))</p><empty-line /><p>
       tree))</p><empty-line /><p>
Many tree operations can be implemented by similar combinations of
sequence operations and recursion.</p>

<p>
<strong>Exercise 2.30.</strong>  Define a procedure square-tree analogous to the square-list
procedure of exercise 2.21.  That is, square-list should behave as follows:</p>

<p>(square-tree</p><empty-line /><p>
 (list 1</p><empty-line /><p>
       (list 2 (list 3 4) 5)</p><empty-line /><p>
       (list 6 7)))</p><empty-line /><p><emphasis>(1 (4 (9 16) 25) (36 49))</emphasis></p><empty-line /><p>
Define square-tree both directly (i.e., without using any
higher-order procedures) and also by using map and recursion.</p>

<p>
<strong>Exercise 2.31.</strong>  Abstract your answer to exercise 2.30 to produce a
procedure tree-map with the property that square-tree
could be defined as</p>

<p>(define (square-tree tree) (tree-map square tree))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.32.</strong>  We can represent a set as a list of distinct elements, and we can
represent the set of all subsets of the set as a list of lists.  For
example, if the set is (1 2 3), then the set of all subsets is
(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)).  Complete the
following definition of a procedure that generates the set of subsets
of a set and give a clear explanation of why it works:</p>

<p>(define (subsets s)</p><empty-line /><p>
  (if (null? s)</p><empty-line /><p>
      (list nil)</p><empty-line /><p>
      (let ((rest (subsets (cdr s))))</p><empty-line /><p>
        (append rest (map &lt;<emphasis>??</emphasis>&gt; rest)))))</p><empty-line /><empty-line /><p><strong>2.2.3  Sequences as Conventional Interfaces</strong></p>

<p>



In working with compound data, we've stressed how data abstraction
permits us to design programs without becoming enmeshed in the details
of data representations, and how abstraction preserves for us the
flexibility to experiment with alternative representations.  In this
section, we introduce another powerful design principle for working
with data structures -- the use of <emphasis>conventional interfaces</emphasis>.</p>

<p>

In section 1.3 we saw how program
abstractions, implemented as higher-order procedures, can capture
common patterns in programs that deal with numerical data.  Our
ability to formulate analogous operations for working with compound
data depends crucially on the style in which we manipulate our data
structures.  Consider, for example, the following procedure, analogous
to the count-leaves procedure of section 2.2.2, which
takes a tree as argument and computes the sum of the squares of the
leaves that are odd:</p>

<p>(define (sum-odd-squares tree)</p><empty-line /><p>
  (cond ((null? tree) 0)</p><empty-line /><p>
        ((not (pair? tree))</p><empty-line /><p>
         (if (odd? tree) (square tree) 0))</p><empty-line /><p>
        (else (+ (sum-odd-squares (car tree))</p><empty-line /><p>
                 (sum-odd-squares (cdr tree))))))</p><empty-line /><p>

On the surface, this procedure is very different from the following
one, which constructs a list of all the even Fibonacci numbers
 <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>k</emphasis>), where <emphasis>k</emphasis> is less than or equal to a given integer <emphasis>n</emphasis>:</p>

<p>(define (even-fibs n)</p><empty-line /><p>
  (define (next k)</p><empty-line /><p>
    (if (&gt; k n)</p><empty-line /><p>
        nil</p><empty-line /><p>
        (let ((f (fib k)))</p><empty-line /><p>
          (if (even? f)</p><empty-line /><p>
              (cons f (next (+ k 1)))</p><empty-line /><p>
              (next (+ k 1))))))</p><empty-line /><p>
  (next 0))</p><empty-line /><empty-line /><p>


Despite the fact that these two procedures are structurally very
different, a more abstract description of the two computations reveals
a great deal of similarity.  The first program</p>

<p>enumerates the leaves of a tree;</p>

<p>filters them, selecting the odd ones;</p>

<p>squares each of the selected ones; and</p>

<p>accumulates the results using +, starting with 0.</p>

<p>
The second program</p>

<p>enumerates the integers from 0 to <emphasis>n</emphasis>;</p>

<p>computes the Fibonacci number for each integer;</p>

<p>filters them, selecting the even ones; and</p>

<p>accumulates the results using cons,  starting with the
empty list.</p>

<p>

A signal-processing engineer would find it natural to conceptualize
these processes in terms of signals flowing through a cascade of
stages, each of which implements part of the program plan, as shown in
figure 2.7.  In sum-odd-squares, we
begin with an <emphasis>enumerator</emphasis>, which generates a "signal"
consisting of the leaves of a given tree.  This signal is passed
through a <emphasis>filter</emphasis>, which eliminates all but the odd elements.
The resulting signal is in turn passed through a <emphasis>map</emphasis>, which is a
"transducer" that applies the square procedure to each
element.  The output of the map is then fed to an <emphasis>accumulator</emphasis>,
which combines the elements using +, starting from an initial 0.
The plan for even-fibs is analogous.</p>

<p><image xlink:href="#_67.jpg" /></p>

<p><strong>Figure 2.7:</strong>  The signal-flow plans for the procedures sum-odd-squares (top) and even-fibs (bottom) reveal the
commonality between the two programs.</p>

<p>

Unfortunately, the two procedure definitions above fail to exhibit this
signal-flow structure.  For instance, if we examine the sum-odd-squares procedure, we find that the enumeration is
implemented partly by the null? and pair? tests and partly
by the tree-recursive structure of the procedure.  Similarly, the
accumulation is found partly in the tests and partly in the addition used
in the recursion.  In general, there are no distinct parts of either
procedure that correspond to the elements in the signal-flow
description.
Our two procedures decompose the computations in a different way,
spreading the enumeration over the program and mingling it with the
map, the filter, and the accumulation.  If we could organize our
programs to make the signal-flow structure manifest in the procedures
we write, this would increase the conceptual clarity of the resulting
code.</p>

<p><strong>Sequence Operations</strong></p>

<p>



The key to organizing programs so as to more clearly reflect the
signal-flow structure is to concentrate on the "signals" that flow
from one stage in the process to the next.  If we represent these
signals as lists, then we can use list operations to implement the
processing at each of the stages.  For instance, we can implement the
mapping stages of the signal-flow diagrams using the map
procedure from section 2.2.1:</p>

<p>(map square (list 1 2 3 4 5))</p><empty-line /><p><emphasis>(1 4 9 16 25)</emphasis></p><empty-line /><empty-line /><p>

Filtering a sequence to select only those elements that satisfy a
given predicate is accomplished by</p>

<p>(define (filter predicate sequence)</p><empty-line /><p>
  (cond ((null? sequence) nil)</p><empty-line /><p>
        ((predicate (car sequence))</p><empty-line /><p>
         (cons (car sequence)</p><empty-line /><p>
               (filter predicate (cdr sequence))))</p><empty-line /><p>
        (else (filter predicate (cdr sequence)))))</p><empty-line /><p>
For example,</p>

<p>(filter odd? (list 1 2 3 4 5))</p><empty-line /><p><emphasis>(1 3 5)</emphasis></p><empty-line /><empty-line /><p>

Accumulations can be implemented by</p>

<p>(define (accumulate op initial sequence)</p><empty-line /><p>
  (if (null? sequence)</p><empty-line /><p>
      initial</p><empty-line /><p>
      (op (car sequence)</p><empty-line /><p>
          (accumulate op initial (cdr sequence)))))</p><empty-line /><p>
(accumulate + 0 (list 1 2 3 4 5))</p><empty-line /><p><emphasis>15</emphasis></p><empty-line /><p>
(accumulate * 1 (list 1 2 3 4 5))</p><empty-line /><p><emphasis>120</emphasis></p><empty-line /><p>
(accumulate cons nil (list 1 2 3 4 5))</p><empty-line /><p><emphasis>(1 2 3 4 5)</emphasis></p><empty-line /><empty-line /><p>


All that remains to implement signal-flow diagrams is to enumerate the
sequence of elements to be processed.  For even-fibs, we need to
generate the sequence of
integers in a given range, which we can do as follows:</p>

<p>(define (enumerate-interval low high)</p><empty-line /><p>
  (if (&gt; low high)</p><empty-line /><p>
      nil</p><empty-line /><p>
      (cons low (enumerate-interval (+ low 1) high))))</p><empty-line /><p>
(enumerate-interval 2 7)</p><empty-line /><p><emphasis>(2 3 4 5 6 7)</emphasis></p><empty-line /><p>
To enumerate the leaves of a tree, we can use<sup>14</sup></p>

<p>(define (enumerate-tree tree)</p><empty-line /><p>
  (cond ((null? tree) nil)</p><empty-line /><p>
        ((not (pair? tree)) (list tree))</p><empty-line /><p>
        (else (append (enumerate-tree (car tree))</p><empty-line /><p>
                      (enumerate-tree (cdr tree))))))</p><empty-line /><p>
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))</p><empty-line /><p><emphasis>(1 2 3 4 5)</emphasis></p><empty-line /><empty-line /><p>

Now we can reformulate sum-odd-squares and even-fibs as in
the signal-flow diagrams.  For sum-odd-squares, we enumerate the
sequence of leaves of the tree, filter this to keep only the odd
numbers in the sequence, square each element, and sum the results:</p>

<p>(define (sum-odd-squares tree)</p><empty-line /><p>
  (accumulate +</p><empty-line /><p>
              0</p><empty-line /><p>
              (map square</p><empty-line /><p>
                   (filter odd?</p><empty-line /><p>
                           (enumerate-tree tree)))))</p><empty-line /><p>
For even-fibs, we enumerate the integers from 0 to <emphasis>n</emphasis>, generate
the Fibonacci number for each of these integers, filter the resulting
sequence to keep only the even elements, and accumulate the results
into a list:</p>

<p>(define (even-fibs n)</p><empty-line /><p>
  (accumulate cons</p><empty-line /><p>
              nil</p><empty-line /><p>
              (filter even?</p><empty-line /><p>
                      (map fib</p><empty-line /><p>
                           (enumerate-interval 0 n)))))</p><empty-line /><empty-line /><p>


The value of expressing programs as sequence operations is that this
helps us make program designs that are modular, that is, designs that
are constructed by combining relatively independent pieces.  We can
encourage modular design by providing a library of standard components
together with a conventional interface for connecting the components
in flexible ways.</p>

<p>

Modular construction is a powerful strategy for
controlling complexity in engineering design.  In real
signal-processing applications, for example, designers regularly build
systems by cascading elements selected from standardized families of
filters and transducers.  Similarly, sequence operations provide a
library of standard program elements that we can mix and match.  For
instance, we can reuse pieces from the sum-odd-squares and even-fibs procedures in a program that constructs a list of the
squares of the first <emphasis>n</emphasis> + 1 Fibonacci numbers:</p>

<p>(define (list-fib-squares n)</p><empty-line /><p>
  (accumulate cons</p><empty-line /><p>
              nil</p><empty-line /><p>
              (map square</p><empty-line /><p>
                   (map fib</p><empty-line /><p>
                        (enumerate-interval 0 n)))))</p><empty-line /><p>
(list-fib-squares 10)</p><empty-line /><p><emphasis>(0 1 1 4 9 25 64 169 441 1156 3025)</emphasis></p><empty-line /><p>
We can rearrange the pieces and use them in computing the product of
the odd integers in a sequence:</p>

<p>(define (product-of-squares-of-odd-elements sequence)</p><empty-line /><p>
  (accumulate *</p><empty-line /><p>
              1</p><empty-line /><p>
              (map square</p><empty-line /><p>
                   (filter odd? sequence))))</p><empty-line /><p>
(product-of-squares-of-odd-elements (list 1 2 3 4 5))</p><empty-line /><p><emphasis>225</emphasis></p><empty-line /><empty-line /><p>

We can also formulate conventional data-processing applications in
terms of sequence operations.  Suppose we have a sequence of personnel
records and we want to find the salary of the highest-paid programmer.
Assume that we have a selector salary that returns the salary of
a record, and a predicate programmer? that tests if a record is
for a programmer.  Then we can write</p>

<p>(define (salary-of-highest-paid-programmer records)</p><empty-line /><p>
  (accumulate max</p><empty-line /><p>
              0</p><empty-line /><p>
              (map salary</p><empty-line /><p>
                   (filter programmer? records))))</p><empty-line /><p>
These examples give just a hint of the vast range of operations that
can be expressed as sequence operations.<sup>15</sup></p>

<p>

Sequences, implemented here as lists, serve
as a conventional interface that permits us to combine processing
modules.  Additionally, when we uniformly represent structures as
sequences, we have localized the data-structure dependencies in our
programs to a small number of sequence operations.  By changing these,
we can experiment with alternative representations of sequences, while
leaving the overall design of our programs intact.  We will exploit
this capability in section 3.5, when we generalize the
sequence-processing paradigm to admit infinite sequences.</p>

<p>
<strong>Exercise 2.33.</strong>  Fill in the missing expressions to complete the following definitions
of some basic list-manipulation operations as accumulations:</p>

<p>(define (map p sequence)</p><empty-line /><p>
  (accumulate (lambda (x y) &lt;<emphasis>??</emphasis>&gt;) nil sequence))</p><empty-line /><p>(define (append seq1 seq2)</p><empty-line /><p>
  (accumulate cons &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt;))</p><empty-line /><p>(define (length sequence)</p><empty-line /><p>
  (accumulate &lt;<emphasis>??</emphasis>&gt; 0 sequence))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.34.</strong>  Evaluating a polynomial in <emphasis>x</emphasis> at a given value of <emphasis>x</emphasis> can be
formulated as an accumulation.  We evaluate the polynomial</p>

<p><image xlink:href="#_68.jpg" /></p>

<p>
using a well-known algorithm called <emphasis>Horner's rule</emphasis>, which
structures the computation as</p>

<p><image xlink:href="#_69.jpg" /></p>

<p>
In other words, we start with <emphasis>a</emphasis><sub><emphasis>n</emphasis></sub>, multiply by <emphasis>x</emphasis>, add <emphasis>a</emphasis><sub><emphasis>n</emphasis>-1</sub>,
multiply by <emphasis>x</emphasis>, and so on, until we reach <emphasis>a</emphasis><sub>0</sub>.<sup>16</sup>
Fill in the following template to produce a procedure that evaluates a
polynomial using Horner's rule.
Assume that the coefficients of the
polynomial are arranged in a sequence, from <emphasis>a</emphasis><sub>0</sub> through <emphasis>a</emphasis><sub><emphasis>n</emphasis></sub>.</p>

<p>(define (horner-eval x coefficient-sequence)</p><empty-line /><p>
  (accumulate (lambda (this-coeff higher-terms) &lt;<emphasis>??</emphasis>&gt;)</p><empty-line /><p>
              0</p><empty-line /><p>
              coefficient-sequence))</p><empty-line /><p>
For example, to compute 1 + 3<emphasis>x</emphasis> + 5<emphasis>x</emphasis><sup>3</sup> + <emphasis>x</emphasis><sup>5</sup> at <emphasis>x</emphasis> = 2 you would evaluate</p>

<p>(horner-eval 2 (list 1 3 0 5 0 1))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.35.</strong>  Redefine count-leaves from section 2.2.2 as an
accumulation:</p>

<p>(define (count-leaves t)</p><empty-line /><p>
  (accumulate &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt; (map &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt;)))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.36.</strong>  The procedure accumulate-n is similar to accumulate except
that it takes as its third argument a sequence of sequences, which are all
assumed to have the same number of elements.  It applies the
designated accumulation procedure to combine all the first elements of
the sequences, all the second elements of the sequences, and so on, and
returns a sequence of the results.  For instance, if s is a sequence
containing four sequences, ((1 2 3) (4 5 6) (7 8 9) (10 11 12)),
then the value of (accumulate-n + 0 s) should be the sequence (22 26 30).  Fill in the missing expressions
in the following definition of accumulate-n:</p>

<p>(define (accumulate-n op init seqs)</p><empty-line /><p>
  (if (null? (car seqs))</p><empty-line /><p>
      nil</p><empty-line /><p>
      (cons (accumulate op init &lt;<emphasis>??</emphasis>&gt;)</p><empty-line /><p>
            (accumulate-n op init &lt;<emphasis>??</emphasis>&gt;))))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.37.</strong>  Suppose we represent vectors <emphasis>v</emphasis> = (<emphasis>v</emphasis><sub><emphasis>i</emphasis></sub>) as sequences of numbers, and
matrices <emphasis>m</emphasis> = (<emphasis>m</emphasis><sub><emphasis>i</emphasis><emphasis>j</emphasis></sub>) as sequences of vectors (the rows of the matrix).
For example, the matrix</p>

<p><image xlink:href="#_70.jpg" /></p>

<p>
is represented as the sequence ((1 2 3 4) (4 5 6 6) (6 7 8 9)).
With this representation, we can use sequence operations to concisely
express the basic matrix and vector operations.  These operations
(which are described in any book on matrix algebra) are the following:</p>

<p><image xlink:href="#_71.jpg" /></p>

<p>

We can define the dot product as<sup>17</sup></p>

<p>(define (dot-product v w)</p><empty-line /><p>
  (accumulate + 0 (map * v w)))</p><empty-line /><p>
Fill in the missing expressions in the following procedures for
computing the other matrix operations.  (The procedure accumulate-n is
defined in exercise 2.36.)</p>

<p>(define (matrix-*-vector m v)</p><empty-line /><p>
  (map &lt;<emphasis>??</emphasis>&gt; m))</p><empty-line /><p>(define (transpose mat)</p><empty-line /><p>
  (accumulate-n &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt; mat))</p><empty-line /><p>(define (matrix-*-matrix m n)</p><empty-line /><p>
  (let ((cols (transpose n)))</p><empty-line /><p>
    (map &lt;<emphasis>??</emphasis>&gt; m)))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.38.</strong>  The accumulate procedure is also known as fold-right,
because it combines the first element of the sequence with the result
of combining all the elements to the right.  There is also a fold-left, which is 
similar to fold-right, except
that it combines elements working in the opposite direction:</p>

<p>(define (fold-left op initial sequence)</p><empty-line /><p>
  (define (iter result rest)</p><empty-line /><p>
    (if (null? rest)</p><empty-line /><p>
        result</p><empty-line /><p>
        (iter (op result (car rest))</p><empty-line /><p>
              (cdr rest))))</p><empty-line /><p>
  (iter initial sequence))</p><empty-line /><p>
What are the values of</p>

<p>(fold-right / 1 (list 1 2 3))</p><empty-line /><p>
(fold-left / 1 (list 1 2 3))</p><empty-line /><p>
(fold-right list nil (list 1 2 3))</p><empty-line /><p>
(fold-left list nil (list 1 2 3))</p><empty-line /><p>
Give a property that op should satisfy to guarantee that fold-right and fold-left will produce the same values for any
sequence.</p>

<p>
<strong>Exercise 2.39.</strong>  
Complete the following definitions of reverse
(exercise 2.18) in terms of fold-right and fold-left from exercise 2.38:</p>

<p>(define (reverse sequence)</p><empty-line /><p>
  (fold-right (lambda (x y) &lt;<emphasis>??</emphasis>&gt;) nil sequence))</p><empty-line /><p>
(define (reverse sequence)</p><empty-line /><p>
  (fold-left (lambda (x y) &lt;<emphasis>??</emphasis>&gt;) nil sequence))</p><empty-line /><empty-line /><p><strong>Nested Mappings</strong></p>

<p>



We can extend the sequence paradigm to include many
computations that are commonly expressed using nested loops.<sup>18</sup>
Consider
this problem: Given a positive integer <emphasis>n</emphasis>, find all ordered pairs of
distinct positive integers <emphasis>i</emphasis> and <emphasis>j</emphasis>, where 1&lt; <emphasis>j</emphasis>&lt; <emphasis>i</emphasis>&lt; <emphasis>n</emphasis>, such
that <emphasis>i</emphasis>  + <emphasis>j</emphasis> is prime.  For example, if <emphasis>n</emphasis> is 6, then the pairs are
the following:</p>

<p><image xlink:href="#_72.jpg" /></p>

<p>
A natural way to organize this computation is to generate the sequence
of all ordered pairs of positive integers less than or equal to <emphasis>n</emphasis>,
filter to select those pairs whose sum is prime, and
then, for each pair (<emphasis>i</emphasis>, <emphasis>j</emphasis>) that passes through the filter, produce the triple
(<emphasis>i</emphasis>,<emphasis>j</emphasis>,<emphasis>i</emphasis> + <emphasis>j</emphasis>).</p>

<p>

Here is a way to generate the sequence of pairs: For each integer
<emphasis>i</emphasis>&lt; <emphasis>n</emphasis>, enumerate the integers <emphasis>j</emphasis>&lt;<emphasis>i</emphasis>, and for each such <emphasis>i</emphasis> and <emphasis>j</emphasis>
generate the pair (<emphasis>i</emphasis>,<emphasis>j</emphasis>).  In terms of sequence operations, we map
along the sequence (enumerate-interval 1 n).  For each <emphasis>i</emphasis> in
this sequence, we map along the sequence (enumerate-interval 1 (-
i 1)).  For each <emphasis>j</emphasis> in this latter sequence, we generate the pair
(list i j).  This gives us a sequence of pairs for each <emphasis>i</emphasis>.
Combining all the sequences for all the <emphasis>i</emphasis> (by accumulating with append) produces the required sequence of pairs:<sup>19</sup></p>

<p>(accumulate append</p><empty-line /><p>
            nil</p><empty-line /><p>
            (map (lambda (i)</p><empty-line /><p>
                   (map (lambda (j) (list i j))</p><empty-line /><p>
                        (enumerate-interval 1 (- i 1))))</p><empty-line /><p>
                 (enumerate-interval 1 n)))</p><empty-line /><p>
The combination of mapping and accumulating with append is so common in this
sort of program that we will isolate it as a separate procedure:</p>

<p>(define (flatmap proc seq)</p><empty-line /><p>
  (accumulate append nil (map proc seq)))</p><empty-line /><p>
Now filter this sequence of pairs to find those whose sum is prime. The
filter predicate is called for each element of the sequence; its
argument is a pair and it must extract the integers from the pair.
Thus, the predicate to apply to each element in the sequence is</p>

<p>(define (prime-sum? pair)</p><empty-line /><p>
  (prime? (+ (car pair) (cadr pair))))</p><empty-line /><p>
Finally, generate the sequence of results by mapping over the filtered
pairs using the following procedure, which constructs a triple
consisting of the two elements of the pair along with their sum:</p>

<p>(define (make-pair-sum pair)</p><empty-line /><p>
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))</p><empty-line /><p>
Combining all these steps yields the complete procedure:</p>

<p>(define (prime-sum-pairs n)</p><empty-line /><p>
  (map make-pair-sum</p><empty-line /><p>
       (filter prime-sum?</p><empty-line /><p>
               (flatmap</p><empty-line /><p>
                (lambda (i)</p><empty-line /><p>
                  (map (lambda (j) (list i j))</p><empty-line /><p>
                       (enumerate-interval 1 (- i 1))))</p><empty-line /><p>
                (enumerate-interval 1 n)))))</p><empty-line /><empty-line /><p>

Nested mappings are also useful for sequences other than those that
enumerate intervals.  Suppose we wish to generate all the permutations
of a set <emphasis>S</emphasis>; that is, all the ways of ordering the items in
the set.  For instance, the permutations of {1,2,3} are
{1,2,3}, { 1,3,2}, {2,1,3}, { 2,3,1}, { 3,1,2}, and
{ 3,2,1}.  Here is a plan for generating the permutations of <emphasis>S</emphasis>:
For each item <emphasis>x</emphasis> in <emphasis>S</emphasis>, recursively generate the sequence of
permutations of <emphasis>S</emphasis> - <emphasis>x</emphasis>,<sup>20</sup> and adjoin
<emphasis>x</emphasis> to the front of each one.  This yields, for each <emphasis>x</emphasis> in <emphasis>S</emphasis>, the sequence
of permutations of <emphasis>S</emphasis> that begin with <emphasis>x</emphasis>.  Combining these
sequences for all <emphasis>x</emphasis> gives all the permutations of <emphasis>S</emphasis>:<sup>21</sup></p>

<p>(define (permutations s)</p><empty-line /><p>
  (if (null? s)                    <emphasis>; empty set?</emphasis></p><empty-line /><p>
      (list nil)                   <emphasis>; sequence containing empty set</emphasis></p><empty-line /><p>
      (flatmap (lambda (x)</p><empty-line /><p>
                 (map (lambda (p) (cons x p))</p><empty-line /><p>
                      (permutations (remove x s))))</p><empty-line /><p>
               s)))</p><empty-line /><p>
Notice how this strategy reduces the problem of generating
permutations of <emphasis>S</emphasis> to the problem of generating the permutations of
sets with fewer elements than <emphasis>S</emphasis>.  In the terminal case, we work our
way down to the empty list, which represents a set of no elements.
For this, we generate (list nil), which is a sequence with one
item, namely the set with no elements.  The remove procedure
used in permutations returns all the items in a given sequence
except for a given item.  This can be expressed as a simple filter:</p>

<p>(define (remove item sequence)</p><empty-line /><p>
  (filter (lambda (x) (not (= x item)))</p><empty-line /><p>
          sequence))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.40.</strong>  Define a procedure unique-pairs that, given an integer <emphasis>n</emphasis>,
generates the sequence of pairs (<emphasis>i</emphasis>,<emphasis>j</emphasis>) with 1&lt; <emphasis>j</emphasis>&lt; <emphasis>i</emphasis>&lt; <emphasis>n</emphasis>.  Use unique-pairs to simplify the definition of prime-sum-pairs
given above.</p>

<p>
<strong>Exercise 2.41.</strong>  Write a procedure to find all ordered
triples of distinct positive integers <emphasis>i</emphasis>, <emphasis>j</emphasis>, and <emphasis>k</emphasis> less than or
equal to a given integer <emphasis>n</emphasis> that sum to a given integer <emphasis>s</emphasis>.</p>

<p>
<strong>Exercise 2.42.</strong></p>

<p><image xlink:href="#_73.jpg" /></p>

<p><strong>Figure 2.8:</strong>  A solution to the eight-queens puzzle.</p>

<p>
The "eight-queens puzzle" asks how to place eight queens on a
chessboard so that no queen is in check from any other (i.e., no two
queens are in the same row, column, or diagonal).  One possible
solution is shown in figure 2.8.  One way to solve the
puzzle is to work across the board, placing a queen in each column.
Once we have placed <emphasis>k</emphasis> - 1 queens, we must place the <emphasis>k</emphasis>th queen in a
position where it does not check any of the queens already on the
board.  We can formulate this approach recursively: Assume that we
have already generated the sequence of all possible ways to place
<emphasis>k</emphasis> - 1 queens in the first <emphasis>k</emphasis> - 1 columns of the board.  For each of
these ways, generate an extended set of positions by placing a queen
in each row of the <emphasis>k</emphasis>th column.  Now filter these, keeping only
the positions for which the queen in the <emphasis>k</emphasis>th column is safe with
respect to the other queens.  This produces the sequence of all ways
to place <emphasis>k</emphasis> queens in the first <emphasis>k</emphasis> columns.  By continuing this
process, we will produce not only one solution, but all solutions to
the puzzle.</p>

<p>


We implement this solution as a procedure queens, which returns
a sequence of all solutions to the problem of placing <emphasis>n</emphasis> queens on an
<emphasis>n</emphasis>× <emphasis>n</emphasis> chessboard.  Queens has an internal procedure queen-cols that returns the sequence of all ways to place queens in
the first <emphasis>k</emphasis> columns of the board.</p>

<p>(define (queens board-size)</p><empty-line /><p>
  (define (queen-cols k)</p><empty-line /><p>
    (if (= k 0)</p><empty-line /><p>
        (list empty-board)</p><empty-line /><p>
        (filter</p><empty-line /><p>
         (lambda (positions) (safe? k positions))</p><empty-line /><p>
         (flatmap</p><empty-line /><p>
          (lambda (rest-of-queens)</p><empty-line /><p>
            (map (lambda (new-row)</p><empty-line /><p>
                   (adjoin-position new-row k rest-of-queens))</p><empty-line /><p>
                 (enumerate-interval 1 board-size)))</p><empty-line /><p>
          (queen-cols (- k 1))))))</p><empty-line /><p>
  (queen-cols board-size))</p><empty-line /><p>
In this procedure rest-of-queens is a way to place <emphasis>k</emphasis> - 1 queens
in the first <emphasis>k</emphasis> - 1 columns, and new-row is a proposed row in
which to place the queen for the <emphasis>k</emphasis>th column.  Complete the program
by implementing the representation for sets of board positions,
including the procedure adjoin-position, which adjoins a new row-column
position to a set of positions, and empty-board, which
represents an empty set of positions.  You must also write the
procedure safe?, which determines for a set of positions,
whether the queen in the <emphasis>k</emphasis>th column is safe with respect to the
others.  (Note that we need only check whether the new queen is
safe -- the other queens are already guaranteed safe with respect to
each other.)</p>

<p>
<strong>Exercise 2.43.</strong>  Louis Reasoner is having a terrible time doing exercise 2.42.  His
queens procedure seems to work, but it runs extremely slowly.
(Louis never does manage to wait long enough for it to solve even the
6× 6 case.)  When Louis asks Eva Lu Ator for help, she points
out that he has interchanged the order of the nested mappings in the
flatmap, writing it as</p>

<p>(flatmap</p><empty-line /><p>
 (lambda (new-row)</p><empty-line /><p>
   (map (lambda (rest-of-queens)</p><empty-line /><p>
          (adjoin-position new-row k rest-of-queens))</p><empty-line /><p>
        (queen-cols (- k 1))))</p><empty-line /><p>
 (enumerate-interval 1 board-size))</p><empty-line /><p>
Explain why this interchange makes the program run slowly.  Estimate
how long it will take Louis's program to solve the eight-queens
puzzle, assuming that the program in exercise 2.42 solves
the puzzle in time <emphasis>T</emphasis>.</p>

<p><strong>2.2.4  Example: A Picture Language</strong></p>

<p>



This section presents a simple language for drawing
pictures that illustrates the
power of data abstraction and closure,
and also exploits higher-order procedures in
an essential way.  The language
is designed to make it easy to experiment with patterns
such as the ones in figure 2.9, which are
composed of repeated elements that are shifted and scaled.<sup>22</sup> In this language,
the data objects being combined
are represented as procedures rather than as list structure.
Just as cons, which satisfies the closure property,
allowed us to easily build arbitrarily complicated
list structure, the operations in this language, which also
satisfy the closure property, allow us to easily build
arbitrarily complicated patterns.</p><empty-line /><p><image xlink:href="#_74.jpg" />
          
<image xlink:href="#_75.jpg" /></p>

<p><strong>Figure 2.9:</strong>  Designs generated with the picture language.</p>

<p><strong>The picture language</strong></p>

<p>

When we began our study of programming in
section 1.1, we emphasized the
importance of describing a language by focusing on the language's
primitives, its means of combination, and its means of abstraction.
We'll follow that framework here.</p>

<p>

Part of the elegance of this picture language is that there is
only one kind of element, called a <emphasis>painter</emphasis>.  A painter
draws an image that is shifted and scaled to fit within a designated
parallelogram-shaped frame.  For example, there's a primitive painter
we'll call wave that makes a crude line drawing, as
shown in figure 2.10.
The actual shape of the drawing depends on the frame -- all
four images in figure 2.10 are produced by the same wave painter, but with respect to four different frames.  Painters
can be more elaborate than this:
The primitive
painter called rogers paints a picture of MIT's founder,
William Barton Rogers, as shown in figure 2.11.<sup>23</sup>
The four images in figure 2.11
are drawn with respect to the same four frames
as the wave images in figure 2.10.</p>

<p>


To combine images,
we use various operations that construct new painters
from given painters.
For example, the beside operation takes two painters and produces a new,
compound painter that draws the first painter's image in the left half
of the frame and the second painter's image in the right half of the frame.
Similarly, below takes two painters and produces a compound
painter that draws the first painter's image below the second
painter's image.
Some operations transform a single painter to produce
a new painter.  For example, flip-vert takes a painter and
produces a painter that draws its image upside-down, and
flip-horiz produces a painter that draws the original
painter's image left-to-right reversed.</p><empty-line /><p><image xlink:href="#_76.jpg" />
          
<image xlink:href="#_77.jpg" /></p>

<p><image xlink:href="#_78.jpg" />
          
<image xlink:href="#_79.jpg" /></p>

<p><strong>Figure 2.10:</strong>  Images produced by the wave painter, with respect
to four different frames.  The frames, shown with dotted lines, are not
part of the images.</p><empty-line /><p><image xlink:href="#_80.jpg" />
          
<image xlink:href="#_81.jpg" /></p>

<p><image xlink:href="#_82.jpg" />
          
<image xlink:href="#_83.jpg" /></p>

<p><strong>Figure 2.11:</strong>  Images of William Barton Rogers, founder and first
president of MIT, painted with respect to the same four frames as in
figure 2.10 (original image reprinted with the permission
of the MIT Museum).</p>

<p>


Figure 2.12 shows the drawing of a painter called
wave4 that is built up in two stages starting from wave:</p>

<p>(define wave2 (beside wave (flip-vert wave)))</p><empty-line /><p>
(define wave4 (below wave2 wave2))</p><empty-line /><empty-line /><p><image xlink:href="#_84.jpg" />
          
<image xlink:href="#_85.jpg" /></p>

<p>(define wave2                         (define wave4</p><empty-line /><p>
  (beside wave (flip-vert wave)))       (below wave2 wave2))</p><empty-line /><empty-line /><p><strong>Figure 2.12:</strong>  Creating a complex figure,
starting from the wave painter of figure 2.10.</p>

<p>

In building up a complex image in this manner we are exploiting the
fact that painters are closed under the language's means of
combination.  The beside or below of two painters is
itself a painter; therefore, we can use it as an element in making
more complex painters.  As with building up list structure using cons, the closure of our data under the means of combination is
crucial to the ability to create complex structures while using only a
few operations.</p>

<p>


Once we can combine painters, we would like to be able to abstract
typical patterns of combining painters.
We will implement the painter operations as Scheme procedures.
This means that we don't need a special abstraction mechanism
in the picture language:
Since the means of combination
are ordinary Scheme procedures, we automatically have the capability
to do anything with painter operations that we can do with
procedures.
For example, we can abstract the pattern in wave4 as</p>

<p>(define (flipped-pairs painter)</p><empty-line /><p>
  (let ((painter2 (beside painter (flip-vert painter))))</p><empty-line /><p>
    (below painter2 painter2)))</p><empty-line /><p>
and define wave4 as an instance of this pattern:</p>

<p>(define wave4 (flipped-pairs wave))</p><empty-line /><empty-line /><p>

We can also define recursive operations.
Here's one that makes painters split and branch
towards the right as shown in figures 2.13
and  2.14:</p>

<p>(define (right-split painter n)</p><empty-line /><p>
  (if (= n 0)</p><empty-line /><p>
      painter</p><empty-line /><p>
      (let ((smaller (right-split painter (- n 1))))</p><empty-line /><p>
        (beside painter (below smaller smaller)))))</p><empty-line /><empty-line /><p><image xlink:href="#_86.jpg" />
                   
<image xlink:href="#_87.jpg" /></p>

<p>     right-split <emphasis>n</emphasis>                   corner-split <emphasis>n</emphasis></p><empty-line /><empty-line /><p><strong>Figure 2.13:</strong>  Recursive plans for right-split and corner-split.</p>

<p>

We can produce balanced patterns by branching upwards
as well as towards the right (see exercise 2.44
and figures 2.13 and  2.14):</p>

<p>(define (corner-split painter n)</p><empty-line /><p>
  (if (= n 0)</p><empty-line /><p>
      painter</p><empty-line /><p>
      (let ((up (up-split painter (- n 1)))</p><empty-line /><p>
            (right (right-split painter (- n 1))))</p><empty-line /><p>
        (let ((top-left (beside up up))</p><empty-line /><p>
              (bottom-right (below right right))</p><empty-line /><p>
              (corner (corner-split painter (- n 1))))</p><empty-line /><p>
          (beside (below painter top-left)</p><empty-line /><p>
                  (below bottom-right corner))))))</p><empty-line /><empty-line /><p><image xlink:href="#_88.jpg" />
          
<image xlink:href="#_89.jpg" /></p>

<p>     (right-split wave 4)         (right-split rogers 4)</p><empty-line /><empty-line /><p><image xlink:href="#_90.jpg" />
          
<image xlink:href="#_91.jpg" /></p>

<p>    (corner-split wave 4)         (corner-split rogers 4)</p><empty-line /><empty-line /><p><strong>Figure 2.14:</strong>  The recursive operations right-split and corner-split applied to the painters wave and rogers.
Combining four corner-split figures produces
symmetric square-limit designs as shown
in figure 2.9.</p>

<p>

By placing four copies of a corner-split
appropriately, we obtain a pattern called square-limit, whose
application to wave and rogers is shown in
figure 2.9:</p>

<p>(define (square-limit painter n)</p><empty-line /><p>
  (let ((quarter (corner-split painter n)))</p><empty-line /><p>
    (let ((half (beside (flip-horiz quarter) quarter)))</p><empty-line /><p>
      (below (flip-vert half) half))))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.44.</strong>  Define the procedure up-split used by corner-split.
It is similar to right-split, except that it switches the
roles of below and beside.</p>

<p><strong>Higher-order operations</strong></p>

<p>


In addition to abstracting patterns of combining painters, we can work
at a higher level, abstracting patterns of combining painter operations.
That is, we can view the painter operations as elements to manipulate
and can write means of combination for these elements -- procedures that
take painter operations as arguments and create new painter operations.</p>

<p>

For example, flipped-pairs and square-limit each
arrange four copies of a painter's image in a square pattern; they differ
only in how they orient the copies.
One way to abstract this pattern of painter combination is with
the following procedure, which takes four one-argument painter operations
and produces a painter operation that transforms a given
painter with those four operations and arranges the results in a square.
Tl, tr, bl, and br are the
transformations to apply to the top left copy, the top right copy,
the bottom left copy, and the bottom right copy, respectively.</p>

<p>(define (square-of-four tl tr bl br)</p><empty-line /><p>
  (lambda (painter)</p><empty-line /><p>
    (let ((top (beside (tl painter) (tr painter)))</p><empty-line /><p>
          (bottom (beside (bl painter) (br painter))))</p><empty-line /><p>
      (below bottom top))))</p><empty-line /><p>
Then flipped-pairs can be defined in terms
of square-of-four as follows:<sup>24</sup></p>

<p>(define (flipped-pairs painter)</p><empty-line /><p>
  (let ((combine4 (square-of-four identity flip-vert</p><empty-line /><p>
                                  identity flip-vert)))</p><empty-line /><p>
    (combine4 painter)))</p><empty-line /><p>
and square-limit can be expressed as<sup>25</sup></p>

<p>(define (square-limit painter n)</p><empty-line /><p>
  (let ((combine4 (square-of-four flip-horiz identity</p><empty-line /><p>
                                  rotate180 flip-vert)))</p><empty-line /><p>
    (combine4 (corner-split painter n))))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.45.</strong>  Right-split and up-split can be expressed as
instances of a general splitting operation.
Define a procedure split with the property that evaluating</p>

<p>(define right-split (split beside below))</p><empty-line /><p>
(define up-split (split below beside))</p><empty-line /><p>
produces procedures right-split and up-split with the same
behaviors as the ones already defined.</p>

<p><strong>Frames</strong></p>

<p>


Before we can show how to implement painters and their
means of combination, we must first consider
frames.  A frame can be described by three vectors -- an origin vector
and two edge vectors.  The origin vector specifies the offset of the
frame's origin from some absolute origin in the plane, and the edge
vectors specify the offsets of the frame's corners from its origin.
If the edges are perpendicular, the frame will be rectangular.
Otherwise the frame will be a more general parallelogram.</p>

<p>

Figure 2.15 shows a frame and its associated vectors.  In
accordance with data abstraction, we need not be
specific yet about how frames are represented, other than to say that
there is a constructor make-frame, which takes three vectors and
produces a frame, and three corresponding selectors origin-frame, edge1-frame, and edge2-frame (see
exercise 2.47).</p>

<p><image xlink:href="#_92.jpg" /></p>

<p><strong>Figure 2.15:</strong>  A frame is described by three vectors -- an
origin and two edges.</p>

<p>

We will use coordinates in the unit square (0&lt; <emphasis>x</emphasis>,<emphasis>y</emphasis>&lt; 1)
to specify images.
With each frame, we associate a <emphasis>frame coordinate map</emphasis>, which
will be used to shift and scale images to fit the frame.  The map
transforms the unit square into the frame by
mapping the vector <strong><emphasis>v</emphasis></strong> = (<emphasis>x</emphasis>,<emphasis>y</emphasis>) to the vector sum</p>

<p><image xlink:href="#_93.jpg" /></p>

<p>
For example, (0,0) is mapped to the origin of the frame, (1,1) to
the vertex diagonally opposite the origin, and (0.5,0.5) to the
center of the frame.  We can create a frame's coordinate map with the
following procedure:<sup>26</sup></p>

<p>(define (frame-coord-map frame)</p><empty-line /><p>
  (lambda (v)</p><empty-line /><p>
    (add-vect</p><empty-line /><p>
     (origin-frame frame)</p><empty-line /><p>
     (add-vect (scale-vect (xcor-vect v)</p><empty-line /><p>
                           (edge1-frame frame))</p><empty-line /><p>
               (scale-vect (ycor-vect v)</p><empty-line /><p>
                           (edge2-frame frame))))))</p><empty-line /><p>
Observe that applying frame-coord-map to a frame returns
a procedure that, given a vector, returns a vector.
If the argument vector is in the unit square, the result vector
will be in the frame.  For example,</p>

<p>((frame-coord-map a-frame) (make-vect 0 0))</p><empty-line /><p>
returns the same vector as</p>

<p>(origin-frame a-frame)</p><empty-line /><empty-line /><p>
<strong>Exercise 2.46.</strong>  A two-dimensional vector <strong>v</strong> running from the origin to a point
can be represented as a pair
consisting of an <emphasis>x</emphasis>-coordinate and a <emphasis>y</emphasis>-coordinate.  Implement a data
abstraction for vectors by giving a constructor make-vect and
corresponding selectors xcor-vect and ycor-vect.  In
terms of your selectors and constructor, implement procedures add-vect, sub-vect, and scale-vect that perform
the operations vector addition, vector subtraction, and multiplying a
vector by a scalar:</p>

<p><image xlink:href="#_94.jpg" /></p><empty-line /><p>
<strong>Exercise 2.47.</strong>  Here are two possible constructors for frames:</p>

<p>(define (make-frame origin edge1 edge2)</p><empty-line /><p>
  (list origin edge1 edge2))</p><empty-line /><empty-line /><p>
(define (make-frame origin edge1 edge2)</p><empty-line /><p>
  (cons origin (cons edge1 edge2)))</p><empty-line /><p>
For each constructor supply the appropriate selectors to produce an
implementation for frames.</p>

<p><strong>Painters</strong></p>

<p>


A painter is represented as a procedure that, given a frame
as argument, draws a particular image shifted and scaled to fit the frame.
That is to say, if p is a painter and f is a frame, then we
produce p's image in f by calling p with f as
argument.</p>

<p>

The details of how primitive painters are implemented depend on the
particular characteristics of the graphics system and the type of
image to be drawn.  For instance, suppose we have a procedure draw-line that draws a line on the screen between two specified
points.  Then we can create painters for line drawings, such as the
wave painter in figure 2.10, from lists of line
segments as follows:<sup>27</sup></p>

<p>(define (segments-&gt;painter segment-list)</p><empty-line /><p>
  (lambda (frame)</p><empty-line /><p>
    (for-each</p><empty-line /><p>
     (lambda (segment)</p><empty-line /><p>
       (draw-line</p><empty-line /><p>
        ((frame-coord-map frame) (start-segment segment))</p><empty-line /><p>
        ((frame-coord-map frame) (end-segment segment))))</p><empty-line /><p>
     segment-list)))</p><empty-line /><p>
The segments are given using coordinates with respect to the unit
square.  For each segment in the list, the painter transforms the
segment endpoints with the frame coordinate map and draws a line
between the transformed points.</p>

<p>

Representing painters as procedures erects a powerful abstraction
barrier in the picture language.  We can create and intermix
all sorts of primitive painters, based on a variety of graphics
capabilities. The details of their implementation do not matter.  Any
procedure can serve as a painter, provided that it takes a frame as
argument and draws something scaled to fit the frame.<sup>28</sup></p>

<p>
<strong>Exercise 2.48.</strong>  A directed line segment in the
plane can be represented as a pair of vectors -- the
vector running from the origin to the start-point of the segment, and
the vector running from the origin to the end-point of the segment.
Use your vector representation from exercise 2.46 to
define a representation for segments with a constructor make-segment and selectors start-segment and end-segment.</p>

<p>
<strong>Exercise 2.49.</strong>  Use segments-&gt;painter to define the following primitive painters:</p>

<p>

a.  The painter that draws the outline of the designated frame.</p>

<p>

b.  The painter that draws an "X" by connecting opposite corners of
the frame.</p>

<p>

c.  The painter that draws a diamond shape by connecting the midpoints of
the sides of the frame.</p>

<p>

d.  The wave painter.</p>

<p><strong>Transforming and combining painters</strong></p>

<p>


An operation on painters (such as flip-vert or beside)
works by creating a painter that invokes the original painters
with respect to frames derived from the argument frame.
Thus, for example, flip-vert doesn't have to know how a painter
works in order to flip it -- it just has to know how to turn a frame
upside down:
The flipped painter just uses the original painter,
but in the inverted frame.</p>

<p>

Painter operations are based on
the procedure transform-painter, which takes as arguments a painter and
information on how to transform a frame and
produces a new painter.  The transformed painter, when called on a frame,
transforms the frame and
calls the original painter on the transformed frame.
The arguments to transform-painter are points (represented as vectors)
that specify the corners of the new frame:
When mapped into
the frame, the first point specifies the new frame's origin
and the other two specify the ends of its edge vectors.
Thus, arguments within the
unit square specify a frame contained within the original frame.</p>

<p>(define (transform-painter painter origin corner1 corner2)</p><empty-line /><p>
  (lambda (frame)</p><empty-line /><p>
    (let ((m (frame-coord-map frame)))</p><empty-line /><p>
      (let ((new-origin (m origin)))</p><empty-line /><p>
        (painter</p><empty-line /><p>
         (make-frame new-origin</p><empty-line /><p>
                     (sub-vect (m corner1) new-origin)</p><empty-line /><p>
                     (sub-vect (m corner2) new-origin)))))))</p><empty-line /><empty-line /><p>

Here's how to flip painter images vertically:</p>

<p>(define (flip-vert painter)</p><empty-line /><p>
  (transform-painter painter</p><empty-line /><p>
                     (make-vect 0.0 1.0)   <emphasis>; new origin</emphasis></p><empty-line /><p>
                     (make-vect 1.0 1.0)   <emphasis>; new end of edge1</emphasis></p><empty-line /><p>
                     (make-vect 0.0 0.0))) <emphasis>; new end of edge2</emphasis></p><empty-line /><p>
Using transform-painter, we can easily define new transformations.
For example, we can define a painter that shrinks its image to the
upper-right quarter of the frame it is given:</p>

<p>(define (shrink-to-upper-right painter)</p><empty-line /><p>
  (transform-painter painter</p><empty-line /><p>
                     (make-vect 0.5 0.5)</p><empty-line /><p>
                     (make-vect 1.0 0.5)</p><empty-line /><p>
                     (make-vect 0.5 1.0)))</p><empty-line /><p>
Other transformations rotate images counterclockwise by 90 degrees<sup>29</sup></p>

<p>(define (rotate90 painter)</p><empty-line /><p>
  (transform-painter painter</p><empty-line /><p>
                     (make-vect 1.0 0.0)</p><empty-line /><p>
                     (make-vect 1.0 1.0)</p><empty-line /><p>
                     (make-vect 0.0 0.0)))</p><empty-line /><p>
or squash images towards the center of the frame:<sup>30</sup></p>

<p>(define (squash-inwards painter)</p><empty-line /><p>
  (transform-painter painter</p><empty-line /><p>
                     (make-vect 0.0 0.0)</p><empty-line /><p>
                     (make-vect 0.65 0.35)</p><empty-line /><p>
                     (make-vect 0.35 0.65)))</p><empty-line /><empty-line /><p>

Frame transformation is also the key to
defining means of combining two or more painters.
The beside procedure,
for example, takes two painters, transforms them
to paint in the left and right halves of an argument frame respectively,
and produces a new, compound painter.
When the compound painter is given a frame, it
calls the first transformed painter to paint in the left half of
the frame and calls the second transformed painter to paint in the
right half of the frame:</p>

<p>(define (beside painter1 painter2)</p><empty-line /><p>
  (let ((split-point (make-vect 0.5 0.0)))</p><empty-line /><p>
    (let ((paint-left</p><empty-line /><p>
           (transform-painter painter1</p><empty-line /><p>
                              (make-vect 0.0 0.0)</p><empty-line /><p>
                              split-point</p><empty-line /><p>
                              (make-vect 0.0 1.0)))</p><empty-line /><p>
          (paint-right</p><empty-line /><p>
           (transform-painter painter2</p><empty-line /><p>
                              split-point</p><empty-line /><p>
                              (make-vect 1.0 0.0)</p><empty-line /><p>
                              (make-vect 0.5 1.0))))</p><empty-line /><p>
      (lambda (frame)</p><empty-line /><p>
        (paint-left frame)</p><empty-line /><p>
        (paint-right frame)))))</p><empty-line /><empty-line /><p>

Observe how the painter data abstraction, and in particular the
representation of painters as procedures, makes beside easy to
implement.  The beside procedure need not know anything
about the details of the component painters other than that each
painter will draw something in its designated frame.</p>

<p>
<strong>Exercise 2.50.</strong>  Define the transformation flip-horiz, which flips
painters horizontally, and transformations that rotate
painters counterclockwise by 180 degrees and 270 degrees.</p>

<p>
<strong>Exercise 2.51.</strong>  Define the below operation for painters.  Below takes two
painters as arguments.  The resulting painter, given a frame,
draws with the first painter in the
bottom of the frame and with the second painter in the top.  Define below in two different ways -- first by writing a procedure that is
analogous to the beside procedure given above, and
again in terms of beside and suitable
rotation operations (from exercise 2.50).</p>

<p><strong>Levels of language for robust design</strong></p>

<p>

The picture language exercises some of the critical ideas
we've introduced about abstraction with procedures and data.  The
fundamental data abstractions, painters, are implemented using
procedural representations, which enables the language to
handle different basic drawing capabilities in a uniform way.  The
means of combination satisfy the closure property, which permits us to
easily build up complex designs.  Finally, all the tools for
abstracting procedures are available to us for abstracting means of
combination for painters.</p>

<p>


We have also obtained a glimpse of another crucial idea about
languages and program design.  This is the approach of <emphasis>stratified
design</emphasis>, the notion that a complex system should be structured as a
sequence of levels that are described using a sequence of languages.
Each level is constructed by combining parts that are regarded as
primitive at that level, and the parts constructed at each level are
used as primitives at the next level.  The language used at each level
of a stratified design has primitives, means of combination, and means
of abstraction appropriate to that level of detail.</p>

<p>

Stratified design pervades the engineering of complex systems.  For
example, in computer engineering, resistors and transistors are
combined (and described using a language of analog circuits) to
produce parts such as and-gates and or-gates, which form the
primitives of a language for digital-circuit design.<sup>31</sup>
These parts are combined to build
processors, bus structures, and memory systems, which are in turn
combined to form computers, using languages appropriate to computer
architecture.  Computers are combined to form distributed systems,
using languages appropriate for describing network interconnections,
and so on.</p>

<p>

As a tiny example of stratification, our picture language uses
primitive elements (primitive painters) that are created using a
language that specifies points and lines to provide the lists of line
segments for segments-&gt;painter, or the
shading details for a painter like rogers.  The bulk of our
description of the picture language focused on combining these
primitives, using geometric combiners such as beside and below.  We also worked at a higher level, regarding beside and
below as primitives to be manipulated in a language whose
operations, such as square-of-four, capture common patterns of
combining geometric combiners.</p>

<p>

Stratified design helps make programs <emphasis>robust</emphasis>, that is, it makes
it likely that small changes in a specification will require
correspondingly small changes in the program.  For instance, suppose
we wanted to change the image based on wave shown in
figure 2.9.  We could work at the lowest level
to change the detailed appearance of the wave element; we could
work at the middle level to change the way corner-split
replicates the wave; we could work at the highest level to
change how square-limit arranges the four copies of the corner.
In general, each level of a stratified design provides a different
vocabulary for expressing the characteristics of the system, and a
different kind of ability to change it.</p>

<p>
<strong>Exercise 2.52.</strong>  Make changes to the square limit of wave shown in
figure 2.9 by working at each of the levels
described above.  In particular:</p>

<p>

a.  Add some segments to the primitive wave painter
of exercise  2.49 (to add a smile, for example).</p>

<p>

b.  Change the pattern constructed by corner-split
(for example, by using only one copy of the
up-split and right-split images instead of two).</p>

<p>

c.  Modify the version of square-limit that uses square-of-four
so as to assemble the corners in a different pattern.  (For example, you
might make the big Mr. Rogers look outward from each corner of the square.)</p><empty-line /><empty-line /><empty-line /><p><sup>6</sup> The use of the word "closure" here comes from abstract algebra,
where a set of elements is said to be closed under an operation if
applying the operation to elements in the set produces an element that
is again an element of the set.  The Lisp community
also (unfortunately) uses the word "closure" to describe a totally unrelated
concept: A closure is an implementation technique for representing
procedures with free variables.  We do not use the word "closure" in
this second sense in this book.</p>

<p><sup>7</sup> The notion that a means of
combination should satisfy closure is a straightforward idea.
Unfortunately, the data combiners provided in many popular programming
languages do not satisfy closure, or make closure cumbersome to
exploit.  In Fortran or Basic, one typically combines data elements by
assembling them into arrays -- but one cannot form arrays whose
elements are themselves arrays.  Pascal and C admit structures whose
elements are structures.  However, this requires that the programmer
manipulate pointers explicitly, and adhere to the restriction that
each field of a structure can contain only elements of a prespecified form.
Unlike
Lisp with its pairs, these languages have no built-in general-purpose
glue that makes it easy to manipulate compound data in a uniform way.
This limitation lies behind Alan Perlis's comment in his foreword to
this book: "In Pascal the plethora of declarable data structures
induces a specialization within functions that inhibits and penalizes
casual cooperation.  It is better to have 100 functions operate on one
data structure than to have 10 functions operate on 10 data
structures."</p>

<p><sup>8</sup> In this book, we use <emphasis>list</emphasis> to mean a chain of
pairs terminated by the end-of-list marker.  In contrast, the term
<emphasis>list structure</emphasis> refers to any data structure made out of pairs,
not just to lists.</p>

<p><sup>9</sup> Since nested applications of car and cdr
are cumbersome to write, Lisp dialects provide abbreviations for
them -- for instance,</p>

<p><image xlink:href="#_95.jpg" /></p>

<p>
The names of all such procedures start with c and end with r.  Each a between them stands for a car operation and
each d for a cdr operation, to be applied in the same order
in which they appear in the name.  The names car and cdr
persist because simple combinations like cadr are
pronounceable.</p>

<p><sup>10</sup> It's remarkable how much energy in the
standardization of Lisp dialects has been dissipated in arguments that
are literally over nothing: Should nil be an ordinary name?
Should the value of nil be a symbol?  Should it be a list?
Should it be a pair?  In Scheme, nil is an ordinary name,
which we use in this section as a variable whose value is
the end-of-list marker (just as true is an ordinary variable
that has a true value).  Other dialects of
Lisp, including Common Lisp, treat nil as a special symbol.  The
authors of this book, who have endured too many language
standardization brawls, would like to avoid the entire issue.  Once we
have introduced quotation in section 2.3, we will
denote the empty list as '() and dispense with the
variable nil entirely.</p>

<p><sup>11</sup> To define f and g using
lambda we would write</p>

<p>(define f (lambda (x y . z) &lt;<emphasis>body</emphasis>&gt;))</p><empty-line /><p>
(define g (lambda w &lt;<emphasis>body</emphasis>&gt;))</p><empty-line /><empty-line /><p><sup>12</sup> Scheme
standardly provides a map procedure that is more general
than the one described here.
This more general map
takes a procedure of <emphasis>n</emphasis> arguments, together with <emphasis>n</emphasis> lists, and
applies the procedure to all the first elements of
the lists, all the second elements of the lists, and so on,
returning a list of the results.  For example:</p>

<p>(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))</p><empty-line /><p><emphasis>(741 852 963)</emphasis></p><empty-line /><empty-line /><p>
(map (lambda (x y) (+ x (* 2 y)))</p><empty-line /><p>
     (list 1 2 3)</p><empty-line /><p>
     (list 4 5 6))</p><empty-line /><p><emphasis>(9 12 15)</emphasis></p><empty-line /><empty-line /><p><sup>13</sup> The order of the
first two clauses in the cond matters, since the empty list
satisfies null? and also is not a pair.</p>

<p><sup>14</sup> This is, in fact, precisely the fringe procedure from
exercise 2.28.  Here we've renamed it to emphasize that
it is part of a family of general sequence-manipulation procedures.</p>

<p><sup>15</sup> Richard Waters (1979)
developed a program that automatically analyzes traditional Fortran
programs, viewing them in terms of maps, filters, and accumulations.
He found that fully 90 percent of the code in the Fortran Scientific
Subroutine Package fits neatly into this paradigm.  One of the reasons
for the success of Lisp as a programming language is that lists
provide a standard medium for expressing ordered collections so that
they can be manipulated using higher-order operations.  The
programming language APL owes much of its power and appeal to a
similar choice. In APL all data are represented as arrays, and there is a
universal and convenient set of generic operators for all sorts of
array operations.</p>

<p><sup>16</sup> According to Knuth (1981), this rule was formulated by
W. G. Horner early in the nineteenth century, but the method was
actually used by Newton over a hundred years earlier.  Horner's rule
evaluates the polynomial using fewer additions and multiplications
than does the straightforward method of first computing <emphasis>a</emphasis><sub><emphasis>n</emphasis></sub><emphasis>x</emphasis><sup><emphasis>n</emphasis></sup>,
then adding <emphasis>a</emphasis><sub><emphasis>n</emphasis>-1</sub><emphasis>x</emphasis><sup><emphasis>n</emphasis>-1</sup>, and so on.  In fact, it is possible to
prove that any algorithm for evaluating arbitrary polynomials must use
at least as many additions and multiplications as does Horner's rule,
and thus Horner's rule is an optimal algorithm for polynomial
evaluation.  This was proved (for the number of additions) by
A. M. Ostrowski in a 1954 paper that essentially founded the modern
study of optimal algorithms.  The analogous statement for
multiplications was proved by V. Y. Pan in 1966.  The book by Borodin
and Munro (1975) provides an overview of these and other results about
optimal algorithms.</p>

<p><sup>17</sup> This definition uses the
extended version of map described in footnote 12.</p>

<p><sup>18</sup> This approach to nested mappings was shown
to us by David Turner, whose languages KRC and Miranda provide elegant
formalisms for dealing with these constructs.  The examples in this
section (see also exercise 2.42) are adapted from Turner
1981.  In section 3.5.3, we'll see how this
approach generalizes to infinite sequences.</p>

<p><sup>19</sup> We're
representing a pair here as a list of two elements rather than as a
Lisp pair.  Thus, the "pair" (<emphasis>i</emphasis>,<emphasis>j</emphasis>) is represented as (list i
j), not (cons i j).</p>

<p><sup>20</sup> The set <emphasis>S</emphasis> - <emphasis>x</emphasis> is the set of all elements
of <emphasis>S</emphasis>, excluding <emphasis>x</emphasis>.</p>

<p><sup>21</sup> Semicolons in Scheme code are used to
introduce <emphasis>comments</emphasis>.  Everything from the semicolon to the end of
the line is ignored by the interpreter.  In this book we don't use
many comments; we try to make our programs self-documenting by using
descriptive names.</p>

<p><sup>22</sup> The picture language is based on the language
Peter Henderson created to construct
images like M.C. Escher's "Square Limit" woodcut (see Henderson 1982).
The woodcut incorporates a
repeated scaled pattern, similar to the arrangements drawn using
the square-limit procedure in this section.</p>

<p><sup>23</sup> William Barton Rogers (1804-1882) was the founder and first president
of MIT.  A geologist and talented teacher, he taught at William and
Mary College and at the University of Virginia.  In 1859 he moved to
Boston, where he had more time for research, worked on a plan
for establishing a "polytechnic institute", and served as
Massachusetts's first State Inspector of Gas Meters.</p>

<p>

When MIT was established in 1861, Rogers was elected its first
president.  Rogers espoused an ideal of "useful learning" that was
different from the university education of the time, with its
overemphasis on the classics, which, as he wrote, "stand in the way of
the broader, higher and more practical instruction and discipline of
the natural and social sciences."  This education was likewise to be
different from narrow trade-school education.  In Rogers's words:</p>

<p>The world-enforced distinction between the practical and the
scientific worker is utterly futile, and the whole experience of
modern times has demonstrated its utter worthlessness.</p>

<p>

Rogers served as president of MIT until 1870, when he resigned due to
ill health.  In 1878 the second president of MIT, John Runkle,
resigned under the pressure of a financial crisis brought on by the
Panic of 1873 and strain of fighting off attempts by Harvard to take
over MIT.  Rogers returned to hold the office of president until
1881.</p>

<p>

Rogers collapsed and died while addressing MIT's graduating class at
the commencement exercises of 1882.  Runkle quoted Rogers's last
words in a memorial address delivered that same year:</p>

<p>"As I stand here today and see what the Institute is, ... I call
to mind the beginnings of science.  I remember one hundred and fifty
years ago Stephen Hales published a pamphlet on the subject of
illuminating gas, in which he stated that his researches had
demonstrated that 128 grains of bituminous coal -- "</p>

<p>"Bituminous coal", these were his last words on earth.  Here he bent
forward, as if consulting some notes on the table before him, then
slowly regaining an erect position, threw up his hands, and was
translated from the scene of his earthly labors and triumphs to "the
tomorrow of death", where the mysteries of life are solved, and the
disembodied spirit finds unending satisfaction in contemplating the
new and still unfathomable mysteries of the infinite future.

In the words of  Francis A. Walker
(MIT's third president):</p>

<p>All his life he had borne himself most faithfully and heroically, and
he died as so good a knight would surely have wished, in harness, at
his post, and in the very part and act of public duty.</p>

<p><sup>24</sup> Equivalently, we could
write</p>

<p>(define flipped-pairs</p><empty-line /><p>
  (square-of-four identity flip-vert identity flip-vert))</p><empty-line /><empty-line /><p><sup>25</sup> Rotate180
rotates a painter by 180 degrees (see exercise 2.50).
Instead of rotate180 we could say (compose flip-vert flip-horiz), using
the compose procedure from exercise 1.42.</p>

<p><sup>26</sup> Frame-coord-map uses
the vector operations described in exercise 2.46 below, which we
assume have been implemented using some representation for vectors.
Because of data abstraction, it doesn't matter what this vector
representation is, so long as the vector operations behave correctly.</p>

<p><sup>27</sup> Segments-&gt;painter uses the representation for line
segments described in exercise 2.48 below.
It also uses the for-each procedure described in exercise 2.23.</p>

<p><sup>28</sup> For example, the rogers painter of
figure 2.11 was constructed from a gray-level image.
For each point in a given frame,
the rogers painter determines the point in the image that is mapped to it
under the frame coordinate map, and shades it
accordingly.  By allowing different types of painters, we are capitalizing on the
abstract data idea discussed in section 2.1.3, where we
argued that a rational-number representation could be anything at all that
satisfies an appropriate condition.  Here we're using the fact that a
painter can be implemented in any way at all, so long as it draws
something in the designated frame.  Section 2.1.3 also
showed how pairs could be implemented as procedures.  Painters are our
second example of a procedural representation for data.</p>

<p><sup>29</sup> Rotate90 is a pure rotation only for square
frames, because it also stretches and shrinks the image to fit into
the rotated frame.</p>

<p><sup>30</sup> The diamond-shaped images in figures 2.10
and 2.11 were created with squash-inwards applied to
wave and rogers.</p>

<p><sup>31</sup> Section 3.3.4 describes one such language.</p>


</section>

<section>


<p><strong>2.3  Symbolic Data</strong></p>

<p>



All the compound data objects we have used so far were constructed
ultimately from numbers.  In this section we extend the representational
capability of our language by introducing the ability to work with
arbitrary symbols as data.</p>

<p><strong>2.3.1  Quotation</strong></p>

<p>



If we can form compound data using symbols, we can have lists such as</p>

<p>(a b c d)</p><empty-line /><p>
(23 45 17)</p><empty-line /><p>
((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))</p><empty-line /><p>
Lists containing symbols can look just like the expressions of our
language:</p>

<p>(* (+ 23 45) (+ x 9))</p><empty-line /><empty-line /><p>
(define (fact n) (if (= n 1) 1 (* n (fact (- n 1)))))</p><empty-line /><empty-line /><p>

In order to manipulate symbols we need a new element in our language:
the ability to <emphasis>quote</emphasis> a data object.  Suppose we want to
construct the list (a b).  We can't accomplish this with (list a b), because this expression constructs
a list of the <emphasis>values</emphasis> of a and b rather than
the symbols themselves.  This issue is well known in the context of
natural languages, where words and sentences may be regarded either as
semantic entities or as character strings (syntactic entities).  The
common practice in natural languages is to use quotation marks to
indicate that a word or a sentence is to be treated literally as a
string of characters.  For instance, the first letter of "John" is
clearly "J."  If we tell somebody "say your name aloud", we expect
to hear that person's name.  However, if we tell somebody "say `your
name' aloud", we expect to hear the words "your name."  Note that
we are forced to nest quotation marks to describe what somebody else
might say.<sup>32</sup></p>

<p>

We can follow this same practice to identify lists and symbols that are
to be treated as data objects rather than as expressions to be
evaluated.  However, our format for quoting differs from that of
natural languages in that we place a quotation mark (traditionally,
the single quote symbol ') only at the beginning of the object
to be quoted.  We can get away with this in Scheme syntax because we
rely on blanks and parentheses to delimit objects.  Thus, the meaning
of the single quote character is to quote the next object.<sup>33</sup></p>

<p>

Now we can distinguish between symbols and their values:</p>

<p>(define a 1)</p><empty-line /><empty-line /><p>
(define b 2)</p><empty-line /><empty-line /><p>
(list a b)</p><empty-line /><p><emphasis>(1 2)</emphasis></p><empty-line /><empty-line /><p>
(list 'a 'b)</p><empty-line /><p><emphasis>(a b)</emphasis></p><empty-line /><empty-line /><p>
(list 'a b)</p><empty-line /><p><emphasis>(a 2)</emphasis></p><empty-line /><empty-line /><p>

Quotation also allows us to type in compound objects, using the
conventional printed representation for lists:<sup>34</sup></p>

<p>(car '(a b c))</p><empty-line /><p><emphasis>a</emphasis></p><empty-line /><empty-line /><p>
(cdr '(a b c))</p><empty-line /><p><emphasis>(b c)</emphasis></p><empty-line /><p>
In keeping with this, we can obtain the empty list by evaluating '(), and thus dispense with the variable nil.</p>

<p>

One additional primitive used in manipulating symbols is eq?,
which takes two symbols as arguments and tests whether they are the
same.<sup>35</sup> Using eq?,
we can implement a useful procedure called memq.  This takes two
arguments, a symbol and a list.  If the symbol is not contained in the
list (i.e., is not eq? to any item in the list), then memq returns false.  Otherwise, it returns the sublist of
the list beginning with the first occurrence of the symbol:</p>

<p>(define (memq item x)</p><empty-line /><p>
  (cond ((null? x) false)</p><empty-line /><p>
        ((eq? item (car x)) x)</p><empty-line /><p>
        (else (memq item (cdr x)))))</p><empty-line /><p>
For example, the value of</p>

<p>(memq 'apple '(pear banana prune))</p><empty-line /><p>
is false, whereas the value of</p>

<p>(memq 'apple '(x (apple sauce) y apple pear))</p><empty-line /><p>
is (apple pear).</p>

<p>
<strong>Exercise 2.53.</strong>  What would the interpreter print in response to evaluating each of the
following expressions?</p>

<p>(list 'a 'b 'c)</p><empty-line /><empty-line /><p>
(list (list 'george))</p><empty-line /><p>
(cdr '((x1 x2) (y1 y2)))</p><empty-line /><empty-line /><p>
(cadr '((x1 x2) (y1 y2)))</p><empty-line /><p>
(pair? (car '(a short list)))</p><empty-line /><p>
(memq 'red '((red shoes) (blue socks)))</p><empty-line /><empty-line /><p>
(memq 'red '(red shoes blue socks))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.54.</strong>  Two lists are said to be equal? if they contain equal elements
arranged in the same order.  For example,</p>

<p>(equal? '(this is a list) '(this is a list))</p><empty-line /><p>
is true, but</p>

<p>(equal? '(this is a list) '(this (is a) list))</p><empty-line /><p>
is false.  To be more precise, we can define equal?
recursively in terms of the basic eq? equality of symbols by
saying that a and b are equal? if they are both
symbols and the symbols are eq?, or if they are both lists such
that (car a) is equal? to (car b) and (cdr
a) is equal? to (cdr b).  Using this idea, implement
equal? as a procedure.<sup>36</sup></p>

<p>
<strong>Exercise 2.55.</strong>  Eva Lu Ator types to the interpreter the expression</p>

<p>(car "abracadabra)</p><empty-line /><p>
To her surprise, the interpreter prints back quote.  Explain.</p>

<p><strong>2.3.2  Example: Symbolic Differentiation</strong></p>

<p>



As an illustration of symbol manipulation and a further illustration
of data abstraction, consider the design of a procedure that performs
symbolic differentiation of algebraic expressions.  We would like the
procedure to take as arguments an algebraic expression and a variable
and to return the derivative of the expression with respect to the
variable.  For example, if the arguments to the procedure are <emphasis>a</emphasis><emphasis>x</emphasis><sup>2</sup>
 + <emphasis>b</emphasis><emphasis>x</emphasis>  + <emphasis>c</emphasis> and <emphasis>x</emphasis>, the procedure should return 2<emphasis>a</emphasis><emphasis>x</emphasis> + <emphasis>b</emphasis>.  Symbolic
differentiation is of special historical significance in Lisp.  It was
one of the motivating examples behind the development of a computer
language for symbol manipulation.  Furthermore, it marked the
beginning of the line of research that led to the development of
powerful systems for symbolic mathematical work, which are currently
being used by a growing number of applied mathematicians and
physicists.</p>

<p>

In developing the symbolic-differentiation program, we will follow the
same strategy of data abstraction that we followed in developing the
rational-number system of section 2.1.1.  That is, we will first
define a differentiation algorithm that operates on abstract
objects such as "sums", "products", and "variables" without
worrying about how these are to be represented.  Only afterward will
we address the representation problem.</p>

<p><strong>The differentiation program with abstract data</strong></p>

<p>


In order to keep things simple, we will consider a very simple
symbolic-differentiation program that handles expressions that are
built up using only the operations of addition and multiplication with
two arguments.  Differentiation of any such expression can be carried
out by applying the following reduction rules:</p>

<p><image xlink:href="#_96.jpg" /></p><empty-line /><p><image xlink:href="#_97.jpg" /></p><empty-line /><p><image xlink:href="#_98.jpg" /></p><empty-line /><p><image xlink:href="#_99.jpg" /></p>

<p>

Observe that the latter two rules are recursive in nature.  That is,
to obtain the derivative of a sum we first find the derivatives of the
terms and add them.  Each of the terms may in turn be an
expression that needs to be decomposed.  Decomposing into smaller and
smaller pieces will eventually produce pieces that are either
constants or variables, whose derivatives will be either 0 or 1.</p>

<p>

To embody these rules in a procedure we indulge in a little wishful
thinking, as we did in designing the rational-number implementation.
If we had a means for representing algebraic expressions, we should be
able to tell whether an expression is a sum, a product, a constant, or
a variable.  We should be able to extract the parts of an expression.
For a sum, for example we want to be able to extract the addend
(first term) and the augend (second term).  We should also be able to
construct expressions from parts.  Let us assume that we already have
procedures to implement the following selectors, constructors, and
predicates:</p>

<p>(variable? e)</p>

<p>Is</p>

<p>e</p>

<p> a variable?</p>

<p>(same-variable? v1 v2)</p>

<p>Are</p>

<p>v1</p>

<p> and</p>

<p>v2</p>

<p> the same variable?</p>

<p>

(sum? e)</p>

<p>Is</p>

<p>e</p>

<p> a sum?</p>

<p>(addend e)</p>

<p>Addend of the sum</p>

<p>e</p>

<p>.</p>

<p>(augend e)</p>

<p>Augend of the sum</p>

<p>e</p>

<p>.</p>

<p>(make-sum a1 a2)</p>

<p>Construct the sum of</p>

<p>a1</p>

<p> and</p>

<p>a2</p>

<p>.</p>

<p>

(product? e)</p>

<p>Is</p>

<p>e</p>

<p> a product?</p>

<p>(multiplier e)</p>

<p>Multiplier of the product</p>

<p>e</p>

<p>.</p>

<p>(multiplicand e)</p>

<p>Multiplicand of the product</p>

<p>e</p>

<p>.</p>

<p>(make-product m1 m2)</p>

<p>Construct the product of</p>

<p>m1</p>

<p> and</p>

<p>m2</p>

<p>.</p>

<p>
Using these, and the primitive predicate</p>

<p>number?</p>

<p>,</p>

<p>which identifies numbers, we can express the differentiation rules as the
following procedure:</p>

<p>(define (deriv exp var)</p><empty-line /><p>
  (cond ((number? exp) 0)</p><empty-line /><p>
        ((variable? exp)</p><empty-line /><p>
         (if (same-variable? exp var) 1 0))</p><empty-line /><p>
        ((sum? exp)</p><empty-line /><p>
         (make-sum (deriv (addend exp) var)</p><empty-line /><p>
                   (deriv (augend exp) var)))</p><empty-line /><p>
        ((product? exp)</p><empty-line /><p>
         (make-sum</p><empty-line /><p>
           (make-product (multiplier exp)</p><empty-line /><p>
                         (deriv (multiplicand exp) var))</p><empty-line /><p>
           (make-product (deriv (multiplier exp) var)</p><empty-line /><p>
                         (multiplicand exp))))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (error "unknown expression type -- DERIV" exp))))</p><empty-line /><p>
This deriv procedure incorporates the complete differentiation algorithm.
Since it is expressed in terms of abstract data, it will work no
matter how we choose to represent algebraic expressions, as long as we
design a proper set of selectors and constructors.  This is the issue
we must address next.</p>

<p><strong>Representing algebraic expressions</strong></p>

<p>


We can imagine many ways to use list structure to represent algebraic
expressions.  For example, we could use lists of symbols that mirror
the usual algebraic notation, representing <emphasis>a</emphasis><emphasis>x</emphasis> + <emphasis>b</emphasis> as the list (a
* x + b).  However, one especially straightforward choice is to use
the same parenthesized prefix notation that Lisp uses for
combinations; that is, to represent <emphasis>a</emphasis><emphasis>x</emphasis> + <emphasis>b</emphasis> as (+ (* a x) b).
Then our data representation for the differentiation problem is as
follows:</p>

<p>The variables are symbols.  They are identified by the primitive predicate
symbol?:</p>

<p>(define (variable? x) (symbol? x))</p><empty-line /><empty-line /><p>Two variables are the same if the symbols representing them are
eq?:</p>

<p>(define (same-variable? v1 v2)</p><empty-line /><p>
  (and (variable? v1) (variable? v2) (eq? v1 v2)))</p><empty-line /><empty-line /><p>Sums and products are constructed as lists:</p>

<p>(define (make-sum a1 a2) (list '+ a1 a2))</p><empty-line /><empty-line /><p>(define (make-product m1 m2) (list '* m1 m2))</p><empty-line /><empty-line /><p>A sum is a list whose first element is the symbol +:</p>

<p>(define (sum? x)</p><empty-line /><p>
  (and (pair? x) (eq? (car x) '+)))</p><empty-line /><empty-line /><p>The addend is the second item of the sum list:</p>

<p>(define (addend s) (cadr s))</p><empty-line /><empty-line /><p>The augend is the third item of the sum list:</p>

<p>(define (augend s) (caddr s))</p><empty-line /><empty-line /><p>A product is a list whose first element is the symbol *:</p>

<p>(define (product? x)</p><empty-line /><p>
  (and (pair? x) (eq? (car x) '*)))</p><empty-line /><empty-line /><p>The multiplier is the second item of the product list:</p>

<p>(define (multiplier p) (cadr p))</p><empty-line /><empty-line /><p>The multiplicand is the third item of the product list:</p>

<p>(define (multiplicand p) (caddr p))</p><empty-line /><empty-line /><p>

Thus, we need only combine these with the algorithm as embodied by
deriv in order to have a working symbolic-differentiation
program.  Let us look at some examples of its behavior:</p>

<p>(deriv '(+ x 3) 'x)</p><empty-line /><p><emphasis>(+ 1 0)</emphasis></p><empty-line /><p>
(deriv '(* x y) 'x)</p><empty-line /><p><emphasis>(+ (* x 0) (* 1 y))</emphasis></p><empty-line /><p>
(deriv '(* (* x y) (+ x 3)) 'x)</p><empty-line /><p><emphasis>(+ (* (* x y) (+ 1 0))</emphasis></p><empty-line /><p><emphasis>
   (* (+ (* x 0) (* 1 y))</emphasis></p><empty-line /><p><emphasis>
      (+  x 3)))</emphasis></p><empty-line /><p>
The program produces answers that are correct; however, they are
unsimplified.  It is true that</p>

<p><image xlink:href="#_100.jpg" /></p>

<p>

but we would like the program to know that <emphasis>x</emphasis> ·  0  =  0, 1 ·  <emphasis>y</emphasis>  = 
<emphasis>y</emphasis>, and 0 + <emphasis>y</emphasis> = <emphasis>y</emphasis>.  The answer for the second example should have been
simply y.  As the third example shows, this becomes a serious
issue when the expressions are complex.</p>

<p>

Our difficulty is much like the one we encountered with the
rational-number implementation: we haven't reduced answers to simplest
form.  To accomplish the rational-number reduction, we needed to
change only the constructors and the selectors of the implementation.
We can adopt a similar strategy here.  We won't change deriv at
all.  Instead, we will change make-sum so that if both summands
are numbers, make-sum will add them and return their sum.  Also,
if one of the summands is 0, then make-sum will return the other
summand.</p>

<p>(define (make-sum a1 a2)</p><empty-line /><p>
  (cond ((=number? a1 0) a2)</p><empty-line /><p>
        ((=number? a2 0) a1)</p><empty-line /><p>
        ((and (number? a1) (number? a2)) (+ a1 a2))</p><empty-line /><p>
        (else (list '+ a1 a2))))</p><empty-line /><p>
This uses the procedure =number?, which checks whether an
expression is equal to a given number:</p>

<p>(define (=number? exp num)</p><empty-line /><p>
  (and (number? exp) (= exp num)))</p><empty-line /><p>
Similarly, we will change make-product to build in the rules that 0
times anything is 0 and 1 times anything is the thing itself:</p>

<p>(define (make-product m1 m2)</p><empty-line /><p>
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)</p><empty-line /><p>
        ((=number? m1 1) m2)</p><empty-line /><p>
        ((=number? m2 1) m1)</p><empty-line /><p>
        ((and (number? m1) (number? m2)) (* m1 m2))</p><empty-line /><p>
        (else (list '* m1 m2))))</p><empty-line /><p>
Here is how this version works on our three examples:</p>

<p>(deriv '(+ x 3) 'x)</p><empty-line /><p><emphasis>1</emphasis></p><empty-line /><p>
(deriv '(* x y) 'x)</p><empty-line /><p><emphasis>y</emphasis></p><empty-line /><p>
(deriv '(* (* x y) (+ x 3)) 'x)</p><empty-line /><p><emphasis>(+ (* x y) (* y (+ x 3)))</emphasis></p><empty-line /><p>
Although this is quite an improvement, the third example shows that
there is still a long way to go before we get a program that puts
expressions into a form that we might agree is "simplest."  The
problem of algebraic simplification is complex because, among other
reasons, a form that may be simplest for one purpose may not be for
another.</p>

<p>
<strong>Exercise 2.56.</strong>  Show how to extend the basic differentiator to handle more kinds of
expressions.  For instance, implement the differentiation rule</p>

<p><image xlink:href="#_101.jpg" /></p>

<p>

by adding a new clause to the deriv program
and defining
appropriate procedures exponentiation?, base, exponent,
and make-exponentiation.  (You may use the symbol ** to denote
exponentiation.)
Build in the rules that anything raised to the power 0 is 1 and
anything raised to the power 1 is the thing itself.</p>

<p>
<strong>Exercise 2.57.</strong>  Extend the differentiation program to handle sums and products of
arbitrary numbers of (two or more) terms.
Then the last example above could be expressed as</p>

<p>(deriv '(* x y (+ x 3)) 'x)</p><empty-line /><p>
Try to do this by changing only the
representation for sums and products, without changing the deriv procedure at all.  For example, the addend of a sum would
be the first term, and the augend would be the sum of the rest
of the terms.</p>

<p>
<strong>Exercise 2.58.</strong>  Suppose we want to modify the differentiation program so that it works
with ordinary mathematical notation, in which + and * are
infix rather than prefix operators.  Since the differentiation program
is defined in terms of abstract data, we can modify it to work with
different representations of expressions solely by changing the
predicates, selectors, and constructors that define the representation
of the algebraic expressions on which the differentiator is to
operate.</p>

<p>a. Show how to do this in order to differentiate algebraic
expressions presented in infix form, such as (x + (3 * (x + (y + 2)))).
To simplify the task, assume that + and * always
take two arguments and that expressions are fully parenthesized.</p>

<p>b. The problem becomes substantially harder if we allow standard
algebraic notation, such as (x + 3 * (x + y + 2)), which drops
unnecessary parentheses and assumes that multiplication is done before
addition.  Can you design appropriate predicates, selectors, and
constructors for this notation such that our derivative program still
works?</p>

<p><strong>2.3.3  Example: Representing Sets</strong></p>

<p>



In the previous examples we built representations for two kinds of
compound data objects: rational numbers and algebraic expressions.  In
one of these examples we had the choice of simplifying (reducing) the
expressions at either construction time or selection time, but other
than that the choice of a representation for these structures in terms
of lists was straightforward. When we turn to the representation of
sets, the choice of a representation is not so obvious.  Indeed, there
are a number of possible representations, and they differ
significantly from one another in several ways.</p>

<p>


Informally, a set is simply a collection of distinct objects.  To give
a more precise definition we can employ the method of data
abstraction.  That is, we define "set" by specifying the operations
that are to be used on sets.  These are union-set,
intersection-set, element-of-set?, and adjoin-set.
Element-of-set? is a predicate that determines whether a given
element is a member of a set.  Adjoin-set takes an object and a
set as arguments and returns a set that contains the elements of the
original set and also the adjoined element.  Union-set computes
the union of two sets, which is the set containing each element that
appears in either argument.  Intersection-set computes the
intersection of two sets, which is the set containing only elements
that appear in both arguments.  From the viewpoint of data abstraction, we
are free to design any representation that implements these operations
in a way consistent with the interpretations given above.<sup>37</sup></p>

<p><strong>Sets as unordered lists</strong></p>

<p>


One way to represent a set is as a list of its elements in which no
element appears more than once.  The empty set is represented by the
empty list.  In this representation, element-of-set? is similar
to the procedure memq of section 2.3.1.  It uses equal?
instead of eq? so that the set elements need not be symbols:</p>

<p>(define (element-of-set? x set)</p><empty-line /><p>
  (cond ((null? set) false)</p><empty-line /><p>
        ((equal? x (car set)) true)</p><empty-line /><p>
        (else (element-of-set? x (cdr set)))))</p><empty-line /><p>
Using this, we can write adjoin-set.  If the object to be adjoined
is already in the set, we just return the set.  Otherwise, we use
cons to add the object to the list that represents the set:</p>

<p>(define (adjoin-set x set)</p><empty-line /><p>
  (if (element-of-set? x set)</p><empty-line /><p>
      set</p><empty-line /><p>
      (cons x set)))</p><empty-line /><p>
For intersection-set we can use a recursive strategy.  If we
know how to form the intersection of set2 and the cdr
of set1, we only need to decide whether to include
the car of set1 in this.  But this depends on whether (car
set1) is also in set2.  Here is the resulting procedure:</p>

<p>(define (intersection-set set1 set2)</p><empty-line /><p>
  (cond ((or (null? set1) (null? set2)) '())</p><empty-line /><p>
        ((element-of-set? (car set1) set2)</p><empty-line /><p>
         (cons (car set1)</p><empty-line /><p>
               (intersection-set (cdr set1) set2)))</p><empty-line /><p>
        (else (intersection-set (cdr set1) set2))))</p><empty-line /><empty-line /><p>

In designing a representation, one of the issues we should be
concerned with is efficiency.  Consider the number of steps required by our set
operations.  Since they all use element-of-set?, the speed
of this operation has a major impact on the efficiency of the set
implementation as a whole.  Now, in order to check whether an object
is a member of a set, element-of-set? may have to scan the
entire set. (In the worst case, the object turns out not to be in the
set.)  Hence, if the set has <emphasis>n</emphasis> elements, element-of-set?
might take up to <emphasis>n</emphasis> steps.  Thus, the number of steps
required grows as <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>).
The number of steps required by adjoin-set, which uses this operation,
also grows as <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>).  For intersection-set, which does an element-of-set? check for each element of set1, the number of steps
required grows as the product of the sizes of the sets involved, or
<image xlink:href="#_25.jpg" />(<emphasis>n</emphasis><sup>2</sup>) for two sets of size <emphasis>n</emphasis>.  The same will be true of union-set.</p>

<p>
<strong>Exercise 2.59.</strong>  Implement the union-set operation for the unordered-list
representation of sets.</p>

<p>
<strong>Exercise 2.60.</strong>  We specified that a set would be represented as a list with no
duplicates.  Now suppose we allow duplicates.  For instance,
the set {1,2,3} could be represented as the list (2 3 2 1 3 2
2).  Design procedures element-of-set?, adjoin-set, union-set, and intersection-set that operate on this
representation.  How does the efficiency of each compare with the
corresponding procedure for the non-duplicate representation?  Are
there applications for which you would use this representation in
preference to the non-duplicate one?</p>

<p><strong>Sets as ordered lists</strong></p>

<p>


One way to speed up our set operations is to change the representation
so that the set elements are listed in increasing order.  To do this,
we need some way to compare two objects so that we can say which is
bigger.  For example, we could compare symbols lexicographically, or
we could agree on some method for assigning a unique number to an
object and then compare the elements by comparing the corresponding
numbers.  To keep our discussion simple, we will consider only the
case where the set elements are numbers, so that we can compare
elements using &gt; and &lt;.  We will represent a set of
numbers by listing its elements in increasing order.  Whereas our
first representation above allowed us to represent the set
{1,3,6,10} by listing the elements in any order, our new
representation allows only the list (1 3 6 10).</p>

<p>

One advantage of ordering shows up in element-of-set?: In
checking for the presence of an item, we no longer have to scan the
entire set.  If we reach a set element that is larger than the item we
are looking for, then we know that the item is not in the set:</p>

<p>(define (element-of-set? x set)</p><empty-line /><p>
  (cond ((null? set) false)</p><empty-line /><p>
        ((= x (car set)) true)</p><empty-line /><p>
        ((&lt; x (car set)) false)</p><empty-line /><p>
        (else (element-of-set? x (cdr set)))))</p><empty-line /><p>
How many steps does this save?  In the worst case, the item we are
looking for may be the largest one in the set, so the number of steps
is the same as for the unordered representation.  On the other hand,
if we search for items of many different sizes we can expect that
sometimes we will be able to stop searching at a point near the
beginning of the list and that other times we will still need to
examine most of the list.  On the average we should expect to have to
examine about half of the items in the set.  Thus, the average
number of steps required will be about <emphasis>n</emphasis>/2.
This is still <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) growth, but
it does save us, on the average, a factor of 2 in number of steps over the
previous implementation.</p>

<p>

We obtain a more impressive speedup with intersection-set.  In
the unordered representation this operation required
<image xlink:href="#_25.jpg" />(<emphasis>n</emphasis><sup>2</sup>) steps, because we performed a complete scan of set2 for
each element of set1.  But with the ordered representation, we
can use a more clever method.  Begin by comparing the initial
elements, x1 and x2, of the two sets.  If x1
equals x2, then that gives an element of the intersection, and
the rest of the intersection is the intersection of the cdrs of
the two sets.  Suppose, however, that x1 is less than x2.
Since x2 is the smallest element in set2, we can
immediately conclude that x1 cannot appear anywhere in set2 and hence is not in the intersection.  Hence, the intersection
is equal to the intersection of set2 with the cdr of set1.  Similarly, if x2 is less than x1, then the
intersection is given by the intersection of set1 with the cdr of set2.  Here is the procedure:</p>

<p>(define (intersection-set set1 set2)</p><empty-line /><p>
  (if (or (null? set1) (null? set2))</p><empty-line /><p>
      '()</p><empty-line /><p>
      (let ((x1 (car set1)) (x2 (car set2)))</p><empty-line /><p>
        (cond ((= x1 x2)</p><empty-line /><p>
               (cons x1</p><empty-line /><p>
                     (intersection-set (cdr set1)</p><empty-line /><p>
                                       (cdr set2))))</p><empty-line /><p>
              ((&lt; x1 x2)</p><empty-line /><p>
               (intersection-set (cdr set1) set2))</p><empty-line /><p>
              ((&lt; x2 x1)</p><empty-line /><p>
               (intersection-set set1 (cdr set2)))))))</p><empty-line /><p>
To estimate the number of steps required by this process, observe that at each
step we reduce the intersection problem to computing intersections of
smaller sets -- removing the first element from set1 or set2 or both.  Thus, the number of steps required is at most the sum
of the sizes of set1 and set2, rather than the product of
the sizes as with the unordered representation.  This is <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) growth
rather than <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis><sup>2</sup>) -- a considerable speedup, even for sets of
moderate size.</p>

<p>
<strong>Exercise 2.61.</strong>  Give an implementation of adjoin-set using the ordered
representation.  By analogy with element-of-set? show how to
take advantage of the ordering to produce a procedure that requires on
the average about half as many steps as with the unordered
representation.</p>

<p>
<strong>Exercise 2.62.</strong>  Give a <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) implementation of union-set for sets
represented as ordered lists.</p>

<p><strong>Sets as binary trees</strong></p>

<p>


We can do better than the ordered-list representation by arranging the
set elements in the form of a tree.  Each node of the tree holds one
element of the set, called the "entry" at that node, and a link to
each of two other (possibly empty) nodes.  The "left" link points to
elements smaller than the one at the node, and the "right" link to
elements greater than the one at the node.
Figure 2.16 shows some trees that represent the set
{1,3,5,7,9,11}.  The same set may be represented by a tree in a
number of different ways.  The only thing we require for a valid
representation is that all elements in the left subtree be smaller
than the node entry and that all elements in the right subtree be
larger.</p>

<p><image xlink:href="#_102.jpg" /></p>

<p><strong>Figure 2.16:</strong>  Various binary trees that represent the set { 1,3,5,7,9,11 }.</p>

<p>

The advantage of the tree representation is this: Suppose we want to
check whether a number <emphasis>x</emphasis> is contained in a set.  We begin by
comparing <emphasis>x</emphasis> with the entry in the top node.  If <emphasis>x</emphasis> is less than
this, we know that we need only search the left subtree; if <emphasis>x</emphasis> is
greater, we need only search the right subtree.  Now, if the tree is
"balanced", each of these subtrees will be about half the size of
the original.  Thus, in one step we have reduced the problem of
searching a tree of size <emphasis>n</emphasis> to searching a tree of size <emphasis>n</emphasis>/2.  Since
the size of the tree is halved at each step, we should expect that the
number of steps needed to search a tree of size <emphasis>n</emphasis> grows as <image xlink:href="#_25.jpg" />(log
<emphasis>n</emphasis>).<sup>38</sup> For large sets, this will
be a significant speedup over the previous representations.</p>

<p>

We can represent trees by using lists.  Each node will be a list of
three items: the entry at the node, the left subtree, and the right
subtree.  A left or a right subtree of the empty list will indicate
that there is no subtree connected there.  We can describe this
representation by the following procedures:<sup>39</sup></p>

<p>(define (entry tree) (car tree))</p><empty-line /><p>(define (left-branch tree) (cadr tree))</p><empty-line /><p>(define (right-branch tree) (caddr tree))</p><empty-line /><p>(define (make-tree entry left right)</p><empty-line /><p>
  (list entry left right))</p><empty-line /><empty-line /><p>

Now we can write the element-of-set? procedure using the strategy
described above:</p>

<p>(define (element-of-set? x set)</p><empty-line /><p>
  (cond ((null? set) false)</p><empty-line /><p>
        ((= x (entry set)) true)</p><empty-line /><p>
        ((&lt; x (entry set))</p><empty-line /><p>
         (element-of-set? x (left-branch set)))</p><empty-line /><p>
        ((&gt; x (entry set))</p><empty-line /><p>
         (element-of-set? x (right-branch set)))))</p><empty-line /><empty-line /><p>

Adjoining an item to a set is implemented similarly and also requires
<image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>) steps.  To adjoin an item x, we compare x with
the node entry to determine whether x should be added to the
right or to the left branch, and having adjoined x to the
appropriate branch we piece this newly constructed branch together
with the original entry and the other branch.  If x is equal to
the entry, we just return the node.  If we are asked to adjoin
x to an empty tree, we generate a tree that has x as the
entry and empty right and left branches.  Here is the procedure:</p>

<p>(define (adjoin-set x set)</p><empty-line /><p>
  (cond ((null? set) (make-tree x '() '()))</p><empty-line /><p>
        ((= x (entry set)) set)</p><empty-line /><p>
        ((&lt; x (entry set))</p><empty-line /><p>
         (make-tree (entry set)</p><empty-line /><p>
                    (adjoin-set x (left-branch set))</p><empty-line /><p>
                    (right-branch set)))</p><empty-line /><p>
        ((&gt; x (entry set))</p><empty-line /><p>
         (make-tree (entry set)</p><empty-line /><p>
                    (left-branch set)</p><empty-line /><p>
                    (adjoin-set x (right-branch set))))))</p><empty-line /><empty-line /><p>

The above claim that searching the tree can be performed in a logarithmic
number of steps
rests on the assumption that the tree is "balanced", i.e., that the
left and the right subtree of every tree have approximately the same
number of elements, so that each subtree contains about half the
elements of its parent.  But how can we be certain that the trees we
construct will be balanced?  Even if we start with a balanced tree,
adding elements with adjoin-set may produce an unbalanced
result.  Since the position of a newly adjoined element depends on how
the element compares with the items already in the set, we can expect
that if we add elements "randomly" the tree will tend to be balanced
on the average.  But this is not a guarantee.  For example, if we
start with an empty set and adjoin the numbers 1 through 7 in sequence
we end up with the highly unbalanced tree shown in
figure 2.17.  In this tree all the left subtrees
are empty, so it has no advantage over a simple ordered list.  One
way to solve this problem is to define an operation that transforms an
arbitrary tree into a balanced tree with the same elements.  Then we
can perform this transformation after every few adjoin-set
operations to keep our set in balance.  There are also other ways to
solve this problem, most of which involve designing new data
structures for which searching and insertion both can be done in
<image xlink:href="#_25.jpg" />(log <emphasis>n</emphasis>) steps.<sup>40</sup></p>

<p><image xlink:href="#_103.jpg" /></p>

<p><strong>Figure 2.17:</strong>  Unbalanced tree produced by adjoining 1 through 7 in sequence.</p>

<p>
<strong>Exercise 2.63.</strong>  Each of the following two procedures converts a binary tree to a list.</p>

<p>(define (tree-&gt;list-1 tree)</p><empty-line /><p>
  (if (null? tree)</p><empty-line /><p>
      '()</p><empty-line /><p>
      (append (tree-&gt;list-1 (left-branch tree))</p><empty-line /><p>
              (cons (entry tree)</p><empty-line /><p>
                    (tree-&gt;list-1 (right-branch tree))))))</p><empty-line /><p>
(define (tree-&gt;list-2 tree)</p><empty-line /><p>
  (define (copy-to-list tree result-list)</p><empty-line /><p>
    (if (null? tree)</p><empty-line /><p>
        result-list</p><empty-line /><p>
        (copy-to-list (left-branch tree)</p><empty-line /><p>
                      (cons (entry tree)</p><empty-line /><p>
                            (copy-to-list (right-branch tree)</p><empty-line /><p>
                                          result-list)))))</p><empty-line /><p>
  (copy-to-list tree '()))</p><empty-line /><empty-line /><p>a. Do the two procedures produce the same result for every tree?  If
not, how do the results differ?  What lists do the two procedures
produce for the trees in figure 2.16?</p>

<p>b. Do the two procedures have the same order of growth in the number
of steps required to convert a balanced tree with <emphasis>n</emphasis> elements to a list?
If not, which one grows more slowly?</p>

<p>
<strong>Exercise 2.64.</strong>  The following procedure list-&gt;tree converts an ordered list to a
balanced binary tree.  The helper procedure partial-tree takes
as arguments an integer <emphasis>n</emphasis> and list of at least <emphasis>n</emphasis> elements and
constructs a balanced tree containing the first <emphasis>n</emphasis> elements of the
list.  The result returned by partial-tree is a pair (formed
with cons) whose car is the constructed tree and whose
cdr is the list of elements not included in the tree.</p>

<p>(define (list-&gt;tree elements)</p><empty-line /><p>
  (car (partial-tree elements (length elements))))</p><empty-line /><empty-line /><p>
(define (partial-tree elts n)</p><empty-line /><p>
  (if (= n 0)</p><empty-line /><p>
      (cons '() elts)</p><empty-line /><p>
      (let ((left-size (quotient (- n 1) 2)))</p><empty-line /><p>
        (let ((left-result (partial-tree elts left-size)))</p><empty-line /><p>
          (let ((left-tree (car left-result))</p><empty-line /><p>
                (non-left-elts (cdr left-result))</p><empty-line /><p>
                (right-size (- n (+ left-size 1))))</p><empty-line /><p>
            (let ((this-entry (car non-left-elts))</p><empty-line /><p>
                  (right-result (partial-tree (cdr non-left-elts)</p><empty-line /><p>
                                              right-size)))</p><empty-line /><p>
              (let ((right-tree (car right-result))</p><empty-line /><p>
                    (remaining-elts (cdr right-result)))</p><empty-line /><p>
                (cons (make-tree this-entry left-tree right-tree)</p><empty-line /><p>
                      remaining-elts))))))))</p><empty-line /><empty-line /><p>a. Write a short paragraph explaining as clearly as you can how partial-tree works.  Draw the tree produced by list-&gt;tree for
the list (1 3 5 7 9 11).</p>

<p>b. What is the order of growth in the number of steps required by list-&gt;tree to convert a list of <emphasis>n</emphasis> elements?</p>

<p>
<strong>Exercise 2.65.</strong>  Use the results of exercises 2.63 and
 2.64 to give <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) implementations of union-set and intersection-set for sets implemented as
(balanced) binary trees.<sup>41</sup></p>

<p><strong>Sets and information retrieval</strong></p>

<p>


We have examined options for using lists to represent sets and have
seen how the choice of representation for a data object can have a
large impact on the performance of the programs that use the data.
Another reason for concentrating on sets is that the techniques
discussed here appear again and again in applications involving
information retrieval.</p>

<p>

Consider a data base containing a large number of individual records,
such as the personnel files for a company or the transactions in an
accounting system.  A typical data-management system spends a large
amount of time accessing or modifying the data in the records and
therefore requires an efficient method for accessing records.  This is
done by identifying a part of each record to serve as an identifying
<emphasis>key</emphasis>.  A key can be anything that uniquely identifies the
record.  For a personnel file, it might be an employee's ID number.
For an accounting system, it might be a transaction number.  Whatever
the key is, when we define the record as a data structure we should
include a key selector procedure that retrieves the key
associated with a given record.</p>

<p>

Now we represent the data base as a set of records. To locate the
record with a given key we use a procedure lookup, which takes
as arguments a key and a data base and which returns the record that
has that key, or false if there is no such record.  Lookup
is implemented in almost the same way as element-of-set?.  For
example, if the set of records is implemented as an unordered list, we
could use</p>

<p>(define (lookup given-key set-of-records)</p><empty-line /><p>
  (cond ((null? set-of-records) false)</p><empty-line /><p>
        ((equal? given-key (key (car set-of-records)))</p><empty-line /><p>
         (car set-of-records))</p><empty-line /><p>
        (else (lookup given-key (cdr set-of-records)))))</p><empty-line /><empty-line /><p>

Of course, there are better ways to represent large sets than as
unordered lists.  Information-retrieval systems in which records have
to be "randomly accessed" are typically implemented by a tree-based
method, such as the binary-tree representation discussed previously.
In designing such a system the methodology of data abstraction
can be a great help.  The designer can create an initial
implementation using a simple, straightforward representation such as
unordered lists.  This will be unsuitable for the eventual system, but
it can be useful in providing a "quick and dirty" data base with
which to test the rest of the system.  Later on, the data
representation can be modified to be more sophisticated.  If the data
base is accessed in terms of abstract selectors and constructors, this
change in representation will not require any changes to the rest of
the system.</p>

<p>
<strong>Exercise 2.66.</strong>  Implement the lookup procedure for the case
where the set of records is structured as a binary tree, ordered by
the numerical values of the keys.</p>

<p><strong>2.3.4  Example: Huffman Encoding Trees</strong></p>

<p>


This section provides practice in the use of list structure and data
abstraction to manipulate sets and trees.  The application is to
methods for representing data as sequences of ones and zeros (bits).
For example, the ASCII standard code used to represent text in
computers encodes each character as a sequence of seven bits.  Using
seven bits allows us to distinguish 2<sup>7</sup>, or 128, possible different
characters.  In general, if we want to distinguish <emphasis>n</emphasis> different
symbols, we will need to use log<sub>2</sub><emphasis>n</emphasis> bits per symbol.  If all our
messages are made up of the eight symbols A, B, C, D, E, F, G, and H,
we can choose a code with three bits per character, for example</p>

<p>A 000</p>

<p>C 010</p>

<p>E 100</p>

<p>G 110</p>

<p>B 001</p>

<p>D 011</p>

<p>F 101</p>

<p>H 111</p>

<p>
With this code, the message</p>

<p>BACADAEAFABBAAAGAH</p>

<p>is encoded as the string of 54 bits</p>

<p>001000010000011000100000101000001001000000000110000111</p>

<p>Codes such as ASCII and the A-through-H code above are known as <emphasis>fixed-length</emphasis> codes, because they represent each symbol in the message
with the same number of bits.  It is sometimes advantageous to use
<emphasis>variable-length</emphasis> codes, in which different symbols may be
represented by different numbers of bits.  For example, Morse code
does not use the same number of dots and dashes for each letter of the
alphabet.  In particular, E, the most frequent letter, is represented
by a single dot.  In general, if our messages are such that some
symbols appear very frequently and some very rarely, we can encode
data more efficiently (i.e., using fewer bits per message) if we
assign shorter codes to the frequent symbols.  Consider the following
alternative code for the letters A through H:</p>

<p>A 0</p>

<p>C 1010</p>

<p>E 1100</p>

<p>G 1110</p>

<p>B 100</p>

<p>D 1011</p>

<p>F 1101</p>

<p>H 1111</p>

<p>
With this code, the same message as above is encoded as the string</p>

<p>100010100101101100011010100100000111001111</p>

<p>This string contains 42 bits, so it saves more than 20% in space in
comparison with the fixed-length code shown above.</p>

<p>

One of the difficulties of using a variable-length code is knowing
when you have reached the end of a symbol in reading a sequence of
zeros and ones.  Morse code solves this problem by using a special
<emphasis>separator code</emphasis> (in this case, a pause) after the sequence of
dots and dashes for each letter.  Another solution is to design the
code in such a way that no complete code for any symbol is the
beginning (or <emphasis>prefix</emphasis>) of the code for another symbol.  Such a
code is called a <emphasis>prefix code</emphasis>.  In the example above, A is
encoded by 0 and B is encoded by 100, so no other symbol can have a
code that begins with 0 or with 100.</p>

<p>

In general, we can attain significant savings if we use
variable-length prefix codes that take advantage of the relative
frequencies of the symbols in the messages to be encoded.  One
particular scheme for doing this is called the Huffman encoding
method, after its discoverer, David Huffman.  A Huffman code can be
represented as a binary tree whose leaves are the symbols that are
encoded.  At each non-leaf node of the tree there is a set containing
all the symbols in the leaves that lie below the node.  In addition,
each symbol at a leaf is assigned a weight (which is its
relative frequency), and each non-leaf
node contains a weight that is the sum of all the weights of the
leaves lying below it.  The weights are not used in the encoding or
the decoding process.  We will see below how they are used to help
construct the tree.</p>

<p><image xlink:href="#_104.jpg" /></p>

<p><strong>Figure 2.18:</strong>  A Huffman encoding tree.</p>

<p>

Figure 2.18 shows the Huffman tree for the A-through-H 
code given above.  The weights at the leaves
indicate that the tree was designed for messages in which A appears
with relative frequency 8, B with relative frequency 3, and the
other letters each with relative frequency 1.</p>

<p>

Given a Huffman tree, we can find the encoding of any symbol by
starting at the root and moving down until we reach the leaf that
holds the symbol.  Each time we move down a left branch we add a 0 to
the code, and each time we move down a right branch we add a 1.  (We
decide which branch to follow by testing to see which branch either is
the leaf node for the symbol or contains the symbol in its set.)  For
example, starting from the root of the tree in
figure 2.18, we arrive at the leaf for D by following a
right branch, then a left branch, then a right branch, then a right
branch; hence, the code for D is 1011.</p>

<p>

To decode a bit sequence using a Huffman tree, we begin at the root
and use the successive zeros and ones of the bit sequence to determine
whether to move down the left or the right branch.  Each time we come
to a leaf, we have generated a new symbol in the message, at which
point we start over from the root of the tree to find the next symbol.
For example, suppose we are given the tree above and the sequence
10001010.  Starting at the root, we move down the right branch, (since
the first bit of the string is 1), then down the left branch (since
the second bit is 0), then down the left branch (since the third bit
is also 0).  This brings us to the leaf for B, so the first symbol of
the decoded message is B.  Now we start again at the root, and we make
a left move because the next bit in the string is 0.  This brings us
to the leaf for A.  Then we start again at the root with the rest of
the string 1010, so we move right, left, right, left and reach C.
Thus, the entire message is BAC.</p>

<p><strong>Generating Huffman trees</strong></p>

<p>

Given an "alphabet" of symbols and their relative frequencies, how
do we construct the "best" code?  (In other words, which tree will
encode messages with the fewest bits?)  Huffman gave an algorithm for
doing this and showed that the resulting code is indeed the best
variable-length code for messages where the relative frequency of the
symbols matches the frequencies with which the code was constructed.
We will not prove this optimality of Huffman codes here, but we will
show how Huffman trees are constructed.<sup>42</sup></p>

<p>

The algorithm for generating a Huffman tree is very simple. The idea
is to arrange the tree so that the symbols with the lowest frequency
appear farthest away from the root. Begin with the set of leaf nodes,
containing symbols and their frequencies, as determined by the initial data
from which the code is to be constructed. Now find two leaves with
the lowest weights and merge them to produce a node that has these
two nodes as its left and right branches. The weight of the new node
is the sum of the two weights. Remove the two leaves from the
original set and replace them by this new node. Now continue this
process. At each step, merge two nodes with the smallest weights,
removing them from the set and replacing them with a node that has
these two as its left and right branches. The process stops when
there is only one node left, which is the root of the entire tree.
Here is how the Huffman tree of figure 2.18 was generated:</p>

<p>Initial leaves</p>

<p>{(A 8)  (B 3)  (C 1)
 (D 1)  (E 1)  (F 1)  (G 1)  (H 1)}</p>

<p>

Merge</p>

<p>{(A 8)  (B 3)  ({C D} 2)  (E
1)  (F 1)  (G 1)  (H 1)}</p>

<p>

Merge</p>

<p>{(A 8)  (B 3)  ({C D} 2) 
({E F} 2)  (G 1)  (H 1)}</p>

<p>

Merge</p>

<p>{(A 8)  (B 3)  ({C D} 2) 
({E F} 2)   ({G H} 2)}</p>

<p>

Merge</p>

<p>{(A 8)   (B 3)  ({C D} 2)  ({E F G H} 4)}</p>

<p>

Merge</p>

<p>{(A 8)  ({B C D} 5)  ({E F G H} 4)}</p>

<p>

Merge</p>

<p>{(A 8)  ({B C D E F G H} 9)}</p>

<p>

Final merge</p>

<p>{({A B C D E F G H} 17)}</p>

<p>
The algorithm does not always specify a unique tree, because there may
not be unique smallest-weight nodes at each step.  Also, the choice of
the order in which the two nodes are merged (i.e., which will be the
right branch and which will be the left branch) is arbitrary.</p>

<p><strong>Representing Huffman trees</strong></p>

<p>

In the exercises below we will work with a system that uses
Huffman trees to encode and decode messages and generates Huffman
trees according to the algorithm outlined above.  We will begin by
discussing how trees are represented.</p>

<p>

Leaves of the tree are represented by a list consisting of the
symbol leaf, the symbol at the leaf, and the weight:</p>

<p>(define (make-leaf symbol weight)</p><empty-line /><p>
  (list 'leaf symbol weight))</p><empty-line /><p>(define (leaf? object)</p><empty-line /><p>
  (eq? (car object) 'leaf))</p><empty-line /><p>(define (symbol-leaf x) (cadr x))</p><empty-line /><p>(define (weight-leaf x) (caddr x))</p><empty-line /><p>
A general tree will be a list of a left branch, a right branch, a set
of symbols, and a weight.  The set of symbols will be simply a list of
the symbols, rather than some more sophisticated set representation.
When we make a tree by merging two nodes, we obtain the weight of the
tree as the sum of the weights of the nodes, and the set of symbols as
the union of the sets of symbols for the nodes.  Since our symbol sets are
represented as lists, we can form the union by using the append
procedure we defined in section 2.2.1:</p>

<p>(define (make-code-tree left right)</p><empty-line /><p>
  (list left</p><empty-line /><p>
        right</p><empty-line /><p>
        (append (symbols left) (symbols right))</p><empty-line /><p>
        (+ (weight left) (weight right))))</p><empty-line /><p>
If we make a tree in this way, we have the following selectors:</p>

<p>(define (left-branch tree) (car tree))</p><empty-line /><empty-line /><p>(define (right-branch tree) (cadr tree))</p><empty-line /><p>(define (symbols tree)</p><empty-line /><p>
  (if (leaf? tree)</p><empty-line /><p>
      (list (symbol-leaf tree))</p><empty-line /><p>
      (caddr tree)))</p><empty-line /><p>(define (weight tree)</p><empty-line /><p>
  (if (leaf? tree)</p><empty-line /><p>
      (weight-leaf tree)</p><empty-line /><p>
      (cadddr tree)))</p><empty-line /><p>
The procedures symbols and weight must do something
slightly different depending on whether they are called with a leaf or
a general tree.  These are simple examples of <emphasis>generic
procedures</emphasis> (procedures that can handle more than one kind of data),
which we will have much more to say about in
sections 2.4 and 2.5.</p>

<p><strong>The decoding procedure</strong></p>

<p>

The following procedure implements the decoding algorithm.
It takes as arguments a list of zeros and ones, together with
a Huffman tree.</p>

<p>(define (decode bits tree)</p><empty-line /><p>
  (define (decode-1 bits current-branch)</p><empty-line /><p>
    (if (null? bits)</p><empty-line /><p>
        '()</p><empty-line /><p>
        (let ((next-branch</p><empty-line /><p>
               (choose-branch (car bits) current-branch)))</p><empty-line /><p>
          (if (leaf? next-branch)</p><empty-line /><p>
              (cons (symbol-leaf next-branch)</p><empty-line /><p>
                    (decode-1 (cdr bits) tree))</p><empty-line /><p>
              (decode-1 (cdr bits) next-branch)))))</p><empty-line /><p>
  (decode-1 bits tree))</p><empty-line /><p>
(define (choose-branch bit branch)</p><empty-line /><p>
  (cond ((= bit 0) (left-branch branch))</p><empty-line /><p>
        ((= bit 1) (right-branch branch))</p><empty-line /><p>
        (else (error "bad bit -- CHOOSE-BRANCH" bit))))</p><empty-line /><p>
The procedure decode-1 takes two arguments: the list of remaining bits
and the current position in the tree.  It keeps moving
"down" the tree, choosing a left or a right branch according to
whether the next bit in the list is a zero or a one.  (This is done
with the procedure choose-branch.)  When it reaches a leaf, it
returns the symbol at that leaf as the next symbol in the message by
consing it onto the result of decoding
the rest of the message, starting at the root of the tree.
Note the error check in the final clause of choose-branch, which
complains if the procedure finds something other than a zero or a one in the
input data.</p>

<p><strong>Sets of weighted elements</strong></p>

<p>

In our representation of trees, each non-leaf node contains a set of
symbols, which we have represented as a simple list.  However, the
tree-generating algorithm discussed above requires that we also work
with sets of leaves and trees, successively merging the two smallest
items.  Since we will be required to repeatedly find the smallest item
in a set, it is convenient to use an ordered representation for this
kind of set.</p>

<p>

We will represent a set of leaves and trees as a list of elements,
arranged in increasing order of weight.  The following adjoin-set procedure for constructing sets is similar to the one
described in exercise 2.61; however, items are compared
by their weights, and the element being added to the set is
never already in it.</p>

<p>(define (adjoin-set x set)</p><empty-line /><p>
  (cond ((null? set) (list x))</p><empty-line /><p>
        ((&lt; (weight x) (weight (car set))) (cons x set))</p><empty-line /><p>
        (else (cons (car set)</p><empty-line /><p>
                    (adjoin-set x (cdr set))))))</p><empty-line /><empty-line /><p>

The following procedure takes a list of
symbol-frequency pairs such as ((A 4) (B 2) (C 1) (D 1)) and
constructs an initial ordered set of leaves, ready to be merged
according to the Huffman algorithm:</p>

<p>(define (make-leaf-set pairs)</p><empty-line /><p>
  (if (null? pairs)</p><empty-line /><p>
      '()</p><empty-line /><p>
      (let ((pair (car pairs)))</p><empty-line /><p>
        (adjoin-set (make-leaf (car pair)    <emphasis>; symbol</emphasis></p><empty-line /><p>
                               (cadr pair))  <emphasis>; frequency</emphasis></p><empty-line /><p>
                    (make-leaf-set (cdr pairs))))))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.67.</strong>  Define an encoding tree and a sample message:</p>

<p>(define sample-tree</p><empty-line /><p>
  (make-code-tree (make-leaf 'A 4)</p><empty-line /><p>
                  (make-code-tree</p><empty-line /><p>
                   (make-leaf 'B 2)</p><empty-line /><p>
                   (make-code-tree (make-leaf 'D 1)</p><empty-line /><p>
                                   (make-leaf 'C 1)))))</p><empty-line /><empty-line /><p>
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))</p><empty-line /><p>
Use the decode procedure to decode the
message, and give the result.</p>

<p>
<strong>Exercise 2.68.</strong>  The encode procedure takes as arguments a message and a tree and
produces the list of bits that gives the encoded message.</p>

<p>(define (encode message tree)</p><empty-line /><p>
  (if (null? message)</p><empty-line /><p>
      '()</p><empty-line /><p>
      (append (encode-symbol (car message) tree)</p><empty-line /><p>
              (encode (cdr message) tree))))</p><empty-line /><p>
Encode-symbol is a procedure, which you must write, that returns
the list of bits that encodes a given symbol according to a given
tree.  You should design encode-symbol so that it signals an
error if the symbol is not in the tree at all.  Test your procedure by
encoding the result you obtained in exercise 2.67 with
the sample tree and seeing whether it is the same as the original
sample message.</p>

<p>
<strong>Exercise 2.69.</strong>  The following procedure takes as its argument a list of
symbol-frequency pairs (where no symbol appears in more than one pair)
and generates a Huffman encoding tree according to the Huffman
algorithm.</p>

<p>(define (generate-huffman-tree pairs)</p><empty-line /><p>
  (successive-merge (make-leaf-set pairs)))</p><empty-line /><p>
Make-leaf-set is the procedure given above that transforms the
list of pairs into an ordered set of leaves.  Successive-merge
is the procedure you must write, using make-code-tree to
successively merge the smallest-weight elements of the set until there
is only one element left, which is the desired Huffman tree.  (This
procedure is slightly tricky, but not really complicated.  If you find
yourself designing a complex procedure, then you are almost certainly
doing something wrong.  You can take significant advantage of the fact
that we are using an ordered set representation.)</p>

<p>
<strong>Exercise 2.70.</strong>  The following eight-symbol alphabet with associated relative
frequencies was designed to efficiently encode the lyrics of 1950s
rock songs.  (Note that the "symbols" of an "alphabet" need not be
individual letters.)</p>

<p>A</p>

<p>2</p>

<p>NA</p>

<p>16</p>

<p>BOOM</p>

<p>1</p>

<p>SHA</p>

<p>3</p>

<p>GET</p>

<p>2</p>

<p>YIP</p>

<p>9</p>

<p>JOB</p>

<p>2</p>

<p>WAH</p>

<p>1</p>

<p>
Use</p>

<p>generate-huffman-tree</p>

<p> (exercise</p>

<p>2.69</p>

<p>)
to generate a corresponding Huffman tree, and use</p>

<p>encode</p>

<p> (exercise</p>

<p>2.68</p>

<p>)
to encode the following message:</p>

<p>Get a job</p>

<p>

Sha na na na na na na na na</p>

<p>

Get a job</p>

<p>

Sha na na na na na na na na</p>

<p>

Wah yip yip yip yip yip yip yip yip yip</p>

<p>

Sha boom</p>

<p>How many bits are required for the encoding?  What is the smallest
number of bits that would be needed to encode this song if we 
used a fixed-length code for the eight-symbol alphabet?</p>

<p>
<strong>Exercise 2.71.</strong>  Suppose we have a Huffman tree for an alphabet of <emphasis>n</emphasis> symbols, and
that the relative frequencies of the symbols are 1, 2, 4, ...,
2<sup><emphasis>n</emphasis>-1</sup>.  Sketch the tree for <emphasis>n</emphasis>=5; for <emphasis>n</emphasis>=10.  In such a tree
(for general <emphasis>n</emphasis>) how many bits are required to encode the most
frequent symbol?  the least frequent symbol?</p>

<p>
<strong>Exercise 2.72.</strong>  Consider the encoding procedure that you designed in
exercise 2.68.  What is the order of growth in the
number of steps needed to encode a symbol?  Be sure to include the
number of steps needed to search the symbol list at each node
encountered.  To answer this question in general is difficult.
Consider the special case where the relative frequencies of the <emphasis>n</emphasis>
symbols are as described in exercise 2.71, and give
the order of growth (as a function of <emphasis>n</emphasis>) of the number of steps
needed to encode the most frequent and least frequent symbols in the
alphabet.</p><empty-line /><empty-line /><empty-line /><p><sup>32</sup> Allowing quotation in a language wreaks havoc
with the ability to reason about the language in simple terms, because
it destroys the notion that equals can be substituted for equals.  For
example, three is one plus two, but the word "three" is not the
phrase "one plus two."  Quotation is powerful because it gives us a way
to build expressions that manipulate other expressions (as we will see
when we write an interpreter in chapter 4). But allowing statements in
a language that talk about other statements in that language makes it
very difficult to maintain any coherent principle of what "equals can
be substituted for equals" should mean.  For example, if we know that
the evening star is the morning star, then from the statement "the
evening star is Venus" we can deduce "the morning star is Venus."
However, given that "John knows that the evening star is Venus" we
cannot infer that "John knows that the morning star is Venus."</p>

<p><sup>33</sup> The single quote is different from the double quote we have
been using to enclose character strings to be printed.  Whereas the
single quote can be used to denote lists or symbols, the double quote
is used only with character strings.  In this book, the only use for
character strings is as items to be printed.</p>

<p><sup>34</sup> Strictly, our
use of the quotation mark violates the general rule that all compound
expressions in our language should be delimited by parentheses
and look like lists.  We
can recover this consistency by introducing a special form quote, which serves the same purpose as the quotation mark.  Thus, we
would type (quote a) instead of 'a, and we would type (quote (a b c)) instead of '(a b c).  This is precisely how the
interpreter works.  The quotation mark is just a single-character
abbreviation for wrapping the next complete expression with quote to form (quote &lt;<emphasis>expression</emphasis>&gt;).  This is important
because it maintains the principle that any expression seen by the
interpreter can be manipulated as a data object.  For instance, we
could construct the expression
(car '(a b c)), which is the same as (car (quote (a b c))),
by evaluating (list 'car (list 'quote '(a b c))).</p>

<p><sup>35</sup> We can consider two symbols to be "the same" if they
consist of the same characters in the same order.  Such a definition
skirts a deep issue that we are not yet ready to address: the meaning
of "sameness" in a programming language.  We will return to this in
chapter 3 (section 3.1.3).</p>

<p><sup>36</sup> In practice, programmers
use equal? to compare lists that contain numbers as well as
symbols.  Numbers are not considered to be symbols.  The question
of whether two numerically equal numbers (as tested by =) are also
eq? is highly implementation-dependent.  A better definition
of equal? (such as the one that comes as a primitive in Scheme)
would also stipulate that if a and b are
both numbers, then a and b are equal? if they are
numerically equal.</p>

<p><sup>37</sup> If
we want to be more formal, we can specify "consistent with the
interpretations given above" to mean that the operations satisfy a
collection of rules such as these:</p>

<p>For any set S and any object x,
(element-of-set? x (adjoin-set x S))
is true (informally: "Adjoining an object to a 
set produces a set that contains the object").</p>

<p>For any sets S and T and any object x,
(element-of-set? x (union-set S T))
is equal to
(or (element-of-set? x S) (element-of-set? x T))
(informally: "The elements of (union S T) are the elements that
are in S or in T").</p>

<p>For any object x,
(element-of-set? x '())
is false (informally: "No object is an element of the empty set").</p>

<p><sup>38</sup> Halving the size of the problem at each step is the
distinguishing characteristic of logarithmic growth, as we saw with
the fast-exponentiation algorithm of section 1.2.4
and the half-interval search method of
section 1.3.3.</p>

<p><sup>39</sup> We are
representing sets in terms of trees, and trees in terms of lists -- in
effect, a data abstraction built upon a data abstraction.  We can
regard the procedures entry, left-branch, right-branch, and make-tree as a way of isolating the
abstraction of a "binary tree" from the particular way we might wish
to represent such a tree in terms of list structure.</p>

<p><sup>40</sup> Examples of such structures include
<emphasis>B-trees</emphasis> and <emphasis>red-black trees</emphasis>.  There is a large literature on
data structures devoted to this problem.  See Cormen,
Leiserson, and Rivest 1990.</p>

<p><sup>41</sup> Exercises 2.63-2.65
are due to Paul Hilfinger.</p>

<p><sup>42</sup> See Hamming 1980
for a discussion of the mathematical properties of Huffman codes.</p>


</section>

<section>


<p><strong>2.4  Multiple Representations for Abstract Data</strong></p>

<p>



We have introduced data abstraction, a methodology for structuring
systems in such a way that much of a program can be specified
independent of the choices involved in implementing the data objects
that the program manipulates.  For example, we saw in
section 2.1.1 how to separate the task of designing a
program that uses rational numbers from the task of implementing
rational numbers in terms of the computer language's primitive
mechanisms for constructing compound data.  The key idea was to erect
an abstraction barrier -- in this case, the selectors and constructors
for rational numbers (make-rat, numer, denom) -- that
isolates the way rational numbers are used from their underlying
representation in terms of list structure.  A similar abstraction
barrier isolates the details of the procedures that perform rational
arithmetic (add-rat, sub-rat, mul-rat, and div-rat) from the "higher-level" procedures that use rational
numbers.  The resulting program has the structure shown in
figure 2.1.</p>

<p>

These data-abstraction barriers are powerful tools for controlling
complexity.  By isolating the underlying representations of data
objects, we can divide the task of designing a large program into
smaller tasks that can be performed separately.  But this kind of data
abstraction is not yet powerful enough, because it may not always make
sense to speak of "the underlying representation" for a data object.</p>

<p>


For one thing, there might be more than one useful representation for
a data object, and we might like to design systems that can deal with
multiple representations.  To take a simple example, complex numbers
may be represented in two almost equivalent ways: in rectangular form
(real and imaginary parts) and in polar form (magnitude and angle).
Sometimes rectangular form is more appropriate and sometimes polar
form is more appropriate.  Indeed, it is perfectly plausible to
imagine a system in which complex numbers are represented in both
ways, and in which the procedures for manipulating complex numbers work
with either representation.</p>

<p>

More importantly, programming systems are often designed by many
people working over extended periods of time, subject to requirements
that change over time.  In such an environment, it is simply not
possible for everyone to agree in advance on choices of data
representation.  So in addition to the data-abstraction barriers that
isolate representation from use, we need abstraction barriers that
isolate different design choices from each other and permit different
choices to coexist in a single program.  Furthermore, since large
programs are often created by combining pre-existing modules that were
designed in isolation, we need conventions that permit programmers to
incorporate modules into larger systems <emphasis>additively</emphasis>, that is,
without having to redesign or reimplement these modules.</p>

<p>

In this section, we will learn how to cope with data that may be
represented in different ways by different parts of a program.  This
requires constructing <emphasis>generic procedures</emphasis> -- procedures that can
operate on data that may be represented in more than one way.  Our
main technique for building generic procedures will be to work in terms
of data objects that have <emphasis>type tags</emphasis>, that is, data objects
that include explicit information about how they are to be processed.
We will also discuss <emphasis>data-directed</emphasis> programming, a powerful and
convenient implementation strategy for additively assembling systems
with generic operations.</p>

<p>

We begin with the simple complex-number example. We will see how
type tags and data-directed style enable us to design separate
rectangular and polar representations for complex numbers while
maintaining the notion of an abstract "complex-number" data object.
We will accomplish this by defining arithmetic procedures for complex
numbers (add-complex, sub-complex, mul-complex, and
div-complex) in terms of generic selectors that access parts of
a complex number independent of how the number is represented.  The
resulting complex-number system, as shown in
figure 2.19, contains two different kinds of
abstraction barriers.  The "horizontal" abstraction barriers play
the same role as the ones in
figure 2.1.  They isolate "higher-level"
operations from "lower-level" representations.  In addition, there
is a "vertical" barrier that gives us the ability to separately
design and install alternative representations.</p>

<p><image xlink:href="#_105.jpg" /></p>

<p><strong>Figure 2.19:</strong>  Data-abstraction barriers in the complex-number system.</p>

<p>


In section 2.5 we will show how to use
type tags and data-directed style to develop a generic arithmetic
package.  This provides procedures (add, mul, and so on)
that can be used to manipulate all sorts of "numbers" and can be
easily extended when a new kind of number is needed.
In section 2.5.3, we'll show how to use generic
arithmetic in a system that performs symbolic algebra.</p>

<p><strong>2.4.1  Representations for Complex Numbers</strong></p>

<p>

We will develop a system that performs arithmetic operations on
complex numbers as a simple but unrealistic example of a program that
uses generic operations.  We begin by discussing two plausible
representations for complex numbers as ordered pairs: rectangular form
(real part and imaginary part) and polar form (magnitude and
angle).<sup>43</sup>  Section 2.4.2
will show how both representations can be made to coexist in a single
system through the use of type tags and generic operations.</p>

<p>

Like rational numbers, complex numbers are naturally represented as
ordered pairs.  The set of complex numbers can be thought of as a
two-dimensional space with two orthogonal axes, the "real" axis and
the "imaginary" axis. (See figure 2.20.)  From
this point of view, the complex number <emphasis>z</emphasis> = <emphasis>x</emphasis> + <emphasis>i</emphasis><emphasis>y</emphasis> (where <emphasis>i</emphasis><sup>2</sup>  =  - 1)
can be thought of as the point in the plane whose real coordinate is <emphasis>x</emphasis> and whose
imaginary coordinate is <emphasis>y</emphasis>.  Addition of complex numbers reduces in
this representation to addition of coordinates:</p>

<p><image xlink:href="#_106.jpg" /></p><empty-line /><p><image xlink:href="#_107.jpg" /></p>

<p>

When multiplying complex numbers, it is more natural to think in terms
of representing a complex number in polar form, as a magnitude and an
angle (<emphasis>r</emphasis> and <emphasis>A</emphasis> in figure 2.20).
The product of two complex numbers is the vector obtained by
stretching one complex number by the length of the other and then
rotating it through the angle of the other:</p>

<p><image xlink:href="#_108.jpg" /></p><empty-line /><p><image xlink:href="#_109.jpg" /></p>

<p>

Thus, there are two different representations for complex numbers,
which are appropriate for different operations.  Yet, from the
viewpoint of someone writing a program that uses complex numbers, the
principle of data abstraction suggests that all the operations for
manipulating complex numbers should be available regardless of which
representation is used by the computer.  For example, it is often
useful to be able to find the magnitude of a complex number that is
specified by rectangular coordinates.  Similarly, it is often useful
to be able to determine the real part of a complex number that is
specified by polar coordinates.</p>

<p><image xlink:href="#_110.jpg" /></p>

<p><strong>Figure 2.20:</strong>  Complex numbers as points in the plane.</p>

<p>

To design such a system, we can follow the same data-abstraction
strategy we followed in designing the rational-number package in
section 2.1.1.  Assume that the operations on complex numbers are
implemented in terms of four selectors: real-part,
imag-part, magnitude, and angle.  Also assume that
we have two procedures for constructing complex numbers: make-from-real-imag returns a complex number with specified real and
imaginary parts, and make-from-mag-ang returns a complex number with
specified magnitude and angle.  These procedures have the property that,
for any complex number z, both</p>

<p>(make-from-real-imag (real-part z) (imag-part z))</p><empty-line /><p>
and</p>

<p>(make-from-mag-ang (magnitude z) (angle z))</p><empty-line /><p>
produce complex numbers that are equal to z.</p>

<p>

Using these constructors and selectors, we can implement
arithmetic on complex numbers using the "abstract data" specified by
the constructors and selectors, just as we did for rational numbers in
section 2.1.1.  As shown in the formulas above, we can add and
subtract complex numbers in terms of real and imaginary parts while
multiplying and dividing complex numbers in terms of magnitudes and
angles:</p>

<p>(define (add-complex z1 z2)</p><empty-line /><p>
  (make-from-real-imag (+ (real-part z1) (real-part z2))</p><empty-line /><p>
                       (+ (imag-part z1) (imag-part z2))))</p><empty-line /><p>(define (sub-complex z1 z2)</p><empty-line /><p>
  (make-from-real-imag (- (real-part z1) (real-part z2))</p><empty-line /><p>
                       (- (imag-part z1) (imag-part z2))))</p><empty-line /><p>(define (mul-complex z1 z2)</p><empty-line /><p>
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))</p><empty-line /><p>
                     (+ (angle z1) (angle z2))))</p><empty-line /><p>(define (div-complex z1 z2)</p><empty-line /><p>
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))</p><empty-line /><p>
                     (- (angle z1) (angle z2))))</p><empty-line /><empty-line /><p>

To complete the complex-number package, we must choose a
representation and we must implement the constructors and selectors in
terms of primitive numbers and primitive list structure.
There are two obvious ways to do this: We can represent a complex
number in "rectangular form" as a pair (real part, imaginary part)
or in "polar form" as a pair (magnitude, angle).  Which shall we
choose?</p>

<p>


In order to make the different choices concrete, imagine that there
are two programmers, Ben Bitdiddle and Alyssa P. Hacker, who are
independently designing representations for the complex-number system.
Ben chooses to represent complex numbers in rectangular form.  With
this choice, selecting the real and imaginary parts of a complex
number is straightforward, as is constructing a complex number with
given real and imaginary parts.  To find the magnitude and the angle,
or to construct a complex number with a given magnitude and angle, he
uses the trigonometric relations</p>

<p><image xlink:href="#_111.jpg" /></p>

<p><image xlink:href="#_112.jpg" /></p>

<p>

which relate the real and imaginary parts (<emphasis>x</emphasis>, <emphasis>y</emphasis>) to the magnitude
and the angle (<emphasis>r</emphasis>, <emphasis>A</emphasis>).<sup>44</sup>  Ben's representation is
therefore given by the following selectors and constructors:</p>

<p>(define (real-part z) (car z))</p><empty-line /><p>(define (imag-part z) (cdr z))</p><empty-line /><p>(define (magnitude z)</p><empty-line /><p>
  (sqrt (+ (square (real-part z)) (square (imag-part z)))))</p><empty-line /><p>(define (angle z)</p><empty-line /><p>
  (atan (imag-part z) (real-part z)))</p><empty-line /><p>(define (make-from-real-imag x y) (cons x y))</p><empty-line /><p>(define (make-from-mag-ang r a)</p><empty-line /><p>
  (cons (* r (cos a)) (* r (sin a))))</p><empty-line /><empty-line /><p>

Alyssa, in contrast, chooses to represent complex numbers in polar
form.  For her, selecting the magnitude and angle is straightforward,
but she has to use the trigonometric relations to obtain the real and
imaginary parts.  Alyssa's representation is:</p>

<p>(define (real-part z)</p><empty-line /><p>
  (* (magnitude z) (cos (angle z))))</p><empty-line /><p>(define (imag-part z)</p><empty-line /><p>
  (* (magnitude z) (sin (angle z))))</p><empty-line /><p>(define (magnitude z) (car z))</p><empty-line /><p>(define (angle z) (cdr z))</p><empty-line /><p>(define (make-from-real-imag x y)</p><empty-line /><p>
  (cons (sqrt (+ (square x) (square y)))</p><empty-line /><p>
        (atan y x)))</p><empty-line /><p>(define (make-from-mag-ang r a) (cons r a))</p><empty-line /><empty-line /><p>

The discipline of data abstraction ensures that the same implementation of
add-complex, sub-complex, mul-complex, and div-complex will work with either Ben's representation or Alyssa's
representation.</p>

<p><strong>2.4.2  Tagged data</strong></p>

<p>



One way to view data abstraction is as an application of the
"principle of least commitment."  In implementing the complex-number
system in section 2.4.1, we can
use either Ben's rectangular representation or Alyssa's polar
representation.  The abstraction barrier formed by the selectors and
constructors permits us to defer to the last possible moment the
choice of a concrete representation for our data objects and thus
retain maximum flexibility in our system design.</p>

<p>

The principle of least commitment can be carried to even further
extremes.  If we desire, we can maintain the ambiguity of
representation even <emphasis>after</emphasis> we have designed the selectors and
constructors, and elect to use both Ben's representation <emphasis>and</emphasis>
Alyssa's representation.  If both representations are included in a
single system, however, we will need some way to distinguish data in
polar form from data in rectangular form.  Otherwise, if we were
asked, for instance, to find the magnitude of the pair (3,4),
we wouldn't know whether to answer 5 (interpreting the number in
rectangular form) or 3 (interpreting the number in polar form).  A
straightforward way to accomplish this distinction is to include a
<emphasis>type tag</emphasis> -- the symbol rectangular or polar -- as
part of each complex number.  Then when we need to manipulate a
complex number we can use the tag to decide which selector to apply.</p>

<p>

In order to manipulate tagged data,
we will assume that we have procedures type-tag and contents that extract from a data object the tag and the actual
contents (the polar or rectangular coordinates, in the case of a
complex number).  We will also postulate a procedure attach-tag that takes a tag and contents and produces a tagged data
object.  A straightforward way to implement this is to use ordinary
list structure:</p>

<p>(define (attach-tag type-tag contents)</p><empty-line /><p>
  (cons type-tag contents))</p><empty-line /><p>(define (type-tag datum)</p><empty-line /><p>
  (if (pair? datum)</p><empty-line /><p>
      (car datum)</p><empty-line /><p>
      (error "Bad tagged datum -- TYPE-TAG" datum)))</p><empty-line /><p>(define (contents datum)</p><empty-line /><p>
  (if (pair? datum)</p><empty-line /><p>
      (cdr datum)</p><empty-line /><p>
      (error "Bad tagged datum -- CONTENTS" datum)))</p><empty-line /><empty-line /><p>

Using these procedures, we can define predicates rectangular?
and polar?, which recognize polar and rectangular numbers,
respectively:</p>

<p>(define (rectangular? z)</p><empty-line /><p>
  (eq? (type-tag z) 'rectangular))</p><empty-line /><p>(define (polar? z)</p><empty-line /><p>
  (eq? (type-tag z) 'polar))</p><empty-line /><empty-line /><p>

With type tags, Ben and Alyssa can now modify their code so that
their two different representations can coexist in the same system.
Whenever Ben constructs a complex number, he tags it as rectangular.
Whenever Alyssa constructs a complex number, she tags it as polar.
In addition, Ben and Alyssa must make sure that the names of their
procedures do not conflict.  One way to do this is for Ben to append
the suffix rectangular to the name of each of his representation
procedures and for Alyssa to append polar to the names of hers.
Here is Ben's revised rectangular representation from
section 2.4.1:</p>

<p>(define (real-part-rectangular z) (car z))</p><empty-line /><p>(define (imag-part-rectangular z) (cdr z))</p><empty-line /><p>(define (magnitude-rectangular z)</p><empty-line /><p>
  (sqrt (+ (square (real-part-rectangular z))</p><empty-line /><p>
           (square (imag-part-rectangular z)))))</p><empty-line /><p>(define (angle-rectangular z)</p><empty-line /><p>
  (atan (imag-part-rectangular z)</p><empty-line /><p>
        (real-part-rectangular z)))</p><empty-line /><p>(define (make-from-real-imag-rectangular x y)</p><empty-line /><p>
  (attach-tag 'rectangular (cons x y)))</p><empty-line /><p>(define (make-from-mag-ang-rectangular r a)</p><empty-line /><p>
  (attach-tag 'rectangular</p><empty-line /><p>
              (cons (* r (cos a)) (* r (sin a)))))</p><empty-line /><p>
and here is Alyssa's revised polar representation:</p>

<p>(define (real-part-polar z)</p><empty-line /><p>
  (* (magnitude-polar z) (cos (angle-polar z))))</p><empty-line /><p>(define (imag-part-polar z)</p><empty-line /><p>
  (* (magnitude-polar z) (sin (angle-polar z))))</p><empty-line /><p>(define (magnitude-polar z) (car z))</p><empty-line /><p>(define (angle-polar z) (cdr z))</p><empty-line /><p>(define (make-from-real-imag-polar x y)</p><empty-line /><p>
  (attach-tag 'polar</p><empty-line /><p>
               (cons (sqrt (+ (square x) (square y)))</p><empty-line /><p>
                     (atan y x))))</p><empty-line /><p>(define (make-from-mag-ang-polar r a)</p><empty-line /><p>
  (attach-tag 'polar (cons r a)))</p><empty-line /><empty-line /><p>


Each generic selector is implemented as a procedure that checks the
tag of its argument and calls the appropriate procedure for handling
data of that type.  For example, to obtain the real part of a complex
number, real-part examines the tag to determine whether to use
Ben's real-part-rectangular or Alyssa's real-part-polar.
In either case, we use contents to extract the bare, untagged
datum and send this to the rectangular or polar procedure as required:</p>

<p>(define (real-part z)</p><empty-line /><p>
  (cond ((rectangular? z)</p><empty-line /><p>
         (real-part-rectangular (contents z)))</p><empty-line /><p>
        ((polar? z)</p><empty-line /><p>
         (real-part-polar (contents z)))</p><empty-line /><p>
        (else (error "Unknown type -- REAL-PART" z))))</p><empty-line /><p>(define (imag-part z)</p><empty-line /><p>
  (cond ((rectangular? z)</p><empty-line /><p>
         (imag-part-rectangular (contents z)))</p><empty-line /><p>
        ((polar? z)</p><empty-line /><p>
         (imag-part-polar (contents z)))</p><empty-line /><p>
        (else (error "Unknown type -- IMAG-PART" z))))</p><empty-line /><p>(define (magnitude z)</p><empty-line /><p>
  (cond ((rectangular? z)</p><empty-line /><p>
         (magnitude-rectangular (contents z)))</p><empty-line /><p>
        ((polar? z)</p><empty-line /><p>
         (magnitude-polar (contents z)))</p><empty-line /><p>
        (else (error "Unknown type -- MAGNITUDE" z))))</p><empty-line /><p>(define (angle z)</p><empty-line /><p>
  (cond ((rectangular? z)</p><empty-line /><p>
         (angle-rectangular (contents z)))</p><empty-line /><p>
        ((polar? z)</p><empty-line /><p>
         (angle-polar (contents z)))</p><empty-line /><p>
        (else (error "Unknown type -- ANGLE" z))))</p><empty-line /><empty-line /><p>

To implement the complex-number arithmetic operations, we can use the
same procedures add-complex, sub-complex, mul-complex, and div-complex from
section 2.4.1, because the
selectors they call are generic, and so will work with either
representation.  For example, the procedure add-complex is still</p>

<p>(define (add-complex z1 z2)</p><empty-line /><p>
  (make-from-real-imag (+ (real-part z1) (real-part z2))</p><empty-line /><p>
                       (+ (imag-part z1) (imag-part z2))))</p><empty-line /><empty-line /><p>

Finally, we must choose whether to construct complex numbers using
Ben's representation or Alyssa's representation.  One reasonable
choice is to construct rectangular numbers whenever we have real and
imaginary parts and to construct polar numbers whenever we have
magnitudes and angles:</p>

<p>(define (make-from-real-imag x y)</p><empty-line /><p>
  (make-from-real-imag-rectangular x y))</p><empty-line /><p>(define (make-from-mag-ang r a)</p><empty-line /><p>
  (make-from-mag-ang-polar r a))</p><empty-line /><empty-line /><p><image xlink:href="#_113.jpg" /></p>

<p><strong>Figure 2.21:</strong>  Structure of the generic complex-arithmetic system.</p>

<p>

The resulting complex-number system has the structure shown in
figure 2.21.  The system has been
decomposed into three relatively independent parts: the
complex-number-arithmetic operations, Alyssa's polar
implementation, and Ben's rectangular implementation.  The polar and
rectangular implementations could have been written by Ben and Alyssa
working separately, and both of these can be used as underlying
representations by a third programmer implementing the
complex-arithmetic procedures in terms of the abstract
constructor/selector interface.</p>

<p>

Since each data object is tagged with its type, the selectors operate
on the data in a generic manner.  That is, each selector is defined to
have a behavior that depends upon the particular type of data it is
applied to.  Notice the general mechanism for interfacing the separate
representations: Within a given representation implementation (say,
Alyssa's polar package) a complex number is an untyped pair
(magnitude, angle).  When a generic selector operates on a number of
polar type, it strips off the tag and passes the contents on to
Alyssa's code.  Conversely, when Alyssa constructs a number for general
use, she tags it with a type so that it can be appropriately
recognized by the higher-level procedures.  This discipline of
stripping off and attaching tags as data objects are passed from level
to level can be an important organizational strategy, as we shall see
in section 2.5.</p>

<p><strong>2.4.3  Data-Directed Programming and Additivity</strong></p>

<p>



The general strategy of checking the type of a datum and calling an
appropriate procedure is called <emphasis>dispatching on type</emphasis>.  This is a
powerful strategy for obtaining modularity in system design.  On
the other hand, implementing the dispatch as in
section 2.4.2 has two significant weaknesses.  One
weakness is that the generic interface procedures (real-part,
imag-part, magnitude, and angle) must know about all
the different representations.  For instance, suppose we wanted to
incorporate a new representation for complex numbers into our
complex-number system.  We would need to identify this new
representation with a type, and then add a clause to each of the
generic interface procedures to check for the new type and apply the
appropriate selector for that representation.</p>

<p>

Another weakness of the technique is that even though the individual
representations can be designed separately, we must guarantee that
no two procedures in the entire system have the same name.  This is
why Ben and Alyssa had to change the names of their original
procedures from section 2.4.1.</p>

<p>

The issue underlying both of these weaknesses is that the technique
for implementing generic interfaces is not <emphasis>additive</emphasis>.  The person
implementing the generic selector procedures must modify those
procedures each time a new representation is installed, and the people
interfacing the individual representations must modify their
code to avoid name conflicts.  In each of these cases, the changes
that must be made to the code are straightforward, but they must be
made nonetheless, and this is a source of inconvenience and error.
This is not much of a problem for the complex-number system as it
stands, but suppose there were not two but hundreds of different
representations for complex numbers.  And suppose that there were many
generic selectors to be maintained in the abstract-data interface.
Suppose, in fact, that no one programmer knew all the interface
procedures or all the representations.  The problem is real and must
be addressed in such programs as large-scale data-base-management
systems.</p>

<p>

What we need is a means for modularizing the system design even
further.  This is provided by the programming technique known as <emphasis>data-directed programming</emphasis>.  To understand how data-directed
programming works, begin with the observation that whenever we deal
with a set of generic operations that are common to a set of
different types we are, in effect, dealing with a two-dimensional
table that contains the possible operations on one axis and the
possible types on the other axis.  The entries in the table are the
procedures that implement each operation for each type of argument
presented.  In the complex-number system developed in the previous
section, the correspondence between operation name, data type, and
actual procedure was spread out among the various conditional clauses
in the generic interface procedures.  But the same information could
have been organized in a table, as shown in
figure 2.22.</p>

<p>


Data-directed programming is the technique of designing programs to
work with such a table directly.  Previously, we implemented the
mechanism that interfaces the complex-arithmetic code with the two
representation packages as a set of procedures that each perform an
explicit dispatch on type.  Here we will implement the interface as a single
procedure that looks up the combination of the operation name and
argument type in
the table to find the correct procedure to apply, and then applies it
to the contents of the argument.  If we do this, then to add a new
representation package to the system we need not change any existing
procedures; we need only add new entries to the table.</p>

<p><image xlink:href="#_114.jpg" /></p>

<p><strong>Figure 2.22:</strong>  Table of operations for the complex-number system.</p>

<p>

To implement this plan, assume that we have two procedures,
put and get, for manipulating the
operation-and-type table:</p>

<p>(put &lt;<emphasis>op</emphasis>&gt; &lt;<emphasis>type</emphasis>&gt; &lt;<emphasis>item</emphasis>&gt;)</p><empty-line /><p>
installs the &lt;<emphasis>item</emphasis>&gt; in the table, indexed by the
&lt;<emphasis>op</emphasis>&gt; and the &lt;<emphasis>type</emphasis>&gt;.</p>

<p>(get &lt;<emphasis>op</emphasis>&gt; &lt;<emphasis>type</emphasis>&gt;)</p><empty-line /><p>
looks up the &lt;<emphasis>op</emphasis>&gt;, &lt;<emphasis>type</emphasis>&gt; entry in the table
and returns the item found there.  If no item is found, get
returns false.</p>

<p>

For now, we can assume that put and get are
included in our language.  In chapter 3
(section 3.3.3, exercise 3.24)
we will see how to implement these and
other operations for manipulating tables.</p>

<p>


Here is how data-directed programming can be used in the
complex-number system.  Ben, who developed the rectangular
representation, implements his code just as he did originally.  He
defines a collection of procedures, or a <emphasis>package</emphasis>, and interfaces
these to the rest of the system by adding entries to the table that
tell the system how to operate on rectangular numbers.
This is accomplished by calling the following procedure:</p>

<p>(define (install-rectangular-package)</p><empty-line /><p>
  <emphasis>;; internal procedures</emphasis></p><empty-line /><p>
  (define (real-part z) (car z))</p><empty-line /><p>
  (define (imag-part z) (cdr z))</p><empty-line /><p>
  (define (make-from-real-imag x y) (cons x y))</p><empty-line /><p>
  (define (magnitude z)</p><empty-line /><p>
    (sqrt (+ (square (real-part z))</p><empty-line /><p>
             (square (imag-part z)))))</p><empty-line /><p>
  (define (angle z)</p><empty-line /><p>
    (atan (imag-part z) (real-part z)))</p><empty-line /><p>
  (define (make-from-mag-ang r a)</p><empty-line /><p>
    (cons (* r (cos a)) (* r (sin a))))</p><empty-line /><p>
  <emphasis>;; interface to the rest of the system</emphasis></p><empty-line /><p>
  (define (tag x) (attach-tag 'rectangular x))</p><empty-line /><p>
  (put 'real-part '(rectangular) real-part)</p><empty-line /><p>
  (put 'imag-part '(rectangular) imag-part)</p><empty-line /><p>
  (put 'magnitude '(rectangular) magnitude)</p><empty-line /><p>
  (put 'angle '(rectangular) angle)</p><empty-line /><p>
  (put 'make-from-real-imag 'rectangular</p><empty-line /><p>
       (lambda (x y) (tag (make-from-real-imag x y))))</p><empty-line /><p>
  (put 'make-from-mag-ang 'rectangular</p><empty-line /><p>
       (lambda (r a) (tag (make-from-mag-ang r a))))</p><empty-line /><p>
  'done)</p><empty-line /><empty-line /><p>

Notice that the internal procedures here are the same procedures from
section 2.4.1 that Ben wrote when
he was working in isolation.  No changes are necessary in order to
interface them to the rest of the system.  Moreover, since these
procedure definitions are internal to the installation procedure, Ben
needn't worry about name conflicts with other procedures outside the
rectangular package.  To interface these to the rest of the system,
Ben installs his real-part procedure under the operation name
real-part and the type (rectangular), and similarly
for the other selectors.<sup>45</sup>  The interface also defines
the constructors to be used by the external system.<sup>46</sup>
These are
identical to Ben's internally defined constructors, except that they
attach the tag.</p>

<p>

Alyssa's polar package is analogous:</p>

<p>(define (install-polar-package)</p><empty-line /><p>
  <emphasis>;; internal procedures</emphasis></p><empty-line /><p>
  (define (magnitude z) (car z))</p><empty-line /><p>
  (define (angle z) (cdr z))</p><empty-line /><p>
  (define (make-from-mag-ang r a) (cons r a))</p><empty-line /><p>
  (define (real-part z)</p><empty-line /><p>
    (* (magnitude z) (cos (angle z))))</p><empty-line /><p>
  (define (imag-part z)</p><empty-line /><p>
    (* (magnitude z) (sin (angle z))))</p><empty-line /><p>
  (define (make-from-real-imag x y)</p><empty-line /><p>
    (cons (sqrt (+ (square x) (square y)))</p><empty-line /><p>
          (atan y x)))</p><empty-line /><p>
  <emphasis>;; interface to the rest of the system</emphasis></p><empty-line /><p>
  (define (tag x) (attach-tag 'polar x))</p><empty-line /><p>
  (put 'real-part '(polar) real-part)</p><empty-line /><p>
  (put 'imag-part '(polar) imag-part)</p><empty-line /><p>
  (put 'magnitude '(polar) magnitude)</p><empty-line /><p>
  (put 'angle '(polar) angle)</p><empty-line /><p>
  (put 'make-from-real-imag 'polar</p><empty-line /><p>
       (lambda (x y) (tag (make-from-real-imag x y))))</p><empty-line /><p>
  (put 'make-from-mag-ang 'polar</p><empty-line /><p>
       (lambda (r a) (tag (make-from-mag-ang r a))))</p><empty-line /><p>
  'done)</p><empty-line /><empty-line /><p>

Even though Ben and Alyssa both still use their original procedures
defined with the same names as each other's (e.g., real-part), these
definitions are now internal to different procedures (see
section 1.1.8), so there is no name
conflict.</p>

<p>

The complex-arithmetic selectors access the table by means of a
general "operation" procedure called apply-generic, which
applies a generic operation to some arguments.  Apply-generic
looks in the table under the name of the operation and the types of the
arguments and applies the resulting procedure if one is present:<sup>47</sup></p>

<p>(define (apply-generic op . args)</p><empty-line /><p>
  (let ((type-tags (map type-tag args)))</p><empty-line /><p>
    (let ((proc (get op type-tags)))</p><empty-line /><p>
      (if proc</p><empty-line /><p>
          (apply proc (map contents args))</p><empty-line /><p>
          (error</p><empty-line /><p>
            "No method for these types -- APPLY-GENERIC"</p><empty-line /><p>
            (list op type-tags))))))</p><empty-line /><p>
Using apply-generic, we can define our generic selectors as follows:</p>

<p>(define (real-part z) (apply-generic 'real-part z))</p><empty-line /><p>(define (imag-part z) (apply-generic 'imag-part z))</p><empty-line /><p>(define (magnitude z) (apply-generic 'magnitude z))</p><empty-line /><p>(define (angle z) (apply-generic 'angle z))</p><empty-line /><p>
Observe that these do not change at all if a new representation is
added to the system.</p>

<p>

We can also extract from the table the
constructors to be used by the programs external to the packages in
making complex numbers from real and imaginary parts and from
magnitudes and angles.
As in section 2.4.2, we
construct rectangular numbers whenever we have real and
imaginary parts, and polar numbers whenever we have magnitudes and angles:</p>

<p>(define (make-from-real-imag x y)</p><empty-line /><p>
  ((get 'make-from-real-imag 'rectangular) x y))</p><empty-line /><p>(define (make-from-mag-ang r a)</p><empty-line /><p>
  ((get 'make-from-mag-ang 'polar) r a))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.73.</strong>  Section 2.3.2 described a program that
performs symbolic differentiation:</p>

<p>(define (deriv exp var)</p><empty-line /><p>
  (cond ((number? exp) 0)</p><empty-line /><p>
        ((variable? exp) (if (same-variable? exp var) 1 0))</p><empty-line /><p>
        ((sum? exp)</p><empty-line /><p>
         (make-sum (deriv (addend exp) var)</p><empty-line /><p>
                   (deriv (augend exp) var)))</p><empty-line /><p>
        ((product? exp)</p><empty-line /><p>
         (make-sum</p><empty-line /><p>
           (make-product (multiplier exp)</p><empty-line /><p>
                         (deriv (multiplicand exp) var))</p><empty-line /><p>
           (make-product (deriv (multiplier exp) var)</p><empty-line /><p>
                         (multiplicand exp))))</p><empty-line /><p>
        &lt;<emphasis>more rules can be added here</emphasis>&gt;</p><empty-line /><p>
        (else (error "unknown expression type -- DERIV" exp))))</p><empty-line /><p>
We can regard this program as performing a dispatch on the type of the
expression to be differentiated.  In this situation the "type tag" of the
datum is the algebraic operator symbol (such as +) and the
operation being performed is deriv.  We can transform this
program into data-directed style by rewriting the basic derivative
procedure as</p>

<p>(define (deriv exp var)</p><empty-line /><p>
   (cond ((number? exp) 0)</p><empty-line /><p>
         ((variable? exp) (if (same-variable? exp var) 1 0))</p><empty-line /><p>
         (else ((get 'deriv (operator exp)) (operands exp)</p><empty-line /><p>
                                            var))))</p><empty-line /><p>
(define (operator exp) (car exp))</p><empty-line /><p>
(define (operands exp) (cdr exp))</p><empty-line /><empty-line /><p>

a.  Explain what was done above.
Why can't we assimilate the predicates number? and same-variable? into the data-directed dispatch?</p>

<p>

b.  Write the procedures for derivatives of sums and products, and the
auxiliary code required to install them in the table used by the
program above.</p>

<p>

c.  Choose any additional differentiation rule that you like, such as
the one for exponents (exercise 2.56),
and install it in this data-directed system.</p>

<p>

d.  In this simple algebraic manipulator the type of an expression is
the algebraic operator that binds it together.  Suppose, however, we
indexed the procedures in the opposite way, so that the dispatch line
in deriv looked like</p>

<p>((get (operator exp) 'deriv) (operands exp) var)</p><empty-line /><p>
What corresponding changes to the derivative system are required?</p>

<p>
<strong>Exercise 2.74.</strong>  Insatiable Enterprises, Inc., is a highly decentralized conglomerate
company consisting of a large number of independent divisions located
all over the world.  The company's computer facilities have just been
interconnected by means of a clever network-interfacing scheme that
makes the entire network appear to any user to be a single computer.
Insatiable's president, in her first attempt to exploit the ability of
the network to extract administrative information from division files,
is dismayed to discover that, although all the division files have
been implemented as data structures in Scheme, the particular data
structure used varies from division to division.  A meeting of
division managers is hastily called to search for a strategy to
integrate the files that will satisfy headquarters' needs while
preserving the existing autonomy of the divisions.</p>

<p>

Show how such a strategy can be implemented with data-directed
programming.  As an example, suppose that each division's personnel
records consist of a single file, which contains a set of records
keyed on employees' names.  The structure of the set varies from
division to division.  Furthermore, each employee's record is itself a
set (structured differently from division to division) that contains
information keyed under identifiers such as address and salary.  In particular:</p>

<p>

a.  Implement for headquarters a get-record procedure that
retrieves a specified employee's record from a specified personnel
file.  The procedure should be applicable to any division's file.
Explain how the individual divisions' files should be structured.  In
particular, what type information must be supplied?</p>

<p>

b.  Implement for headquarters a get-salary procedure that
returns the salary information from a given employee's record from any
division's personnel file.  How should the record be structured in
order to make this operation work?</p>

<p>

c.  Implement for headquarters a find-employee-record procedure.
This should search all the divisions' files for the record of a given
employee and return the record.  Assume that this procedure takes as
arguments an employee's name and a list of all the divisions' files.</p>

<p>

d.  When Insatiable takes over a new company, what changes must
be made in order to incorporate the new personnel information into the
central system?</p>

<p><strong>Message passing</strong></p>

<p>


The key idea of data-directed programming is to handle generic
operations in programs by dealing explicitly with operation-and-type
tables, such as the table in figure 2.22.  The
style of programming we used in section 2.4.2
organized the required dispatching on type by having each operation
take care of its own dispatching.  In effect, this decomposes the
operation-and-type table into rows, with each generic operation
procedure representing a row of the table.</p>

<p>

An alternative implementation strategy is to decompose the table into
columns and, instead of using "intelligent operations" that dispatch
on data types, to work with "intelligent data objects" that dispatch
on operation names.  We can do this by arranging things so that a data
object, such as a rectangular number, is represented as a procedure
that takes as input the required operation name and performs the
operation indicated.  In such a discipline, make-from-real-imag
could be written as</p>

<p>(define (make-from-real-imag x y)</p><empty-line /><p>
  (define (dispatch op)</p><empty-line /><p>
    (cond ((eq? op 'real-part) x)</p><empty-line /><p>
          ((eq? op 'imag-part) y)</p><empty-line /><p>
          ((eq? op 'magnitude)</p><empty-line /><p>
           (sqrt (+ (square x) (square y))))</p><empty-line /><p>
          ((eq? op 'angle) (atan y x))</p><empty-line /><p>
          (else</p><empty-line /><p>
           (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))</p><empty-line /><p>
  dispatch)</p><empty-line /><p>
The corresponding apply-generic procedure, which applies a
generic operation to an argument, now simply feeds the operation's
name to the data object and lets the object do the work:<sup>48</sup></p>

<p>(define (apply-generic op arg) (arg op))</p><empty-line /><p>
Note that the value returned by make-from-real-imag is a
procedure -- the internal dispatch procedure.  This is the
procedure that is invoked when apply-generic requests an operation to
be performed.</p>

<p>

This style of programming is called <emphasis>message passing</emphasis>.  The name
comes from the image that a data object is an entity that receives the
requested operation name as a "message."  We have already seen an
example of message passing in section 2.1.3, where we saw
how cons, car, and cdr could be defined with no data
objects but only procedures.  Here we see that message passing is not
a mathematical trick but a useful technique for organizing systems
with generic operations.  In the remainder of this chapter we will
continue to use data-directed programming, rather than message
passing, to discuss generic arithmetic operations.  In chapter 3 we
will return to message passing, and we will see that it can be a
powerful tool for structuring simulation programs.</p>

<p>
<strong>Exercise 2.75.</strong>  Implement the constructor make-from-mag-ang in message-passing style.
This procedure should be analogous to the make-from-real-imag
procedure given above.</p>

<p>
<strong>Exercise 2.76.</strong>  As a large system with generic operations evolves, new types of data
objects or new operations may be needed.  For each of the three
strategies -- generic operations with explicit dispatch, data-directed
style, and message-passing-style -- describe the changes that must be
made to a system in order to add new types or new operations.  Which
organization would be most appropriate for a system in which new types
must often be added?  Which would be most appropriate for a system in
which new operations must often be added?</p><empty-line /><empty-line /><empty-line /><p><sup>43</sup> In actual computational systems, rectangular form is
preferable to polar form most of the time because of roundoff errors
in conversion between rectangular and polar form.  This is why the
complex-number example is unrealistic.  Nevertheless, it provides a
clear illustration of the design of a system using generic operations
and a good introduction to the more substantial systems to be
developed later in this chapter.</p>

<p><sup>44</sup> The arctangent function referred to
here, computed by Scheme's atan procedure,
is defined so as to take two arguments <emphasis>y</emphasis> and <emphasis>x</emphasis> and to return
the angle whose tangent is <emphasis>y</emphasis>/<emphasis>x</emphasis>.  The signs of the arguments
determine the quadrant of the angle.</p>

<p><sup>45</sup> We use the list (rectangular)
rather than the symbol rectangular to allow for the possibility
of operations with multiple arguments, not all of the same
type.</p>

<p><sup>46</sup> The
type the constructors are installed under needn't be a list because
a constructor is always used to make an object of one particular
type.</p>

<p><sup>47</sup> Apply-generic uses the dotted-tail notation described in
exercise 2.20, because different generic operations
may take different numbers of arguments.  In apply-generic, op has as its value the first argument to apply-generic and
args has as its value a list of the remaining arguments.</p>

<p>

Apply-generic also uses the primitive procedure apply,
which takes two arguments, a procedure and a list.  Apply
applies the procedure, using the elements in the list as arguments.
For example,</p>

<p>(apply + (list 1 2 3 4))</p><empty-line /><p>
returns 10.</p>

<p><sup>48</sup> One
limitation of this organization is it permits only generic procedures
of one argument.</p>


</section>

<section>


<p><strong>2.5  Systems with Generic Operations</strong></p>

<p>

In the previous section, we saw how to design systems in which data
objects can be represented in more than one way.  The key idea is to
link the code that specifies the data operations to the several
representations by means of generic interface procedures.  Now we will
see how to use this same idea not only to define operations that are
generic over different representations but also to define operations
that are generic over different kinds of arguments.  We have already
seen several different packages of arithmetic operations: the primitive
arithmetic (+, -, *, /) built into our
language, the rational-number arithmetic (add-rat, sub-rat, mul-rat, div-rat) of
section 2.1.1, and the complex-number arithmetic that we
implemented in section 2.4.3.  We will now use
data-directed techniques to construct a package of arithmetic
operations that incorporates all the arithmetic packages we have already
constructed.</p>

<p>

Figure 2.23 shows the structure of the system we
shall build.  Notice the abstraction barriers.  From the perspective
of someone using "numbers", there is a single procedure add
that operates on whatever numbers are supplied.  Add is part of
a generic interface that allows the separate ordinary-arithmetic,
rational-arithmetic, and complex-arithmetic packages to be accessed
uniformly by programs that use numbers.  Any individual arithmetic
package (such as the complex package) may itself be accessed through
generic procedures (such as add-complex) that combine packages
designed for different representations (such as rectangular and
polar).  Moreover, the structure of the system is additive, so
that one can design the individual arithmetic packages separately and
combine them to produce a generic arithmetic system.</p>

<p><image xlink:href="#_115.jpg" /></p>

<p><strong>Figure 2.23:</strong>  Generic arithmetic system.</p>

<p><strong>2.5.1  Generic Arithmetic Operations</strong></p>

<p>



The task of designing generic arithmetic operations is analogous to
that of designing the generic complex-number operations.  We would
like, for instance, to have a generic addition procedure add that
acts like ordinary primitive addition + on ordinary numbers,
like add-rat on rational numbers, and like add-complex on
complex numbers.  We can implement add, and the other generic
arithmetic operations, by following the same strategy we used in
section 2.4.3 to implement the generic selectors for
complex numbers.  We will attach a type tag to each kind of
number and cause the generic procedure to dispatch to an appropriate
package according to the data type of its arguments.</p>

<p>

The generic arithmetic procedures are defined as follows:</p>

<p>(define (add x y) (apply-generic 'add x y))</p><empty-line /><p>(define (sub x y) (apply-generic 'sub x y))</p><empty-line /><p>(define (mul x y) (apply-generic 'mul x y))</p><empty-line /><p>(define (div x y) (apply-generic 'div x y))</p><empty-line /><empty-line /><p>

We begin by installing a package for handling <emphasis>ordinary</emphasis> numbers,
that is, the primitive numbers of our language.  We will tag these
with the symbol scheme-number.  The arithmetic operations in this
package are the primitive arithmetic procedures (so there is no need to
define extra procedures to handle the untagged numbers).  Since
these operations each take two arguments, they are installed in the
table keyed by the list (scheme-number scheme-number):</p>

<p>(define (install-scheme-number-package)</p><empty-line /><p>
  (define (tag x)</p><empty-line /><p>
    (attach-tag 'scheme-number x))</p><empty-line /><p>
  (put 'add '(scheme-number scheme-number)</p><empty-line /><p>
       (lambda (x y) (tag (+ x y))))</p><empty-line /><p>
  (put 'sub '(scheme-number scheme-number)</p><empty-line /><p>
       (lambda (x y) (tag (- x y))))</p><empty-line /><p>
  (put 'mul '(scheme-number scheme-number)</p><empty-line /><p>
       (lambda (x y) (tag (* x y))))</p><empty-line /><p>
  (put 'div '(scheme-number scheme-number)</p><empty-line /><p>
       (lambda (x y) (tag (/ x y))))</p><empty-line /><p>
  (put 'make 'scheme-number</p><empty-line /><p>
       (lambda (x) (tag x)))</p><empty-line /><p>
  'done)</p><empty-line /><empty-line /><p>


Users of the Scheme-number package
will create (tagged) ordinary numbers by means of the procedure:</p>

<p>(define (make-scheme-number n)</p><empty-line /><p>
  ((get 'make 'scheme-number) n))</p><empty-line /><empty-line /><p>

Now that the framework of the generic arithmetic system is in place,
we can readily include new kinds of numbers.  Here is a package that
performs rational arithmetic.  Notice that, as a benefit of
additivity, we can use without modification the rational-number code
from section 2.1.1 as the internal procedures in the
package:</p>

<p>(define (install-rational-package)</p><empty-line /><p>
  <emphasis>;; internal procedures</emphasis></p><empty-line /><p>
  (define (numer x) (car x))</p><empty-line /><p>
  (define (denom x) (cdr x))</p><empty-line /><p>
  (define (make-rat n d)</p><empty-line /><p>
    (let ((g (gcd n d)))</p><empty-line /><p>
      (cons (/ n g) (/ d g))))</p><empty-line /><p>
  (define (add-rat x y)</p><empty-line /><p>
    (make-rat (+ (* (numer x) (denom y))</p><empty-line /><p>
                 (* (numer y) (denom x)))</p><empty-line /><p>
              (* (denom x) (denom y))))</p><empty-line /><p>
  (define (sub-rat x y)</p><empty-line /><p>
    (make-rat (- (* (numer x) (denom y))</p><empty-line /><p>
                 (* (numer y) (denom x)))</p><empty-line /><p>
              (* (denom x) (denom y))))</p><empty-line /><p>
  (define (mul-rat x y)</p><empty-line /><p>
    (make-rat (* (numer x) (numer y))</p><empty-line /><p>
              (* (denom x) (denom y))))</p><empty-line /><p>
  (define (div-rat x y)</p><empty-line /><p>
    (make-rat (* (numer x) (denom y))</p><empty-line /><p>
              (* (denom x) (numer y))))</p><empty-line /><p>
  <emphasis>;; interface to rest of the system</emphasis></p><empty-line /><p>
  (define (tag x) (attach-tag 'rational x))</p><empty-line /><p>
  (put 'add '(rational rational)</p><empty-line /><p>
       (lambda (x y) (tag (add-rat x y))))</p><empty-line /><p>
  (put 'sub '(rational rational)</p><empty-line /><p>
       (lambda (x y) (tag (sub-rat x y))))</p><empty-line /><p>
  (put 'mul '(rational rational)</p><empty-line /><p>
       (lambda (x y) (tag (mul-rat x y))))</p><empty-line /><p>
  (put 'div '(rational rational)</p><empty-line /><p>
       (lambda (x y) (tag (div-rat x y))))</p><empty-line /><empty-line /><p>
  (put 'make 'rational</p><empty-line /><p>
       (lambda (n d) (tag (make-rat n d))))</p><empty-line /><p>
  'done)</p><empty-line /><p>(define (make-rational n d)</p><empty-line /><p>
  ((get 'make 'rational) n d))</p><empty-line /><empty-line /><p>

We can install a similar package to handle complex numbers, using the
tag complex.  In creating the package, we extract from the table
the operations make-from-real-imag and make-from-mag-ang
that were defined by the rectangular and polar packages.  Additivity
permits us to use, as the internal operations, the same add-complex, sub-complex, mul-complex, and div-complex procedures from
section 2.4.1.</p>

<p>(define (install-complex-package)</p><empty-line /><p>
  <emphasis>;; imported procedures from rectangular and polar packages</emphasis></p><empty-line /><p>
  (define (make-from-real-imag x y)</p><empty-line /><p>
    ((get 'make-from-real-imag 'rectangular) x y))</p><empty-line /><p>
  (define (make-from-mag-ang r a)</p><empty-line /><p>
    ((get 'make-from-mag-ang 'polar) r a))</p><empty-line /><p>
  <emphasis>;; internal procedures</emphasis></p><empty-line /><p>
  (define (add-complex z1 z2)</p><empty-line /><p>
    (make-from-real-imag (+ (real-part z1) (real-part z2))</p><empty-line /><p>
                         (+ (imag-part z1) (imag-part z2))))</p><empty-line /><p>
  (define (sub-complex z1 z2)</p><empty-line /><p>
    (make-from-real-imag (- (real-part z1) (real-part z2))</p><empty-line /><p>
                         (- (imag-part z1) (imag-part z2))))</p><empty-line /><p>
  (define (mul-complex z1 z2)</p><empty-line /><p>
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))</p><empty-line /><p>
                       (+ (angle z1) (angle z2))))</p><empty-line /><p>
  (define (div-complex z1 z2)</p><empty-line /><p>
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))</p><empty-line /><p>
                       (- (angle z1) (angle z2))))</p><empty-line /><p>
  <emphasis>;; interface to rest of the system</emphasis></p><empty-line /><p>
  (define (tag z) (attach-tag 'complex z))</p><empty-line /><p>
  (put 'add '(complex complex)</p><empty-line /><p>
       (lambda (z1 z2) (tag (add-complex z1 z2))))</p><empty-line /><p>
  (put 'sub '(complex complex)</p><empty-line /><p>
       (lambda (z1 z2) (tag (sub-complex z1 z2))))</p><empty-line /><p>
  (put 'mul '(complex complex)</p><empty-line /><p>
       (lambda (z1 z2) (tag (mul-complex z1 z2))))</p><empty-line /><p>
  (put 'div '(complex complex)</p><empty-line /><p>
       (lambda (z1 z2) (tag (div-complex z1 z2))))</p><empty-line /><p>
  (put 'make-from-real-imag 'complex</p><empty-line /><p>
       (lambda (x y) (tag (make-from-real-imag x y))))</p><empty-line /><p>
  (put 'make-from-mag-ang 'complex</p><empty-line /><p>
       (lambda (r a) (tag (make-from-mag-ang r a))))</p><empty-line /><p>
  'done)</p><empty-line /><empty-line /><p>

Programs outside the complex-number package can construct complex
numbers either from real and imaginary parts or from magnitudes and
angles.  Notice how the underlying procedures, originally defined in
the rectangular and polar packages, are exported to the complex
package, and exported from there to the outside world.</p>

<p>(define (make-complex-from-real-imag x y)</p><empty-line /><p>
  ((get 'make-from-real-imag 'complex) x y))</p><empty-line /><p>(define (make-complex-from-mag-ang r a)</p><empty-line /><p>
  ((get 'make-from-mag-ang 'complex) r a))</p><empty-line /><empty-line /><p>

What we have here is a two-level tag system.  A typical complex number,
such as 3 + 4<emphasis>i</emphasis> in rectangular form, would be
represented as shown in figure 2.24.
The outer tag (complex) is used to direct the number to the
complex package.  Once within the complex package, the next tag (rectangular) is used to direct the number to the rectangular package.
In a large and complicated system there might be many levels, each
interfaced with the next by means of generic operations.  As a data
object is passed "downward", the outer tag that is used to direct
it to the appropriate package is stripped off (by applying contents) and the next level of tag (if any) becomes visible to be used for
further dispatching.</p>

<p><image xlink:href="#_116.jpg" /></p>

<p><strong>Figure 2.24:</strong>  Representation of 3 + 4<emphasis>i</emphasis> in rectangular form.</p>

<p>

In the above packages, we used add-rat, add-complex, and
the other arithmetic procedures exactly as originally written.
Once these definitions are internal to different installation procedures,
however, they no longer need names that are distinct from each other:
we could simply name them add, sub, mul, and div
in both packages.</p>

<p>
<strong>Exercise 2.77.</strong>  Louis Reasoner tries to evaluate the
expression (magnitude z) where z is the object
shown in figure 2.24.  To his
surprise, instead of the answer 5
he gets an error message from apply-generic,
saying there is no method for the operation magnitude
on the types (complex).
He shows this interaction to Alyssa P. Hacker, who says
"The problem is that the complex-number selectors were never
defined for complex numbers, just for polar and rectangular
numbers.  All you have to do to make this work is add the following
to the complex package:"</p>

<p>(put 'real-part '(complex) real-part)</p><empty-line /><p>
(put 'imag-part '(complex) imag-part)</p><empty-line /><p>
(put 'magnitude '(complex) magnitude)</p><empty-line /><p>
(put 'angle '(complex) angle)</p><empty-line /><p>
Describe in detail why this works.  As an example, trace through all
the procedures called in evaluating the expression (magnitude z)
where z is the object shown in
figure 2.24.  In particular, how many
times is apply-generic invoked?  What procedure is dispatched to
in each case?</p>

<p>
<strong>Exercise 2.78.</strong>  The internal procedures in the scheme-number package are essentially
nothing more than calls to the primitive procedures +, -,
etc.  It was not possible to use the primitives of the language
directly because our type-tag system requires that each data
object have a type attached to it.  In fact, however, all Lisp
implementations do have a type system, which they use internally.
Primitive predicates such as symbol? and number?
determine whether data objects have particular types.  Modify the
definitions of type-tag, contents, and attach-tag
from section 2.4.2 so that our generic system takes
advantage of Scheme's internal type system.  That is to say, the system
should work as before except that ordinary numbers should be
represented simply as Scheme numbers rather than as pairs whose car is
the symbol scheme-number.</p>

<p>
<strong>Exercise 2.79.</strong>  Define a generic equality predicate equ? that tests the equality
of two numbers, and install it in the generic arithmetic
package.  This operation should work for ordinary numbers, rational numbers, and
complex numbers.</p>

<p>
<strong>Exercise 2.80.</strong>  Define a generic
predicate =zero? that tests if its argument is zero,
and install it in the generic arithmetic package.  This
operation should work for ordinary numbers, rational numbers, and
complex numbers.</p>

<p><strong>2.5.2  Combining Data of Different Types</strong></p>

<p>

We have seen how to define a unified arithmetic system that
encompasses ordinary numbers, complex numbers, rational numbers, and
any other type of number we might decide to invent, but we have
ignored an important issue.  The operations we have defined so far
treat the different data types as being completely independent.  Thus,
there are separate packages for adding, say, two ordinary numbers, or
two complex numbers.  What we have not yet considered is the fact that
it is meaningful to define operations that cross the type boundaries,
such as the addition of a complex number to an ordinary number.  We
have gone to great pains to introduce barriers between parts of our
programs so that they can be developed and understood separately.  We
would like to introduce the cross-type operations in some carefully
controlled way, so that we can support them
without seriously violating our module boundaries.</p>

<p>

One way to handle cross-type operations is to design a different
procedure for each possible combination of types for which the
operation is valid.  For example, we could extend the complex-number
package so that it provides a procedure for adding complex numbers to
ordinary numbers and installs this in the table using the tag (complex scheme-number):<sup>49</sup></p>

<p><emphasis>;; to be included in the complex package</emphasis></p><empty-line /><p>(define (add-complex-to-schemenum z x)</p><empty-line /><p>
  (make-from-real-imag (+ (real-part z) x)</p><empty-line /><p>
                       (imag-part z)))</p><empty-line /><p>
(put 'add '(complex scheme-number)</p><empty-line /><p>
     (lambda (z x) (tag (add-complex-to-schemenum z x))))</p><empty-line /><empty-line /><p>

This technique works, but it is cumbersome.  With such a system, the
cost of introducing a new type is not just the construction of the
package of procedures for that type but also the construction and
installation of the procedures that implement the cross-type
operations.  This can easily be much more code than is needed to
define the operations on the type itself.  The method also undermines
our ability to combine separate packages additively, or
least to limit the extent to which the implementors of the individual
packages need to take account of other packages.  For instance, in the
example above, it seems reasonable that handling mixed operations on
complex numbers and ordinary numbers should be the responsibility of
the complex-number package.  Combining rational numbers and complex
numbers, however, might be done by the complex package, by the
rational package, or by some third package that uses operations
extracted from these two packages.  Formulating coherent policies on the
division of responsibility among packages can be an overwhelming task
in designing systems with many packages and many cross-type
operations.</p>

<p><strong>Coercion</strong></p>

<p>


In the general situation of completely unrelated operations acting on
completely unrelated types, implementing explicit cross-type
operations, cumbersome though it may be, is the best that one can hope
for.  Fortunately, we can usually do better by taking advantage of
additional structure that may be latent in our type system.  Often the
different data types are not completely independent, and there may be
ways by which objects of one type may be viewed as being of another
type.  This process is called <emphasis>coercion</emphasis>.  For example, if we are
asked to arithmetically combine an ordinary number with a complex
number, we can view the ordinary number as a complex number whose
imaginary part is zero.  This transforms the problem to that of
combining two complex numbers, which can be handled in the ordinary
way by the complex-arithmetic package.</p>

<p>

In general, we can implement this idea by designing coercion
procedures that transform an object of one type into an equivalent
object of another type.  Here is a typical coercion procedure, which
transforms a given ordinary number to a complex number with that real
part and zero imaginary part:</p>

<p>(define (scheme-number-&gt;complex n)</p><empty-line /><p>
  (make-complex-from-real-imag (contents n) 0))</p><empty-line /><p>
We install these coercion procedures in a special coercion table,
indexed under the names of the two types:</p>

<p>(put-coercion 'scheme-number 'complex scheme-number-&gt;complex)</p><empty-line /><p>
(We assume that there are put-coercion and get-coercion
procedures available for manipulating this table.)  Generally some of
the slots in the table will be empty, because it is not generally
possible to coerce an arbitrary data object of each type into all
other types.  For example, there is no way to coerce an arbitrary
complex number to an ordinary number, so there will be no general complex-&gt;scheme-number procedure included in the table.</p>

<p>

Once the coercion table has been set up, we can handle coercion in a
uniform manner by modifying the apply-generic procedure of
section 2.4.3.  When asked to apply an operation, we
first check whether the operation is defined for the arguments' types,
just as before.  If so, we dispatch to the procedure found in the
operation-and-type table.
Otherwise, we try coercion.  For simplicity, we consider only the case
where there are two arguments.<sup>50</sup>  We
check the coercion table to see if objects of the first type can
be coerced to the second type.  If so, we coerce the first argument and try the
operation again.  If objects of the first type cannot in general be coerced to
the second type, we try the coercion the other way around to see if there is a
way to coerce the second argument to the type of the first argument.
Finally, if there
is no known way to coerce either type to the other type, we give up.
Here is the procedure:</p>

<p>(define (apply-generic op . args)</p><empty-line /><p>
  (let ((type-tags (map type-tag args)))</p><empty-line /><p>
    (let ((proc (get op type-tags)))</p><empty-line /><p>
      (if proc</p><empty-line /><p>
          (apply proc (map contents args))</p><empty-line /><p>
          (if (= (length args) 2)</p><empty-line /><p>
              (let ((type1 (car type-tags))</p><empty-line /><p>
                    (type2 (cadr type-tags))</p><empty-line /><p>
                    (a1 (car args))</p><empty-line /><p>
                    (a2 (cadr args)))</p><empty-line /><p>
                (let ((t1-&gt;t2 (get-coercion type1 type2))</p><empty-line /><p>
                      (t2-&gt;t1 (get-coercion type2 type1)))</p><empty-line /><p>
                  (cond (t1-&gt;t2</p><empty-line /><p>
                         (apply-generic op (t1-&gt;t2 a1) a2))</p><empty-line /><p>
                        (t2-&gt;t1</p><empty-line /><p>
                         (apply-generic op a1 (t2-&gt;t1 a2)))</p><empty-line /><p>
                        (else</p><empty-line /><p>
                         (error "No method for these types"</p><empty-line /><p>
                                (list op type-tags))))))</p><empty-line /><p>
              (error "No method for these types"</p><empty-line /><p>
                     (list op type-tags)))))))</p><empty-line /><empty-line /><p>

This coercion scheme has many advantages over the method of defining
explicit cross-type operations, as outlined above.  Although we still
need to write coercion procedures to relate the types (possibly <emphasis>n</emphasis><sup>2</sup>
procedures for a system with <emphasis>n</emphasis> types), we need to write only one
procedure for each pair of types rather than a different procedure for
each collection of types and each generic operation.<sup>51</sup>  What we are counting on here is the fact that the
appropriate transformation between types depends only on the types
themselves, not on the operation to be applied.</p>

<p>

On the other hand, there may be applications for which our coercion
scheme is not general enough.  Even when neither of the objects to be
combined can be converted to the type of the other it may still be
possible to perform the operation by converting both objects to a
third type.  In order to deal with such complexity and still preserve
modularity in our programs, it is usually necessary to build systems
that take advantage of still further structure in the relations among
types, as we discuss next.</p>

<p><strong>Hierarchies of types</strong></p>

<p>


The coercion scheme presented above relied on the existence of natural
relations between pairs of types.  Often there is more "global"
structure in how the different types relate to each other.  For
instance, suppose we are building a generic arithmetic system to
handle integers, rational numbers, real numbers, and complex numbers.
In such a system, it is quite natural to regard an integer as a
special kind of rational number, which is in turn a special kind of
real number, which is in turn a special kind of complex number.  What
we actually have is a so-called <emphasis>hierarchy of types</emphasis>, in which,
for example, integers are a <emphasis>subtype</emphasis> of rational numbers (i.e.,
any operation that can be applied to a rational number can
automatically be applied to an integer).  Conversely, we say that
rational numbers form a <emphasis>supertype</emphasis> of integers.  The particular
hierarchy we have here is of a very simple kind, in which each type
has at most one supertype and at most one subtype.  Such a structure,
called a <emphasis>tower</emphasis>, is illustrated in figure 2.25.</p>

<p><image xlink:href="#_117.jpg" /></p>

<p><strong>Figure 2.25:</strong>  A tower of types.</p>

<p>

If we have a tower structure, then we can greatly simplify the problem
of adding a new type to the hierarchy, for we need only specify how
the new type is embedded in the next supertype above it and how it is
the supertype of the type below it.  For example, if we want to add an
integer to a complex number, we need not explicitly define a special
coercion procedure integer-&gt;complex.  Instead, we define how an
integer can be transformed into a rational number, how a rational
number is transformed into a real number, and how a real number is
transformed into a complex number.  We then allow the system to
transform the integer into a complex number through these steps and
then add the two complex numbers.</p>

<p>

We can redesign our apply-generic procedure in the following
way: For each type, we need to supply a raise procedure, which
"raises" objects of that type one level in the tower.  Then when the
system is required to operate on objects of different types it can
successively raise the lower types until all the objects are at
the same level in the tower.  (Exercises 2.83
and  2.84
concern the details of implementing such a strategy.)</p>

<p>

Another advantage of a tower is that we can easily implement the
notion that every type "inherits" all operations defined on a
supertype.  For instance, if we do not supply a special procedure for
finding the real part of an integer, we should nevertheless expect
that real-part will be defined for integers by virtue of the
fact that integers are a subtype of complex numbers.  In a tower, we
can arrange for this to happen in a uniform way by modifying apply-generic.  If the required operation is not directly defined for
the type of the object given, we raise the object to its supertype and
try again.  We thus crawl up the tower, transforming our argument as we
go, until we either find a level at which the desired operation can be
performed or hit the top (in which case we give up).</p>

<p>

Yet another advantage of a tower over a more general hierarchy is that
it gives us a simple way to "lower" a data object to the simplest
representation.  For example, if we add 2 + 3<emphasis>i</emphasis> to 4 - 3<emphasis>i</emphasis>, it would be
nice to obtain the answer as the integer 6 rather than as the complex
number 6 + 0<emphasis>i</emphasis>.  Exercise 2.85 discusses a way to implement
such a lowering operation.  (The trick is that we need a general way
to distinguish those objects that can be lowered, such as 6 + 0<emphasis>i</emphasis>, from
those that cannot, such as 6 + 2<emphasis>i</emphasis>.)</p>

<p><image xlink:href="#_118.jpg" /></p>

<p><strong>Figure 2.26:</strong>  Relations among types of geometric figures.</p>

<p><strong>Inadequacies of hierarchies</strong></p>

<p>



If the data types in our system can be naturally arranged in a tower,
this greatly simplifies the problems of dealing with generic operations
on different types, as we have seen.  Unfortunately, this is usually
not the case.  Figure 2.26 illustrates a
more complex arrangement of mixed types, this one showing relations
among different types of geometric figures.  We see that, in general,
a type may have more than one subtype.  Triangles and quadrilaterals,
for instance, are both subtypes of polygons.  In addition, a type may
have more than one supertype.  For example, an isosceles right
triangle may be regarded either as an isosceles triangle or as a right
triangle.  This multiple-supertypes issue is particularly thorny,
since it means that there is no unique way to "raise" a type in the
hierarchy.  Finding the "correct" supertype in which to apply an
operation to an object may involve considerable searching through the
entire type network on the part of a procedure such as apply-generic.  Since there generally are multiple subtypes for a
type, there is a similar problem in coercing a value "down" the type
hierarchy.  Dealing with large numbers of interrelated types while
still preserving modularity in the design of large systems is very
difficult, and is an area of much current research.<sup>52</sup></p>

<p>
<strong>Exercise 2.81.</strong>  Louis Reasoner has noticed that apply-generic may try to
coerce the arguments to each other's type even if they already have
the same type.  Therefore, he reasons, we need to put procedures
in the coercion table to "coerce" arguments of each type to their
own type.  For example, in addition to the scheme-number-&gt;complex
coercion shown above, he would do:</p>

<p>(define (scheme-number-&gt;scheme-number n) n)</p><empty-line /><p>(define (complex-&gt;complex z) z)</p><empty-line /><p>
(put-coercion 'scheme-number 'scheme-number</p><empty-line /><p>
              scheme-number-&gt;scheme-number)</p><empty-line /><p>
(put-coercion 'complex 'complex complex-&gt;complex)</p><empty-line /><empty-line /><p>a. With Louis's coercion procedures installed, what happens if apply-generic
is called with two arguments of type scheme-number or two arguments of
type complex for an operation that is not found in the table for those
types?  For example, assume that we've defined a generic exponentiation
operation:</p>

<p>(define (exp x y) (apply-generic 'exp x y))</p><empty-line /><p>
and have put a procedure for exponentiation in the Scheme-number
package but not in any other package:</p>

<p><emphasis>;; following added to Scheme-number package</emphasis></p><empty-line /><p>
(put 'exp '(scheme-number scheme-number)</p><empty-line /><p>
     (lambda (x y) (tag (expt x y)))) <emphasis>; using primitive expt</emphasis></p><empty-line /><p>
What happens if we call exp with two complex numbers as arguments?</p>

<p>b. Is Louis correct that something had to be done about
coercion with arguments of the same type, or does apply-generic
work correctly as is?</p>

<p>c. Modify apply-generic so that it doesn't try coercion if
the two arguments have the same type.</p>

<p>
<strong>Exercise 2.82.</strong>  Show how to generalize apply-generic to handle
coercion in the general case of multiple arguments.  One strategy is
to attempt to coerce all the arguments to the type of the first argument, then
to the type of the second argument, and so on.  Give an example of a situation
where this strategy (and likewise the two-argument version given
above) is not sufficiently general.  (Hint: Consider the case where
there are some suitable mixed-type operations present in the table
that will not be tried.)</p>

<p>
<strong>Exercise 2.83.</strong>  Suppose you are designing a generic arithmetic system for dealing with
the tower of types shown in figure 2.25:
integer, rational, real, complex.  For
each type (except complex), design a procedure that raises objects of
that type one level in the tower.  Show how to install a generic raise operation that will work for each type (except complex).</p>

<p>
<strong>Exercise 2.84.</strong>  Using the raise operation of exercise 2.83, modify the apply-generic procedure so that it coerces its arguments to have the
same type by the method of successive raising, as discussed in this
section.  You will need to devise a way to test which of two types is
higher in the tower.  Do this in a manner that is "compatible" with
the rest of the system and will not lead to problems in adding new
levels to the tower.</p>

<p>
<strong>Exercise 2.85.</strong>  This section mentioned a method for "simplifying" a data object
by lowering it in the tower of types as far as possible.  Design
a procedure drop that accomplishes this for the tower described
in exercise 2.83.  The key is to decide, in some general way, whether
an object can be lowered.  For example, the complex number 1.5 + 0<emphasis>i</emphasis>
can be lowered as far as real, the complex number 1 + 0<emphasis>i</emphasis> can be
lowered as far as integer, and the complex number 2 + 3<emphasis>i</emphasis> cannot
be lowered at all.  Here is a plan for determining whether an object
can be lowered: Begin by defining a generic operation project
that "pushes" an object down in the tower.  For example, projecting
a complex number would involve throwing away the imaginary part.  Then
a number can be dropped if, when we project it and raise
the result back to the type we started with, we end up with something
equal to what we started with.  Show how to implement this idea in
detail, by writing a drop procedure that drops an object as far
as possible.  You will need to design the various projection
operations<sup>53</sup> and install project as a generic operation in
the system.  You will also need to make use of a generic equality
predicate, such as described in exercise 2.79.  Finally, use drop
to rewrite apply-generic from exercise 2.84 so that it
"simplifies" its answers.</p>

<p>
<strong>Exercise 2.86.</strong>  Suppose we want to handle complex numbers whose real
parts, imaginary parts, magnitudes, and angles can be either ordinary
numbers, rational numbers, or other numbers we might wish to add to
the system.  Describe and implement the changes to the system needed
to accommodate this.  You will have to define operations such as sine and cosine that are generic over ordinary numbers and
rational numbers.</p>

<p><strong>2.5.3  Example: Symbolic Algebra</strong></p>

<p>



The manipulation of symbolic algebraic expressions is a complex
process that illustrates many of the hardest problems that occur in
the design of large-scale systems.  An algebraic expression, in
general, can be viewed as a hierarchical structure, a tree of
operators applied to operands.  We can construct algebraic expressions
by starting with a set of primitive objects, such as constants and
variables, and combining these by means of algebraic operators, such
as addition and multiplication.  As in other languages, we form
abstractions that enable us to refer to compound objects in simple
terms.  Typical abstractions in symbolic algebra are ideas such as
linear combination, polynomial, rational function, or trigonometric
function.  We can regard these as compound "types", which are often
useful for directing the processing of expressions.  For example, we
could describe the expression</p>

<p><image xlink:href="#_119.jpg" /></p>

<p>
as a polynomial in <emphasis>x</emphasis> with coefficients that are trigonometric
functions of polynomials in <emphasis>y</emphasis> whose coefficients are integers.</p>

<p>

We will not attempt to develop a complete algebraic-manipulation
system here.  Such systems are exceedingly complex programs, embodying
deep algebraic knowledge and elegant algorithms.  What we will do is
look at a simple but important part of algebraic manipulation: the
arithmetic of polynomials.  We will illustrate the kinds of decisions
the designer of such a system faces, and how to apply the ideas of
abstract data and generic operations to help organize this effort.</p>

<p><strong>Arithmetic on polynomials</strong></p>

<p>


Our first task in designing a system for performing arithmetic on
polynomials is to decide just what a polynomial is.  Polynomials are
normally defined relative to certain variables (the <emphasis>indeterminates</emphasis> of the polynomial).  For simplicity, we will restrict
ourselves to polynomials having just one indeterminate (<emphasis>univariate polynomials</emphasis>).<sup>54</sup> We will define a polynomial to be a
sum of terms, each of which is either a coefficient, a power of the
indeterminate, or a product of a coefficient and a power of the
indeterminate.  A coefficient is defined as an algebraic expression
that is not dependent upon the indeterminate of the polynomial.  For
example,</p>

<p><image xlink:href="#_120.jpg" /></p>

<p>
is a simple polynomial in <emphasis>x</emphasis>, and</p>

<p><image xlink:href="#_121.jpg" /></p>

<p>
is a polynomial in <emphasis>x</emphasis> whose coefficients are polynomials in <emphasis>y</emphasis>.</p>

<p>

Already we are skirting some thorny issues.  Is the first of these
polynomials the same as the polynomial 5<emphasis>y</emphasis><sup>2</sup>  + 3<emphasis>y</emphasis>  + 7, or not?  A
reasonable answer might be "yes, if we are considering a polynomial
purely as a mathematical function, but no, if we are considering a
polynomial to be a syntactic form."  The second polynomial is
algebraically equivalent to a polynomial in <emphasis>y</emphasis> whose coefficients are
polynomials in <emphasis>x</emphasis>.  Should our system recognize this, or not?
Furthermore, there are other ways to represent a polynomial -- for
example, as a product of factors, or (for a univariate polynomial) as
the set of roots, or as a listing of the values of the polynomial at a
specified set of points.<sup>55</sup>
We can finesse these questions by deciding that in our
algebraic-manipulation system a "polynomial" will be a
particular syntactic form, not its underlying mathematical meaning.</p>

<p>

Now we must consider how to go about doing arithmetic on polynomials.
In this simple system, we will consider only addition and
multiplication.  Moreover, we will insist that two polynomials to be
combined must have the same indeterminate.</p>

<p>


We will approach the design of our system by following the familiar
discipline of data abstraction.  We will represent polynomials using a
data structure called a <emphasis>poly</emphasis>, which consists of a variable and a
collection of terms.  We assume that we have selectors variable
and term-list that extract those parts from a poly and
a constructor make-poly that assembles a
poly from a given variable and a term list.
A variable will be just a symbol, so we can use the same-variable?
procedure of section 2.3.2 to compare variables.
The following procedures define addition and multiplication of polys:</p>

<p>(define (add-poly p1 p2)</p><empty-line /><p>
  (if (same-variable? (variable p1) (variable p2))</p><empty-line /><p>
      (make-poly (variable p1)</p><empty-line /><p>
                 (add-terms (term-list p1)</p><empty-line /><p>
                            (term-list p2)))</p><empty-line /><p>
      (error "Polys not in same var -- ADD-POLY"</p><empty-line /><p>
             (list p1 p2))))</p><empty-line /><p>(define (mul-poly p1 p2)</p><empty-line /><p>
  (if (same-variable? (variable p1) (variable p2))</p><empty-line /><p>
      (make-poly (variable p1)</p><empty-line /><p>
                 (mul-terms (term-list p1)</p><empty-line /><p>
                            (term-list p2)))</p><empty-line /><p>
      (error "Polys not in same var -- MUL-POLY"</p><empty-line /><p>
             (list p1 p2))))</p><empty-line /><empty-line /><p>

To incorporate polynomials into our generic arithmetic system, we need
to supply them with type tags.  We'll use the tag polynomial,
and install appropriate operations on tagged polynomials in
the operation table.  We'll embed all our code
in an installation procedure for the polynomial package,
similar to the ones in
section 2.5.1:</p>

<p>(define (install-polynomial-package)</p><empty-line /><p>
  <emphasis>;; internal procedures</emphasis></p><empty-line /><p>
  <emphasis>;; representation of poly</emphasis></p><empty-line /><p>
  (define (make-poly variable term-list)</p><empty-line /><p>
    (cons variable term-list))</p><empty-line /><p>
  (define (variable p) (car p))</p><empty-line /><p>
  (define (term-list p) (cdr p))</p><empty-line /><p>
  &lt;<emphasis>procedures same-variable? and variable? from section 2.3.2</emphasis>&gt;</p><empty-line /><p>
  <emphasis>;; representation of terms and term lists</emphasis></p><empty-line /><p>
  &lt;<emphasis>procedures adjoin-term ...coeff from text below</emphasis>&gt;</p><empty-line /><empty-line /><p>
  <emphasis>;; continued on next page</emphasis></p><empty-line /><empty-line /><p>
  (define (add-poly p1 p2) ...)</p><empty-line /><p>
  &lt;<emphasis>procedures used by add-poly</emphasis>&gt;</p><empty-line /><p>
  (define (mul-poly p1 p2) ...)</p><empty-line /><p>
  &lt;<emphasis>procedures used by mul-poly</emphasis>&gt;</p><empty-line /><p>
  <emphasis>;; interface to rest of the system</emphasis></p><empty-line /><p>
  (define (tag p) (attach-tag 'polynomial p))</p><empty-line /><p>
  (put 'add '(polynomial polynomial)</p><empty-line /><p>
       (lambda (p1 p2) (tag (add-poly p1 p2))))</p><empty-line /><p>
  (put 'mul '(polynomial polynomial)</p><empty-line /><p>
       (lambda (p1 p2) (tag (mul-poly p1 p2))))</p><empty-line /><p>
  (put 'make 'polynomial</p><empty-line /><p>
       (lambda (var terms) (tag (make-poly var terms))))</p><empty-line /><p>
  'done)</p><empty-line /><empty-line /><p>

Polynomial addition is performed termwise.  Terms of the same order
(i.e., with the same power of the indeterminate) must be combined.
This is done by forming a new term of the same order whose coefficient
is the sum of the coefficients of the addends.  Terms in one addend
for which there are no terms of the same order in the other addend are
simply accumulated into the sum polynomial being constructed.</p>

<p>

In order to manipulate term lists, we will assume that we have a
constructor the-empty-termlist that returns an empty term list
and a constructor adjoin-term that adjoins a new term to a term
list.  We will also assume that we have a predicate empty-termlist? that tells if a given term list is empty, a selector
first-term that extracts the highest-order term from a term
list, and a selector rest-terms that returns all but the highest-order
term.  To manipulate terms, we will suppose that we have a
constructor make-term that constructs a term with given
order and coefficient, and selectors order and coeff that return, respectively, the order and the
coefficient of the term.  These operations allow us to consider both
terms and term lists as data abstractions, whose concrete
representations we can worry about separately.</p>

<p>

Here is the procedure that constructs the term list for the sum of two
polynomials:<sup>56</sup></p>

<p>(define (add-terms L1 L2)</p><empty-line /><p>
  (cond ((empty-termlist? L1) L2)</p><empty-line /><p>
        ((empty-termlist? L2) L1)</p><empty-line /><p>
        (else</p><empty-line /><p>
         (let ((t1 (first-term L1)) (t2 (first-term L2)))</p><empty-line /><p>
           (cond ((&gt; (order t1) (order t2))</p><empty-line /><p>
                  (adjoin-term</p><empty-line /><p>
                   t1 (add-terms (rest-terms L1) L2)))</p><empty-line /><p>
                 ((&lt; (order t1) (order t2))</p><empty-line /><p>
                  (adjoin-term</p><empty-line /><p>
                   t2 (add-terms L1 (rest-terms L2))))</p><empty-line /><p>
                 (else</p><empty-line /><p>
                  (adjoin-term</p><empty-line /><p>
                   (make-term (order t1)</p><empty-line /><p>
                              (add (coeff t1) (coeff t2)))</p><empty-line /><p>
                   (add-terms (rest-terms L1)</p><empty-line /><p>
                              (rest-terms L2)))))))))</p><empty-line /><p>
The most important point to note here is that we used the generic
addition procedure add to add together the coefficients of the
terms being combined.  This has powerful consequences, as we will see
below.</p>

<p>

In order to multiply two term lists, we multiply each term of the
first list by all the terms of the other list, repeatedly using
mul-term-by-all-terms, which multiplies a given term by
all terms in a given term list.  The resulting term lists (one for
each term of the first list) are accumulated into a sum.  Multiplying
two terms forms a term whose order is the sum of the orders of the
factors and whose coefficient is the product of the coefficients of
the factors:</p>

<p>(define (mul-terms L1 L2)</p><empty-line /><p>
  (if (empty-termlist? L1)</p><empty-line /><p>
      (the-empty-termlist)</p><empty-line /><p>
      (add-terms (mul-term-by-all-terms (first-term L1) L2)</p><empty-line /><p>
                 (mul-terms (rest-terms L1) L2))))</p><empty-line /><p>
(define (mul-term-by-all-terms t1 L)</p><empty-line /><p>
  (if (empty-termlist? L)</p><empty-line /><p>
      (the-empty-termlist)</p><empty-line /><p>
      (let ((t2 (first-term L)))</p><empty-line /><p>
        (adjoin-term</p><empty-line /><p>
         (make-term (+ (order t1) (order t2))</p><empty-line /><p>
                    (mul (coeff t1) (coeff t2)))</p><empty-line /><p>
         (mul-term-by-all-terms t1 (rest-terms L))))))</p><empty-line /><empty-line /><p>

This is really all there is to polynomial addition and multiplication.
Notice that, since we operate on terms using the generic procedures
add and mul, our polynomial package is automatically able
to handle any type of coefficient that is known about by the generic
arithmetic package.  If we include a coercion mechanism such as one of
those discussed in section 2.5.2,
then we also are automatically able to handle operations on
polynomials of different coefficient types, such as</p>

<p><image xlink:href="#_122.jpg" /></p>

<p>

Because we installed the polynomial addition and
multiplication procedures add-poly and mul-poly in the generic
arithmetic system as the add and mul operations
for type polynomial, our system is also
automatically able to handle polynomial operations such as</p>

<p><image xlink:href="#_123.jpg" /></p>

<p>

The reason is that when the system tries to combine coefficients, it
will dispatch through add and mul.  Since the coefficients
are themselves polynomials (in <emphasis>y</emphasis>), these will be combined using add-poly and mul-poly.  The result is a kind of "data-directed
recursion" in which, for example, a call to mul-poly will result
in recursive calls to mul-poly in order to multiply the
coefficients.  If the coefficients of the coefficients were themselves
polynomials (as might be used to represent polynomials in three
variables), the data direction would ensure that the system would
follow through another level of recursive calls, and so on through as
many levels as the structure of the data dictates.<sup>57</sup></p>

<p><strong>Representing term lists</strong></p>

<p>


Finally, we must confront the job of implementing a good
representation for term lists.  A term list is, in effect, a set of
coefficients keyed by the order of the term.  Hence, any of the
methods for representing sets, as discussed in
section 2.3.3, can be applied to this task.  On
the other hand, our procedures add-terms and mul-terms always
access term lists sequentially from highest to lowest order.  Thus, we
will use some kind of ordered list representation.</p>

<p>

How should we structure the list that represents a term list?  One
consideration is the "density" of the polynomials we intend to
manipulate.  A polynomial is said to be <emphasis>dense</emphasis> if it has nonzero
coefficients in terms of most orders.  If it has many zero terms it
is said to be <emphasis>sparse</emphasis>.  For example,</p>

<p><image xlink:href="#_124.jpg" /></p>

<p>
is a dense polynomial, whereas</p>

<p><image xlink:href="#_125.jpg" /></p>

<p>
is sparse.</p>

<p>

The term lists of dense polynomials are most efficiently represented
as lists of the coefficients.  For example, <emphasis>A</emphasis> above would be nicely
represented as (1 2 0 3 -2 -5).  The order of a term in this
representation is the length of the sublist beginning with that term's
coefficient, decremented by 1.<sup>58</sup>  This would be a terrible representation for a
sparse polynomial such as <emphasis>B</emphasis>: There would be a giant list of zeros
punctuated by a few lonely nonzero terms.  A more reasonable
representation of the term list of a sparse polynomial is as a list of
the nonzero terms, where each term is a list containing the order of the
term and the coefficient for that order.  In such a scheme, polynomial
<emphasis>B</emphasis> is efficiently represented as ((100 1) (2 2) (0 1)).  As
most polynomial manipulations are performed on sparse polynomials, we
will use this method.  We will assume that term lists are represented
as lists of terms, arranged from highest-order to lowest-order term.
Once we have made this decision, implementing the selectors and
constructors for terms and term lists is straightforward:<sup>59</sup></p>

<p>(define (adjoin-term term term-list)</p><empty-line /><p>
  (if (=zero? (coeff term))</p><empty-line /><p>
      term-list</p><empty-line /><p>
      (cons term term-list)))</p><empty-line /><p>(define (the-empty-termlist) '())</p><empty-line /><p>(define (first-term term-list) (car term-list))</p><empty-line /><p>(define (rest-terms term-list) (cdr term-list))</p><empty-line /><p>(define (empty-termlist? term-list) (null? term-list))</p><empty-line /><p>(define (make-term order coeff) (list order coeff))</p><empty-line /><p>(define (order term) (car term))</p><empty-line /><p>(define (coeff term) (cadr term))</p><empty-line /><p>
where =zero? is as defined in
exercise 2.80.  (See also exercise 2.87 below.)</p>

<p>

Users of the polynomial package
will create (tagged) polynomials by means of the procedure:</p>

<p>(define (make-polynomial var terms)</p><empty-line /><p>
  ((get 'make 'polynomial) var terms))</p><empty-line /><empty-line /><p>
<strong>Exercise 2.87.</strong>  Install =zero? for polynomials in the generic arithmetic
package.  This will allow adjoin-term to work for polynomials
with coefficients that are themselves polynomials.</p>

<p>
<strong>Exercise 2.88.</strong>  Extend the polynomial system to include subtraction of polynomials.
(Hint: You may find it helpful to define a generic negation operation.)</p>

<p>
<strong>Exercise 2.89.</strong>  Define procedures that implement the term-list representation
described above as appropriate for dense polynomials.</p>

<p>
<strong>Exercise 2.90.</strong>  Suppose we want to have a polynomial system that is efficient for both
sparse and dense polynomials.  One way to do this is to allow both
kinds of term-list representations in our system.  The situation is
analogous to the complex-number example of section 2.4,
where we allowed both rectangular and polar representations.
To do this we must distinguish different types of term lists and make
the operations on term lists generic.  Redesign the polynomial system
to implement this generalization.  This is a major effort, not a local
change.</p>

<p>
<strong>Exercise 2.91.</strong>  A univariate polynomial can be divided by another one to produce a
polynomial quotient and a polynomial remainder.  For example,</p>

<p><image xlink:href="#_126.jpg" /></p>

<p>

Division can be performed via long division.
That is, divide the highest-order term of the dividend by
the highest-order term of the divisor.  The result is the first term of the
quotient.  Next, multiply the result by the divisor, subtract that
from the dividend, and produce the rest of the answer by recursively
dividing the difference by the divisor.  Stop when the order of the
divisor exceeds the order of the dividend and declare the dividend to
be the remainder.  Also, if the dividend ever becomes zero, return
zero as both quotient and remainder.</p>

<p>

We can design a div-poly procedure on the model of add-poly and
mul-poly. The procedure checks to see if the two polys have
the same variable.  If so, div-poly strips off the variable and
passes the problem to div-terms, which performs the division
operation on term lists. Div-poly finally reattaches the variable
to the result supplied by div-terms.  It is convenient
to design div-terms to compute both the quotient and the remainder
of a division.  Div-terms can take two term lists as arguments and
return a list of the quotient term list and the remainder term list.</p>

<p>

Complete the following definition of div-terms by filling in the
missing expressions.  Use this to implement div-poly, which takes
two polys as arguments and returns a list of the quotient and
remainder polys.</p>

<p>(define (div-terms L1 L2)</p><empty-line /><p>
  (if (empty-termlist? L1)</p><empty-line /><p>
      (list (the-empty-termlist) (the-empty-termlist))</p><empty-line /><p>
      (let ((t1 (first-term L1))</p><empty-line /><p>
            (t2 (first-term L2)))</p><empty-line /><p>
        (if (&gt; (order t2) (order t1))</p><empty-line /><p>
            (list (the-empty-termlist) L1)</p><empty-line /><p>
            (let ((new-c (div (coeff t1) (coeff t2)))</p><empty-line /><p>
                  (new-o (- (order t1) (order t2))))</p><empty-line /><p>
              (let ((rest-of-result</p><empty-line /><p>
                     &lt;<emphasis>compute rest of result recursively</emphasis>&gt;</p><empty-line /><p>
                     ))</p><empty-line /><p>
                &lt;<emphasis>form complete result</emphasis>&gt;</p><empty-line /><p>
                ))))))</p><empty-line /><empty-line /><p><strong>Hierarchies of types in symbolic algebra</strong></p>

<p>


Our polynomial system illustrates how objects of one type
(polynomials) may in fact be complex objects that have objects of many
different types as parts.  This poses no real difficulty in defining
generic operations.  We need only install appropriate generic operations
for performing the necessary manipulations of the parts of the
compound types.  In fact, we saw that polynomials form a kind of
"recursive data abstraction", in that parts of a polynomial may
themselves be polynomials.  Our generic operations and our
data-directed programming style can handle this complication without
much trouble.</p>

<p>

On the other hand, polynomial algebra is a system for which the data
types cannot be naturally arranged in a tower.  For instance, it is
possible to have polynomials in <emphasis>x</emphasis> whose coefficients are polynomials
in <emphasis>y</emphasis>.  It is also possible to have polynomials in <emphasis>y</emphasis> whose
coefficients are polynomials in <emphasis>x</emphasis>.  Neither of these types is
"above" the other in any natural way, yet it is often necessary to
add together elements from each set.  There are several ways to do
this.  One possibility is to convert one polynomial to the type of the
other by expanding and rearranging terms so that both polynomials have
the same principal variable.  One can impose a towerlike structure on
this by ordering the variables and thus always converting any
polynomial to a "canonical form" with the highest-priority variable
dominant and the lower-priority variables buried in the coefficients.
This strategy works fairly well, except that the conversion may expand
a polynomial unnecessarily, making it hard to read and perhaps less
efficient to work with.  The tower strategy is certainly not natural
for this domain or for any domain where the user can invent new types
dynamically using old types in various combining forms, such as
trigonometric functions, power series, and integrals.</p>

<p>

It should not be surprising that controlling coercion is a serious
problem in the design of large-scale algebraic-manipulation systems.
Much of the complexity of such systems is concerned with relationships
among diverse types.  Indeed, it is fair to say that we do not yet
completely understand coercion.  In fact, we do not yet completely
understand the concept of a data type.  Nevertheless, what we know
provides us with powerful structuring and modularity principles to
support the design of large systems.</p>

<p>
<strong>Exercise 2.92.</strong>  By imposing an ordering on variables, extend the polynomial package so
that addition and multiplication of polynomials works for polynomials
in different variables.  (This is not easy!)</p>

<p><strong>Extended exercise: Rational functions</strong></p>

<p>

We can extend our generic arithmetic system to include <emphasis>rational
functions</emphasis>.  These are "fractions" whose numerator and denominator
are polynomials, such as</p>

<p><image xlink:href="#_127.jpg" /></p>

<p>
The system should be able to add, subtract, multiply, and divide
rational functions, and to perform such computations as</p>

<p><image xlink:href="#_128.jpg" /></p>

<p>
(Here the sum has been simplified by removing common factors.
Ordinary "cross multiplication" would have produced a 
fourth-degree polynomial over a fifth-degree polynomial.)</p>

<p>

If we modify our rational-arithmetic package so that it uses generic
operations, then it will do what we want, except for the problem
of reducing fractions to lowest terms.</p>

<p>
<strong>Exercise 2.93.</strong>  Modify the rational-arithmetic package to use generic operations, but
change make-rat so that it does not attempt to reduce fractions
to lowest terms.  Test your system by calling make-rational on
two polynomials to produce a rational function</p>

<p>(define p1 (make-polynomial 'x '((2 1)(0 1))))</p><empty-line /><p>
(define p2 (make-polynomial 'x '((3 1)(0 1))))</p><empty-line /><p>
(define rf (make-rational p2 p1))</p><empty-line /><p>
Now add rf to itself, using add. You will observe that
this addition procedure does not reduce fractions to lowest terms.</p><empty-line /><p>
We can reduce polynomial fractions to lowest terms using the same idea
we used with integers: modifying make-rat to divide both the
numerator and the denominator by their greatest common divisor.  The
notion of "greatest common divisor" makes sense for polynomials.  In
fact, we can compute the GCD of two polynomials using essentially the
same Euclid's Algorithm that works for integers.<sup>60</sup>  The
integer version is</p>

<p>(define (gcd a b)</p><empty-line /><p>
  (if (= b 0)</p><empty-line /><p>
      a</p><empty-line /><p>
      (gcd b (remainder a b))))</p><empty-line /><p>
Using this, we could make the obvious modification to define a GCD
operation that works on term lists:</p>

<p>(define (gcd-terms a b)</p><empty-line /><p>
  (if (empty-termlist? b)</p><empty-line /><p>
      a</p><empty-line /><p>
      (gcd-terms b (remainder-terms a b))))</p><empty-line /><p>
where remainder-terms picks out the remainder component of the
list returned by the term-list division operation div-terms that
was implemented in exercise 2.91.</p>

<p>
<strong>Exercise 2.94.</strong>  Using div-terms, implement the procedure remainder-terms and
use this to define gcd-terms as above.  Now write a procedure
gcd-poly that computes the polynomial GCD of two polys.
(The procedure should signal an error if the two polys are not
in the same variable.)  Install in the system a generic operation greatest-common-divisor that reduces to gcd-poly for polynomials
and to ordinary gcd for ordinary numbers.  As a test, try</p>

<p>(define p1 (make-polynomial 'x '((4 1) (3 -1) (2 -2) (1 2))))</p><empty-line /><p>
(define p2 (make-polynomial 'x '((3 1) (1 -1))))</p><empty-line /><p>
(greatest-common-divisor p1 p2)</p><empty-line /><p>
and check your result by hand.</p>

<p>
<strong>Exercise 2.95.</strong>  Define <emphasis>P</emphasis><sub>1</sub>, <emphasis>P</emphasis><sub>2</sub>, and <emphasis>P</emphasis><sub>3</sub> to be the polynomials</p>

<p><image xlink:href="#_129.jpg" /></p><empty-line /><p><image xlink:href="#_130.jpg" /></p><empty-line /><p><image xlink:href="#_131.jpg" /></p>

<p>

Now define <emphasis>Q</emphasis><sub>1</sub> to be the product of <emphasis>P</emphasis><sub>1</sub> and <emphasis>P</emphasis><sub>2</sub> and <emphasis>Q</emphasis><sub>2</sub> to
be the product of <emphasis>P</emphasis><sub>1</sub> and <emphasis>P</emphasis><sub>3</sub>, and use greatest-common-divisor
(exercise 2.94) to
compute the GCD of <emphasis>Q</emphasis><sub>1</sub> and <emphasis>Q</emphasis><sub>2</sub>.
Note that the answer is not the same as <emphasis>P</emphasis><sub>1</sub>.
This example introduces noninteger
operations into the computation, causing difficulties with the GCD
algorithm.<sup>61</sup>
To understand what is happening,
try tracing gcd-terms while computing the GCD or
try performing the division by hand.</p><empty-line /><p>We can solve the problem exhibited in exercise 2.95 if
we use the following modification of the GCD algorithm (which really
works only in the case of polynomials with integer coefficients).
Before performing any polynomial division in the GCD computation, we
multiply the dividend by an integer constant factor, chosen to
guarantee that no fractions will arise during the division process.
Our answer will thus differ from the actual GCD by an integer constant
factor, but this does not matter in the case of reducing rational
functions to lowest terms; the GCD will be used to divide both the
numerator and denominator, so the integer constant factor will cancel
out.</p>

<p>

More precisely, if <emphasis>P</emphasis> and <emphasis>Q</emphasis> are polynomials, let <emphasis>O</emphasis><sub>1</sub> be the
order of <emphasis>P</emphasis> (i.e., the order of the largest term of <emphasis>P</emphasis>) and let
<emphasis>O</emphasis><sub>2</sub> be the order of <emphasis>Q</emphasis>.  Let <emphasis>c</emphasis> be the leading coefficient of
<emphasis>Q</emphasis>.  Then it can be shown that, if we multiply <emphasis>P</emphasis> by the <emphasis>integerizing factor</emphasis> <emphasis>c</emphasis><sup>1+<emphasis>O</emphasis><sub>1</sub> -<emphasis>O</emphasis><sub>2</sub></sup>, the resulting polynomial can
be divided by <emphasis>Q</emphasis> by using the div-terms algorithm without
introducing any fractions.  The operation of multiplying the dividend
by this constant and then dividing is sometimes called the <emphasis>pseudodivision</emphasis> of <emphasis>P</emphasis> by <emphasis>Q</emphasis>.  The remainder of the division is
called the <emphasis>pseudoremainder</emphasis>.</p>

<p>
<strong>Exercise 2.96.</strong>  a.    Implement the procedure pseudoremainder-terms, which is just like
remainder-terms except that it multiplies the dividend by
the integerizing factor described above before calling div-terms.
Modify gcd-terms to use pseudoremainder-terms, and verify
that greatest-common-divisor now produces an answer with integer
coefficients on the example in exercise 2.95.</p>

<p>b.    The GCD now has integer coefficients, but they are larger than those
of <emphasis>P</emphasis><sub>1</sub>.  Modify gcd-terms so that it removes common factors from
the coefficients of the answer by dividing all the coefficients by their
(integer) greatest common divisor.</p>

<p>Thus, here is how to reduce a rational function to lowest terms:</p>

<p>Compute the GCD of the numerator and denominator, using
the version of gcd-terms from exercise 2.96.</p>

<p>When you obtain the GCD, multiply both numerator and
denominator by the same integerizing factor before dividing through by
the GCD, so that division by the GCD will not introduce any noninteger
coefficients.  As the factor you can use the leading coefficient of
the GCD raised to the power 1 + <emphasis>O</emphasis><sub>1</sub>  - <emphasis>O</emphasis><sub>2</sub>, where <emphasis>O</emphasis><sub>2</sub> is the order
of the GCD and <emphasis>O</emphasis><sub>1</sub> is the maximum of the orders of the numerator
and denominator.  This will ensure that dividing the numerator and
denominator by the GCD will not introduce any fractions.</p>

<p>The result of this operation will be a numerator and denominator
with integer coefficients.  The coefficients will normally be very
large because of all of the integerizing factors, so the last step is
to remove the redundant factors by computing the (integer) greatest
common divisor of all the coefficients of the numerator and the
denominator and dividing through by this factor.</p>

<p>
<strong>Exercise 2.97.</strong>  a. Implement this algorithm as a procedure reduce-terms that takes two
term lists n and d as arguments and returns a list nn, dd, which are n and d reduced to lowest terms
via the algorithm given above.
Also write a procedure reduce-poly, analogous to add-poly,
that checks to see if the two polys have
the same variable.  If so, reduce-poly strips off the variable and
passes the problem to reduce-terms, then reattaches the variable
to the two term lists supplied by reduce-terms.</p>

<p>b. Define a procedure analogous to reduce-terms
that does what the original make-rat did for integers:</p>

<p>(define (reduce-integers n d)</p><empty-line /><p>
  (let ((g (gcd n d)))</p><empty-line /><p>
    (list (/ n g) (/ d g))))</p><empty-line /><p>
and define
reduce as a generic operation that calls apply-generic to
dispatch to either reduce-poly (for polynomial arguments)
or reduce-integers (for scheme-number arguments).
You can now easily make the
rational-arithmetic package reduce fractions to lowest terms by
having make-rat call reduce before combining the given
numerator and denominator to form a rational number.
The system now
handles rational expressions in either integers or polynomials.
To test your program, try the example at the beginning of this
extended exercise:</p>

<p>(define p1 (make-polynomial 'x '((1 1)(0 1))))</p><empty-line /><p>
(define p2 (make-polynomial 'x '((3 1)(0 -1))))</p><empty-line /><p>
(define p3 (make-polynomial 'x '((1 1))))</p><empty-line /><p>
(define p4 (make-polynomial 'x '((2 1)(0 -1))))</p><empty-line /><empty-line /><p>
(define rf1 (make-rational p1 p2))</p><empty-line /><p>
(define rf2 (make-rational p3 p4))</p><empty-line /><empty-line /><p>
(add rf1 rf2)</p><empty-line /><p>
See if you get the correct answer, correctly reduced to lowest terms.</p>

<p>The GCD computation is at the heart of any system that does operations
on rational functions.  The algorithm used above, although
mathematically straightforward, is extremely slow.  The slowness is
due partly to the large number of division operations and partly to
the enormous size of the intermediate coefficients generated by the
pseudodivisions.  One of the active areas in the development of
algebraic-manipulation systems is the design of better algorithms for
computing polynomial GCDs.<sup>62</sup></p><empty-line /><empty-line /><empty-line /><p><sup>49</sup> We also have to supply an almost identical
procedure to handle the types (scheme-number complex).</p>

<p><sup>50</sup> See
exercise 2.82 for generalizations.</p>

<p><sup>51</sup> If we are
clever, we can usually get by with fewer than <emphasis>n</emphasis><sup>2</sup> coercion
procedures.  For instance, if we know how to convert from type 1 to
type 2 and from type 2 to type 3, then we can use this knowledge to
convert from type 1 to type 3.  This can greatly decrease the number
of coercion procedures we need to supply explicitly when we add a new
type to the system.  If we are willing to build the required amount of
sophistication into our system, we can have it search the "graph" of
relations among types and automatically generate those coercion
procedures that can be inferred from the ones that are supplied
explicitly.</p>

<p><sup>52</sup> This statement, which also appears in the first edition of this book,
is just as true now as it was when we wrote it twelve years ago.
Developing a useful, general framework for expressing the relations
among different types of entities (what philosophers call
"ontology") seems intractably difficult.  The main difference
between the confusion that existed ten years ago and the confusion
that exists now is that now a variety of inadequate ontological
theories have been embodied in a plethora of correspondingly
inadequate programming languages.  For example, much of the complexity
of object-oriented programming languages -- and the subtle and
confusing differences among contemporary object-oriented
languages -- centers on the treatment of generic operations on
interrelated types.  Our own discussion of computational objects in
chapter 3 avoids these issues entirely.  Readers familiar with
object-oriented programming will notice that we have much to say in
chapter 3 about local state, but we do not even mention "classes" or
"inheritance."  In fact, we suspect that these problems cannot be
adequately addressed in terms of computer-language design alone,
without also drawing on work in knowledge representation and automated
reasoning.</p>

<p><sup>53</sup> A real number can be projected to an integer
using the round primitive, which returns the closest integer
to its argument.</p>

<p><sup>54</sup> On the other hand, we will allow
polynomials whose coefficients are themselves polynomials in other
variables.  This will give us essentially the same representational
power as a full multivariate system, although it does lead to coercion
problems, as discussed below.</p>

<p><sup>55</sup> For univariate polynomials, giving
the value of a polynomial at a given set of points can be a
particularly good representation.  This makes polynomial arithmetic
extremely simple.  To obtain, for example, the sum of two polynomials
represented in this way, we need only add the values of the
polynomials at corresponding points.  To transform back to a more
familiar representation, we can use the Lagrange interpolation
formula, which shows how to recover the coefficients of a polynomial
of degree <emphasis>n</emphasis> given the values of the polynomial at <emphasis>n</emphasis> + 1 points.</p>

<p><sup>56</sup> This operation is very much like the ordered
union-set operation we developed in exercise  2.62.
In fact, if we think of the terms of the polynomial as a set ordered
according to the power of the indeterminate, then the program that
produces the term list for a sum is almost identical to union-set.</p>

<p><sup>57</sup> To make
this work completely smoothly, we should also add to our generic
arithmetic system the ability to coerce a "number" to a polynomial
by regarding it as a polynomial of degree zero whose coefficient is
the number.  This is necessary if we are going to perform operations
such as</p>

<p><image xlink:href="#_132.jpg" /></p>

<p>
which requires adding the coefficient <emphasis>y</emphasis> + 1 to the coefficient 2.</p>

<p><sup>58</sup> In these polynomial examples,
we assume that we have implemented the generic arithmetic system using
the type mechanism suggested in exercise 2.78.
Thus, coefficients that are ordinary numbers will be represented as
the numbers themselves rather than as pairs whose car is the
symbol scheme-number.</p>

<p><sup>59</sup> Although
we are assuming that term
lists are ordered, we have implemented adjoin-term to simply
cons the new term onto the existing term list.  We can get away
with this so long as we guarantee that the procedures (such as add-terms) that use adjoin-term always call it with a higher-order
term than appears in the list.  If we did not want to make such a
guarantee, we could have implemented adjoin-term to be similar
to the adjoin-set constructor for the ordered-list
representation of sets (exercise 2.61).</p>

<p><sup>60</sup> The fact
that Euclid's Algorithm works for polynomials is formalized in algebra
by saying that polynomials form a kind of algebraic domain called a
<emphasis>Euclidean ring</emphasis>.  A Euclidean ring is a domain that admits
addition, subtraction, and commutative multiplication, together with a
way of assigning to each element <emphasis>x</emphasis> of the ring a positive integer
"measure" <emphasis>m</emphasis>(<emphasis>x</emphasis>) with the properties that <emphasis>m</emphasis>(<emphasis>x</emphasis><emphasis>y</emphasis>)&gt; <emphasis>m</emphasis>(<emphasis>x</emphasis>) for
any nonzero <emphasis>x</emphasis> and <emphasis>y</emphasis> and that, given any <emphasis>x</emphasis> and <emphasis>y</emphasis>, there exists
a <emphasis>q</emphasis> such that <emphasis>y</emphasis> = <emphasis>q</emphasis><emphasis>x</emphasis> + <emphasis>r</emphasis> and either <emphasis>r</emphasis> = 0 or <emphasis>m</emphasis>(<emphasis>r</emphasis>)&lt; <emphasis>m</emphasis>(<emphasis>x</emphasis>).  From an
abstract point of view, this is what is needed to prove that Euclid's
Algorithm works.  For the domain of integers, the measure <emphasis>m</emphasis> of an
integer is the absolute value of the integer itself.  For the domain
of polynomials, the measure of a polynomial is its degree.</p>

<p><sup>61</sup> In an implementation like MIT Scheme, this produces a polynomial
that is indeed a divisor of <emphasis>Q</emphasis><sub>1</sub> and <emphasis>Q</emphasis><sub>2</sub>, but with rational coefficients.
In many other Scheme systems, in which division of integers can produce
limited-precision decimal numbers, we may fail to get a valid divisor.</p>

<p><sup>62</sup> One extremely efficient and
elegant method for computing polynomial GCDs was discovered by Richard
Zippel (1979).  The method is a probabilistic algorithm, as is the
fast test for primality that we discussed in chapter 1.  Zippel's book
(1993) describes this method, together with other ways to compute
polynomial GCDs.</p>


</section>

<section>


<p><strong>
</strong></p>

<p><strong>Chapter 3</strong></p>

<p>
Modularity, Objects, and State</p><empty-line /><p>

M<image xlink:href="#_133.jpg" /></p><empty-line /><p>

(Even while it changes, it stands still.)</p>

<p>

Heraclitus</p>

<p>

Plus ça change, plus c'est la même chose.</p>

<p>

Alphonse Karr</p><empty-line /><p>

The preceding chapters introduced the basic elements from which
programs are made.  We saw how primitive procedures and primitive data
are combined to construct compound entities, and we learned that
abstraction is vital in helping us to cope with the complexity of
large systems.  But these tools are not sufficient for designing
programs.  Effective program synthesis also requires organizational
principles that can guide us in formulating the overall design of a
program.  In particular, we need strategies to help us structure large
systems so that they will be <emphasis>modular</emphasis>, that is, so that they can
be divided "naturally" into coherent parts that can be separately
developed and maintained.</p>

<p>

One powerful design strategy, which is particularly appropriate to the
construction of programs for modeling physical systems, is to base the
structure of our programs on the structure of the system being
modeled.  For each object in the system, we construct a corresponding
computational object.  For each system action, we define a symbolic
operation in our computational model.  Our hope in using this strategy
is that extending the model to accommodate new objects or new actions
will require no strategic changes to the program, only the addition of
the new symbolic analogs of those objects or actions.  If we have been
successful in our system organization, then to add a new feature or
debug an old one we will have to work on only a localized part of the
system.</p>

<p>


To a large extent, then, the way we organize a large program is
dictated by our perception of the system to be modeled.  In this
chapter we will investigate two prominent organizational strategies
arising from two rather different "world views" of the structure of
systems.  The first organizational strategy concentrates on <emphasis>objects</emphasis>, viewing a large system as a collection of distinct objects
whose behaviors may change over time.  An alternative organizational
strategy concentrates on the <emphasis>streams</emphasis> of information that flow in
the system, much as an electrical engineer views a signal-processing
system.</p>

<p>

Both the object-based approach and the stream-processing approach
raise significant linguistic issues in programming.
With objects, we must be concerned with how a computational object can
change and yet maintain its identity.  This will force us to abandon
our old substitution model of computation
(section 1.1.5) in favor of a more mechanistic
but less theoretically tractable <emphasis>environment model</emphasis> of
computation.  The difficulties of dealing with objects, change, and
identity are a fundamental consequence of the need to grapple with
time in our computational models.  These difficulties become even
greater when we allow the possibility of concurrent execution of
programs.  The stream approach can be most fully exploited when we
decouple simulated time in our model from the order of the events that
take place in the computer during evaluation.  We will accomplish this
using a technique known as <emphasis>delayed evaluation</emphasis>.</p>


</section>

<section>


<p><strong>3.1  Assignment and Local State</strong></p>

<p>


We ordinarily view the world as populated by independent objects, each
of which has a state that changes over time.  An object is said to
"have state" if its behavior is influenced by its history.  A bank
account, for example, has state in that the answer to the question
"Can I withdraw $100?"  depends upon the history of deposit and
withdrawal transactions.  We can characterize an object's state by one
or more <emphasis>state variables</emphasis>, which among them maintain enough
information about history to determine the object's current behavior.
In a simple banking system, we could characterize the state of an
account by a current balance rather than by remembering the entire
history of account transactions.</p>

<p>

In a system composed of many objects, the objects are rarely
completely independent.  Each may influence the states of others
through interactions, which serve to couple the state variables of one
object to those of other objects.  Indeed, the view that a system is
composed of separate objects is most useful when the state variables
of the system can be grouped into closely coupled subsystems that are
only loosely coupled to other subsystems.</p>

<p>


This view of a system can be a powerful framework for organizing
computational models of the system.  For such a model to be modular,
it should be decomposed into computational objects that model the
actual objects in the system.  Each computational object must have its
own <emphasis>local state variables</emphasis> describing the actual object's state.
Since the states of objects in the system being modeled change over
time, the state variables of the corresponding computational objects
must also change.  If we choose to model the flow of time in the
system by the elapsed time in the computer, then we must have a way to
construct computational objects whose behaviors change as our programs
run.  In particular, if we wish to model state variables by ordinary
symbolic names in the programming language, then the language must
provide an <emphasis>assignment operator</emphasis> to enable us to change the value
associated with a name.</p>

<p><strong>3.1.1  Local State Variables</strong></p>

<p>



To illustrate what we mean by having a computational object with
time-varying state, let us model the situation of withdrawing money
from a bank account.  We will do this using a procedure withdraw, which takes as argument an amount to be withdrawn.
If there is enough money in the account to accommodate the withdrawal,
then withdraw should return the balance remaining after the
withdrawal.  Otherwise, withdraw should return the message <emphasis>Insufficient funds.</emphasis> For example, if we begin with $100 in the
account, we should obtain the following sequence of responses using
withdraw:</p>

<p>(withdraw 25)</p><empty-line /><p><emphasis>75</emphasis></p><empty-line /><p>
(withdraw 25)</p><empty-line /><p><emphasis>50</emphasis></p><empty-line /><p>
(withdraw 60)</p><empty-line /><p><emphasis>"Insufficient funds"</emphasis></p><empty-line /><p>
(withdraw 15)</p><empty-line /><p><emphasis>35</emphasis></p><empty-line /><p>
Observe that the expression (withdraw 25), evaluated twice,
yields different values.  This is a new kind of behavior for a
procedure.  Until now, all our procedures could be viewed as
specifications for computing mathematical functions.  A call to a
procedure computed the value of the function applied to the given
arguments, and two calls to the same procedure with the
same arguments always produced the same result.<sup>1</sup></p>

<p>

To implement withdraw, we can use a variable balance to
indicate the balance of money in the account and define withdraw
as a procedure that accesses balance.  The withdraw
procedure checks to see if balance is at least as large as the
requested amount.  If so, withdraw decrements balance by amount and returns the new value of balance.
Otherwise, withdraw returns the <emphasis>Insufficient funds</emphasis>
message.  Here are the definitions of balance and withdraw:</p>

<p>(define balance 100)</p><empty-line /><empty-line /><p>(define (withdraw amount)</p><empty-line /><p>
  (if (&gt;= balance amount)</p><empty-line /><p>
      (begin (set! balance (- balance amount))</p><empty-line /><p>
             balance)</p><empty-line /><p>
      "Insufficient funds"))</p><empty-line /><p>
Decrementing balance is accomplished by the expression</p>

<p>(set! balance (- balance amount))</p><empty-line /><p>
This uses the set! special form, whose syntax is</p>

<p>(set! &lt;<emphasis>name</emphasis>&gt; &lt;<emphasis>new-value</emphasis>&gt;)</p><empty-line /><p>
Here &lt;<emphasis>name</emphasis>&gt; is a symbol and &lt;<emphasis>new-value</emphasis>&gt; is any expression.  Set! changes &lt;<emphasis>name</emphasis>&gt; so that its value is the result obtained by
evaluating &lt;<emphasis>new-value</emphasis>&gt;.  In the case at hand, we are changing balance so that its new value will be the result of subtracting amount from the previous value of balance.<sup>2</sup></p>

<p>

Withdraw also uses the begin special form to cause
two expressions to be evaluated
in the case where the if test is true: first decrementing balance and then returning the value of balance.  In general,
evaluating the expression</p>

<p>(begin &lt;<emphasis>exp<sub>1</sub></emphasis>&gt; &lt;<emphasis>exp<sub>2</sub></emphasis>&gt; ... &lt;<emphasis>exp<sub>k</sub></emphasis>&gt;)</p><empty-line /><p>
causes the expressions &lt;<emphasis>exp<sub>1</sub></emphasis>&gt; through &lt;<emphasis>exp<sub>k</sub></emphasis>&gt; to be
evaluated in sequence and the value of the final expression
&lt;<emphasis>exp<sub>k</sub></emphasis>&gt; to be returned as the value of the entire begin
form.<sup>3</sup></p>

<p>

Although withdraw works as desired, the variable
balance presents a problem.  As specified above, balance
is a name defined in the global environment and is freely accessible
to be examined or modified by any procedure.  It would be much better
if we could somehow make balance internal to withdraw, so
that withdraw would be the only procedure that could access balance directly and any other procedure could access balance
only indirectly (through calls to withdraw).  This would more
accurately model the notion that balance is a local state
variable used by withdraw to keep track of the state of the
account.</p>

<p>

We can make balance internal to withdraw by rewriting the
definition as follows:</p>

<p>(define new-withdraw</p><empty-line /><p>
  (let ((balance 100))</p><empty-line /><p>
    (lambda (amount)</p><empty-line /><p>
      (if (&gt;= balance amount)</p><empty-line /><p>
          (begin (set! balance (- balance amount))</p><empty-line /><p>
                 balance)</p><empty-line /><p>
          "Insufficient funds"))))</p><empty-line /><p>
What we have done here is use let to establish an environment
with a local variable balance, bound to the initial value 100.
Within this local environment, we use lambda to create a
procedure that takes amount as an argument and behaves like our
previous withdraw procedure.  This procedure -- returned as the
result of evaluating the let expression -- is new-withdraw,
which behaves in precisely the same way as withdraw but whose
variable balance is not accessible by any other
procedure.<sup>4</sup></p>

<p>

Combining set! with local variables is the general programming
technique we will use for constructing computational objects with
local state.  Unfortunately, using this technique raises a serious
problem: When we first introduced procedures, we also introduced the
substitution model of evaluation
(section 1.1.5) to provide an interpretation of
what procedure application means.  We said that applying a procedure
should be interpreted as evaluating the body of the procedure with the
formal parameters replaced by their values.  The trouble is that, as
soon as we introduce assignment into our language, substitution is no
longer an adequate model of procedure application.  (We will see why
this is so in section 3.1.3.)  As a
consequence, we technically have at this point no way to understand
why the new-withdraw procedure behaves as claimed above.  In
order to really understand a procedure such as new-withdraw, we
will need to develop a new model of procedure application.  In
section 3.2 we will introduce such a model,
together with an explanation of set! and local variables.
First, however, we examine some variations on the theme established by
new-withdraw.</p>

<p>

The following procedure, make-withdraw, creates "withdrawal
processors."  The formal parameter balance in make-withdraw specifies the initial amount of money in the
account.<sup>5</sup></p>

<p>(define (make-withdraw balance)</p><empty-line /><p>
  (lambda (amount)</p><empty-line /><p>
    (if (&gt;= balance amount)</p><empty-line /><p>
        (begin (set! balance (- balance amount))</p><empty-line /><p>
               balance)</p><empty-line /><p>
        "Insufficient funds")))</p><empty-line /><p>
Make-withdraw can be used as follows to create two objects
W1 and W2:</p>

<p>(define W1 (make-withdraw 100))</p><empty-line /><p>
(define W2 (make-withdraw 100))</p><empty-line /><p>
(W1 50)</p><empty-line /><p><emphasis>50</emphasis></p><empty-line /><p>
(W2 70)</p><empty-line /><p><emphasis>30</emphasis></p><empty-line /><p>
(W2 40)</p><empty-line /><p><emphasis>"Insufficient funds"</emphasis></p><empty-line /><p>
(W1 40)</p><empty-line /><p><emphasis>10</emphasis></p><empty-line /><p>
Observe that W1 and W2 are completely independent objects,
each with its own local state variable balance.  Withdrawals
from one do not affect the other.</p>

<p>

We can also create objects that handle deposits as well as
withdrawals, and thus we can represent simple bank accounts.  Here is
a procedure that returns a "bank-account object" with
a specified initial balance:</p>

<p>(define (make-account balance)</p><empty-line /><p>
  (define (withdraw amount)</p><empty-line /><p>
    (if (&gt;= balance amount)</p><empty-line /><p>
        (begin (set! balance (- balance amount))</p><empty-line /><p>
               balance)</p><empty-line /><p>
        "Insufficient funds"))</p><empty-line /><p>
  (define (deposit amount)</p><empty-line /><p>
    (set! balance (+ balance amount))</p><empty-line /><p>
    balance)</p><empty-line /><p>
  (define (dispatch m)</p><empty-line /><p>
    (cond ((eq? m 'withdraw) withdraw)</p><empty-line /><p>
          ((eq? m 'deposit) deposit)</p><empty-line /><p>
          (else (error "Unknown request -- MAKE-ACCOUNT"</p><empty-line /><p>
                       m))))</p><empty-line /><p>
  dispatch)</p><empty-line /><p>
Each call to make-account sets up an environment with a local
state variable balance.  Within this environment, make-account defines procedures deposit and withdraw
that access balance and an additional procedure dispatch
that takes a "message" as input and returns one of the two local
procedures.  The dispatch procedure itself is returned as the
value that represents the bank-account object.
This is precisely the <emphasis>message-passing</emphasis>
style of programming that we saw in section 2.4.3, although
here we are using it in conjunction with the ability to modify local
variables.</p>

<p>

Make-account can be used as follows:</p>

<p>(define acc (make-account 100))</p><empty-line /><p>
((acc 'withdraw) 50)</p><empty-line /><p><emphasis>50</emphasis></p><empty-line /><p>
((acc 'withdraw) 60)</p><empty-line /><p><emphasis>"Insufficient funds"</emphasis></p><empty-line /><p>
((acc 'deposit) 40)</p><empty-line /><p><emphasis>90</emphasis></p><empty-line /><p>
((acc 'withdraw) 60)</p><empty-line /><p><emphasis>30</emphasis></p><empty-line /><p>
Each call to acc returns the locally defined deposit or
withdraw procedure, which is then applied to the specified amount.  As was the case with make-withdraw, another call to make-account</p>

<p>(define acc2 (make-account 100))</p><empty-line /><p>
will produce a completely separate account object, which maintains its
own local balance.</p>

<p>
<strong>Exercise 3.1.</strong>  An <emphasis>accumulator</emphasis> is a procedure that is called repeatedly with a
single numeric argument and accumulates its arguments into a sum.
Each time it is called, it returns the currently accumulated sum.
Write a procedure make-accumulator that generates accumulators,
each maintaining an independent sum.  The input to make-accumulator should specify the initial value of the sum; for
example</p>

<p>(define A (make-accumulator 5))</p><empty-line /><p>
(A 10)</p><empty-line /><p><emphasis>15</emphasis></p><empty-line /><p>
(A 10)</p><empty-line /><p><emphasis>25</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 3.2.</strong>  In software-testing applications, it is useful to be able to count the
number of times a given procedure is called during the course of a
computation.  Write a procedure make-monitored that takes as
input a procedure, f, that itself takes one input.  The result
returned by make-monitored is a third procedure, say mf,
that keeps track of the number of times it has been called by
maintaining an internal counter.  If the input to mf is the
special symbol how-many-calls?, then mf returns the
value of the counter.  If the input is the special symbol reset-count, then mf resets the counter to zero.  For any other
input, mf returns the result of calling f on that input
and increments the counter.  For instance, we could make a monitored
version of the sqrt procedure:</p>

<p>(define s (make-monitored sqrt))</p><empty-line /><empty-line /><p>
(s 100)</p><empty-line /><p><emphasis>10</emphasis></p><empty-line /><empty-line /><p>
(s 'how-many-calls?)</p><empty-line /><p><emphasis>1</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 3.3.</strong>  Modify the make-account procedure so that it creates
password-protected accounts.  That is, make-account should take
a symbol as an additional argument, as in</p>

<p>(define acc (make-account 100 'secret-password))</p><empty-line /><p>
The resulting account object should process a request only if it is
accompanied by the password with which the account was created, and
should otherwise return a complaint:</p>

<p>((acc 'secret-password 'withdraw) 40)</p><empty-line /><p><emphasis>60</emphasis></p><empty-line /><empty-line /><p>
((acc 'some-other-password 'deposit) 50)</p><empty-line /><p><emphasis>"Incorrect password"</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 3.4.</strong>  Modify the make-account procedure of
exercise 3.3 by adding another local state
variable so that, if an account is accessed more than seven
consecutive times with an incorrect password, it invokes the procedure
call-the-cops.</p>

<p><strong>3.1.2  The Benefits of Introducing Assignment</strong></p>

<p>



As we shall see, introducing assignment into our programming language
leads us into a thicket of difficult conceptual issues.  Nevertheless,
viewing systems as collections of objects with local state is a
powerful technique for maintaining a modular design.  As a simple
example, consider the design of a procedure rand that, whenever
it is called, returns an integer chosen at random.</p>

<p>

It is not at all clear what is meant by "chosen at random."  What we
presumably want is for successive calls to rand to produce a
sequence of numbers that has statistical properties of uniform
distribution.  We will not discuss methods for generating suitable
sequences here.  Rather, let us assume that we have a procedure rand-update that has the property that if we start with a given
number <emphasis>x</emphasis><sub>1</sub> and form</p>

<p><emphasis>x</emphasis><sub>2</sub> = (rand-update <emphasis>x</emphasis><sub>1</sub>)</p><empty-line /><p><emphasis>x</emphasis><sub>3</sub> = (rand-update <emphasis>x</emphasis><sub>2</sub>)</p><empty-line /><p>
then the sequence of values <emphasis>x</emphasis><sub>1</sub>, <emphasis>x</emphasis><sub>2</sub>, <emphasis>x</emphasis><sub>3</sub>, ..., will have the
desired statistical properties.<sup>6</sup></p>

<p>

We can implement rand as a procedure with a local state variable
x that is initialized to some fixed value random-init.
Each call to rand computes rand-update of the current
value of x, returns this as the random number, and also stores
this as the new value of x.</p>

<p>(define rand</p><empty-line /><p>
  (let ((x random-init))</p><empty-line /><p>
    (lambda ()</p><empty-line /><p>
      (set! x (rand-update x))</p><empty-line /><p>
      x)))</p><empty-line /><empty-line /><p>

Of course, we could generate the same sequence of random numbers
without using assignment by simply calling rand-update directly.
However, this would mean that any part of our program that used random
numbers would have to explicitly remember the current value of x
to be passed as an argument to rand-update.  To realize what an
annoyance this would be, consider using random numbers to implement a
technique called <emphasis>Monte Carlo simulation</emphasis>.</p>

<p>

The Monte Carlo method consists of choosing sample experiments at
random from a large set and then making deductions on the basis of the
probabilities estimated from tabulating the results of those
experiments.  For example, we can approximate <image xlink:href="#_37.jpg" /> using the fact
that 6/<image xlink:href="#_37.jpg" /><sup>2</sup> is the probability that two integers chosen at random
will have no factors in common; that is, that their greatest common
divisor will be 1.<sup>7</sup> To obtain
the approximation to <image xlink:href="#_37.jpg" />, we perform a large number of experiments.
In each experiment we choose two integers at random and perform a test
to see if their GCD is 1.  The fraction of times that the test is
passed gives us our estimate of 6/<image xlink:href="#_37.jpg" /><sup>2</sup>, and from this we obtain our
approximation to <image xlink:href="#_37.jpg" />.</p>

<p>

The heart of our program is a procedure monte-carlo, which takes
as arguments the number of times to try an experiment, together with
the experiment, represented as a no-argument procedure that will
return either true or false each time it is run.  Monte-carlo
runs the experiment for the designated number of trials and returns a
number telling the fraction of the trials in which the experiment was
found to be true.</p>

<p>(define (estimate-pi trials)</p><empty-line /><p>
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))</p><empty-line /><p>(define (cesaro-test)</p><empty-line /><p>
   (= (gcd (rand) (rand)) 1))</p><empty-line /><p>(define (monte-carlo trials experiment)</p><empty-line /><p>
  (define (iter trials-remaining trials-passed)</p><empty-line /><p>
    (cond ((= trials-remaining 0)</p><empty-line /><p>
           (/ trials-passed trials))</p><empty-line /><p>
          ((experiment)</p><empty-line /><p>
           (iter (- trials-remaining 1) (+ trials-passed 1)))</p><empty-line /><p>
          (else</p><empty-line /><p>
           (iter (- trials-remaining 1) trials-passed))))</p><empty-line /><p>
  (iter trials 0))</p><empty-line /><empty-line /><p>

Now let us try the same computation using rand-update directly
rather than rand, the way we would be forced to proceed if we
did not use assignment to model local state:</p>

<p>(define (estimate-pi trials)</p><empty-line /><p>
  (sqrt (/ 6 (random-gcd-test trials random-init))))</p><empty-line /><p>
(define (random-gcd-test trials initial-x)</p><empty-line /><p>
  (define (iter trials-remaining trials-passed x)</p><empty-line /><p>
    (let ((x1 (rand-update x)))</p><empty-line /><p>
      (let ((x2 (rand-update x1)))</p><empty-line /><p>
        (cond ((= trials-remaining 0)</p><empty-line /><p>
               (/ trials-passed trials))</p><empty-line /><p>
              ((= (gcd x1 x2) 1)</p><empty-line /><p>
               (iter (- trials-remaining 1)</p><empty-line /><p>
                     (+ trials-passed 1)</p><empty-line /><p>
                     x2))</p><empty-line /><p>
              (else</p><empty-line /><p>
               (iter (- trials-remaining 1)</p><empty-line /><p>
                     trials-passed</p><empty-line /><p>
                     x2))))))</p><empty-line /><p>
  (iter trials 0 initial-x))</p><empty-line /><empty-line /><p>

While the program is still simple, it betrays some painful
breaches of modularity.  In our first version of the program, using
rand, we can express the Monte Carlo method directly as
a general monte-carlo procedure that takes as an argument an
arbitrary experiment procedure.  In our second version of the
program, with no local state for the random-number generator, random-gcd-test must explicitly manipulate the random numbers x1 and x2 and recycle x2 through the iterative loop as
the new input to rand-update.  This explicit handling of the
random numbers intertwines the structure of accumulating test results
with the fact that our particular experiment uses two random numbers,
whereas other Monte Carlo experiments might use one random number or
three.  Even the top-level procedure estimate-pi has to be
concerned with supplying an initial random number.  The fact that the
random-number generator's insides are leaking out into other parts of
the program makes it difficult for us to isolate the Monte Carlo idea
so that it can be applied to other tasks.  In the first version of the
program, assignment encapsulates the state of the random-number
generator within the rand procedure, so that the details of
random-number generation remain independent of the rest of the
program.</p>

<p>

The general phenomenon illustrated by the Monte Carlo example is this:
From the point of view of one part of a complex process, the other
parts appear to change with time.  They have hidden time-varying local
state.  If we wish to write computer programs whose structure reflects
this decomposition, we make
computational objects (such as bank accounts and random-number
generators) whose behavior changes with time.  We model state with
local state variables, and we model the changes of state with
assignments to those variables.</p>

<p>

It is tempting to conclude this discussion by saying that, by
introducing assignment and the technique of hiding state in local
variables, we are able to structure systems in a more modular fashion
than if all state had to be manipulated explicitly, by passing
additional parameters.  Unfortunately, as we shall see, the story is
not so simple.</p>

<p>
<strong>Exercise 3.5.</strong>  <emphasis>Monte Carlo integration</emphasis> is a method of estimating definite
integrals by means of Monte Carlo simulation.  Consider computing the
area of a region of space described by a predicate <emphasis>P</emphasis>(<emphasis>x</emphasis>, <emphasis>y</emphasis>) that is
true for points (<emphasis>x</emphasis>, <emphasis>y</emphasis>) in the region and false for points not in the
region.  For example, the region contained within a circle of radius
3 centered at (5, 7) is described by the predicate that tests
whether (<emphasis>x</emphasis> - 5)<sup>2</sup>  +  (<emphasis>y</emphasis> - 7)<sup>2</sup>&lt; 3<sup>2</sup>.  To estimate the area of the
region described by such a predicate, begin by choosing a rectangle
that contains the region.  For example, a rectangle with diagonally
opposite corners at (2, 4) and (8, 10) contains the circle above.
The desired integral is the area of that portion of the rectangle that
lies in the region.  We can estimate the integral by picking, at
random, points (<emphasis>x</emphasis>,<emphasis>y</emphasis>) that lie in the rectangle, and testing <emphasis>P</emphasis>(<emphasis>x</emphasis>,
<emphasis>y</emphasis>) for each point to determine whether the point lies in the region.
If we try this with many points, then the fraction of points that fall
in the region should give an estimate of the proportion of the
rectangle that lies in the region.  Hence, multiplying this fraction
by the area of the entire rectangle should produce an estimate of the
integral.</p>

<p>

Implement Monte Carlo integration as a procedure estimate-integral that takes as arguments a predicate P, upper
and lower bounds x1, x2, y1, and y2 for the
rectangle, and the number of trials to perform in order to produce the
estimate.  Your procedure should use the same monte-carlo procedure that was used above to estimate <image xlink:href="#_37.jpg" />.  Use
your estimate-integral to produce an estimate of <image xlink:href="#_37.jpg" /> by
measuring the area of a unit circle.</p>

<p>

You will find it useful to have a procedure that returns a number
chosen at random from a given range.  The following random-in-range
procedure implements this in terms of the random
procedure used in section 1.2.6, which returns a nonnegative
number less than its input.<sup>8</sup></p>

<p>(define (random-in-range low high)</p><empty-line /><p>
  (let ((range (- high low)))</p><empty-line /><p>
    (+ low (random range))))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.6.</strong>  It is useful to be able to reset a random-number generator to produce
a sequence starting from a given value.  Design a new rand
procedure that is called with an argument that is either the symbol
generate or the symbol reset and behaves as follows: (rand
'generate) produces a new random number; ((rand 'reset)
&lt;<emphasis>new-value</emphasis>&gt;) resets the internal state variable to the designated
&lt;<emphasis>new-value</emphasis>&gt;.  Thus, by resetting the state, one can generate
repeatable sequences.  These are very handy to have when testing and
debugging programs that use random numbers.</p>

<p><strong>3.1.3  The Costs of Introducing Assignment</strong></p>

<p>



As we have seen, the set! operation enables us to model objects
that have local state.  However, this advantage comes at a price.  Our
programming language can no longer be interpreted in terms of the
substitution model of procedure application that we introduced in
section 1.1.5.  Moreover, no simple model with
"nice" mathematical properties can be an adequate framework for
dealing with objects and assignment in programming languages.</p>

<p>

So long as we do not use assignments, two evaluations of the same
procedure with the same arguments will produce the same result, so
that procedures can be viewed as computing mathematical functions.
Programming without any use of assignments, as we did throughout the
first two chapters of this book, is accordingly known as <emphasis>functional programming</emphasis>.</p>

<p>

To understand how assignment complicates matters, consider a
simplified version of the make-withdraw procedure of
section 3.1.1 that does not bother to check
for an insufficient amount:</p>

<p>(define (make-simplified-withdraw balance)</p><empty-line /><p>
  (lambda (amount)</p><empty-line /><p>
    (set! balance (- balance amount))</p><empty-line /><p>
    balance))</p><empty-line /><p>
(define W (make-simplified-withdraw 25))</p><empty-line /><p>
(W 20)</p><empty-line /><p><emphasis>5</emphasis></p><empty-line /><p>
(W 10)</p><empty-line /><p><emphasis> - 5</emphasis></p><empty-line /><p>
Compare this procedure with the following make-decrementer
procedure, which does not use set!:</p>

<p>(define (make-decrementer balance)</p><empty-line /><p>
  (lambda (amount)</p><empty-line /><p>
    (- balance amount)))</p><empty-line /><p>
Make-decrementer returns a procedure that subtracts its input
from a designated amount balance, but there is no accumulated effect
over successive calls, as with make-simplified-withdraw:</p>

<p>(define D (make-decrementer 25))</p><empty-line /><p>
(D 20)</p><empty-line /><p><emphasis>5</emphasis></p><empty-line /><p>
(D 10)</p><empty-line /><p><emphasis>15</emphasis></p><empty-line /><p>
We can use the substitution model to explain how make-decrementer works.  For instance, let us analyze the evaluation
of the expression</p>

<p>((make-decrementer 25) 20)</p><empty-line /><p>
We first simplify the operator of the combination by substituting 25
for balance in the body of make-decrementer.  This reduces
the expression to</p>

<p>((lambda (amount) (- 25 amount)) 20)</p><empty-line /><p>
Now we apply the operator by substituting 20 for amount in the
body of the lambda expression:</p>

<p>(- 25 20)</p><empty-line /><p>
The final answer is 5.</p>

<p>

Observe, however, what happens if we attempt a similar substitution
analysis with make-simplified-withdraw:</p>

<p>((make-simplified-withdraw 25) 20)</p><empty-line /><p>
We first simplify the operator by substituting 25 for balance in
the body of make-simplified-withdraw.
This reduces the expression to<sup>9</sup></p>

<p>((lambda (amount) (set! balance (- 25 amount)) 25) 20)</p><empty-line /><p>
Now we apply the operator by substituting 20 for amount in the
body of the lambda expression:</p>

<p>(set! balance (- 25 20)) 25</p><empty-line /><p>
If we adhered to the substitution model, we would have to say that the
meaning of the procedure application is to first set balance to
5 and then return 25 as the value of the expression.  This gets the
wrong answer.  In order to get the correct answer, we would have to
somehow distinguish the first occurrence of balance (before the
effect of the set!)  from the second occurrence of balance
(after the effect of the set!), and the substitution model
cannot do this.</p>

<p>


The trouble here is that substitution is based ultimately on the
notion that the symbols in our language are essentially names for
values.  But as soon as we introduce set! and the idea that the
value of a variable can change, a variable can no longer be simply a
name.  Now a variable somehow refers to a place where a value can be
stored, and the value stored at this place can change.  In
section 3.2
we will see how environments play this role of "place" in our
computational model.</p>

<p><strong>Sameness and change</strong></p>

<p>


The issue surfacing here is more profound than the mere breakdown of a
particular model of computation.  As soon as we introduce change into
our computational models, many notions that were previously
straightforward become problematical.  Consider the concept of two
things being "the same."</p>

<p>

Suppose we call make-decrementer twice with the same argument to
create two procedures:</p>

<p>(define D1 (make-decrementer 25))</p><empty-line /><p>
(define D2 (make-decrementer 25))</p><empty-line /><p>
Are D1 and D2 the same?  An acceptable answer is yes,
because D1 and D2 have the same computational
behavior -- each is a procedure that subtracts its input from 25.  In
fact, D1 could be substituted for D2 in any computation
without changing the result.</p>

<p>

Contrast this with making two calls to make-simplified-withdraw:</p>

<p>(define W1 (make-simplified-withdraw 25))</p><empty-line /><p>
(define W2 (make-simplified-withdraw 25))</p><empty-line /><p>
Are W1 and W2 the same?  Surely not, because calls to W1 and W2 have distinct effects, as shown by the following
sequence of interactions:</p>

<p>(W1 20)</p><empty-line /><p><emphasis>5</emphasis></p><empty-line /><p>
(W1 20)</p><empty-line /><p><emphasis> - 15</emphasis></p><empty-line /><p>
(W2 20)</p><empty-line /><p><emphasis>5</emphasis></p><empty-line /><p>
Even though W1 and W2 are "equal" in the sense that they
are both created by evaluating the same expression, (make-simplified-withdraw 25), it is not true that W1 could be
substituted for W2 in any expression without changing the result
of evaluating the expression.</p>

<p>

A language that supports the concept that "equals can be substituted
for equals" in an expresssion
without changing the value of the expression is said to be
<emphasis>referentially transparent</emphasis>.  Referential transparency is violated
when we include set! in our computer language.  This makes it
tricky to determine when we can simplify expressions by substituting
equivalent expressions.  Consequently, reasoning about programs that
use assignment becomes drastically more difficult.</p>

<p>

Once we forgo referential transparency, the notion of what it means
for computational objects to be "the same" becomes difficult to
capture in a formal way.  Indeed, the meaning of "same" in the real
world that our programs model is hardly clear in itself.  In general,
we can determine that two apparently identical objects are indeed
"the same one" only by modifying one object and then observing
whether the other object has changed in the same way.  But how can we
tell if an object has "changed" other than by observing the "same"
object twice and seeing whether some property of the object differs
from one observation to the next?  Thus, we cannot determine
"change" without some <emphasis>a priori</emphasis> notion of "sameness", and we
cannot determine sameness without observing the effects of change.</p>

<p>

As an example of how this issue arises in programming, consider the
situation where Peter and Paul have a bank account with $100 in
it.  There is a substantial difference between modeling this as</p>

<p>(define peter-acc (make-account 100))</p><empty-line /><p>
(define paul-acc (make-account 100))</p><empty-line /><p>
and modeling it as</p>

<p>(define peter-acc (make-account 100))</p><empty-line /><p>
(define paul-acc peter-acc)</p><empty-line /><p>
In the first situation, the two bank accounts are distinct.
Transactions made by Peter will not affect Paul's account, and vice
versa.  In the second situation, however, we have defined paul-acc to be <emphasis>the same thing</emphasis> as peter-acc.  In effect,
Peter and Paul now have a joint bank account, and if Peter makes a
withdrawal from peter-acc Paul will observe less money in paul-acc.  These two similar but distinct situations can cause
confusion in building computational models.  With the shared account,
in particular, it can be especially confusing that there is one object
(the bank account) that has two different names (peter-acc and
paul-acc); if we are searching for all the places in our program
where paul-acc can be changed, we must remember to look also at
things that change peter-acc.<sup>10</sup></p>

<p>


With reference to the above remarks on "sameness" and "change",
observe that if Peter and Paul could only examine their bank balances,
and could not perform operations that changed the balance, then the
issue of whether the two accounts are distinct would be moot.  In
general, so long as we never modify data objects, we can regard a
compound data object to be precisely the totality of its pieces.  For
example, a rational number is determined by giving its numerator and
its denominator.  But this view is no longer valid in the presence of
change, where a compound data object has an "identity" that is
something different from the pieces of which it is composed.  A bank
account is still "the same" bank account even if we change the
balance by making a withdrawal; conversely, we could have two
different bank accounts with the same state information.  This
complication is a consequence, not of our programming language, but of
our perception of a bank account as an object.  We do not, for
example, ordinarily regard a rational number as a changeable object
with identity, such that we could change the numerator and still have
"the same" rational number.</p>

<p><strong>Pitfalls of imperative programming</strong></p>

<p>

In contrast to functional programming, programming that makes
extensive use of assignment is known as <emphasis>imperative
programming</emphasis>.  In addition to raising complications about
computational models, programs written in imperative style are
susceptible to bugs that cannot occur in functional programs.  For
example, recall the iterative factorial program from
section 1.2.1:</p>

<p>(define (factorial n)</p><empty-line /><p>
  (define (iter product counter)</p><empty-line /><p>
    (if (&gt; counter n)</p><empty-line /><p>
        product</p><empty-line /><p>
        (iter (* counter product)</p><empty-line /><p>
              (+ counter 1))))</p><empty-line /><p>
  (iter 1 1))</p><empty-line /><p>
Instead of passing arguments in the internal iterative loop, we could
adopt a more imperative style by using explicit assignment
to update the values of the variables product and counter:</p>

<p>(define (factorial n)</p><empty-line /><p>
  (let ((product 1)</p><empty-line /><p>
        (counter 1))</p><empty-line /><p>
    (define (iter)</p><empty-line /><p>
      (if (&gt; counter n)</p><empty-line /><p>
          product</p><empty-line /><p>
          (begin (set! product (* counter product))</p><empty-line /><p>
                 (set! counter (+ counter 1))</p><empty-line /><p>
                 (iter))))</p><empty-line /><p>
    (iter)))</p><empty-line /><p>
This does not change the results produced by the program, but it does
introduce a subtle trap.  How do we decide the order of the assignments?
As it happens, the program is correct as written.  But
writing the assignments in the opposite order</p>

<p>(set! counter (+ counter 1))</p><empty-line /><p>
(set! product (* counter product))</p><empty-line /><p>
would have produced a different, incorrect result.
In general, programming with assignment forces us to
carefully consider the relative orders of the assignments to make sure
that each statement is using the correct version of the variables that
have been changed.  This issue simply does not arise in functional
programs.<sup>11</sup>

The complexity of imperative programs becomes even worse if we
consider applications in which several processes execute concurrently.  We
will return to this in section 3.4.
First, however, we will address the issue of providing a computational
model for expressions that involve assignment, and explore the uses of
objects with local state in designing simulations.</p>

<p>
<strong>Exercise 3.7.</strong>  Consider the bank account objects created by make-account, with
the password modification described in
exercise 3.3.  Suppose that our banking
system requires the ability to make joint accounts.  Define a
procedure make-joint that accomplishes this.  Make-joint
should take three arguments.  The first is a password-protected
account.  The second argument must match the password with which the
account was defined in order for the make-joint operation to
proceed.  The third argument is a new password.  Make-joint is
to create an additional access to the original account using the new
password.  For example, if peter-acc is a bank account with
password open-sesame, then</p>

<p>(define paul-acc</p><empty-line /><p>
  (make-joint peter-acc 'open-sesame 'rosebud))</p><empty-line /><p>
will allow one to make transactions on peter-acc using the name
paul-acc and the password rosebud.  You may wish to modify
your solution to exercise 3.3 to accommodate
this new feature.</p>

<p>
<strong>Exercise 3.8.</strong>  When we defined the evaluation model in
section 1.1.3, we said that the first step
in evaluating an expression is to evaluate its subexpressions.  But we
never specified the order in which the subexpressions should be
evaluated (e.g., left to right or right to left).  When we introduce
assignment, the order in which the arguments to a procedure are
evaluated can make a difference to the result.  Define a simple
procedure f such that evaluating (+ (f 0) (f 1)) will
return 0 if the arguments to + are evaluated from left to right
but will return 1 if the arguments are evaluated from right to left.</p><empty-line /><empty-line /><empty-line /><p><sup>1</sup> Actually,
this is not quite true.  One exception was the random-number generator
in section 1.2.6.  Another exception involved the
operation/type tables we introduced in section 2.4.3,
where the values of two calls to get with the same arguments
depended on intervening calls to put.
On the other hand, until we introduce
assignment, we have no way to create such procedures ourselves.</p>

<p><sup>2</sup> The value of a set! expression is implementation-dependent.
Set! should be used only for its effect, not for its value.</p>

<p>

The name
set! reflects a naming convention used in Scheme: Operations
that change the values of variables (or that change data structures,
as we will see in section 3.3) are given names that
end with an exclamation point.  This is similar to the convention of
designating predicates by names that end with a question mark.</p>

<p><sup>3</sup> We have already used begin implicitly in our
programs, because in Scheme the body of a procedure can be a sequence
of expressions.  Also, the &lt;<emphasis>consequent</emphasis>&gt; part of each clause in a
cond expression can be a sequence of expressions rather than a
single expression.</p>

<p><sup>4</sup> In programming-language jargon, the variable balance is said to be <emphasis>encapsulated</emphasis> within the new-withdraw procedure.  Encapsulation reflects the general
system-design principle known as the <emphasis>hiding principle</emphasis>: One can
make a system more modular and robust by protecting parts of the
system from each other; that is, by providing information access only
to those parts of the system that have a "need to know."</p>

<p><sup>5</sup> In contrast with new-withdraw above, we do not
have to use let to make balance a local variable, since
formal parameters are already local.  This will be clearer after the
discussion of the environment model of evaluation in section 3.2.
(See also exercise 3.10.)</p>

<p><sup>6</sup> One common way to implement
rand-update is to use the rule that <emphasis>x</emphasis> is updated to <emphasis>a</emphasis><emphasis>x</emphasis> + <emphasis>b</emphasis>
modulo <emphasis>m</emphasis>, where <emphasis>a</emphasis>, <emphasis>b</emphasis>, and <emphasis>m</emphasis> are appropriately chosen integers.
Chapter 3 of Knuth 1981 includes an extensive discussion of techniques
for generating sequences of random numbers and establishing their
statistical properties.  Notice that the rand-update procedure
computes a mathematical function: Given the same input twice, it
produces the same output.  Therefore, the number sequence produced by
rand-update certainly is not "random", if by "random" we
insist that each number in the sequence is unrelated to the preceding
number.  The relation between "real randomness" and so-called <emphasis>pseudo-random</emphasis> sequences, which are produced by well-determined
computations and yet have suitable statistical properties, is a
complex question involving difficult issues in mathematics and
philosophy.  Kolmogorov, Solomonoff, and Chaitin have made great
progress in clarifying these issues; a discussion can be found in
Chaitin 1975.</p>

<p><sup>7</sup> This theorem is due to E. Cesàro.  See
section 4.5.2 of Knuth 1981 for a discussion and a proof.</p>

<p><sup>8</sup> MIT Scheme provides such a procedure.  If random
is given an exact
integer (as in section 1.2.6) it returns an exact integer,
but if it is given a decimal value (as in this exercise) it returns
a decimal value.</p>

<p><sup>9</sup> We don't substitute for
the occurrence of balance in the set! expression because
the &lt;<emphasis>name</emphasis>&gt; in a set! is not evaluated.
If we did substitute for it, we would get
(set! 25 (- 25 amount)), which makes no sense.</p>

<p><sup>10</sup> The phenomenon of a
single computational object being accessed by more than one name is
known as <emphasis>aliasing</emphasis>.  The joint bank account situation illustrates
a very simple example of an alias.  In section 3.3
we will see much more complex examples, such as "distinct" compound
data structures that share parts.  Bugs can occur in our programs if
we forget that a change to an object may also, as a "side effect",
change a "different" object because the two "different" objects
are actually a single object appearing under different aliases.  These
so-called <emphasis>side-effect bugs</emphasis> are so difficult to locate and to
analyze that some people have proposed that programming languages be
designed in such a way as to not allow side effects or aliasing
(Lampson et al. 1981; Morris, Schmidt, and Wadler 1980).</p>

<p><sup>11</sup> In view of this, it is ironic that introductory programming
is most often taught in a highly imperative style.  This may be a
vestige of a belief, common throughout the 1960s and 1970s, that
programs that call procedures must inherently be less efficient than
programs that perform assignments.  (Steele (1977) debunks this
argument.)  Alternatively it may reflect a view that step-by-step
assignment is easier for beginners to visualize than procedure call.
Whatever the reason, it often saddles beginning programmers with
"should I set this variable before or after that one" concerns that can
complicate programming and obscure the important ideas.</p>


</section>

<section>


<p><strong>3.2  The Environment Model of Evaluation</strong></p>

<p>



When we introduced compound procedures in chapter 1, we used the
substitution model of evaluation
(section 1.1.5) to define what is meant by
applying a procedure to arguments:</p>

<p>To apply a compound procedure to arguments, evaluate the body of the
procedure with each formal parameter replaced by the corresponding
argument.</p>

<p>

Once we admit assignment into our programming language, such a
definition is no longer adequate.  In particular,
section 3.1.3 argued that, in the presence of
assignment, a variable can no longer be considered to be merely a name
for a value.  Rather, a variable must somehow designate a "place" in
which values can be stored.  In our new model of evaluation, these
places will be maintained in structures called <emphasis>environments</emphasis>.</p>

<p>

An environment is a sequence of <emphasis>frames</emphasis>.  Each frame is a table
(possibly empty) of <emphasis>bindings</emphasis>, which associate variable names with
their corresponding values.  (A single frame may contain at most one
binding for any variable.)  Each frame also has a pointer to its <emphasis>enclosing environment</emphasis>, unless, for the purposes of discussion, the
frame is considered to be <emphasis>global</emphasis>.  The <emphasis>value of a variable</emphasis>
with respect to an environment is the value given by the binding of
the variable in the first frame in the environment that contains a
binding for that variable.  If no frame in the sequence specifies a
binding for the variable, then the variable is said to be <emphasis>unbound</emphasis> in the environment.</p>

<p><image xlink:href="#_134.jpg" /></p>

<p><strong>Figure 3.1:</strong>  A simple environment structure.</p>

<p>

Figure 3.1 shows a simple environment
structure consisting of three frames, labeled I, II, and III.  In the
diagram, A, B, C, and D are pointers to environments.  C and D point
to the same environment.  The variables z and x are bound
in frame II, while y and x are bound in frame I.  The
value of x in environment D is 3.  The value of x with
respect to environment B is also 3.  This is determined as follows: We
examine the first frame in the sequence (frame III) and do not find a
binding for x, so we proceed to the enclosing environment D and
find the binding in frame I.  On the other hand, the value of x
in environment A is 7, because the first frame in the sequence (frame
II) contains a binding of x to 7.  With respect to environment
A, the binding of x to 7 in frame II is said to <emphasis>shadow</emphasis> the
binding of x to 3 in frame I.</p>

<p>


The environment is crucial to the evaluation process,
because it determines the context in which an expression should be
evaluated.  Indeed, one could say that expressions in a programming
language do not, in themselves, have any meaning.  Rather, an
expression acquires a meaning only with respect to some environment in
which it is evaluated.  Even the interpretation of an expression as
straightforward as (+ 1 1) depends on an understanding that one
is operating in a context in which + is the symbol for addition.
Thus, in our model of evaluation we will always speak of evaluating an
expression with respect to some environment.  To describe interactions
with the interpreter, we will suppose that there is a global
environment, consisting of a single frame (with no enclosing
environment) that includes values for the symbols associated with the
primitive procedures.  For example, the idea that + is the
symbol for addition is captured by saying that the symbol + is
bound in the global environment to the primitive addition procedure.</p>

<p><strong>3.2.1  The Rules for Evaluation</strong></p>

<p>


The overall specification of how the interpreter evaluates a
combination remains the same as when we first introduced it in
section 1.1.3:</p>

<p>To evaluate a combination:</p><empty-line /><p>1.  Evaluate the subexpressions of the
combination.<sup>12</sup></p>

<p>2.  Apply the value of the operator subexpression to the values of the
operand subexpressions.</p>

<p>

The environment model of evaluation replaces the substitution model in
specifying what it means to apply a compound procedure to arguments.</p>

<p>

In the environment model of evaluation, a procedure is always a pair
consisting of some code and a pointer to an environment.  Procedures
are created in one way only: by evaluating a lambda expression.
This produces a procedure whose code is obtained from the text of the
lambda expression and whose environment is the environment in
which the lambda expression was evaluated to produce the
procedure.  For example, consider the procedure definition</p>

<p>(define (square x)</p><empty-line /><p>
  (* x x))</p><empty-line /><p>
evaluated in the global environment.  The procedure definition syntax
is just syntactic sugar for an underlying implicit lambda
expression.  It would have been equivalent to have used</p>

<p>(define square</p><empty-line /><p>
  (lambda (x) (* x x)))</p><empty-line /><p>
which evaluates (lambda (x) (* x x)) and binds square to the resulting value, all in the global environment.</p>

<p>

Figure 3.2 shows the result of evaluating this
define expression.  The procedure object is a pair whose code
specifies that the procedure has one formal parameter, namely x,
and a procedure body (* x x).  The environment part of the
procedure is a pointer to the global environment, since that is the
environment in which the lambda expression was evaluated to
produce the procedure. A new binding, which associates the procedure
object with the symbol square, has been added to the global
frame.  In general, define creates definitions by adding
bindings to frames.</p>

<p><image xlink:href="#_135.jpg" /></p>

<p><strong>Figure 3.2:</strong>  Environment structure produced by
evaluating
(define (square x) (* x x)) in the global environment.</p>

<p>

Now that we have seen how procedures are created, we can describe how
procedures are applied.  The environment model specifies: To apply a
procedure to arguments, create a new environment containing a frame
that binds the parameters to the values of the arguments.  The
enclosing environment of this frame is the environment specified by
the procedure.  Now, within this new environment, evaluate the
procedure body.</p>

<p>


To show how this rule is followed, figure 3.3
illustrates the environment structure created by evaluating the
expression (square 5) in the global environment, where square is the procedure generated in
figure 3.2.  Applying the procedure results in
the creation of a new environment, labeled E1 in the figure, that
begins with a frame in which x, the formal parameter for the
procedure, is bound to the argument 5.  The pointer leading upward
from this frame shows that the frame's enclosing environment is the
global environment.  The global environment is chosen here, because
this is the environment that is indicated as part of the square
procedure object.  Within E1, we evaluate the body of the procedure,
(* x x).  Since the value of x in E1 is 5, the result is
(* 5 5), or 25.</p>

<p><image xlink:href="#_136.jpg" /></p>

<p><strong>Figure 3.3:</strong>  Environment created by evaluating (square 5)
in the global environment.</p>

<p>

The environment model of procedure application can be summarized by
two rules:</p>

<p>A procedure object is applied to a set of arguments by
constructing a frame, binding the formal parameters of the procedure
to the arguments of the call, and then evaluating the body of
the procedure in the context of the new environment constructed.  The
new frame has as its enclosing environment the environment part of the
procedure object being applied.</p>

<p>A procedure is created by evaluating a lambda
expression relative to a given environment.  The resulting procedure
object is a pair consisting of the text of the lambda expression
and a pointer to the environment in which the procedure was created.</p>

<p>

We also specify that defining a symbol using define creates a
binding in the current environment frame and assigns to the symbol the
indicated value.<sup>13</sup>  Finally, we specify the behavior of
set!, the operation that forced us to introduce the environment
model in the first place.  Evaluating the expression (set!
&lt;<emphasis>variable</emphasis>&gt; &lt;<emphasis>value</emphasis>&gt;) in some environment locates the binding of
the variable in the environment and changes that binding to indicate
the new value.  That is, one finds the first frame in the environment
that contains a binding for the variable and modifies that frame.  If
the variable is unbound in the environment, then set! signals
an error.</p>

<p>


These evaluation rules, though considerably more complex than the
substitution model, are still reasonably straightforward.  Moreover,
the evaluation model, though abstract, provides a correct description
of how the interpreter evaluates expressions.  In chapter 4 we shall
see how this model can serve as a blueprint for implementing a working
interpreter.  The following sections elaborate the details of the
model by analyzing some illustrative programs.</p>

<p><strong>3.2.2  Applying Simple Procedures</strong></p>

<p>


When we introduced the substitution model in
section 1.1.5 we showed how the combination
(f 5) evaluates to 136, given the following procedure
definitions:</p>

<p>(define (square x)</p><empty-line /><p>
  (* x x))</p><empty-line /><p>
(define (sum-of-squares x y)</p><empty-line /><p>
  (+ (square x) (square y)))</p><empty-line /><p>
(define (f a)</p><empty-line /><p>
  (sum-of-squares (+ a 1) (* a 2)))</p><empty-line /><p>
We can analyze the same example using the environment model.
Figure 3.4 shows the three procedure objects
created by evaluating the definitions of f, square, and
sum-of-squares in the global environment.  Each procedure object
consists of some code, together with a pointer to the global
environment.</p>

<p><image xlink:href="#_137.jpg" /></p>

<p><strong>Figure 3.4:</strong>  Procedure objects in the global frame.</p>

<p>

In figure 3.5 we see the environment structure created
by evaluating the expression (f 5).  The call to f creates
a new environment E1 beginning with a frame in which a, the
formal parameter of f, is bound to the argument 5.  In E1, we
evaluate the body of f:</p>

<p>(sum-of-squares (+ a 1) (* a 2))</p><empty-line /><empty-line /><p><image xlink:href="#_138.jpg" /></p>

<p><strong>Figure 3.5:</strong>  Environments created by evaluating (f 5)
using the procedures in figure 3.4.</p>

<p>


To evaluate this combination, we first evaluate the subexpressions.
The first subexpression, sum-of-squares, has a value that is a
procedure object.  (Notice how this value is found: We first look in
the first frame of E1, which contains no binding for sum-of-squares.  Then we proceed to the enclosing environment,
i.e. the global environment, and find the binding shown in
figure 3.4.)  The other two subexpressions are
evaluated by applying the primitive operations + and * to
evaluate the two combinations (+ a 1) and (* a 2) to
obtain 6 and 10, respectively.</p>

<p>

Now we apply the procedure object sum-of-squares to the
arguments 6 and 10.  This results in a new environment E2 in which the
formal parameters x and y are bound to the arguments.
Within E2 we evaluate the combination (+ (square x) (square y)).
This leads us to evaluate (square x), where square is
found in the global frame and x is 6.  Once again, we set up a
new environment, E3, in which x is bound to 6, and within this
we evaluate the body of square, which is (* x x).  Also as
part of applying sum-of-squares, we must evaluate the
subexpression (square y), where y is 10.  This second call
to square creates another environment, E4, in which x, the
formal parameter of square, is bound to 10.  And within E4 we
must evaluate (* x x).</p>

<p>

The important point to observe is that each call to square
creates a new environment containing a binding for x.  We can
see here how the different frames serve to keep separate the different
local variables all named x.  Notice that each frame created by
square points to the global environment, since this is the
environment indicated by the square procedure object.</p>

<p>

After the subexpressions are evaluated, the results are
returned.  The values generated by the two calls to square are
added by sum-of-squares, and this result is returned by f.
Since our focus here is on the environment structures, we will not
dwell on how these returned values are passed from call to call;
however, this is also an important aspect of the evaluation process,
and we will return to it in detail in chapter 5.</p>

<p>
<strong>Exercise 3.9.</strong>  In section 1.2.1
we used the substitution model to analyze two
procedures for computing factorials, a recursive version</p>

<p>(define (factorial n)</p><empty-line /><p>
  (if (= n 1)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* n (factorial (- n 1)))))</p><empty-line /><p>
and an iterative version</p>

<p>(define (factorial n)</p><empty-line /><p>
  (fact-iter 1 1 n))</p><empty-line /><p>
(define (fact-iter product counter max-count)</p><empty-line /><p>
  (if (&gt; counter max-count)</p><empty-line /><p>
      product</p><empty-line /><p>
      (fact-iter (* counter product)</p><empty-line /><p>
                 (+ counter 1)</p><empty-line /><p>
                 max-count)))</p><empty-line /><p>
Show the environment structures created by evaluating (factorial 6)
using each version of the factorial procedure.<sup>14</sup></p>

<p><strong>3.2.3  Frames as the Repository of Local State</strong></p>

<p>



We can turn to the environment model to see how procedures and
assignment can be used to represent objects with local state.  As an
example, consider the "withdrawal processor" from
section 3.1.1 created by calling the
procedure</p>

<p>(define (make-withdraw balance)</p><empty-line /><p>
  (lambda (amount)</p><empty-line /><p>
    (if (&gt;= balance amount)</p><empty-line /><p>
        (begin (set! balance (- balance amount))</p><empty-line /><p>
               balance)</p><empty-line /><p>
        "Insufficient funds")))</p><empty-line /><p>
Let us describe the evaluation of</p>

<p>(define W1 (make-withdraw 100))</p><empty-line /><p>
followed by</p>

<p>(W1 50)</p><empty-line /><p><emphasis>50</emphasis></p><empty-line /><p>
Figure 3.6 shows the result of defining the make-withdraw procedure in the global environment.  This produces a
procedure object that contains a pointer to the global environment.
So far, this is no different from the examples we have already seen,
except that the body of the procedure is itself a lambda
expression.</p>

<p><image xlink:href="#_139.jpg" /></p>

<p><strong>Figure 3.6:</strong>  Result of defining make-withdraw
in the global environment.</p>

<p>

The interesting part of the computation happens when we apply the
procedure make-withdraw to an argument:</p>

<p>(define W1 (make-withdraw 100))</p><empty-line /><p>
We begin, as usual, by setting up an environment E1 in which the
formal parameter balance is bound to the argument 100.  Within
this environment, we evaluate the body of make-withdraw, namely
the lambda expression.  This constructs a new procedure object,
whose code is as specified by the lambda and whose environment
is E1, the environment in which the lambda was evaluated to
produce the procedure.  The resulting procedure object is the value
returned by the call to make-withdraw.  This is bound to W1 in the global environment, since the define itself is being
evaluated in the global environment.  Figure 3.7 shows the
resulting environment structure.</p>

<p><image xlink:href="#_140.jpg" /></p>

<p><strong>Figure 3.7:</strong>  Result of evaluating (define W1 (make-withdraw 100)).</p>

<p>

Now we can analyze what happens when W1 is applied to an
argument:</p>

<p>(W1 50)</p><empty-line /><p><emphasis>50</emphasis></p><empty-line /><p>
We begin by constructing a frame in which amount, the formal
parameter of W1, is bound to the argument 50.  The crucial point
to observe is that this frame has as its enclosing environment not the
global environment, but rather the environment E1, because this is the
environment that is specified by the W1 procedure object.
Within this new environment, we evaluate the body of the procedure:</p>

<p>(if (&gt;= balance amount)</p><empty-line /><p>
    (begin (set! balance (- balance amount))</p><empty-line /><p>
           balance)</p><empty-line /><p>
    "Insufficient funds")</p><empty-line /><p>
The resulting environment structure is shown in
figure 3.8.  The expression being evaluated references
both amount and balance.  Amount will be found in
the first frame in the environment, while balance will be found
by following the enclosing-environment pointer to E1.</p>

<p><image xlink:href="#_141.jpg" /></p>

<p><strong>Figure 3.8:</strong>  Environments created by applying the procedure
object W1.</p>

<p>

When the set! is executed, the binding of balance in E1 is changed.  At the completion of the call to W1,
balance is 50, and the frame that contains balance
is still pointed to by the procedure object W1.  The frame
that binds amount
(in which we executed the code that changed balance) is no longer
relevant, since the procedure call that constructed it has terminated,
and there are no pointers to that frame from other parts of the
environment.  The next time W1 is called, this will build a new
frame that binds amount and whose enclosing environment is E1.
We see that E1 serves as the "place" that holds the local state
variable for the procedure object W1.  Figure 3.9
shows the situation after the call to W1.</p>

<p><image xlink:href="#_142.jpg" /></p>

<p><strong>Figure 3.9:</strong>  Environments after the call to W1.</p>

<p>

Observe what happens when we create a second "withdraw" object by
making another call to make-withdraw:</p>

<p>(define W2 (make-withdraw 100))</p><empty-line /><p>
This produces the environment structure of figure 3.10, which shows
that W2 is a procedure object, that is, a pair with some code
and an environment.  The environment E2 for W2 was created by
the call to make-withdraw.  It contains a frame with its own
local binding for balance.  On the other hand, W1 and W2 have the same code: the code specified by the lambda
expression in the body of make-withdraw.<sup>15</sup> We see here why W1 and W2
behave as independent objects.  Calls to W1 reference the state
variable balance stored in E1, whereas calls to W2
reference the balance stored in E2. Thus, changes to the local
state of one object do not affect the other object.</p>

<p><image xlink:href="#_143.jpg" /></p>

<p><strong>Figure 3.10:</strong>  Using (define W2 (make-withdraw 100))
to create a second object.</p>

<p>
<strong>Exercise 3.10.</strong>  In the make-withdraw procedure, the local variable balance
is created as a parameter of make-withdraw.  We could also
create the local state variable explicitly, using let, as
follows:</p>

<p>(define (make-withdraw initial-amount)</p><empty-line /><p>
  (let ((balance initial-amount))</p><empty-line /><p>
    (lambda (amount)</p><empty-line /><p>
      (if (&gt;= balance amount)</p><empty-line /><p>
          (begin (set! balance (- balance amount))</p><empty-line /><p>
                 balance)</p><empty-line /><p>
          "Insufficient funds"))))</p><empty-line /><p>
Recall from section 1.3.2 that let is simply
syntactic sugar for a procedure call:</p>

<p>(let ((&lt;<emphasis>var</emphasis>&gt; &lt;<emphasis>exp</emphasis>&gt;)) &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
is interpreted as an alternate syntax for</p>

<p>((lambda (&lt;<emphasis>var</emphasis>&gt;) &lt;<emphasis>body</emphasis>&gt;) &lt;<emphasis>exp</emphasis>&gt;)</p><empty-line /><p>
Use the environment model to analyze this alternate
version of make-withdraw, drawing figures like the ones above to
illustrate the interactions</p>

<p>(define W1 (make-withdraw 100))</p><empty-line /><empty-line /><p>
(W1 50)</p><empty-line /><empty-line /><p>
(define W2 (make-withdraw 100))</p><empty-line /><p>
Show that the two versions of make-withdraw create objects with
the same behavior.  How do the environment structures differ for the two
versions?</p>

<p><strong>3.2.4  Internal Definitions</strong></p>

<p>


Section 1.1.8 introduced the idea that procedures can have internal
definitions, thus leading to a block structure as in the
following procedure to compute square roots:</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (define (good-enough? guess)</p><empty-line /><p>
    (&lt; (abs (- (square guess) x)) 0.001))</p><empty-line /><p>
  (define (improve guess)</p><empty-line /><p>
    (average guess (/ x guess)))</p><empty-line /><p>
  (define (sqrt-iter guess)</p><empty-line /><p>
    (if (good-enough? guess)</p><empty-line /><p>
        guess</p><empty-line /><p>
        (sqrt-iter (improve guess))))</p><empty-line /><p>
  (sqrt-iter 1.0))</p><empty-line /><p>
Now we can use the environment model to see why these internal
definitions behave as desired.  Figure 3.11 shows the point in the
evaluation of the expression (sqrt 2) where the internal
procedure good-enough? has been called for the first time with
guess equal to 1.</p>

<p><image xlink:href="#_144.jpg" /></p>

<p><strong>Figure 3.11:</strong>  Sqrt procedure with internal definitions.</p>

<p>

Observe the structure of the environment.  Sqrt is a symbol in
the global environment that is bound to a procedure object whose
associated environment is the global environment.  When sqrt was
called, a new environment E1 was formed, subordinate to the global
environment, in which the parameter x is bound to 2.  The body
of sqrt was then evaluated in E1.  Since the first expression in
the body of sqrt is</p>

<p>(define (good-enough? guess)</p><empty-line /><p>
  (&lt; (abs (- (square guess) x)) 0.001))</p><empty-line /><p>
evaluating this expression defined the procedure good-enough?
in the environment E1.  To be more precise, the symbol good-enough? was added to the first frame of E1, bound to a
procedure object whose associated environment is E1.  Similarly, improve and sqrt-iter were defined as procedures in E1.  For
conciseness, figure 3.11 shows only the procedure
object for good-enough?.</p>

<p>

After the local procedures were defined, the
expression (sqrt-iter 1.0) was evaluated,
still in environment E1.  So the
procedure object bound to sqrt-iter in E1 was called with 1 as
an argument.  This created an environment E2 in which guess,
the parameter of sqrt-iter, is bound to 1.  Sqrt-iter in
turn called good-enough? with the value of guess (from
E2) as the argument for good-enough?.  This set up another
environment, E3, in which guess (the parameter of good-enough?) is bound to 1.  Although sqrt-iter and good-enough? both have a parameter named guess, these are two
distinct local variables located in different frames.  Also, E2 and E3
both have E1 as their enclosing environment, because the sqrt-iter and good-enough? procedures both have E1 as their
environment part.  One consequence of this is that the symbol x
that appears in the body of good-enough? will reference the
binding of x that appears in E1, namely the value of x
with which the original sqrt procedure was called.

The environment model thus explains the two key properties that make
local procedure definitions a useful technique for modularizing
programs:</p>

<p>The names of the local procedures do not interfere with
names external to the enclosing procedure, because the local procedure
names will be bound in the frame that the procedure creates when it is
run, rather than being bound in the global environment.</p>

<p>The local procedures can access the arguments of the enclosing
procedure, simply by using parameter names as free variables.
This is because the body of the local procedure is evaluated in an
environment that is subordinate to the evaluation environment for the
enclosing procedure.</p>

<p>
<strong>Exercise 3.11.</strong>  In section 3.2.3
we saw how the environment model described the
behavior of procedures with local state.  Now we have seen how
internal definitions work.  A typical message-passing procedure
contains both of these aspects.  Consider the bank account procedure
of section 3.1.1:</p>

<p>(define (make-account balance)</p><empty-line /><p>
  (define (withdraw amount)</p><empty-line /><p>
    (if (&gt;= balance amount)</p><empty-line /><p>
        (begin (set! balance (- balance amount))</p><empty-line /><p>
               balance)</p><empty-line /><p>
        "Insufficient funds"))</p><empty-line /><p>
  (define (deposit amount)</p><empty-line /><p>
    (set! balance (+ balance amount))</p><empty-line /><p>
    balance)</p><empty-line /><p>
  (define (dispatch m)</p><empty-line /><p>
    (cond ((eq? m 'withdraw) withdraw)</p><empty-line /><p>
          ((eq? m 'deposit) deposit)</p><empty-line /><p>
          (else (error "Unknown request -- MAKE-ACCOUNT"</p><empty-line /><p>
                       m))))</p><empty-line /><p>
  dispatch)</p><empty-line /><p>
Show the environment structure generated by the sequence of
interactions</p>

<p>(define acc (make-account 50))</p><empty-line /><empty-line /><p>
((acc 'deposit) 40)</p><empty-line /><p><emphasis>90</emphasis></p><empty-line /><empty-line /><p>
((acc 'withdraw) 60)</p><empty-line /><p><emphasis>30</emphasis></p><empty-line /><p>
Where is the local state for acc kept?  Suppose we define
another account</p>

<p>(define acc2 (make-account 100))</p><empty-line /><p>
How are the local states for the two accounts kept distinct?  Which
parts of the environment structure are shared between acc and
acc2?</p><empty-line /><empty-line /><empty-line /><p><sup>12</sup> Assignment introduces a subtlety into step 1 of
the evaluation rule.  As shown in
exercise 3.8, the presence of assignment
allows us to write expressions that will produce different values
depending on the order in which the subexpressions in a combination
are evaluated.  Thus, to be precise, we should specify an evaluation
order in step 1 (e.g., left to right or right to left).  However, this
order should always be considered to be an implementation detail, and
one should never write programs that depend on some particular order.
For instance, a sophisticated compiler might optimize a program by
varying the order in which subexpressions are evaluated.</p>

<p><sup>13</sup> If there is already a binding for the
variable in the current frame, then the binding is changed.  This is
convenient because it allows redefinition of symbols; however, it also
means that define can be used to change values, and this brings
up the issues of assignment without explicitly using set!.
Because of this, some people prefer redefinitions of existing symbols
to signal errors or warnings.</p>

<p><sup>14</sup> The
environment model will not clarify our claim in
section 1.2.1 that the interpreter can
execute a procedure such as fact-iter in a constant amount of
space using tail recursion.  We will discuss tail recursion when we
deal with the control structure of the interpreter in
section 5.4.</p>

<p><sup>15</sup> Whether
W1 and W2 share the same physical code stored in the
computer, or whether they each keep a copy of the code, is a detail of
the implementation.  For the interpreter we implement in chapter 4,
the code is in fact shared.</p>


</section>

<section>


<p><strong>3.3  Modeling with Mutable Data</strong></p>

<p>



Chapter 2 dealt with compound data as a means for constructing
computational objects that have several parts, in order to model
real-world objects that have several aspects.  In that chapter we
introduced the discipline of data abstraction, according to which data
structures are specified in terms of constructors, which create data
objects, and selectors, which access the parts of compound data
objects.  But we now know that there is another aspect of data that
chapter 2 did not address.  The desire to model systems composed of
objects that have changing state leads us to the need to modify
compound data objects, as well as to construct and select from them.
In order to model compound objects with changing state, we will design
data abstractions to include, in addition to selectors and
constructors, operations called <emphasis>mutators</emphasis>, which modify data
objects.  For instance, modeling a banking system requires us to
change account balances.  Thus, a data structure for representing bank
accounts might admit an operation</p>

<p>(set-balance! &lt;<emphasis>account</emphasis>&gt; &lt;<emphasis>new-value</emphasis>&gt;)</p><empty-line /><p>
that changes the balance of the designated account to the designated
new value.  Data objects for which mutators are defined are known as
<emphasis>mutable data objects</emphasis>.</p>

<p>

Chapter 2 introduced pairs as a general-purpose "glue" for
synthesizing compound data.  We begin this section by defining basic
mutators for pairs, so that pairs can serve as building blocks for
constructing mutable data objects.  These mutators greatly enhance the
representational power of pairs, enabling us to build data structures
other than the sequences and trees that we worked with in
section 2.2.  We also present some examples of
simulations in which complex systems are modeled as collections of
objects with local state.</p>

<p><strong>3.3.1  Mutable List Structure</strong></p>

<p>




The basic operations on pairs -- cons, car, and cdr -- can be used to construct list structure and to select parts
from list structure, but they are incapable of modifying list
structure.  The same is true of the list operations we have used so
far, such as append and list, since these can be defined
in terms of cons, car, and cdr.  To modify list
structures we need new operations.</p>

<p><image xlink:href="#_145.jpg" /></p>

<p><strong>Figure 3.12:</strong>  Lists x: ((a b) c d) and y: (e
f).</p><empty-line /><p><image xlink:href="#_146.jpg" /></p>

<p><strong>Figure 3.13:</strong>  Effect of (set-car! x y) on the lists in
figure 3.12.</p><empty-line /><p><image xlink:href="#_147.jpg" /></p>

<p><strong>Figure 3.14:</strong>  Effect of (define z (cons y (cdr x))) on 
the lists in figure 3.12.</p><empty-line /><p><image xlink:href="#_148.jpg" /></p>

<p><strong>Figure 3.15:</strong>  Effect of (set-cdr! x y) on the lists in
figure 3.12.</p>

<p>

The primitive mutators for pairs are set-car! and set-cdr!. Set-car! takes two arguments, the first of which
must be a pair.  It modifies this pair, replacing the car
pointer by a pointer to the second argument of set-car!.<sup>16</sup></p>

<p>

As an example, suppose that x is bound to the list ((a b) c
d) and y to the list (e f) as illustrated in
figure 3.12.  Evaluating the expression (set-car!
x y) modifies the pair to which x is bound, replacing its car by the value of y.  The result of the operation is shown in
figure 3.13.  The structure x has been modified and
would now be printed
as ((e f) c d).  The
pairs representing the list (a b), identified by the pointer
that was replaced, are now detached from the original
structure.<sup>17</sup></p>

<p>

Compare figure 3.13 with figure 3.14,
which illustrates the result of executing (define z (cons y (cdr
x))) with x and y bound to the original lists of
figure 3.12.  The variable z is now bound to a
new pair created by the cons operation; the list to which x is bound is unchanged.</p>

<p>

The set-cdr! operation is similar to set-car!.  The
only difference is that the cdr pointer of the pair, rather than
the car pointer, is replaced.  The effect of executing (set-cdr! x y) on the lists of figure 3.12 is shown
in figure 3.15.
Here the cdr pointer of x has been replaced by the pointer
to (e f).  Also, the list (c d), which used to be the cdr of x, is now detached from the structure.</p>

<p>

Cons builds new list structure by creating new pairs, while
set-car! and set-cdr! modify existing pairs.  Indeed, we
could implement cons in terms of the two mutators, together with
a procedure get-new-pair, which returns a new pair that is not
part of any existing list structure.  We obtain the new pair, set its
car and cdr pointers to the designated objects, and return
the new pair as the result of the cons.<sup>18</sup></p>

<p>(define (cons x y)</p><empty-line /><p>
  (let ((new (get-new-pair)))</p><empty-line /><p>
    (set-car! new x)</p><empty-line /><p>
    (set-cdr! new y)</p><empty-line /><p>
    new))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.12.</strong>  The following procedure for appending lists was introduced in
section 2.2.1:</p>

<p>(define (append x y)</p><empty-line /><p>
  (if (null? x)</p><empty-line /><p>
      y</p><empty-line /><p>
      (cons (car x) (append (cdr x) y))))</p><empty-line /><p>
Append forms a new list by successively consing the
elements of x onto y.  The procedure append! is
similar to append, but it is a mutator rather than a constructor.
It appends the lists by splicing them together, modifying the final
pair of x so that its cdr is now y.
(It is an error to call append! with an empty x.)</p>

<p>(define (append! x y)</p><empty-line /><p>
  (set-cdr! (last-pair x) y)</p><empty-line /><p>
  x)</p><empty-line /><p>
Here last-pair is a procedure that returns the last pair in its
argument:</p>

<p>(define (last-pair x)</p><empty-line /><p>
  (if (null? (cdr x))</p><empty-line /><p>
      x</p><empty-line /><p>
      (last-pair (cdr x))))</p><empty-line /><p>
Consider the interaction</p>

<p>(define x (list 'a 'b))</p><empty-line /><p>
(define y (list 'c 'd))</p><empty-line /><p>
(define z (append x y))</p><empty-line /><p>
z</p><empty-line /><p><emphasis>(a b c d)</emphasis></p><empty-line /><p>
(cdr x)</p><empty-line /><p>
&lt;<emphasis>response</emphasis>&gt;</p><empty-line /><p>
(define w (append! x y))</p><empty-line /><p>
w</p><empty-line /><p><emphasis>(a b c d)</emphasis></p><empty-line /><p>
(cdr x)</p><empty-line /><p>
&lt;<emphasis>response</emphasis>&gt;</p><empty-line /><p>
What are the missing &lt;<emphasis>response</emphasis>&gt;s?
Draw box-and-pointer diagrams to explain your answer.</p>

<p>
<strong>Exercise 3.13.</strong>  Consider the following make-cycle procedure, which uses the last-pair procedure defined in exercise 3.12:</p>

<p>(define (make-cycle x)</p><empty-line /><p>
  (set-cdr! (last-pair x) x)</p><empty-line /><p>
  x)</p><empty-line /><p>
Draw a box-and-pointer diagram that shows the structure z
created by</p>

<p>(define z (make-cycle (list 'a 'b 'c)))</p><empty-line /><p>
What happens if we try to compute (last-pair z)?</p>

<p>
<strong>Exercise 3.14.</strong>  The following procedure is quite useful, although obscure:</p>

<p>(define (mystery x)</p><empty-line /><p>
  (define (loop x y)</p><empty-line /><p>
    (if (null? x)</p><empty-line /><p>
        y</p><empty-line /><p>
        (let ((temp (cdr x)))</p><empty-line /><p>
          (set-cdr! x y)</p><empty-line /><p>
          (loop temp x))))</p><empty-line /><p>
  (loop x '()))</p><empty-line /><p>
Loop uses the "temporary" variable temp to hold
the old value of the cdr of x, since the set-cdr!
on the next line destroys the cdr.  Explain what mystery
does in general.  Suppose v is defined by (define v (list 'a
'b 'c 'd)). Draw the box-and-pointer diagram that represents the list
to which v is bound.  Suppose that we now evaluate (define
w (mystery v)). Draw box-and-pointer diagrams that show the
structures v and w after evaluating this expression.  What
would be printed as the values of v and w ?</p>

<p><strong>Sharing and identity</strong></p>

<p>


We mentioned in section 3.1.3 the theoretical
issues of "sameness" and "change" raised by the introduction of
assignment.  These issues arise in practice when individual pairs are
<emphasis>shared</emphasis> among different data objects.  For example, consider the
structure formed by</p>

<p>(define x (list 'a 'b))</p><empty-line /><p>
(define z1 (cons x x))</p><empty-line /><p>
As shown in figure 3.16, z1 is a pair whose car and cdr both point to the same pair x.  This sharing
of x by the car and cdr of z1 is a consequence
of the straightforward way in which cons is implemented.  In
general, using cons to construct lists will result in an
interlinked structure of pairs in which many individual pairs are
shared by many different structures.</p>

<p><image xlink:href="#_149.jpg" /></p>

<p><strong>Figure 3.16:</strong>  The list z1 formed by (cons x x).</p><empty-line /><p><image xlink:href="#_150.jpg" /></p>

<p><strong>Figure 3.17:</strong>  The list z2 formed by 
(cons (list 'a 'b) (list 'a 'b)).</p>

<p>


In contrast to figure 3.16, figure 3.17 shows
the structure created by</p>

<p>(define z2 (cons (list 'a 'b) (list 'a 'b)))</p><empty-line /><p>
In this structure, the pairs in the two (a b) lists are
distinct, although the actual symbols are shared.<sup>19</sup></p>

<p>

When thought of as a list, z1 and z2 both represent "the
same" list, ((a b) a b).  In general, sharing is completely
undetectable if we operate on lists using only cons, car,
and cdr.  However, if we allow mutators on list structure,
sharing becomes significant.  As an example of the difference that
sharing can make, consider the following procedure, which modifies the
car of the structure to which it is applied:</p>

<p>(define (set-to-wow! x)</p><empty-line /><p>
  (set-car! (car x) 'wow)</p><empty-line /><p>
  x)</p><empty-line /><p>
Even though z1 and z2 are "the same" structure,
applying set-to-wow! to them yields different results.  With
z1, altering the car also changes the cdr, because
in z1 the car and the cdr are the same pair.  With
z2, the car and cdr are distinct, so set-to-wow! modifies only the car:</p>

<p>z1</p><empty-line /><p><emphasis>((a b) a b)</emphasis></p><empty-line /><empty-line /><p>
(set-to-wow! z1)</p><empty-line /><p><emphasis>((wow b) wow b)</emphasis></p><empty-line /><empty-line /><p>
z2</p><empty-line /><p><emphasis>((a b) a b)</emphasis></p><empty-line /><empty-line /><p>
(set-to-wow! z2)</p><empty-line /><p><emphasis>((wow b) a b)</emphasis></p><empty-line /><empty-line /><p>

One way to detect sharing in list structures is to use the predicate
eq?, which we introduced in section 2.3.1 as a
way to test whether two symbols are equal.  More generally, (eq?
x y) tests whether x and y are the same object (that is,
whether x and y are equal as pointers).  Thus, with z1 and z2 as defined in figures 3.16
and 3.17, (eq? (car z1) (cdr z1)) is true and
(eq? (car z2) (cdr z2)) is false.</p>

<p>

As will be seen in the following sections, we can exploit sharing to
greatly extend the repertoire of data structures that can be
represented by pairs.  On the other hand, sharing can also be
dangerous, since modifications made to structures will also affect
other structures that happen to share the modified parts.  The
mutation operations set-car! and set-cdr! should be used
with care; unless we have a good understanding of how our data objects
are shared, mutation can have unanticipated results.<sup>20</sup></p>

<p>
<strong>Exercise 3.15.</strong>  Draw box-and-pointer diagrams to explain the effect of set-to-wow! on the structures z1 and z2 above.</p>

<p>
<strong>Exercise 3.16.</strong>  Ben Bitdiddle decides to write a procedure to count the number of
pairs in any list structure.  "It's easy", he reasons.  "The number
of pairs in any structure is the number in the car plus the
number in the cdr plus one more to count the current pair."
So Ben writes the following procedure:</p>

<p>(define (count-pairs x)</p><empty-line /><p>
  (if (not (pair? x))</p><empty-line /><p>
      0</p><empty-line /><p>
      (+ (count-pairs (car x))</p><empty-line /><p>
         (count-pairs (cdr x))</p><empty-line /><p>
         1)))</p><empty-line /><p>
Show that this procedure is not correct.  In particular, draw
box-and-pointer diagrams representing list structures made up of
exactly three pairs for which Ben's procedure would return 3; return
4; return 7; never return at all.</p>

<p>
<strong>Exercise 3.17.</strong>  Devise a correct version of the count-pairs procedure of
exercise 3.16 that returns the number of distinct
pairs in any structure.  (Hint: Traverse the structure, maintaining an
auxiliary data structure that is used to keep track of which pairs
have already been counted.)</p><empty-line /><p>
<strong>Exercise 3.18.</strong>  Write a procedure that examines a list and determines whether it
contains a cycle, that is, whether a program that tried to find the
end of the list by taking successive cdrs would go into an
infinite loop.  Exercise 3.13 constructed such lists.</p>

<p>
<strong>Exercise 3.19.</strong>  Redo exercise 3.18 using an algorithm that takes only a
constant amount of space.  (This requires a very clever idea.)</p>

<p><strong>Mutation is just assignment</strong></p>

<p>


When we introduced compound data, we observed in
section 2.1.3 that pairs can be represented purely in terms
of procedures:</p>

<p>(define (cons x y)</p><empty-line /><p>
  (define (dispatch m)</p><empty-line /><p>
    (cond ((eq? m 'car) x)</p><empty-line /><p>
          ((eq? m 'cdr) y)</p><empty-line /><p>
          (else (error "Undefined operation -- CONS" m))))</p><empty-line /><p>
  dispatch)</p><empty-line /><p>(define (car z) (z 'car))</p><empty-line /><p>(define (cdr z) (z 'cdr))</p><empty-line /><p>
The same observation is true for mutable data.  We can implement
mutable data objects as procedures using assignment and local state.
For instance, we can extend the above pair implementation to handle
set-car! and set-cdr! in a manner analogous to the way
we implemented bank accounts using make-account in
section 3.1.1:</p>

<p>(define (cons x y)</p><empty-line /><p>
  (define (set-x! v) (set! x v))</p><empty-line /><p>
  (define (set-y! v) (set! y v))</p><empty-line /><p>
  (define (dispatch m)</p><empty-line /><p>
    (cond ((eq? m 'car) x)</p><empty-line /><p>
          ((eq? m 'cdr) y)</p><empty-line /><p>
          ((eq? m 'set-car!) set-x!)</p><empty-line /><p>
          ((eq? m 'set-cdr!) set-y!)</p><empty-line /><p>
          (else (error "Undefined operation -- CONS" m))))</p><empty-line /><p>
  dispatch)</p><empty-line /><p>(define (car z) (z 'car))</p><empty-line /><p>(define (cdr z) (z 'cdr))</p><empty-line /><p>(define (set-car! z new-value)</p><empty-line /><p>
  ((z 'set-car!) new-value)</p><empty-line /><p>
  z)</p><empty-line /><p>(define (set-cdr! z new-value)</p><empty-line /><p>
  ((z 'set-cdr!) new-value)</p><empty-line /><p>
  z)</p><empty-line /><empty-line /><p>

Assignment is all that is needed, theoretically, to account for the
behavior of mutable data.  As soon as we admit set! to our
language, we raise all the issues, not only of assignment, but of
mutable data in general.<sup>21</sup></p>

<p>
<strong>Exercise 3.20.</strong>  Draw environment diagrams to illustrate the evaluation of the sequence
of expressions</p>

<p>(define x (cons 1 2))</p><empty-line /><p>
(define z (cons x x))</p><empty-line /><p>
(set-car! (cdr z) 17)</p><empty-line /><p>
(car x)</p><empty-line /><p><emphasis>17</emphasis></p><empty-line /><p>
using the procedural implementation of pairs given above.  (Compare
exercise 3.11.)</p>

<p><strong>3.3.2  Representing Queues</strong></p>

<p>



The mutators set-car! and set-cdr! enable us to use
pairs to construct data structures that cannot be built with cons, car, and cdr alone.  This section shows how to use
pairs to represent a data structure called a queue.  Section 3.3.3
will show how to represent data structures called tables.</p>

<p>

A <emphasis>queue</emphasis> is a sequence in which items are inserted at one end
(called the <emphasis>rear</emphasis> of the queue) and deleted from the other end
(the <emphasis>front</emphasis>).  Figure 3.18 shows an initially empty
queue in which the items a and b are inserted.  Then a is removed, c and d are inserted, and b is
removed.  Because items are always removed in the order in which they
are inserted, a queue is sometimes called a <emphasis>FIFO</emphasis> (first in,
first out) buffer.</p>

<p>Operation Resulting Queue  (define q (make-queue)) (insert-queue! q 'a) a(insert-queue! q 'b) a b(delete-queue! q) b(insert-queue! q 'c) b c(insert-queue! q 'd) b c d(delete-queue! q) c d</p>

<p><strong>Figure 3.18:</strong>  Queue operations.</p>

<p>

In terms of data abstraction, we can regard a queue as defined by the
following set of operations:</p>

<p>a constructor:</p><empty-line /><p>(make-queue)</p><empty-line /><p>
returns an empty queue (a queue containing no items).</p>

<p>two selectors:</p><empty-line /><p>(empty-queue? &lt;<emphasis>queue</emphasis>&gt;)</p><empty-line /><p>
tests if the queue is empty.</p><empty-line /><p>(front-queue &lt;<emphasis>queue</emphasis>&gt;)</p><empty-line /><p>
returns the object at the front of
the queue, signaling an error if the queue is empty; it does not
modify the queue.</p>

<p>two mutators:</p><empty-line /><p>(insert-queue! &lt;<emphasis>queue</emphasis>&gt; &lt;<emphasis>item</emphasis>&gt;)</p><empty-line /><p>
inserts the item at the rear of the queue and returns the modified
queue as its value.</p><empty-line /><p>(delete-queue! &lt;<emphasis>queue</emphasis>&gt;)</p><empty-line /><p>
removes the item at the
front of the queue and returns the modified queue as its value,
signaling an error if the queue is empty before the deletion.</p>

<p>

Because a queue is a sequence of items, we could certainly represent
it as an ordinary list; the front of the queue would be the car
of the list, inserting an item in the queue would amount to appending
a new element at the end of the list, and deleting an item from the
queue would just be taking the cdr of the list.  However, this
representation is inefficient, because in order to insert an item we
must scan the list until we reach the end.  Since the only method we
have for scanning a list is by successive cdr operations, this
scanning requires <image xlink:href="#_25.jpg" />(<emphasis>n</emphasis>) steps for a list of <emphasis>n</emphasis> items.  A simple
modification to the list representation overcomes this disadvantage by
allowing the queue operations to be implemented so that they require
<image xlink:href="#_25.jpg" />(1) steps; that is, so that the number of steps
needed is independent of the length of the queue.</p>

<p>

The difficulty with the list representation arises from the need to
scan to find the end of the list.  The reason we need to scan is that,
although the standard way of representing a list as a chain of pairs
readily provides us with a pointer to the beginning of the list, it
gives us no easily accessible pointer to the end.  The modification
that avoids the drawback is to represent the queue as a list, together
with an additional pointer that indicates the final pair in the list.
That way, when we go to insert an item, we can consult the rear
pointer and so avoid scanning the list.</p>

<p>

A queue is represented, then, as a pair of pointers, front-ptr
and rear-ptr, which indicate, respectively, the first and last
pairs in an ordinary list.  Since we would like the queue to be an
identifiable object, we can use cons to combine the two
pointers.  Thus, the queue itself will be the cons of the two
pointers.  Figure 3.19 illustrates this
representation.</p>

<p><image xlink:href="#_151.jpg" /></p>

<p><strong>Figure 3.19:</strong>  Implementation of a queue as a list with front and rear
pointers.</p>

<p>

To define the queue operations we use the following procedures, which
enable us to select and to modify the front and rear pointers of a
queue:</p>

<p>(define (front-ptr queue) (car queue))</p><empty-line /><p>(define (rear-ptr queue) (cdr queue))</p><empty-line /><p>(define (set-front-ptr! queue item) (set-car! queue item))</p><empty-line /><p>(define (set-rear-ptr! queue item) (set-cdr! queue item))</p><empty-line /><empty-line /><p>

Now we can implement the actual queue operations.  We will consider a
queue to be empty if its front pointer is the empty list:</p>

<p>(define (empty-queue? queue) (null? (front-ptr queue)))</p><empty-line /><p>
The make-queue constructor returns, as an initially empty queue,
a pair whose car and cdr are both the empty list:</p>

<p>(define (make-queue) (cons '() '()))</p><empty-line /><p>
To select the item at the front of the queue, we return the car
of the pair indicated by the front pointer:</p>

<p>(define (front-queue queue)</p><empty-line /><p>
  (if (empty-queue? queue)</p><empty-line /><p>
      (error "FRONT called with an empty queue" queue)</p><empty-line /><p>
      (car (front-ptr queue))))</p><empty-line /><empty-line /><p>


To insert an item in a queue, we follow the method whose result is
indicated in figure 3.20.  We first create a new
pair whose car is the item to be inserted and whose cdr is
the empty list.  If the queue was initially empty, we set the front and
rear pointers of the queue to this new pair.  Otherwise, we modify the
final pair in the queue to point to the new pair, and also set the
rear pointer to the new pair.</p>

<p><image xlink:href="#_152.jpg" /></p>

<p><strong>Figure 3.20:</strong>  Result of using (insert-queue! q 'd) 
on the queue of figure 3.19.</p><empty-line /><p>(define (insert-queue! queue item)</p><empty-line /><p>
  (let ((new-pair (cons item '())))</p><empty-line /><p>
    (cond ((empty-queue? queue)</p><empty-line /><p>
           (set-front-ptr! queue new-pair)</p><empty-line /><p>
           (set-rear-ptr! queue new-pair)</p><empty-line /><p>
           queue)</p><empty-line /><p>
          (else</p><empty-line /><p>
           (set-cdr! (rear-ptr queue) new-pair)</p><empty-line /><p>
           (set-rear-ptr! queue new-pair)</p><empty-line /><p>
           queue))))</p><empty-line /><empty-line /><p>

To delete the item at the front of the queue, we merely modify the
front pointer so that it now points at the second item in the queue,
which can be found by following the cdr pointer of the first
item (see figure 3.21):<sup>22</sup></p>

<p><image xlink:href="#_153.jpg" /></p>

<p><strong>Figure 3.21:</strong>  Result of using (delete-queue! q) on 
the queue of figure 3.20.</p><empty-line /><p>(define (delete-queue! queue)</p><empty-line /><p>
  (cond ((empty-queue? queue)</p><empty-line /><p>
         (error "DELETE! called with an empty queue" queue))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (set-front-ptr! queue (cdr (front-ptr queue)))</p><empty-line /><p>
         queue)))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.21.</strong>  Ben Bitdiddle decides to test the queue implementation described
above.  He types in the procedures to the Lisp interpreter and
proceeds to try them out:</p>

<p>(define q1 (make-queue))</p><empty-line /><p>
(insert-queue! q1 'a)</p><empty-line /><p><emphasis>((a) a)</emphasis></p><empty-line /><p>
(insert-queue! q1 'b)</p><empty-line /><p><emphasis>((a b) b)</emphasis></p><empty-line /><p>
(delete-queue! q1)</p><empty-line /><p><emphasis>((b) b)</emphasis></p><empty-line /><p>
(delete-queue! q1)</p><empty-line /><p><emphasis>(() b)</emphasis></p><empty-line /><p>
"It's all wrong!" he complains.  "The interpreter's response shows
that the last item is inserted into the queue twice.  And when I
delete both items, the second b is still there, so the queue
isn't empty, even though it's supposed to be."  Eva Lu Ator suggests
that Ben has misunderstood what is happening.  "It's not that the
items are going into the queue twice", she explains.  "It's just
that the standard Lisp printer doesn't know how to make sense of the
queue representation.  If you want to see the queue printed correctly,
you'll have to define your own print procedure for queues." Explain
what Eva Lu is talking about.  In particular, show why Ben's examples
produce the printed results that they do.  Define a procedure print-queue that takes a queue as input and prints the sequence of
items in the queue.</p>

<p>
<strong>Exercise 3.22.</strong>  Instead of representing a queue as a pair of pointers, we can build a
queue as a procedure with local state.  The local state will consist
of pointers to the beginning and the end of an ordinary list.  Thus,
the make-queue procedure will have the form</p>

<p>(define (make-queue)</p><empty-line /><p>
  (let ((front-ptr ...)</p><empty-line /><p>
        (rear-ptr ...))</p><empty-line /><p>
    &lt;<emphasis>definitions of internal procedures</emphasis>&gt;</p><empty-line /><p>
    (define (dispatch m) ...)</p><empty-line /><p>
    dispatch))</p><empty-line /><p>
Complete the definition of make-queue and provide
implementations of the queue operations using this representation.</p>

<p>
<strong>Exercise 3.23.</strong>  A <emphasis>deque</emphasis> ("double-ended queue") is a sequence in which items
can be inserted and deleted at either the front or the rear.
Operations on deques are the constructor make-deque, the predicate empty-deque?, selectors front-deque and rear-deque, and mutators front-insert-deque!, rear-insert-deque!, front-delete-deque!, and rear-delete-deque!.  Show how to represent deques using pairs, and
give implementations of the operations.<sup>23</sup>
All operations should be accomplished in <image xlink:href="#_25.jpg" />(1) steps.</p>

<p><strong>3.3.3  Representing Tables</strong></p>

<p>



When we studied various ways of representing sets in chapter 2, we
mentioned in section 2.3.3 the task of
maintaining a table of records indexed by identifying keys.  In the
implementation of data-directed programming in
section 2.4.3, we made extensive use of
two-dimensional tables, in which information is stored and retrieved
using two keys.  Here we see how to build tables as mutable list
structures.</p>

<p>

We first consider a one-dimensional table, in which each value is
stored under a single key.  We implement the table as a list of
records, each of which is implemented as a pair consisting of a key
and the associated value. The records are glued together to form a
list by pairs whose cars point to successive records.  These
gluing pairs are called the <emphasis>backbone</emphasis> of the table.  In order to
have a place that we can change when we add a new record to the table,
we build the table as a <emphasis>headed list</emphasis>.  A headed list has a
special backbone pair at the beginning, which holds a dummy
"record" -- in this case the arbitrarily chosen symbol *table*.
Figure 3.22 shows the box-and-pointer diagram for the table</p>

<p>a:  1</p><empty-line /><p>
b:  2</p><empty-line /><p>
c:  3</p><empty-line /><empty-line /><p><image xlink:href="#_154.jpg" /></p>

<p><strong>Figure 3.22:</strong>  A table represented as a headed list.</p>

<p>

To extract information from a table we use the lookup
procedure, which takes a key as argument and returns the associated
value (or false if there is no value stored under that key).
Lookup is defined in terms of the assoc operation, which
expects a key and a list of records as arguments.  Note that assoc never sees the dummy record.  Assoc returns the record
that has the given key as its car.<sup>24</sup>
Lookup then
checks to see that the resulting record returned by assoc is not
false, and returns the value (the cdr) of the record.</p>

<p>(define (lookup key table)</p><empty-line /><p>
  (let ((record (assoc key (cdr table))))</p><empty-line /><p>
    (if record</p><empty-line /><p>
        (cdr record)</p><empty-line /><p>
        false)))</p><empty-line /><p>(define (assoc key records)</p><empty-line /><p>
  (cond ((null? records) false)</p><empty-line /><p>
        ((equal? key (caar records)) (car records))</p><empty-line /><p>
        (else (assoc key (cdr records)))))</p><empty-line /><empty-line /><p>

To insert a value in a table under a specified key, we first use assoc to see if there is already a record in the table with this key.
If not, we form a new record by consing the key with the value,
and insert this at the head of the table's list of records, after the
dummy record.  If there already is a record with this key, we set the
cdr of this record to the designated new value.  The header of
the table provides us with a fixed location to modify in order to
insert the new record.<sup>25</sup></p>

<p>(define (insert! key value table)</p><empty-line /><p>
  (let ((record (assoc key (cdr table))))</p><empty-line /><p>
    (if record</p><empty-line /><p>
        (set-cdr! record value)</p><empty-line /><p>
        (set-cdr! table</p><empty-line /><p>
                  (cons (cons key value) (cdr table)))))</p><empty-line /><p>
  'ok)</p><empty-line /><empty-line /><p>

To construct a new table, we simply create a list containing the
symbol *table*:</p>

<p>(define (make-table)</p><empty-line /><p>
  (list '*table*))</p><empty-line /><empty-line /><p><strong>Two-dimensional tables</strong></p>

<p>


In a two-dimensional table, each value is indexed by two keys.  We can
construct such a table as a one-dimensional table in which each key
identifies a subtable.
Figure 3.23 shows the box-and-pointer diagram for the table</p>

<p>math:</p><empty-line /><p>
    +:  43</p><empty-line /><p>
    -:  45</p><empty-line /><p>
    *:  42</p><empty-line /><p>
letters:</p><empty-line /><p>
    a:  97</p><empty-line /><p>
    b:  98</p><empty-line /><p>
which has two subtables.  (The subtables don't need a
special header symbol, since the key that identifies the subtable
serves this purpose.)</p>

<p><image xlink:href="#_155.jpg" /></p>

<p><strong>Figure 3.23:</strong>  A two-dimensional table.</p>

<p>

When we look up an item, we use the first key
to identify the correct subtable.  Then we use the second key to
identify the record within the subtable.</p>

<p>(define (lookup key-1 key-2 table)</p><empty-line /><p>
  (let ((subtable (assoc key-1 (cdr table))))</p><empty-line /><p>
    (if subtable</p><empty-line /><p>
        (let ((record (assoc key-2 (cdr subtable))))</p><empty-line /><p>
          (if record</p><empty-line /><p>
              (cdr record)</p><empty-line /><p>
              false))</p><empty-line /><p>
        false)))</p><empty-line /><empty-line /><p>

To insert a new item under a pair of keys, we use assoc to see if
there is a subtable stored under the first key.  If not, we build a
new subtable containing the single record (key-2, value)
and insert it into the table under the first key.  If a subtable
already exists for the first key, we insert the new record into this
subtable, using the insertion method for one-dimensional tables
described above:</p>

<p>(define (insert! key-1 key-2 value table)</p><empty-line /><p>
  (let ((subtable (assoc key-1 (cdr table))))</p><empty-line /><p>
    (if subtable</p><empty-line /><p>
        (let ((record (assoc key-2 (cdr subtable))))</p><empty-line /><p>
          (if record</p><empty-line /><p>
              (set-cdr! record value)</p><empty-line /><p>
              (set-cdr! subtable</p><empty-line /><p>
                        (cons (cons key-2 value)</p><empty-line /><p>
                              (cdr subtable)))))</p><empty-line /><p>
        (set-cdr! table</p><empty-line /><p>
                  (cons (list key-1</p><empty-line /><p>
                              (cons key-2 value))</p><empty-line /><p>
                        (cdr table)))))</p><empty-line /><p>
  'ok)</p><empty-line /><empty-line /><p><strong>Creating local tables</strong></p>

<p>


The lookup and insert! operations defined above take the
table as an argument.  This enables us to use programs that access
more than one table.  Another way to deal with multiple tables is to
have separate lookup and insert! procedures for each
table.  We can do this by representing a table procedurally, as an
object that maintains an internal table as part of its local state.
When sent an appropriate message, this "table object" supplies the
procedure with which to operate on the internal table.  Here is a
generator for two-dimensional tables represented in this fashion:</p>

<p>(define (make-table)</p><empty-line /><p>
  (let ((local-table (list '*table*)))</p><empty-line /><p>
    (define (lookup key-1 key-2)</p><empty-line /><p>
      (let ((subtable (assoc key-1 (cdr local-table))))</p><empty-line /><p>
        (if subtable</p><empty-line /><p>
            (let ((record (assoc key-2 (cdr subtable))))</p><empty-line /><p>
              (if record</p><empty-line /><p>
                  (cdr record)</p><empty-line /><p>
                  false))</p><empty-line /><p>
            false)))</p><empty-line /><p>
    (define (insert! key-1 key-2 value)</p><empty-line /><p>
      (let ((subtable (assoc key-1 (cdr local-table))))</p><empty-line /><p>
        (if subtable</p><empty-line /><p>
            (let ((record (assoc key-2 (cdr subtable))))</p><empty-line /><p>
              (if record</p><empty-line /><p>
                  (set-cdr! record value)</p><empty-line /><p>
                  (set-cdr! subtable</p><empty-line /><p>
                            (cons (cons key-2 value)</p><empty-line /><p>
                                  (cdr subtable)))))</p><empty-line /><p>
            (set-cdr! local-table</p><empty-line /><p>
                      (cons (list key-1</p><empty-line /><p>
                                  (cons key-2 value))</p><empty-line /><p>
                            (cdr local-table)))))</p><empty-line /><p>
      'ok)</p><empty-line /><p>
    (define (dispatch m)</p><empty-line /><p>
      (cond ((eq? m 'lookup-proc) lookup)</p><empty-line /><p>
            ((eq? m 'insert-proc!) insert!)</p><empty-line /><p>
            (else (error "Unknown operation -- TABLE" m))))</p><empty-line /><p>
    dispatch))</p><empty-line /><empty-line /><p>

Using make-table, we could implement the get and put
operations used in section 2.4.3 for data-directed
programming, as follows:</p>

<p>(define operation-table (make-table))</p><empty-line /><p>(define get (operation-table 'lookup-proc))</p><empty-line /><p>(define put (operation-table 'insert-proc!))</p><empty-line /><p>
Get takes as arguments two keys, and put takes
as arguments two keys and a value.  Both operations access the same
local table, which is encapsulated within the object created by the
call to make-table.</p>

<p>
<strong>Exercise 3.24.</strong>  In the table implementations above, the keys are tested for equality
using equal? (called by assoc).  This is not always the appropriate test.  For
instance, we might have a table with numeric keys in which we don't
need an exact match to the number we're looking up,
but only a number within some tolerance of it.
Design a table constructor make-table that takes as an argument a same-key? procedure
that will be used to test "equality" of keys.  Make-table should
return a dispatch procedure that can be used to access
appropriate lookup and insert! procedures for a local
table.</p>

<p>
<strong>Exercise 3.25.</strong>  Generalizing one- and two-dimensional tables, show how to implement a
table in which values are stored under an arbitrary number of keys and
different values may be stored under different numbers of keys.  The
lookup and insert! procedures should take as input a list
of keys used to access the table.</p>

<p>
<strong>Exercise 3.26.</strong>  To search a table as implemented above, one needs to scan through the
list of records.  This is basically the unordered list representation of
section 2.3.3.  For large tables, it may be more
efficient to structure the table in a different manner.  Describe a
table implementation where the (key, value) records are organized
using a binary tree, assuming that keys can be ordered in some way
(e.g., numerically or alphabetically).  (Compare
exercise 2.66 of chapter 2.)</p>

<p>
<strong>Exercise 3.27.</strong>  <emphasis>Memoization</emphasis> (also called <emphasis>tabulation</emphasis>) is a technique that
enables a procedure to record, in a local table, values that have
previously been computed.  This technique can make a vast difference
in the performance of a program.  A memoized procedure maintains a
table in which values of previous calls are stored
using as keys the arguments that produced the values.  When the
memoized procedure is asked to compute a value, it first checks the
table to see if the value is already there and, if so, just returns
that value.  Otherwise, it computes the new value in the ordinary way
and stores this in the table.  As an example of memoization, recall
from section 1.2.2 the exponential process for
computing Fibonacci numbers:</p>

<p>(define (fib n)</p><empty-line /><p>
  (cond ((= n 0) 0)</p><empty-line /><p>
        ((= n 1) 1)</p><empty-line /><p>
        (else (+ (fib (- n 1))</p><empty-line /><p>
                 (fib (- n 2))))))</p><empty-line /><p>
The memoized version of the same procedure is</p>

<p>(define memo-fib</p><empty-line /><p>
  (memoize (lambda (n)</p><empty-line /><p>
             (cond ((= n 0) 0)</p><empty-line /><p>
                   ((= n 1) 1)</p><empty-line /><p>
                   (else (+ (memo-fib (- n 1))</p><empty-line /><p>
                            (memo-fib (- n 2))))))))</p><empty-line /><p>
where the memoizer is defined as</p>

<p>(define (memoize f)</p><empty-line /><p>
  (let ((table (make-table)))</p><empty-line /><p>
    (lambda (x)</p><empty-line /><p>
      (let ((previously-computed-result (lookup x table)))</p><empty-line /><p>
        (or previously-computed-result</p><empty-line /><p>
            (let ((result (f x)))</p><empty-line /><p>
              (insert! x result table)</p><empty-line /><p>
              result))))))</p><empty-line /><p>
Draw an environment diagram to analyze the computation of (memo-fib 3).  Explain why memo-fib computes the <emphasis>n</emphasis>th
Fibonacci number in a number of steps proportional to <emphasis>n</emphasis>.
Would the scheme still
work if we had simply defined memo-fib to be (memoize
fib)?</p>

<p><strong>3.3.4  A Simulator for Digital Circuits</strong></p>

<p>



Designing complex digital systems, such as computers, is an important
engineering activity.  Digital systems are constructed by
interconnecting simple elements.  Although the behavior of these
individual elements is simple, networks of them can have very complex
behavior.  Computer simulation of proposed circuit designs is an
important tool used by digital systems engineers.  In this section we
design a system for performing digital logic simulations.  This system
typifies a kind of program called an <emphasis>event-driven simulation</emphasis>, in
which actions ("events") trigger further events that happen at a
later time, which in turn trigger more events, and so so.</p>

<p>


Our computational model of a circuit will be composed of objects that
correspond to the elementary components from which the circuit is
constructed.  There are <emphasis>wires</emphasis>, which carry <emphasis>digital signals</emphasis>.  A
digital signal may at any moment have only one of two possible values,
0 and 1.  There are also various types of digital <emphasis>function
boxes</emphasis>, which connect wires carrying input signals to other output
wires.  Such boxes produce output signals computed from their input
signals.  The output signal is delayed by a time that depends on the
type of the function box.  For example, an <emphasis>inverter</emphasis> is a
primitive function box that inverts its input.  If the
input signal to an inverter changes to 0, then one inverter-delay
later the inverter will change its output signal to 1.  If the input
signal to an inverter changes to 1, then one inverter-delay later the
inverter will change its output signal to 0.  We draw an inverter
symbolically as in figure 3.24.  An <emphasis>and-gate</emphasis>,
also shown in figure 3.24, is a primitive function
box with two inputs and one output.  It drives its output signal to a
value that is the <emphasis>logical and</emphasis> of the inputs.  That is, if both
of its input signals become 1, then one and-gate-delay time later the
and-gate will force its output signal to be 1; otherwise the output
will be 0.  An <emphasis>or-gate</emphasis> is a similar two-input primitive function
box that drives its output signal to a value that is the <emphasis>logical
or</emphasis> of the inputs.  That is, the output will become 1 if at least one
of the input signals is 1; otherwise the output will become 0.</p>

<p><image xlink:href="#_156.jpg" /></p>

<p><strong>Figure 3.24:</strong>  Primitive functions in the digital logic simulator.</p>

<p>

We can connect primitive functions together to construct more complex
functions.  To accomplish this we wire the outputs of some
function boxes to the inputs of other function boxes.  For example,
the <emphasis>half-adder</emphasis> circuit shown in figure 3.25 consists of an
or-gate, two and-gates, and an inverter.  It takes two input signals,
A and B, and has two output signals, S and C.  S will become 1
whenever precisely one of A and B is 1, and C will become 1 whenever A
and B are both 1.  We can see from the figure that, because of the
delays involved, the outputs may be generated at different times.
Many of the difficulties in the design of digital circuits arise from
this fact.</p>

<p><image xlink:href="#_157.jpg" /></p>

<p><strong>Figure 3.25:</strong>  A half-adder circuit.</p>

<p>

We will now build a program for modeling the digital logic circuits we
wish to study.  The program will construct computational objects
modeling the wires, which will "hold" the signals.  Function boxes
will be modeled by procedures that enforce the correct relationships
among the signals.</p>

<p>

One basic element of our simulation will be a procedure make-wire, which constructs wires.  For example, we can construct six
wires as follows:</p>

<p>(define a (make-wire))</p><empty-line /><p>
(define b (make-wire))</p><empty-line /><p>
(define c (make-wire))</p><empty-line /><empty-line /><p>
(define d (make-wire))</p><empty-line /><p>
(define e (make-wire))</p><empty-line /><p>
(define s (make-wire))</p><empty-line /><p>
We attach a function box to a set of wires by calling a procedure that
constructs that kind of box.  The arguments to the constructor
procedure are the wires to be attached to the box.  For example, given
that we can construct and-gates, or-gates, and inverters, we can wire
together the half-adder shown in figure 3.25:</p>

<p>(or-gate a b d)</p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><empty-line /><p>
(and-gate a b c)</p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><empty-line /><p>
(inverter c e)</p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><empty-line /><p>
(and-gate d e s)</p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><empty-line /><p>

Better yet, we can explicitly name this operation by defining a procedure half-adder that constructs this circuit, given the four
external wires to be attached to the half-adder:</p>

<p>(define (half-adder a b s c)</p><empty-line /><p>
  (let ((d (make-wire)) (e (make-wire)))</p><empty-line /><p>
    (or-gate a b d)</p><empty-line /><p>
    (and-gate a b c)</p><empty-line /><p>
    (inverter c e)</p><empty-line /><p>
    (and-gate d e s)</p><empty-line /><p>
    'ok))</p><empty-line /><p>
The advantage of making this definition is that we can use
half-adder itself as a building block in creating more complex
circuits.  Figure 3.26, for example, shows a <emphasis>full-adder</emphasis> composed of two half-adders and an or-gate.<sup>26</sup> We can construct a full-adder
as follows:</p>

<p>(define (full-adder a b c-in sum c-out)</p><empty-line /><p>
  (let ((s (make-wire))</p><empty-line /><p>
        (c1 (make-wire))</p><empty-line /><p>
        (c2 (make-wire)))</p><empty-line /><p>
    (half-adder b c-in s c1)</p><empty-line /><p>
    (half-adder a s sum c2)</p><empty-line /><p>
    (or-gate c1 c2 c-out)</p><empty-line /><p>
    'ok))</p><empty-line /><p>
Having defined full-adder as a procedure, we can now use it as a
building block for creating still more complex circuits.  (For
example, see exercise 3.30.)</p>

<p><image xlink:href="#_158.jpg" /></p>

<p><strong>Figure 3.26:</strong>  A full-adder circuit.</p>

<p>

In essence, our simulator provides us with the tools to construct a
language of circuits.  If we adopt the general perspective on
languages with which we approached the study of Lisp in
section 1.1,
we can say that the primitive function boxes form the primitive
elements of the language, that wiring boxes together provides a means
of combination, and that specifying wiring patterns as procedures
serves as a means of abstraction.</p>

<p><strong>Primitive function boxes</strong></p>

<p>


The primitive function boxes implement the "forces" by which a
change in the signal on one wire influences the signals on other
wires.  To build function boxes, we use the following operations on
wires:</p>

<p>(get-signal &lt;<emphasis>wire</emphasis>&gt;)</p><empty-line /><p>returns the current value of the signal on the wire.</p>

<p>(set-signal! &lt;<emphasis>wire</emphasis>&gt; &lt;<emphasis>new value</emphasis>&gt;)</p><empty-line /><p>changes the value of the signal on the wire to the new value.</p>

<p>(add-action! &lt;<emphasis>wire</emphasis>&gt; &lt;<emphasis>procedure of no arguments</emphasis>&gt;)</p><empty-line /><p>asserts that the designated procedure should be run whenever the
signal on the wire changes value.  Such procedures are the vehicles by
which changes in the signal value on the wire are communicated to
other wires.</p>

<p>
In addition, we will make use of a procedure after-delay that
takes a time delay and a procedure to be run and executes the
given procedure after the given delay.</p>

<p>

Using these procedures, we can define the primitive digital logic
functions.  To connect an input to an output through an inverter, we
use add-action! to associate with the input wire a procedure
that will be run whenever the signal on the input wire changes value.
The procedure computes the logical-not of the input signal, and
then, after one inverter-delay, sets the output signal to be
this new value:</p>

<p>(define (inverter input output)</p><empty-line /><p>
  (define (invert-input)</p><empty-line /><p>
    (let ((new-value (logical-not (get-signal input))))</p><empty-line /><p>
      (after-delay inverter-delay</p><empty-line /><p>
                   (lambda ()</p><empty-line /><p>
                     (set-signal! output new-value)))))</p><empty-line /><p>
  (add-action! input invert-input)</p><empty-line /><p>
  'ok)</p><empty-line /><p>(define (logical-not s)</p><empty-line /><p>
  (cond ((= s 0) 1)</p><empty-line /><p>
        ((= s 1) 0)</p><empty-line /><p>
        (else (error "Invalid signal" s))))</p><empty-line /><empty-line /><p>

An and-gate is a little more complex.  The action procedure must be run if
either of the inputs to the gate changes.  It computes the logical-and (using a procedure analogous to logical-not) of the
values of the signals on the input wires and sets up a change to the
new value to occur on the output wire after one and-gate-delay.</p>

<p>(define (and-gate a1 a2 output)</p><empty-line /><p>
  (define (and-action-procedure)</p><empty-line /><p>
    (let ((new-value</p><empty-line /><p>
           (logical-and (get-signal a1) (get-signal a2))))</p><empty-line /><p>
      (after-delay and-gate-delay</p><empty-line /><p>
                   (lambda ()</p><empty-line /><p>
                     (set-signal! output new-value)))))</p><empty-line /><p>
  (add-action! a1 and-action-procedure)</p><empty-line /><p>
  (add-action! a2 and-action-procedure)</p><empty-line /><p>
  'ok)</p><empty-line /><empty-line /><p>
<strong>Exercise 3.28.</strong>  Define an or-gate as a primitive function box.  Your or-gate
constructor should be similar to and-gate.</p>

<p>
<strong>Exercise 3.29.</strong>  Another way to construct an or-gate is as a compound digital logic
device, built from and-gates and inverters.  Define a procedure or-gate that accomplishes this.  What is the delay time of the
or-gate in terms of and-gate-delay and inverter-delay?</p>

<p>
<strong>Exercise 3.30.</strong>  Figure 3.27 shows a <emphasis>ripple-carry adder</emphasis> formed by stringing
together <emphasis>n</emphasis> full-adders.  This is the simplest form of parallel adder
for adding two <emphasis>n</emphasis>-bit binary numbers.  The inputs A<sub>1</sub>, A<sub>2</sub>,
A<sub>3</sub>, ..., A<sub><emphasis>n</emphasis></sub> and B<sub>1</sub>, B<sub>2</sub>, B<sub>3</sub>, ...,
B<sub><emphasis>n</emphasis></sub> are the two binary numbers to be added (each A<sub><emphasis>k</emphasis></sub> and B<sub><emphasis>k</emphasis></sub>
is a 0 or a 1).  The circuit generates S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>,
..., S<sub><emphasis>n</emphasis></sub>, the <emphasis>n</emphasis> bits of the sum, and C, the carry from
the addition.  Write a procedure ripple-carry-adder that
generates this circuit.  The procedure should take as arguments three
lists of <emphasis>n</emphasis> wires each -- the A<sub><emphasis>k</emphasis></sub>, the B<sub><emphasis>k</emphasis></sub>, and the S<sub><emphasis>k</emphasis></sub> -- and
also another wire C.  The major drawback of the ripple-carry adder is
the need to wait for the carry signals to propagate.  What is the
delay needed to obtain the complete output from an <emphasis>n</emphasis>-bit
ripple-carry adder, expressed in terms of the delays for and-gates,
or-gates, and inverters?</p><empty-line /><p><image xlink:href="#_159.jpg" /></p>

<p><strong>Figure 3.27:</strong>  A ripple-carry adder for <emphasis>n</emphasis>-bit numbers.</p>

<p><strong>Representing wires</strong></p>

<p>


A wire in our simulation will be a computational object with two local
state variables: a signal-value (initially taken to be 0) and a
collection of action-procedures to be run when the signal
changes value.  We implement the wire, using message-passing style, as
a collection of local procedures together with a dispatch
procedure that selects the appropriate local operation, just as we did
with the simple bank-account object in section
 3.1.1:</p>

<p>(define (make-wire)</p><empty-line /><p>
  (let ((signal-value 0) (action-procedures '()))</p><empty-line /><p>
    (define (set-my-signal! new-value)</p><empty-line /><p>
      (if (not (= signal-value new-value))</p><empty-line /><p>
          (begin (set! signal-value new-value)</p><empty-line /><p>
                 (call-each action-procedures))</p><empty-line /><p>
          'done))</p><empty-line /><p>
    (define (accept-action-procedure! proc)</p><empty-line /><p>
      (set! action-procedures (cons proc action-procedures))</p><empty-line /><p>
      (proc))</p><empty-line /><p>
    (define (dispatch m)</p><empty-line /><p>
      (cond ((eq? m 'get-signal) signal-value)</p><empty-line /><p>
            ((eq? m 'set-signal!) set-my-signal!)</p><empty-line /><p>
            ((eq? m 'add-action!) accept-action-procedure!)</p><empty-line /><p>
            (else (error "Unknown operation -- WIRE" m))))</p><empty-line /><p>
    dispatch))</p><empty-line /><p>
The local procedure set-my-signal! tests whether the new signal
value changes the signal on the wire.  If so, it runs each of the
action procedures, using the following procedure call-each,
which calls each of the items in a list of no-argument procedures:</p>

<p>(define (call-each procedures)</p><empty-line /><p>
  (if (null? procedures)</p><empty-line /><p>
      'done</p><empty-line /><p>
      (begin</p><empty-line /><p>
        ((car procedures))</p><empty-line /><p>
        (call-each (cdr procedures)))))</p><empty-line /><p>
The local procedure accept-action-procedure! adds the given
procedure to the list of procedures to be run, and then runs the new
procedure once.  (See exercise 3.31.)</p>

<p>

With the local dispatch procedure set up as specified, we can
provide the following procedures to access the local operations on
wires:<sup>27</sup></p>

<p>(define (get-signal wire)</p><empty-line /><p>
  (wire 'get-signal))</p><empty-line /><p>(define (set-signal! wire new-value)</p><empty-line /><p>
  ((wire 'set-signal!) new-value))</p><empty-line /><p>(define (add-action! wire action-procedure)</p><empty-line /><p>
  ((wire 'add-action!) action-procedure))</p><empty-line /><empty-line /><p>

Wires, which have time-varying signals and may be incrementally
attached to devices, are typical of mutable objects.  We have modeled
them as procedures with local state variables that are modified by
assignment.  When a new wire is created, a new set of state variables
is allocated (by the let expression in make-wire) and a
new dispatch procedure is constructed and returned, capturing
the environment with the new state variables.</p>

<p>

The wires are shared among the various devices that have been
connected to them.  Thus, a change made by an interaction with one
device will affect all the other devices attached to the wire.  The
wire communicates the change to its neighbors by calling the action
procedures provided to it when the connections were established.</p>

<p><strong>The agenda</strong></p>

<p>


The only thing needed to complete the simulator is after-delay.
The idea here is that we maintain a data structure, called an <emphasis>agenda</emphasis>, that contains a schedule of things to do.  The following
operations are defined for agendas:</p>

<p>(make-agenda)</p><empty-line /><p>
returns a new empty agenda.</p>

<p>(empty-agenda? &lt;<emphasis>agenda</emphasis>&gt;)</p><empty-line /><p>
is true if the specified agenda is empty.</p>

<p>(first-agenda-item &lt;<emphasis>agenda</emphasis>&gt;)</p><empty-line /><p>
returns the first item on the agenda.</p>

<p>(remove-first-agenda-item! &lt;<emphasis>agenda</emphasis>&gt;)</p><empty-line /><p>
modifies the agenda by removing the first item.</p>

<p>(add-to-agenda! &lt;<emphasis>time</emphasis>&gt; &lt;<emphasis>action</emphasis>&gt; &lt;<emphasis>agenda</emphasis>&gt;)</p><empty-line /><p>
modifies the agenda by adding the given action procedure to be run at
the specified time.</p>

<p>(current-time &lt;<emphasis>agenda</emphasis>&gt;)</p><empty-line /><p>
returns the current simulation time.</p>

<p>

The particular agenda that we use is denoted by
the-agenda.  The procedure after-delay adds new
elements to the-agenda:</p>

<p>(define (after-delay delay action)</p><empty-line /><p>
  (add-to-agenda! (+ delay (current-time the-agenda))</p><empty-line /><p>
                  action</p><empty-line /><p>
                  the-agenda))</p><empty-line /><empty-line /><p>

The simulation is driven by the procedure propagate, which
operates on the-agenda, executing each procedure on the agenda
in sequence.  In general, as the simulation runs, new items will be
added to the agenda, and propagate will continue the simulation
as long as there are items on the agenda:</p>

<p>(define (propagate)</p><empty-line /><p>
  (if (empty-agenda? the-agenda)</p><empty-line /><p>
      'done</p><empty-line /><p>
      (let ((first-item (first-agenda-item the-agenda)))</p><empty-line /><p>
        (first-item)</p><empty-line /><p>
        (remove-first-agenda-item! the-agenda)</p><empty-line /><p>
        (propagate))))</p><empty-line /><empty-line /><p><strong>A sample simulation</strong></p>

<p>


The following procedure, which places a "probe" on a wire, shows the
simulator in action.  The probe tells the wire that, whenever its
signal changes value, it should print the new signal value, together
with the current time and a name that identifies the wire:</p>

<p>(define (probe name wire)</p><empty-line /><p>
  (add-action! wire</p><empty-line /><p>
               (lambda ()</p><empty-line /><p>
                 (newline)</p><empty-line /><p>
                 (display name)</p><empty-line /><p>
                 (display " ")</p><empty-line /><p>
                 (display (current-time the-agenda))</p><empty-line /><p>
                 (display "  New-value = ")</p><empty-line /><p>
                 (display (get-signal wire)))))</p><empty-line /><empty-line /><p>

We begin by initializing the agenda and specifying delays for the
primitive function boxes:</p>

<p>(define the-agenda (make-agenda))</p><empty-line /><p>
(define inverter-delay 2)</p><empty-line /><p>
(define and-gate-delay 3)</p><empty-line /><p>
(define or-gate-delay 5)</p><empty-line /><p>
Now we define four wires, placing probes on two of them:</p>

<p>(define input-1 (make-wire))</p><empty-line /><p>
(define input-2 (make-wire))</p><empty-line /><p>
(define sum (make-wire))</p><empty-line /><p>
(define carry (make-wire))</p><empty-line /><p>
(probe 'sum sum)</p><empty-line /><p><emphasis>sum 0  New-value = 0</emphasis></p><empty-line /><p>
(probe 'carry carry)</p><empty-line /><p><emphasis>carry 0  New-value = 0</emphasis></p><empty-line /><p>
Next we connect the wires in a half-adder circuit (as in
figure 3.25), set the signal on input-1 to 1,
and run the simulation:</p>

<p>(half-adder input-1 input-2 sum carry)</p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><p>
(set-signal! input-1 1)</p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
(propagate)</p><empty-line /><p><emphasis>sum 8  New-value = 1</emphasis></p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
The sum signal changes to 1 at time 8.  We are now eight time
units from the beginning of the simulation.  At this point, we can set
the signal on input-2 to 1 and allow the values to propagate:</p>

<p>(set-signal! input-2 1)</p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
(propagate)</p><empty-line /><p><emphasis>carry 11  New-value = 1</emphasis></p><empty-line /><p><emphasis>sum 16  New-value = 0</emphasis></p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
The carry changes to 1 at time 11 and the sum changes to 0
at time 16.</p>

<p>
<strong>Exercise 3.31.</strong>  
The internal procedure accept-action-procedure! defined in make-wire specifies that when a new action procedure is added to
a wire, the procedure is immediately run.  Explain why this initialization
is necessary.  In particular, trace through the half-adder example in
the paragraphs above and say how the system's response would differ if
we had defined accept-action-procedure! as</p>

<p>(define (accept-action-procedure! proc)</p><empty-line /><p>
  (set! action-procedures (cons proc action-procedures)))</p><empty-line /><empty-line /><p><strong>Implementing the agenda</strong></p>

<p>


Finally, we give details of the agenda data structure, which holds the
procedures that are scheduled for future execution.</p>

<p>

The agenda is made up of <emphasis>time segments</emphasis>.  Each time segment is a
pair consisting of a number (the time) and a queue (see
exercise 3.32) that holds the procedures that are
scheduled to be run during that time segment.</p>

<p>(define (make-time-segment time queue)</p><empty-line /><p>
  (cons time queue))</p><empty-line /><p>(define (segment-time s) (car s))</p><empty-line /><p>(define (segment-queue s) (cdr s))</p><empty-line /><p>
We will operate on the time-segment queues using the queue operations
described in section 3.3.2.</p>

<p>

The agenda itself is a one-dimensional table of time segments.  It
differs from the tables described in section 3.3.3 in that
the segments will be sorted in order of increasing time.  In addition,
we store the <emphasis>current time</emphasis> (i.e., the time of the last action
that was processed) at the head of the agenda.  A newly constructed
agenda has no time segments and has a current time of 0:<sup>28</sup></p>

<p>(define (make-agenda) (list 0))</p><empty-line /><p>(define (current-time agenda) (car agenda))</p><empty-line /><p>(define (set-current-time! agenda time)</p><empty-line /><p>
  (set-car! agenda time))</p><empty-line /><p>(define (segments agenda) (cdr agenda))</p><empty-line /><p>(define (set-segments! agenda segments)</p><empty-line /><p>
  (set-cdr! agenda segments))</p><empty-line /><p>(define (first-segment agenda) (car (segments agenda)))</p><empty-line /><p>(define (rest-segments agenda) (cdr (segments agenda)))</p><empty-line /><empty-line /><p>

An agenda is empty if it has no time segments:</p>

<p>(define (empty-agenda? agenda)</p><empty-line /><p>
  (null? (segments agenda)))</p><empty-line /><empty-line /><p>


To add an action to an agenda, we first check if the agenda is empty.
If so, we create a time segment for the action and install this in
the agenda.  Otherwise, we scan the agenda, examining the time of each
segment.  If we find a segment for our appointed time, we add the
action to the associated queue.  If we reach a time later than the one
to which we are appointed, we insert a new time segment into the
agenda just before it.  If we reach the end of the agenda, we must
create a new time segment at the end.</p>

<p>(define (add-to-agenda! time action agenda)</p><empty-line /><p>
  (define (belongs-before? segments)</p><empty-line /><p>
    (or (null? segments)</p><empty-line /><p>
        (&lt; time (segment-time (car segments)))))</p><empty-line /><p>
  (define (make-new-time-segment time action)</p><empty-line /><p>
    (let ((q (make-queue)))</p><empty-line /><p>
      (insert-queue! q action)</p><empty-line /><p>
      (make-time-segment time q)))</p><empty-line /><p>
  (define (add-to-segments! segments)</p><empty-line /><p>
    (if (= (segment-time (car segments)) time)</p><empty-line /><p>
        (insert-queue! (segment-queue (car segments))</p><empty-line /><p>
                       action)</p><empty-line /><p>
        (let ((rest (cdr segments)))</p><empty-line /><p>
          (if (belongs-before? rest)</p><empty-line /><p>
              (set-cdr!</p><empty-line /><p>
               segments</p><empty-line /><p>
               (cons (make-new-time-segment time action)</p><empty-line /><p>
                     (cdr segments)))</p><empty-line /><p>
              (add-to-segments! rest)))))</p><empty-line /><p>
  (let ((segments (segments agenda)))</p><empty-line /><p>
    (if (belongs-before? segments)</p><empty-line /><p>
        (set-segments!</p><empty-line /><p>
         agenda</p><empty-line /><p>
         (cons (make-new-time-segment time action)</p><empty-line /><p>
               segments))</p><empty-line /><p>
        (add-to-segments! segments))))</p><empty-line /><empty-line /><p>

The procedure that removes the first item from the agenda deletes the
item at the front of the queue in the first time segment.  If this
deletion makes the time segment empty, we remove it from the list of
segments:<sup>29</sup></p>

<p>(define (remove-first-agenda-item! agenda)</p><empty-line /><p>
  (let ((q (segment-queue (first-segment agenda))))</p><empty-line /><p>
    (delete-queue! q)</p><empty-line /><p>
    (if (empty-queue? q)</p><empty-line /><p>
        (set-segments! agenda (rest-segments agenda)))))</p><empty-line /><empty-line /><p>

The first agenda item is found at the head of the queue in the first
time segment.  Whenever we extract an item, we also update the current
time:<sup>30</sup></p>

<p>(define (first-agenda-item agenda)</p><empty-line /><p>
  (if (empty-agenda? agenda)</p><empty-line /><p>
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")</p><empty-line /><p>
      (let ((first-seg (first-segment agenda)))</p><empty-line /><p>
        (set-current-time! agenda (segment-time first-seg))</p><empty-line /><p>
        (front-queue (segment-queue first-seg)))))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.32.</strong>  The procedures to be run during each time segment of the agenda are
kept in a queue.  Thus, the procedures for each segment are called in
the order in which they were added to the agenda (first in, first
out).  Explain why this order must be used.  In particular, trace the
behavior of an and-gate whose inputs change from 0,1 to 1,0 in the
same segment and say how the behavior would differ if we stored a
segment's procedures in an ordinary list, adding and removing
procedures only at the front (last in, first out).</p>

<p><strong>3.3.5  Propagation of Constraints</strong></p>

<p>



Computer programs are traditionally organized as
one-directional computations, which perform operations on prespecified
arguments to produce desired outputs.  On the other hand, we often
model systems in terms of relations among quantities.  For example, a
mathematical model of a mechanical structure might include the
information that the deflection <emphasis>d</emphasis> of a metal rod is related to the
force <emphasis>F</emphasis> on the rod, the length <emphasis>L</emphasis> of the rod, the cross-sectional
area <emphasis>A</emphasis>, and the elastic modulus <emphasis>E</emphasis> via the equation</p>

<p><image xlink:href="#_160.jpg" /></p>

<p>
Such an equation is not one-directional.  Given any four of the
quantities, we can use it to compute the fifth.  Yet translating the
equation into a traditional computer language would force us to choose
one of the quantities to be computed in terms of the other four.
Thus, a procedure for computing the area <emphasis>A</emphasis> could not be used to
compute the deflection <emphasis>d</emphasis>, even though the computations of <emphasis>A</emphasis> and
<emphasis>d</emphasis> arise from the same equation.<sup>31</sup></p>

<p>

In this section, we sketch the design of a language that enables us to
work in terms of relations themselves.  The primitive elements of the
language are <emphasis>primitive constraints</emphasis>, which state that certain
relations hold between quantities.  For example, (adder a b c)
specifies that the quantities <emphasis>a</emphasis>, <emphasis>b</emphasis>, and <emphasis>c</emphasis> must be related by the
equation <emphasis>a</emphasis> + <emphasis>b</emphasis> = <emphasis>c</emphasis>, (multiplier x y z) expresses the constraint
<emphasis>x</emphasis><emphasis>y</emphasis>  =  <emphasis>z</emphasis>, and (constant 3.14 x) says that the value of <emphasis>x</emphasis> must
be 3.14.</p>

<p>


Our language provides a means of combining primitive constraints in
order to express more complex relations.  We combine constraints by
constructing <emphasis>constraint networks</emphasis>, in which constraints are
joined by <emphasis>connectors</emphasis>.  A connector is an object that "holds" a
value that may participate in one or more constraints.  For example,
we know that the relationship between Fahrenheit and Celsius
temperatures is</p>

<p><image xlink:href="#_161.jpg" /></p>

<p>

Such a constraint can be thought of as a network consisting of
primitive adder, multiplier, and constant constraints
(figure 3.28).  In the figure, we see on the left a
multiplier box with three terminals, labeled <emphasis>m</emphasis>1, <emphasis>m</emphasis>2, and <emphasis>p</emphasis>.
These connect the multiplier to the rest of the network as follows:
The <emphasis>m</emphasis>1 terminal is linked to a connector <emphasis>C</emphasis>, which will hold the
Celsius temperature.  The <emphasis>m</emphasis>2 terminal is linked to a connector
<emphasis>w</emphasis>, which is also linked to a constant box that holds 9.  The <emphasis>p</emphasis>
terminal, which the multiplier box constrains to be the product of
<emphasis>m</emphasis>1 and <emphasis>m</emphasis>2, is linked to the <emphasis>p</emphasis> terminal
of another multiplier box, whose <emphasis>m</emphasis>2 is connected to a constant 5 and
whose <emphasis>m</emphasis>1 is connected to one of the terms in a sum.</p>

<p><image xlink:href="#_162.jpg" /></p>

<p><strong>Figure 3.28:</strong>  The relation 9<emphasis>C</emphasis>  =  5(<emphasis>F</emphasis>  -  32)
expressed as a constraint network.</p>

<p>

Computation by such a network proceeds as follows: When a connector is
given a value (by the user or by a constraint box to which it is
linked), it awakens all of its associated constraints (except for the
constraint that just awakened it) to inform them that it has a value.
Each awakened constraint box then polls its connectors to see if there
is enough information to determine a value for a connector.  If so,
the box sets that connector, which then awakens all of its associated
constraints, and so on.  For instance, in conversion between
Celsius and Fahrenheit, <emphasis>w</emphasis>, <emphasis>x</emphasis>, and <emphasis>y</emphasis> are immediately set by
the constant boxes to 9, 5, and 32, respectively.  The connectors
awaken the multipliers and the adder, which determine that there is
not enough information to proceed.  If the user (or some other part of
the network) sets <emphasis>C</emphasis> to a value (say 25), the leftmost multiplier
will be awakened, and it will set <emphasis>u</emphasis> to 25 ·  9 = 225.  Then <emphasis>u</emphasis>
awakens the second multiplier, which sets <emphasis>v</emphasis> to 45, and <emphasis>v</emphasis> awakens
the adder, which sets <emphasis>F</emphasis> to 77.</p>

<p><strong>Using the constraint system</strong></p>

<p>

To use the constraint system to carry out the temperature computation
outlined above, we first create two connectors, C and F,
by calling the constructor make-connector, and link C and
F in an appropriate network:</p>

<p>(define C (make-connector))</p><empty-line /><p>
(define F (make-connector))</p><empty-line /><p>
(celsius-fahrenheit-converter C F)</p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><p>
The procedure that creates the network is defined as follows:</p>

<p>(define (celsius-fahrenheit-converter c f)</p><empty-line /><p>
  (let ((u (make-connector))</p><empty-line /><p>
        (v (make-connector))</p><empty-line /><p>
        (w (make-connector))</p><empty-line /><p>
        (x (make-connector))</p><empty-line /><p>
        (y (make-connector)))</p><empty-line /><p>
    (multiplier c w u)</p><empty-line /><p>
    (multiplier v x u)</p><empty-line /><p>
    (adder v y f)</p><empty-line /><p>
    (constant 9 w)</p><empty-line /><p>
    (constant 5 x)</p><empty-line /><p>
    (constant 32 y)</p><empty-line /><p>
    'ok))</p><empty-line /><p>
This procedure creates the internal connectors u, v, w, x, and y, and links them as shown in
figure 3.28 using the primitive constraint
constructors adder, multiplier, and constant.  Just
as with the digital-circuit simulator of
section 3.3.4, expressing these combinations of
primitive elements in terms of procedures automatically provides our
language with a means of abstraction for compound objects.</p>

<p>

To watch the network in action, we can place probes on the connectors
C and F, using a probe procedure similar to the one
we used to monitor wires in section 3.3.4.
Placing a probe on a connector will cause a message to be printed
whenever the connector is given a value:</p>

<p>(probe "Celsius temp" C)</p><empty-line /><p>
(probe "Fahrenheit temp" F)</p><empty-line /><p>
Next we set the value of C to 25.  (The third argument to set-value! tells C that this directive comes from the user.)</p>

<p>(set-value! C 25 'user)</p><empty-line /><p><emphasis>Probe: Celsius temp = 25</emphasis></p><empty-line /><p><emphasis>Probe: Fahrenheit temp = 77</emphasis></p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
The probe on C awakens and reports the value.  C also
propagates its value through the network as described above.  This
sets F to 77, which is reported by the probe on F.</p>

<p>

Now we can try to set F to a new value, say 212:</p>

<p>(set-value! F 212 'user)</p><empty-line /><p><emphasis>Error! Contradiction (77 212)</emphasis></p><empty-line /><p>
The connector complains that it has sensed a contradiction: Its value
is 77, and someone is trying to set it to 212.  If we really want to
reuse the network with new values, we can tell C to forget its
old value:</p>

<p>(forget-value! C 'user)</p><empty-line /><p><emphasis>Probe: Celsius temp = ?</emphasis></p><empty-line /><p><emphasis>Probe: Fahrenheit temp = ?</emphasis></p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
C finds that the user, who set its value originally, is
now retracting that value, so C agrees to lose its value, as
shown by the probe, and informs the rest of the network of this fact.
This information eventually propagates to F, which now finds
that it has no reason for continuing to believe that its own value is
77.  Thus, F also gives up its value, as shown by the probe.</p>

<p>

Now that F has no value, we are free to set it to 212:</p>

<p>(set-value! F 212 'user)</p><empty-line /><p><emphasis>Probe: Fahrenheit temp = 212</emphasis></p><empty-line /><p><emphasis>Probe: Celsius temp = 100</emphasis></p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
This new value, when propagated through the network, forces C to
have a value of 100, and this is registered by the probe on C.
Notice that the very same network is being used to compute C
given F and to compute F given C.  This
nondirectionality of computation is the distinguishing feature of
constraint-based systems.</p>

<p><strong>Implementing the constraint system</strong></p>

<p>

The constraint system is implemented via procedural objects with local
state, in a manner very similar to the digital-circuit simulator of
section 3.3.4.  Although the primitive objects
of the constraint system are somewhat more complex, the overall system
is simpler, since there is no concern about agendas and logic delays.</p>

<p>

The basic operations on connectors are the following:</p>

<p>(has-value? &lt;<emphasis>connector</emphasis>&gt;)</p><empty-line /><p>
tells whether the connector has a value.</p>

<p>(get-value &lt;<emphasis>connector</emphasis>&gt;)</p><empty-line /><p>
returns the connector's current value.</p>

<p>(set-value! &lt;<emphasis>connector</emphasis>&gt; &lt;<emphasis>new-value</emphasis>&gt; &lt;<emphasis>informant</emphasis>&gt;)</p><empty-line /><p>
indicates that the informant is requesting the connector to set its
value to the new value.</p>

<p>(forget-value! &lt;<emphasis>connector</emphasis>&gt; &lt;<emphasis>retractor</emphasis>&gt;)</p><empty-line /><p>
tells the connector that the retractor is requesting it to forget its value.</p>

<p>(connect &lt;<emphasis>connector</emphasis>&gt; &lt;<emphasis>new-constraint</emphasis>&gt;)</p><empty-line /><p>
tells the connector to participate in the new constraint.</p>

<p>

The connectors communicate with the constraints by means of the
procedures inform-about-value, which tells the given
constraint that the connector has a value, and inform-about-no-value, which tells the constraint that the connector
has lost its value.</p>

<p>

Adder constructs an adder constraint among summand connectors
a1 and a2 and a sum connector.  An adder is
implemented as a procedure with local state (the procedure me
below):</p>

<p>(define (adder a1 a2 sum)</p><empty-line /><p>
  (define (process-new-value)</p><empty-line /><p>
    (cond ((and (has-value? a1) (has-value? a2))</p><empty-line /><p>
           (set-value! sum</p><empty-line /><p>
                       (+ (get-value a1) (get-value a2))</p><empty-line /><p>
                       me))</p><empty-line /><p>
          ((and (has-value? a1) (has-value? sum))</p><empty-line /><p>
           (set-value! a2</p><empty-line /><p>
                       (- (get-value sum) (get-value a1))</p><empty-line /><p>
                       me))</p><empty-line /><p>
          ((and (has-value? a2) (has-value? sum))</p><empty-line /><p>
           (set-value! a1</p><empty-line /><p>
                       (- (get-value sum) (get-value a2))</p><empty-line /><p>
                       me))))</p><empty-line /><p>
  (define (process-forget-value)</p><empty-line /><p>
    (forget-value! sum me)</p><empty-line /><p>
    (forget-value! a1 me)</p><empty-line /><p>
    (forget-value! a2 me)</p><empty-line /><p>
    (process-new-value))</p><empty-line /><p>
  (define (me request)</p><empty-line /><p>
    (cond ((eq? request 'I-have-a-value)</p><empty-line /><p>
           (process-new-value))</p><empty-line /><p>
          ((eq? request 'I-lost-my-value)</p><empty-line /><p>
           (process-forget-value))</p><empty-line /><p>
          (else</p><empty-line /><p>
           (error "Unknown request -- ADDER" request))))</p><empty-line /><p>
  (connect a1 me)</p><empty-line /><p>
  (connect a2 me)</p><empty-line /><p>
  (connect sum me)</p><empty-line /><p>
  me)</p><empty-line /><p>
Adder connects the new adder to the designated connectors and
returns it as its value.  The procedure me, which represents the
adder, acts as a dispatch to the local procedures.  The following
"syntax interfaces" (see footnote 27 in
section 3.3.4) are used in conjunction with the
dispatch:</p>

<p>(define (inform-about-value constraint)</p><empty-line /><p>
  (constraint 'I-have-a-value))</p><empty-line /><p>(define (inform-about-no-value constraint)</p><empty-line /><p>
  (constraint 'I-lost-my-value))</p><empty-line /><p>
The adder's local procedure process-new-value is called when the
adder is informed that one of its connectors has a value. The adder
first checks to see if both a1 and a2 have values. If so,
it tells sum to set its value to the sum of the two addends.
The informant argument to set-value! is me, which is
the adder object itself.  If a1 and a2 do not both have
values, then the adder checks to see if perhaps a1 and sum
have values.  If so, it sets a2 to the difference of these two.
Finally, if a2 and sum have values, this gives the adder
enough information to set a1.  If the adder is told that one of
its connectors has lost a value, it requests that all of its
connectors now lose their values.  (Only those values that were set by
this adder are actually lost.)  Then it runs process-new-value.
The reason for this last step is that one or more connectors may still
have a value (that is, a connector may have had a value that was not
originally set by the adder), and these values may need to be
propagated back through the adder.</p>

<p>

A multiplier is very similar to an adder. It will set its product to 0 if either of the factors is 0, even if the other factor
is not known.</p>

<p>(define (multiplier m1 m2 product)</p><empty-line /><p>
  (define (process-new-value)</p><empty-line /><p>
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))</p><empty-line /><p>
               (and (has-value? m2) (= (get-value m2) 0)))</p><empty-line /><p>
           (set-value! product 0 me))</p><empty-line /><p>
          ((and (has-value? m1) (has-value? m2))</p><empty-line /><p>
           (set-value! product</p><empty-line /><p>
                       (* (get-value m1) (get-value m2))</p><empty-line /><p>
                       me))</p><empty-line /><p>
          ((and (has-value? product) (has-value? m1))</p><empty-line /><p>
           (set-value! m2</p><empty-line /><p>
                       (/ (get-value product) (get-value m1))</p><empty-line /><p>
                       me))</p><empty-line /><p>
          ((and (has-value? product) (has-value? m2))</p><empty-line /><p>
           (set-value! m1</p><empty-line /><p>
                       (/ (get-value product) (get-value m2))</p><empty-line /><p>
                       me))))</p><empty-line /><p>
  (define (process-forget-value)</p><empty-line /><p>
    (forget-value! product me)</p><empty-line /><p>
    (forget-value! m1 me)</p><empty-line /><p>
    (forget-value! m2 me)</p><empty-line /><p>
    (process-new-value))</p><empty-line /><p>
  (define (me request)</p><empty-line /><p>
    (cond ((eq? request 'I-have-a-value)</p><empty-line /><p>
           (process-new-value))</p><empty-line /><p>
          ((eq? request 'I-lost-my-value)</p><empty-line /><p>
           (process-forget-value))</p><empty-line /><p>
          (else</p><empty-line /><p>
           (error "Unknown request -- MULTIPLIER" request))))</p><empty-line /><p>
  (connect m1 me)</p><empty-line /><p>
  (connect m2 me)</p><empty-line /><p>
  (connect product me)</p><empty-line /><p>
  me)</p><empty-line /><p>
A constant constructor simply sets the value of the designated
connector.  Any I-have-a-value or I-lost-my-value message
sent to the constant box will produce an error.</p>

<p>(define (constant value connector)</p><empty-line /><p>
  (define (me request)</p><empty-line /><p>
    (error "Unknown request -- CONSTANT" request))</p><empty-line /><p>
  (connect connector me)</p><empty-line /><p>
  (set-value! connector value me)</p><empty-line /><p>
  me)</p><empty-line /><p>
Finally, a probe prints a message about the setting or unsetting of
the designated connector:</p>

<p>(define (probe name connector)</p><empty-line /><p>
  (define (print-probe value)</p><empty-line /><p>
    (newline)</p><empty-line /><p>
    (display "Probe: ")</p><empty-line /><p>
    (display name)</p><empty-line /><p>
    (display " = ")</p><empty-line /><p>
    (display value))</p><empty-line /><p>
  (define (process-new-value)</p><empty-line /><p>
    (print-probe (get-value connector)))</p><empty-line /><p>
  (define (process-forget-value)</p><empty-line /><p>
    (print-probe "?"))</p><empty-line /><p>
  (define (me request)</p><empty-line /><p>
    (cond ((eq? request 'I-have-a-value)</p><empty-line /><p>
           (process-new-value))</p><empty-line /><p>
          ((eq? request 'I-lost-my-value)</p><empty-line /><p>
           (process-forget-value))</p><empty-line /><p>
          (else</p><empty-line /><p>
           (error "Unknown request -- PROBE" request))))</p><empty-line /><p>
  (connect connector me)</p><empty-line /><p>
  me)</p><empty-line /><empty-line /><p><strong>Representing connectors</strong></p>

<p>


A connector is represented as a procedural object with local state
variables value, the current value of the connector; informant, the object that set the connector's value; and constraints, a list of the constraints in which the connector
participates.</p>

<p>(define (make-connector)</p><empty-line /><p>
  (let ((value false) (informant false) (constraints '()))</p><empty-line /><p>
    (define (set-my-value newval setter)</p><empty-line /><p>
      (cond ((not (has-value? me))</p><empty-line /><p>
             (set! value newval)</p><empty-line /><p>
             (set! informant setter)</p><empty-line /><p>
             (for-each-except setter</p><empty-line /><p>
                              inform-about-value</p><empty-line /><p>
                              constraints))</p><empty-line /><p>
            ((not (= value newval))</p><empty-line /><p>
             (error "Contradiction" (list value newval)))</p><empty-line /><p>
            (else 'ignored)))</p><empty-line /><p>
    (define (forget-my-value retractor)</p><empty-line /><p>
      (if (eq? retractor informant)</p><empty-line /><p>
          (begin (set! informant false)</p><empty-line /><p>
                 (for-each-except retractor</p><empty-line /><p>
                                  inform-about-no-value</p><empty-line /><p>
                                  constraints))</p><empty-line /><p>
          'ignored))</p><empty-line /><p>
    (define (connect new-constraint)</p><empty-line /><p>
      (if (not (memq new-constraint constraints))</p><empty-line /><p>
          (set! constraints</p><empty-line /><p>
                (cons new-constraint constraints)))</p><empty-line /><p>
      (if (has-value? me)</p><empty-line /><p>
          (inform-about-value new-constraint))</p><empty-line /><p>
      'done)</p><empty-line /><p>
    (define (me request)</p><empty-line /><p>
      (cond ((eq? request 'has-value?)</p><empty-line /><p>
             (if informant true false))</p><empty-line /><p>
            ((eq? request 'value) value)</p><empty-line /><p>
            ((eq? request 'set-value!) set-my-value)</p><empty-line /><p>
            ((eq? request 'forget) forget-my-value)</p><empty-line /><p>
            ((eq? request 'connect) connect)</p><empty-line /><p>
            (else (error "Unknown operation -- CONNECTOR"</p><empty-line /><p>
                         request))))</p><empty-line /><p>
    me))</p><empty-line /><empty-line /><p>


The connector's local procedure set-my-value is called when
there is a request to set the connector's value.  If the connector
does not currently have a value, it will set its value and remember as
informant the constraint that requested the value to be
set.<sup>32</sup>
Then the connector will notify all of its participating
constraints except the constraint that requested the value to be set.
This is accomplished using the following iterator, which applies a
designated procedure to all items in a list except a given one:</p>

<p>(define (for-each-except exception procedure list)</p><empty-line /><p>
  (define (loop items)</p><empty-line /><p>
    (cond ((null? items) 'done)</p><empty-line /><p>
          ((eq? (car items) exception) (loop (cdr items)))</p><empty-line /><p>
          (else (procedure (car items))</p><empty-line /><p>
                (loop (cdr items)))))</p><empty-line /><p>
  (loop list))</p><empty-line /><empty-line /><p>

If a connector is asked to forget its value, it runs the local
procedure forget-my-value, which first checks to make sure that
the request is coming from the same object that set the value
originally.  If so, the connector informs its associated constraints
about the loss of the value.</p>

<p>

The local procedure connect adds the designated new constraint
to the list of constraints if it is not already in that list.  Then,
if the connector has a value, it informs the new constraint of this
fact.</p>

<p>

The connector's procedure me serves as a dispatch to the other
internal procedures and also represents the connector as an object.
The following procedures provide a syntax interface for the dispatch:</p>

<p>(define (has-value? connector)</p><empty-line /><p>
  (connector 'has-value?))</p><empty-line /><p>(define (get-value connector)</p><empty-line /><p>
  (connector 'value))</p><empty-line /><p>(define (set-value! connector new-value informant)</p><empty-line /><p>
  ((connector 'set-value!) new-value informant))</p><empty-line /><p>(define (forget-value! connector retractor)</p><empty-line /><p>
  ((connector 'forget) retractor))</p><empty-line /><p>(define (connect connector new-constraint)</p><empty-line /><p>
  ((connector 'connect) new-constraint))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.33.</strong>  Using primitive multiplier, adder, and constant constraints, define a
procedure averager that takes three connectors a, b,
and c as inputs and establishes the constraint that the value of
c is the average of the values of a and b.</p>

<p>
<strong>Exercise 3.34.</strong>  Louis Reasoner wants to build a squarer, a constraint device with two
terminals such that the value of connector b on the second
terminal will always be the square of the value a on the first
terminal.  He proposes the following simple device made from a
multiplier:</p>

<p>(define (squarer a b)</p><empty-line /><p>
  (multiplier a a b))</p><empty-line /><p>
There is a serious flaw in this idea.  Explain.</p>

<p>
<strong>Exercise 3.35.</strong>  Ben Bitdiddle tells Louis that one way to avoid the trouble in
exercise 3.34 is to define a squarer as a new
primitive constraint.  Fill in the missing portions in Ben's outline
for a procedure to implement such a constraint:</p>

<p>(define (squarer a b)</p><empty-line /><p>
  (define (process-new-value)</p><empty-line /><p>
    (if (has-value? b)</p><empty-line /><p>
        (if (&lt; (get-value b) 0)</p><empty-line /><p>
            (error "square less than 0 -- SQUARER" (get-value b))</p><empty-line /><p>
            &lt;<emphasis>alternative1</emphasis>&gt;)</p><empty-line /><p>
        &lt;<emphasis>alternative2</emphasis>&gt;))</p><empty-line /><p>
  (define (process-forget-value) &lt;<emphasis>body1</emphasis>&gt;)</p><empty-line /><p>
  (define (me request) &lt;<emphasis>body2</emphasis>&gt;)</p><empty-line /><p>
  &lt;<emphasis>rest of definition</emphasis>&gt;</p><empty-line /><p>
  me)</p><empty-line /><empty-line /><p>
<strong>Exercise 3.36.</strong>  Suppose we evaluate the following sequence of expressions in the
global environment:</p>

<p>(define a (make-connector))</p><empty-line /><p>
(define b (make-connector))</p><empty-line /><p>
(set-value! a 10 'user)</p><empty-line /><p>
At some time during evaluation of the set-value!, the following
expression from the connector's local procedure is evaluated:</p>

<p>(for-each-except setter inform-about-value constraints)</p><empty-line /><p>
Draw an environment diagram showing the environment in which the above
expression is evaluated.</p>

<p>
<strong>Exercise 3.37.</strong>  The celsius-fahrenheit-converter procedure is cumbersome when
compared with a more expression-oriented style of definition, such as</p>

<p>(define (celsius-fahrenheit-converter x)</p><empty-line /><p>
  (c+ (c* (c/ (cv 9) (cv 5))</p><empty-line /><p>
          x)</p><empty-line /><p>
      (cv 32)))</p><empty-line /><p>
(define C (make-connector))</p><empty-line /><p>
(define F (celsius-fahrenheit-converter C))</p><empty-line /><p>
Here c+, c*, etc. are the "constraint" versions of the
arithmetic operations.  For example, c+ takes two connectors as
arguments and returns a connector that is related to these by an adder
constraint:</p>

<p>(define (c+ x y)</p><empty-line /><p>
  (let ((z (make-connector)))</p><empty-line /><p>
    (adder x y z)</p><empty-line /><p>
    z))</p><empty-line /><p>
Define analogous procedures c-, c*, c/, and cv
(constant value) that enable us to define compound constraints as in
the converter example above.<sup>33</sup></p><empty-line /><empty-line /><empty-line /><p><sup>16</sup> Set-car! and set-cdr! return implementation-dependent
values.  Like set!, they should be used only for their effect.</p>

<p><sup>17</sup> We see from this that mutation operations on lists
can create "garbage" that is not part of any accessible structure.
We will see in section 5.3.2 that Lisp memory-management
systems include a <emphasis>garbage collector</emphasis>, which identifies and
recycles the memory space used by unneeded pairs.</p>

<p><sup>18</sup> Get-new-pair is one of the operations that must be implemented as
part of the memory management required by a Lisp implementation.  We
will discuss this in section 5.3.1.</p>

<p><sup>19</sup> The two pairs
are distinct because each call to cons returns a new pair.  The
symbols are shared; in Scheme there is a unique symbol with any given
name.  Since Scheme provides no way to mutate a symbol, this sharing is
undetectable.  Note also that the sharing is what enables us to
compare symbols using eq?, which simply checks equality of
pointers.</p>

<p><sup>20</sup> The
subtleties of dealing with sharing of mutable data objects reflect the
underlying issues of "sameness" and "change" that were raised in
section 3.1.3.  We mentioned there that
admitting change to our language requires that a compound object must
have an "identity" that is something different from the pieces from
which it is composed.  In Lisp, we consider this "identity" to be
the quality that is tested by eq?, i.e., by equality of
pointers.  Since in most Lisp implementations a pointer is
essentially a memory address, we are "solving the problem" of
defining the identity of objects by stipulating that a data object
"itself" is the information stored in some particular set of memory
locations in the computer.  This suffices for simple Lisp programs,
but is hardly a general way to resolve the issue of "sameness" in
computational models.</p>

<p><sup>21</sup> On the other hand, from the
viewpoint of implementation, assignment requires us to modify the
environment, which is itself a mutable data structure.  Thus,
assignment and mutation are equipotent: Each can be implemented in
terms of the other.</p>

<p><sup>22</sup> If the first item is
the final item in the queue, the front pointer will be the empty list after
the deletion, which will mark the queue as empty; we needn't worry
about updating the rear pointer, which will still point to the deleted
item, because empty-queue? looks only at the front pointer.</p>

<p><sup>23</sup> Be careful not to
make the interpreter try to print a structure that contains cycles.
(See exercise 3.13.)</p>

<p><sup>24</sup> Because assoc
uses equal?, it can recognize keys that are symbols, numbers,
or list structure.</p>

<p><sup>25</sup> Thus, the first backbone pair is the
object that represents the table "itself"; that is, a pointer to the
table is a pointer to this pair.  This same backbone pair always
starts the table.  If we did not arrange things in this way, insert! would have to return a new value for the start of the table
when it added a new record.</p>

<p><sup>26</sup> A
full-adder is a basic circuit element used in adding two binary
numbers.  Here A and B are the bits at corresponding positions in the
two numbers to be added, and C<sub><emphasis>i</emphasis><emphasis>n</emphasis></sub> is the carry bit from the
addition one place to the right.  The circuit generates SUM, which is
the sum bit in the corresponding position, and C<sub><emphasis>o</emphasis><emphasis>u</emphasis><emphasis>t</emphasis></sub>, which is the
carry bit to be propagated to the left.</p>

<p><sup>27</sup> These procedures are simply syntactic sugar that allow
us to use ordinary procedural syntax to access the local procedures of
objects.  It is striking that we can interchange the role of
"procedures" and "data" in such a simple way.  For example, if we
write (wire 'get-signal) we think of wire as a procedure
that is called with the message get-signal as input.
Alternatively, writing (get-signal wire) encourages us to think
of wire as a data object that is the input to a procedure get-signal.  The truth of the matter is that, in a language in which
we can deal with procedures as objects, there is no fundamental
difference between "procedures" and "data", and we can choose our
syntactic sugar to allow us to program in whatever style we choose.</p>

<p><sup>28</sup> The
agenda is a headed list, like the tables in section 3.3.3,
but since the list is headed by the time, we do not need an additional
dummy header (such as the *table* symbol used with tables).</p>

<p><sup>29</sup> Observe that the if expression in
this procedure has no
&lt;<emphasis>alternative</emphasis>&gt; expression.  Such a "one-armed if statement"
is used to decide whether to do something, rather than to select
between two expressions.  An if expression returns an
unspecified value if the predicate is false and there is no
&lt;<emphasis>alternative</emphasis>&gt;.</p>

<p><sup>30</sup> In this way, the current time will always be the time
of the action most recently processed.  Storing this time at the head
of the agenda ensures that it will still be available even if the
associated time segment has been deleted.</p>

<p><sup>31</sup> Constraint propagation
first appeared in the incredibly forward-looking SKETCHPAD system of
Ivan Sutherland (1963).  A beautiful constraint-propagation system
based on the Smalltalk language was developed by Alan Borning (1977)
at Xerox Palo Alto Research Center.  Sussman, Stallman, and Steele
applied constraint propagation to electrical circuit analysis (Sussman
and Stallman 1975; Sussman and Steele 1980). TK!Solver (Konopasek and
Jayaraman 1984) is an extensive modeling environment based on
constraints.</p>

<p><sup>32</sup> The setter might not be a constraint.  In our
temperature example, we used user as the setter.</p>

<p><sup>33</sup> The expression-oriented format
is convenient because it avoids the need to name the intermediate
expressions in a computation.  Our original formulation of the
constraint language is cumbersome in the same way that many languages
are cumbersome when dealing with operations on compound data.  For
example, if we wanted to compute the product (<emphasis>a</emphasis> + <emphasis>b</emphasis>) · (<emphasis>c</emphasis> + <emphasis>d</emphasis>), where the
variables represent vectors, we could work in "imperative style",
using procedures that set the values of designated vector arguments
but do not themselves return vectors as values:</p>

<p>(v-sum a b temp1)</p><empty-line /><p>
(v-sum c d temp2)</p><empty-line /><p>
(v-prod temp1 temp2 answer)</p><empty-line /><p>
Alternatively, we could deal with expressions, using
procedures that return vectors as values, and thus avoid
explicitly mentioning temp1 and temp2:</p>

<p>(define answer (v-prod (v-sum a b) (v-sum c d)))</p><empty-line /><p>
Since Lisp allows us to return compound objects as values of
procedures, we can transform our imperative-style constraint language
into an expression-oriented style as shown in this exercise.  In
languages that are impoverished in handling compound objects, such as
Algol, Basic, and Pascal (unless one explicitly uses Pascal pointer
variables), one is usually stuck with the imperative style when
manipulating compound objects.  Given the advantage of the
expression-oriented format, one might ask if there is any reason to
have implemented the system in imperative style, as we did in this
section.  One reason is that the non-expression-oriented constraint
language provides a handle on constraint objects (e.g., the value of
the adder procedure) as well as on connector objects.  This is
useful if we wish to extend the system with new operations that
communicate with constraints directly rather than only indirectly via
operations on connectors.  Although it is easy to implement the
expression-oriented style in terms of the imperative implementation,
it is very difficult to do the converse.</p>


</section>

<section>


<p><strong>3.4  Concurrency: Time Is of the Essence</strong></p>

<p>



We've seen the power of computational objects with local state as
tools for modeling.  Yet, as section 3.1.3
warned, this power extracts a price: the loss of referential
transparency, giving rise to a thicket of questions about sameness and
change, and the need to abandon the substitution model of evaluation in
favor of the more intricate environment model.</p>

<p>

The central issue lurking beneath the complexity of state, sameness,
and change is that by introducing assignment we are forced to admit
<emphasis>time</emphasis> into our computational models.  Before we introduced
assignment, all our programs were timeless, in the sense that any
expression that has a value always has the same value.  In contrast,
recall the example of modeling withdrawals from a bank account
and returning the resulting balance,
introduced at the beginning of
section 3.1.1:</p>

<p>(withdraw 25)</p><empty-line /><p><emphasis>75</emphasis></p><empty-line /><p>
(withdraw 25)</p><empty-line /><p><emphasis>50</emphasis></p><empty-line /><p>
Here successive evaluations of the same expression yield different
values.  This behavior arises from the fact that the execution of
assignment statements (in this case, assignments to the variable balance) delineates <emphasis>moments in time</emphasis> when values change.  The
result of evaluating an expression depends not only on the expression
itself, but also on whether the evaluation occurs before or after
these moments.  Building models in terms of computational objects with
local state forces us to confront time as an essential concept in
programming.</p>

<p>

We can go further in structuring computational models to match our
perception of the physical world.  Objects in the world do not change
one at a time in sequence.  Rather we perceive them as acting <emphasis>concurrently</emphasis> -- all at once.  So it is often natural to model systems
as collections of computational processes that execute concurrently.
Just as we can make our programs modular by organizing models in
terms of objects with separate local state, it is often appropriate to
divide computational models into parts that evolve separately and
concurrently.  Even if the programs are to be executed on a sequential
computer, the practice of writing programs as if they were to be
executed concurrently forces the programmer to avoid inessential
timing constraints and thus makes programs more modular.</p>

<p>

In addition to making programs more modular, concurrent computation
can provide a speed advantage over sequential computation.  Sequential
computers execute only one operation at a time, so the amount of time
it takes to perform a task is proportional to the total number of
operations performed.<sup>34</sup>
However, if it is possible to decompose a problem into pieces that are
relatively independent and need to communicate only rarely, it may be
possible to allocate pieces to separate computing processors,
producing a speed advantage proportional to the number of processors
available.</p>

<p>

Unfortunately, the complexities introduced by assignment become even
more problematic in the presence of concurrency.  The fact of
concurrent execution, either because the world operates in parallel or
because our computers do, entails additional complexity in our
understanding of time.</p>

<p><strong>3.4.1  The Nature of Time in Concurrent Systems</strong></p>

<p>



On the surface, time seems straightforward.  It
is an ordering imposed on events.<sup>35</sup>
For any events <emphasis>A</emphasis> and <emphasis>B</emphasis>, either <emphasis>A</emphasis> occurs before <emphasis>B</emphasis>, <emphasis>A</emphasis> and <emphasis>B</emphasis>
are simultaneous, or <emphasis>A</emphasis> occurs after <emphasis>B</emphasis>.  For instance,
returning to the bank account example, suppose that Peter withdraws
$10 and Paul withdraws $25 from a joint account that initially
contains $100, leaving $65 in the account.  Depending on the order
of the two withdrawals, the sequence of balances in the account is
either $100 <image xlink:href="#_35.jpg" /> $90 <image xlink:href="#_35.jpg" /> $65 or
$100 <image xlink:href="#_35.jpg" /> $75 <image xlink:href="#_35.jpg" /> $65.  In a computer implementation
of the banking system, this changing sequence of balances could be
modeled by successive assignments to a variable balance.</p>

<p>

In complex situations, however, such a view can be problematic.
Suppose that Peter and Paul, and other people besides, are
accessing the same bank account through a network of banking machines
distributed all over the world.  The actual sequence of balances in
the account will depend critically on the detailed timing of the
accesses and the details of the communication among the machines.</p>

<p>

This indeterminacy in the order of events can pose serious problems in
the design of concurrent systems.  For instance, suppose that the
withdrawals made by Peter and Paul are implemented as two separate
processes sharing a common variable balance, each process
specified by the procedure given in
section 3.1.1:</p>

<p>(define (withdraw amount)</p><empty-line /><p>
  (if (&gt;= balance amount)</p><empty-line /><p>
      (begin (set! balance (- balance amount))</p><empty-line /><p>
             balance)</p><empty-line /><p>
      "Insufficient funds"))</p><empty-line /><p>
If the two processes operate independently, then Peter might test the
balance and attempt to withdraw a legitimate amount.  However, Paul
might withdraw some funds in between the time that Peter checks the
balance and the time Peter completes the withdrawal, thus invalidating
Peter's test.</p>

<p>

Things can be worse still.  Consider the expression</p>

<p>(set! balance (- balance amount))</p><empty-line /><p>
executed as part of each withdrawal process.  This consists of three
steps: (1) accessing the value of the balance variable; (2)
computing the new balance; (3) setting balance to this new
value.  If Peter and Paul's withdrawals execute this statement
concurrently, then the two withdrawals might interleave the order in
which they access balance and set it to the new value.</p>

<p>


The timing diagram in figure 3.29 depicts an order of
events where balance starts at 100, Peter withdraws 10,
Paul withdraws 25, and yet the final value of balance is 75.  As
shown in the diagram, the reason for this anomaly is that Paul's
assignment of 75 to balance is made under the assumption that
the value of balance to be decremented is 100.  That assumption,
however, became invalid when Peter changed balance to 90.  This
is a catastrophic failure for the banking system, because the total
amount of money in the system is not conserved.  Before the transactions,
the total amount of money was $100.  Afterwards, Peter has $10, Paul
has $25, and the bank has $75.<sup>36</sup></p>

<p>


The general phenomenon illustrated
here is that several processes may share  a
common state variable.  What makes this complicated is that more than
one process may be trying to manipulate the shared state at the same
time.  For the bank account example, during each transaction, each
customer should be able to act as if the other customers did not
exist.  When a customer changes the balance in a way that depends on
the balance, he must be able to assume that, just before the moment of
change, the balance is still what he thought it was.</p>

<p><strong>Correct behavior of concurrent programs</strong></p>

<p>


The above example typifies the subtle bugs that can creep into
concurrent programs.  The root of this complexity lies in the
assignments to variables that are shared among the different
processes.  We already know that we must be careful in writing
programs that use set!, because the results of a computation
depend on the order in which the assignments occur.<sup>37</sup>
With concurrent processes we must be especially careful about
assignments, because we may not be able to control the order of the
assignments made by the different processes.  If several such changes
might be made concurrently (as with two depositors accessing a joint
account) we need some way to ensure that our system behaves correctly.
For example, in the case of withdrawals from a joint bank account, we
must ensure that money is conserved.
To make concurrent programs behave correctly, we may have to
place some restrictions on concurrent execution.</p>

<p><image xlink:href="#_163.jpg" /></p>

<p><strong>Figure 3.29:</strong>  Timing diagram showing how interleaving the order of events
in two banking withdrawals can lead to an incorrect final balance.</p>

<p>

One possible restriction on concurrency would
stipulate that no two operations that
change any shared state variables can occur at the same time.  This is an
extremely stringent requirement.  For distributed banking, it would
require the system designer to ensure that only one transaction could
proceed at a time.  This would be both inefficient and overly
conservative.  Figure 3.30 shows Peter and
Paul sharing a bank account, where Paul has a private account as well.
The diagram illustrates two withdrawals from the shared account
(one by Peter and one by Paul) and a deposit to Paul's private account.<sup>38</sup>
The two withdrawals from the shared account must not be
concurrent (since both access and update the same account), and Paul's
deposit and withdrawal must not be concurrent (since both access and
update the amount in Paul's wallet).
But there should be no problem
permitting Paul's deposit to his private account to proceed
concurrently with Peter's withdrawal from the shared account.</p>

<p><image xlink:href="#_164.jpg" /></p>

<p><strong>Figure 3.30:</strong>  Concurrent deposits and withdrawals from a joint account
in Bank1 and a private account in Bank2.</p>

<p>

A less stringent restriction on concurrency would ensure that a
concurrent system produces the same result
as if the processes had run sequentially in some order.
There are two important aspects to this requirement.
First, it does not require the processes to actually run sequentially,
but only to produce results that are the same <emphasis>as if</emphasis> they had run
sequentially.  For the example in
figure 3.30, the designer of the bank account
system can safely allow Paul's deposit and Peter's withdrawal to
happen concurrently, because the net result will be the same as if the
two operations had happened sequentially.  Second, there may be more
than one possible "correct" result produced by a concurrent program,
because we require only that the result be the same as for <emphasis>some</emphasis>
sequential order.
For example, suppose that Peter and Paul's joint account starts out
with $100, and Peter deposits $40 while Paul concurrently withdraws
half the money in the account.
Then sequential execution could result in the account balance being
either $70 or $90 (see exercise 3.38).<sup>39</sup></p>

<p>

There are still weaker requirements for correct execution of
concurrent programs.  A program for simulating diffusion (say, the
flow of heat in an object) might consist of a large number of
processes, each one representing a small volume of space, that update
their values concurrently.  Each process repeatedly changes its
value to the average of its own value and its neighbors' values.
This algorithm
converges to the right answer independent of the order in which the
operations are done; there is no need for any restrictions on
concurrent use of the shared values.</p>

<p>
<strong>Exercise 3.38.</strong>  Suppose that Peter, Paul, and Mary share a joint bank account that
initially contains $100.  Concurrently, Peter deposits $10, Paul
withdraws $20, and Mary withdraws half the money in the account, by
executing the following commands:</p>

<p>Peter:</p>

<p>(set! balance (+ balance 10))</p>

<p>Paul:</p>

<p>(set! balance (- balance 20))</p>

<p>Mary:</p>

<p>(set! balance (- balance (/ balance 2)))</p><empty-line /><p>a. List all the different possible values for balance after these
three transactions have been completed, assuming that the banking
system forces the three processes to run sequentially in some order.</p>

<p>b. What are some other values
that could be produced if the system allows the processes to be interleaved?
Draw timing diagrams like the one in figure 3.29 to
explain how these values can occur.</p>

<p><strong>3.4.2  Mechanisms for Controlling Concurrency</strong></p>

<p>


We've seen that the difficulty in dealing with concurrent processes is
rooted in the need to consider the interleaving of the order of events
in the different processes.  For example, suppose we have two
processes, one with three ordered events (<emphasis>a</emphasis>,<emphasis>b</emphasis>,<emphasis>c</emphasis>) and one with three
ordered events (<emphasis>x</emphasis>,<emphasis>y</emphasis>,<emphasis>z</emphasis>).  If the two processes run concurrently, with
no constraints on how their execution is interleaved, then there are
20 different possible orderings for the events that are consistent
with the individual orderings for the two processes:</p>

<p><image xlink:href="#_165.jpg" /></p>

<p>
As programmers designing this system, we would have to consider the
effects of each of these 20 orderings and check that each behavior is
acceptable.  Such an approach rapidly becomes unwieldy as the numbers
of processes and events increase.</p>

<p>

A more practical approach to the design of concurrent systems is to
devise general mechanisms that allow us to constrain the interleaving
of concurrent processes so that we can be sure that the program
behavior is correct.  Many mechanisms have been developed for this
purpose.  In this section, we describe one of them, the <emphasis>serializer</emphasis>.</p>

<p><strong>Serializing access to shared state</strong></p>

<p>


Serialization implements the following idea: Processes will execute
concurrently, but there will be certain collections of procedures that
cannot be executed concurrently.  More precisely, serialization creates
distinguished sets of procedures such that only one execution of a
procedure in each serialized set is permitted to happen at a time.
If some procedure in the set is being executed, then a process that
attempts to execute any procedure in the set will be forced to wait
until the first execution has finished.</p>

<p>

We can use serialization to control access to shared variables.
For example, if we want to update a shared variable based on the
previous value of that variable, we put the access to the previous
value of the variable and the assignment of the new value to the
variable in the same procedure.  We then ensure that no other
procedure that assigns to the variable can run concurrently with this
procedure by serializing all of these procedures with the same
serializer.  This guarantees that the value of the variable cannot be
changed between an access and the corresponding assignment.</p>

<p><strong>Serializers in Scheme</strong></p>

<p>

To make the above mechanism more concrete, suppose that we have
extended Scheme to include a procedure called parallel-execute:</p>

<p>(parallel-execute &lt;<emphasis>p<sub>1</sub></emphasis>&gt; &lt;<emphasis>p<sub>2</sub></emphasis>&gt; ... &lt;<emphasis>p<sub>k</sub></emphasis>&gt;)</p><empty-line /><p>
Each &lt;<emphasis>p</emphasis>&gt; must be a procedure of no arguments.  Parallel-execute
creates a separate process for each
&lt;<emphasis>p</emphasis>&gt;, which applies &lt;<emphasis>p</emphasis>&gt; (to no arguments).  These processes all
run concurrently.<sup>40</sup></p>

<p>

As an example of how this is used, consider</p>

<p>(define x 10)</p><empty-line /><empty-line /><p>
(parallel-execute (lambda () (set! x (* x x)))</p><empty-line /><p>
                  (lambda () (set! x (+ x 1))))</p><empty-line /><p>
This creates two concurrent processes -- <emphasis>P</emphasis><sub>1</sub>, which sets x to
x times x, and <emphasis>P</emphasis><sub>2</sub>, which increments x.  After
execution is complete, x will be left with one of five possible
values, depending on the interleaving of the events of <emphasis>P</emphasis><sub>1</sub> and
<emphasis>P</emphasis><sub>2</sub>:</p>

<p>101:</p>

<p><emphasis>P</emphasis></p>

<p><sub>1</sub></p>

<p> sets</p>

<p>x</p>

<p> to 100 and then</p>

<p><emphasis>P</emphasis></p>

<p><sub>2</sub></p>

<p> increments</p>

<p>x</p>

<p> to 101.</p>

<p>121:</p>

<p><emphasis>P</emphasis></p>

<p><sub>2</sub></p>

<p> increments</p>

<p>x</p>

<p> to 11 and then</p>

<p><emphasis>P</emphasis></p>

<p><sub>1</sub></p>

<p> sets</p>

<p>x</p>

<p> to</p>

<p>x</p>

<p> times</p>

<p>x</p>

<p>.</p>

<p>110:</p>

<p><emphasis>P</emphasis></p>

<p><sub>2</sub></p>

<p> changes</p>

<p>x</p>

<p> from 10 to 11 between the two times that</p>

<p><emphasis>P</emphasis></p>

<p><sub>1</sub></p>

<p> accesses the value of</p>

<p>x</p>

<p> during the evaluation of</p>

<p>(* x x)</p>

<p>.</p>

<p>11:</p>

<p><emphasis>P</emphasis></p>

<p><sub>2</sub></p>

<p> accesses</p>

<p>x</p>

<p>, then</p>

<p><emphasis>P</emphasis></p>

<p><sub>1</sub></p>

<p> sets</p>

<p>x</p>

<p> to 100,
then</p>

<p><emphasis>P</emphasis></p>

<p><sub>2</sub></p>

<p> sets</p>

<p>x</p>

<p>.</p>

<p>100:</p>

<p><emphasis>P</emphasis></p>

<p><sub>1</sub></p>

<p> accesses</p>

<p>x</p>

<p> (twice), then</p>

<p><emphasis>P</emphasis></p>

<p><sub>2</sub></p>

<p> sets</p>

<p>x</p>

<p> to 11,
then</p>

<p><emphasis>P</emphasis></p>

<p><sub>1</sub></p>

<p> sets</p>

<p>x</p>

<p>.</p>

<p>


We can constrain the concurrency by using serialized procedures,
which are created by <emphasis>serializers</emphasis>. Serializers are constructed by make-serializer, whose implementation is given below.  A serializer
takes a procedure as argument and returns a serialized procedure that
behaves like the original procedure.  All calls to a given serializer
return serialized procedures in the same set.</p>

<p>

Thus, in contrast to the example above, executing</p>

<p>(define x 10)</p><empty-line /><empty-line /><p>
(define s (make-serializer))</p><empty-line /><empty-line /><p>
(parallel-execute (s (lambda () (set! x (* x x))))</p><empty-line /><p>
                  (s (lambda () (set! x (+ x 1)))))</p><empty-line /><p>
can produce only two possible values for x, 101 or 121.  The
other possibilities are eliminated, because the execution of <emphasis>P</emphasis><sub>1</sub> and
<emphasis>P</emphasis><sub>2</sub> cannot be interleaved.</p>

<p>

Here is a version of the make-account procedure from
section 3.1.1, where the deposits and
withdrawals have been serialized:</p>

<p>(define (make-account balance)</p><empty-line /><p>
  (define (withdraw amount)</p><empty-line /><p>
    (if (&gt;= balance amount)</p><empty-line /><p>
        (begin (set! balance (- balance amount))</p><empty-line /><p>
               balance)</p><empty-line /><p>
        "Insufficient funds"))</p><empty-line /><p>
  (define (deposit amount)</p><empty-line /><p>
    (set! balance (+ balance amount))</p><empty-line /><p>
    balance)</p><empty-line /><p>
  (let ((protected (make-serializer)))</p><empty-line /><p>
    (define (dispatch m)</p><empty-line /><p>
      (cond ((eq? m 'withdraw) (protected withdraw))</p><empty-line /><p>
            ((eq? m 'deposit) (protected deposit))</p><empty-line /><p>
            ((eq? m 'balance) balance)</p><empty-line /><p>
            (else (error "Unknown request -- MAKE-ACCOUNT"</p><empty-line /><p>
                         m))))</p><empty-line /><p>
    dispatch))</p><empty-line /><p>
With this implementation, two processes cannot be withdrawing from or
depositing into a single account concurrently.  This eliminates the source
of the error illustrated in figure 3.29, where Peter
changes the account balance between the times when Paul accesses the
balance to compute the new value and when Paul actually performs the
assignment.  On the other hand, each account has its own serializer,
so that deposits and withdrawals for different accounts can proceed
concurrently.</p>

<p>
<strong>Exercise 3.39.</strong>  Which of the five possibilities in the parallel execution shown above
remain if we instead serialize execution as follows:</p>

<p>(define x 10)</p><empty-line /><empty-line /><p>
(define s (make-serializer))</p><empty-line /><empty-line /><p>
(parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))</p><empty-line /><p>
                  (s (lambda () (set! x (+ x 1)))))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.40.</strong>  Give all possible values of x that can result from executing</p>

<p>(define x 10)</p><empty-line /><empty-line /><p>
(parallel-execute (lambda () (set! x (* x x)))</p><empty-line /><p>
                  (lambda () (set! x (* x x x))))</p><empty-line /><p>
Which of these possibilities remain if we instead use serialized
procedures:</p>

<p>(define x 10)</p><empty-line /><empty-line /><p>
(define s (make-serializer))</p><empty-line /><empty-line /><p>
(parallel-execute (s (lambda () (set! x (* x x))))</p><empty-line /><p>
                  (s (lambda () (set! x (* x x x)))))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.41.</strong>  Ben Bitdiddle worries that it would be better to implement the bank
account as follows (where the commented line has been changed):</p>

<p>(define (make-account balance)</p><empty-line /><p>
  (define (withdraw amount)</p><empty-line /><p>
    (if (&gt;= balance amount)</p><empty-line /><p>
        (begin (set! balance (- balance amount))</p><empty-line /><p>
               balance)</p><empty-line /><p>
        "Insufficient funds"))</p><empty-line /><p>
  (define (deposit amount)</p><empty-line /><p>
    (set! balance (+ balance amount))</p><empty-line /><p>
    balance)</p><empty-line /><p>
  <emphasis>;; continued on next page</emphasis></p><empty-line /><empty-line /><p>
  (let ((protected (make-serializer)))</p><empty-line /><p>
    (define (dispatch m)</p><empty-line /><p>
      (cond ((eq? m 'withdraw) (protected withdraw))</p><empty-line /><p>
            ((eq? m 'deposit) (protected deposit))</p><empty-line /><p>
            ((eq? m 'balance)</p><empty-line /><p>
             ((protected (lambda () balance)))) <emphasis>; serialized</emphasis></p><empty-line /><p>
            (else (error "Unknown request -- MAKE-ACCOUNT"</p><empty-line /><p>
                         m))))</p><empty-line /><p>
    dispatch))</p><empty-line /><p>
because allowing unserialized access to the bank balance can result in
anomalous behavior.  Do you agree?  Is there any scenario that
demonstrates Ben's concern?</p>

<p>
<strong>Exercise 3.42.</strong>  Ben Bitdiddle suggests that it's a waste of time to create a new
serialized procedure in response to every withdraw and deposit message.  He says that make-account could be changed so
that the calls to protected are done outside the dispatch
procedure.  That is, an account would return the same serialized
procedure (which was created at the same time as the account) each time
it is asked for a withdrawal procedure.</p>

<p>(define (make-account balance)</p><empty-line /><p>
  (define (withdraw amount)</p><empty-line /><p>
    (if (&gt;= balance amount)</p><empty-line /><p>
        (begin (set! balance (- balance amount))</p><empty-line /><p>
               balance)</p><empty-line /><p>
        "Insufficient funds"))</p><empty-line /><p>
  (define (deposit amount)</p><empty-line /><p>
    (set! balance (+ balance amount))</p><empty-line /><p>
    balance)</p><empty-line /><p>
  (let ((protected (make-serializer)))</p><empty-line /><p>
    (let ((protected-withdraw (protected withdraw))</p><empty-line /><p>
          (protected-deposit (protected deposit)))</p><empty-line /><p>
      (define (dispatch m)</p><empty-line /><p>
        (cond ((eq? m 'withdraw) protected-withdraw)</p><empty-line /><p>
              ((eq? m 'deposit) protected-deposit)</p><empty-line /><p>
              ((eq? m 'balance) balance)</p><empty-line /><p>
              (else (error "Unknown request -- MAKE-ACCOUNT"</p><empty-line /><p>
                           m))))</p><empty-line /><p>
      dispatch)))</p><empty-line /><p>
Is this a safe change to make?  In particular, is there any difference in
what concurrency is allowed by these two versions of make-account ?</p>

<p><strong>Complexity of using multiple shared resources</strong></p>

<p>


Serializers provide a powerful abstraction that helps isolate the
complexities of concurrent programs so that they can be dealt with
carefully and (hopefully) correctly.  However, while using serializers
is relatively straightforward when there is only a single shared
resource (such as a single bank account), concurrent programming can
be treacherously difficult when there are multiple shared resources.</p>

<p>

To illustrate one of the difficulties that can arise, suppose we wish to swap
the balances in two bank accounts.  We access each account to find the
balance, compute the difference between the balances, withdraw this
difference from one account, and deposit it in the other account.  We
could implement this as follows:<sup>41</sup></p>

<p>(define (exchange account1 account2)</p><empty-line /><p>
  (let ((difference (- (account1 'balance)</p><empty-line /><p>
                       (account2 'balance))))</p><empty-line /><p>
    ((account1 'withdraw) difference)</p><empty-line /><p>
    ((account2 'deposit) difference)))</p><empty-line /><empty-line /><p>

This procedure works well when only a single process is trying to do
the exchange.  Suppose, however, that Peter and Paul both have access
to accounts <emphasis>a</emphasis>1, <emphasis>a</emphasis>2, and <emphasis>a</emphasis>3, and that
Peter exchanges <emphasis>a</emphasis>1 and
<emphasis>a</emphasis>2 while Paul concurrently exchanges <emphasis>a</emphasis>1 and <emphasis>a</emphasis>3.
Even with account deposits and withdrawals
serialized for individual accounts (as in the make-account
procedure shown above in this section), exchange can still
produce incorrect results.  For example, Peter might compute the
difference in the balances for <emphasis>a</emphasis>1 and <emphasis>a</emphasis>2, but then Paul
might change the balance in <emphasis>a</emphasis>1 before Peter is able to complete
the exchange.<sup>42</sup>
For correct behavior, we must arrange for the exchange procedure
to lock out any other concurrent accesses to the accounts during the
entire time of the exchange.</p>

<p>

One way we can accomplish this is by using both accounts' serializers
to serialize the entire exchange procedure.
To do this, we will arrange for access to an account's serializer.
Note that we are deliberately
breaking the modularity of the bank-account object by exposing the
serializer.  The following version of make-account is identical
to the original version given in
section 3.1.1, except that a serializer is
provided to protect the balance variable, and the serializer is
exported via message passing:</p>

<p>(define (make-account-and-serializer balance)</p><empty-line /><p>
  (define (withdraw amount)</p><empty-line /><p>
    (if (&gt;= balance amount)</p><empty-line /><p>
        (begin (set! balance (- balance amount))</p><empty-line /><p>
               balance)</p><empty-line /><p>
        "Insufficient funds"))</p><empty-line /><p>
  (define (deposit amount)</p><empty-line /><p>
    (set! balance (+ balance amount))</p><empty-line /><p>
    balance)</p><empty-line /><p>
  (let ((balance-serializer (make-serializer)))</p><empty-line /><p>
    (define (dispatch m)</p><empty-line /><p>
      (cond ((eq? m 'withdraw) withdraw)</p><empty-line /><p>
            ((eq? m 'deposit) deposit)</p><empty-line /><p>
            ((eq? m 'balance) balance)</p><empty-line /><p>
            ((eq? m 'serializer) balance-serializer)</p><empty-line /><p>
            (else (error "Unknown request -- MAKE-ACCOUNT"</p><empty-line /><p>
                         m))))</p><empty-line /><p>
    dispatch))</p><empty-line /><empty-line /><p>


We can use this to do serialized deposits and withdrawals.  However,
unlike our earlier serialized account, it is now the responsibility of
each user of bank-account objects to explicitly manage the
serialization, for example as follows:<sup>43</sup></p>

<p>(define (deposit account amount)</p><empty-line /><p>
  (let ((s (account 'serializer))</p><empty-line /><p>
        (d (account 'deposit)))</p><empty-line /><p>
    ((s d) amount)))</p><empty-line /><empty-line /><p>

Exporting the serializer in this way gives us enough flexibility to
implement a serialized exchange program.  We simply
serialize the original
exchange procedure with the serializers for both accounts:</p>

<p>(define (serialized-exchange account1 account2)</p><empty-line /><p>
  (let ((serializer1 (account1 'serializer))</p><empty-line /><p>
        (serializer2 (account2 'serializer)))</p><empty-line /><p>
    ((serializer1 (serializer2 exchange))</p><empty-line /><p>
     account1</p><empty-line /><p>
     account2)))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.43.</strong>  Suppose that the balances in three accounts start out as $10, $20,
and $30, and that multiple processes run, exchanging the balances in
the accounts.  Argue that if the processes are run sequentially,
after any number of concurrent exchanges, the account balances should be 
$10, $20, and $30 in some order.
Draw a timing diagram like the one in figure 3.29 to
show how this condition can be violated if the exchanges are
implemented using the first version of the account-exchange program in
this section.  On the other hand, argue that even with this exchange program, the sum of the balances in the accounts will be
preserved.  Draw a timing diagram to show how even this condition would
be violated if we did not serialize the transactions
on individual accounts.</p>

<p>
<strong>Exercise 3.44.</strong>  Consider the problem of transferring an amount from one account to
another.  Ben Bitdiddle claims that this can be accomplished with the
following procedure, even if there are multiple people concurrently
transferring money among multiple accounts, using any account
mechanism that serializes deposit and withdrawal transactions, for
example, the version of make-account in the text above.</p>

<p>(define (transfer from-account to-account amount)</p><empty-line /><p>
  ((from-account 'withdraw) amount)</p><empty-line /><p>
  ((to-account 'deposit) amount))</p><empty-line /><p>
Louis Reasoner claims that there is a problem here, and that we need
to use a more sophisticated method, such as the one required for
dealing with the exchange problem.  Is Louis right?  If not, what is
the essential difference between the transfer problem and the exchange
problem?  (You should assume that the balance in from-account
is at least amount.)</p>

<p>
<strong>Exercise 3.45.</strong>  Louis Reasoner thinks our bank-account system is unnecessarily complex and
error-prone now that deposits and withdrawals aren't automatically serialized.
He suggests that make-account-and-serializer should have
exported the serializer (for use by such procedures as
serialized-exchange) in addition to (rather than instead of)
using it to serialize accounts and deposits as make-account did.
He proposes to redefine accounts as follows:</p>

<p>(define (make-account-and-serializer balance)</p><empty-line /><p>
  (define (withdraw amount)</p><empty-line /><p>
    (if (&gt;= balance amount)</p><empty-line /><p>
        (begin (set! balance (- balance amount))</p><empty-line /><p>
               balance)</p><empty-line /><p>
        "Insufficient funds"))</p><empty-line /><p>
  (define (deposit amount)</p><empty-line /><p>
    (set! balance (+ balance amount))</p><empty-line /><p>
    balance)</p><empty-line /><p>
  (let ((balance-serializer (make-serializer)))</p><empty-line /><p>
    (define (dispatch m)</p><empty-line /><p>
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))</p><empty-line /><p>
            ((eq? m 'deposit) (balance-serializer deposit))</p><empty-line /><p>
            ((eq? m 'balance) balance)</p><empty-line /><p>
            ((eq? m 'serializer) balance-serializer)</p><empty-line /><p>
            (else (error "Unknown request -- MAKE-ACCOUNT"</p><empty-line /><p>
                         m))))</p><empty-line /><p>
    dispatch))</p><empty-line /><p>
Then deposits are handled as with the original make-account:</p>

<p>(define (deposit account amount)</p><empty-line /><p>
 ((account 'deposit) amount))</p><empty-line /><p>
Explain what is wrong with Louis's reasoning.  In particular,
consider what happens when serialized-exchange is called.</p>

<p><strong>Implementing serializers</strong></p>

<p>


We implement serializers in terms of a more primitive synchronization
mechanism called a <emphasis>mutex</emphasis>.  A mutex is an object that supports
two operations -- the mutex can be <emphasis>acquired</emphasis>, and the mutex can be
<emphasis>released</emphasis>.  Once a mutex has been acquired, no other acquire
operations on that mutex may proceed until the mutex is released.<sup>44</sup> In our implementation, each
serializer has an associated mutex.  Given a procedure p, the
serializer returns a procedure that acquires the mutex, runs p,
and then releases the mutex.  This ensures that only one of the
procedures produced by the serializer can be running at once, which is
precisely the serialization property that we need to guarantee.</p>

<p>(define (make-serializer)</p><empty-line /><p>
  (let ((mutex (make-mutex)))</p><empty-line /><p>
    (lambda (p)</p><empty-line /><p>
      (define (serialized-p . args)</p><empty-line /><p>
        (mutex 'acquire)</p><empty-line /><p>
        (let ((val (apply p args)))</p><empty-line /><p>
          (mutex 'release)</p><empty-line /><p>
          val))</p><empty-line /><p>
      serialized-p)))</p><empty-line /><empty-line /><p>

The mutex is a mutable object (here we'll use a one-element
list, which we'll refer to as a <emphasis>cell</emphasis>) that can hold the value
true or false.  When the value is false, the mutex is available to be
acquired.  When the value is true, the mutex is unavailable, and any
process that attempts to acquire the mutex must wait.</p>

<p>

Our mutex constructor make-mutex begins by initializing the cell
contents to false.  To acquire the mutex, we test the cell.  If the
mutex is available, we set the cell contents to true and proceed.
Otherwise, we wait in a loop, attempting to acquire over and over
again, until we find that the mutex is available.<sup>45</sup>  To release the
mutex, we set the cell contents to false.</p>

<p>(define (make-mutex)</p><empty-line /><p>
  (let ((cell (list false)))</p><empty-line /><p>
    (define (the-mutex m)</p><empty-line /><p>
      (cond ((eq? m 'acquire)</p><empty-line /><p>
             (if (test-and-set! cell)</p><empty-line /><p>
                 (the-mutex 'acquire))) <emphasis>; retry</emphasis></p><empty-line /><p>
            ((eq? m 'release) (clear! cell))))</p><empty-line /><p>
    the-mutex))</p><empty-line /><p>
(define (clear! cell)</p><empty-line /><p>
  (set-car! cell false))</p><empty-line /><empty-line /><p>

Test-and-set! tests the cell and returns the result of the
test.  In addition, if the test was false, test-and-set! sets
the cell contents to true before returning false.  We can express this
behavior as the following procedure:</p>

<p>(define (test-and-set! cell)</p><empty-line /><p>
  (if (car cell)</p><empty-line /><p>
      true</p><empty-line /><p>
      (begin (set-car! cell true)</p><empty-line /><p>
             false)))</p><empty-line /><empty-line /><p>

However, this implementation of test-and-set! does not suffice
as it stands.  There is a crucial subtlety here, which is the
essential place where concurrency control enters the system: The test-and-set! operation must be performed <emphasis>atomically</emphasis>.  That
is, we must guarantee that, once a process has tested the cell and
found it to be false, the cell contents will actually be set to true
before any other process can test the cell.  If we do not make this
guarantee, then the mutex can fail in a way similar to the
bank-account failure in figure 3.29.  (See
exercise 3.46.)</p>

<p>

The actual implementation of test-and-set! depends on the
details of how our system runs concurrent processes.  For example, we
might be executing concurrent processes on a sequential processor
using a time-slicing mechanism that cycles through the processes,
permitting each process to run for a short time before interrupting it
and moving on to the next process.  In that case, test-and-set!
can work by disabling time slicing during the testing and setting.<sup>46</sup>
Alternatively, multiprocessing computers provide instructions that
support atomic operations directly in hardware.<sup>47</sup></p>

<p>
<strong>Exercise 3.46.</strong>  Suppose that we implement test-and-set!  using an ordinary
procedure as shown in the text, without attempting to make the operation
atomic.  Draw a timing diagram like the one in
figure 3.29 to demonstrate how the mutex
implementation can fail by allowing two processes to acquire the mutex
at the same time.</p>

<p>
<strong>Exercise 3.47.</strong>  A semaphore (of size <emphasis>n</emphasis>) is a generalization of a mutex.  Like a
mutex, a semaphore supports acquire and release operations, but it is
more general in that up to <emphasis>n</emphasis> processes can acquire it
concurrently.  Additional processes that attempt to acquire the
semaphore must wait for release operations.  Give implementations of
semaphores</p>

<p>a. in terms of mutexes</p>

<p>b. in terms of atomic test-and-set! operations.</p>

<p><strong>Deadlock</strong></p>

<p>


Now that we have seen how to implement serializers, we can see
that account exchanging still has a problem, even with the
serialized-exchange procedure above.
Imagine that Peter attempts to exchange <emphasis>a</emphasis>1
with <emphasis>a</emphasis>2 while Paul concurrently attempts to exchange <emphasis>a</emphasis>2
with <emphasis>a</emphasis>1.  Suppose that Peter's process reaches the point where
it has entered a serialized procedure protecting <emphasis>a</emphasis>1 and, just
after that, Paul's process enters a serialized procedure protecting
<emphasis>a</emphasis>2.  Now Peter cannot proceed (to enter a serialized procedure
protecting <emphasis>a</emphasis>2) until Paul exits the serialized procedure
protecting <emphasis>a</emphasis>2.  Similarly, Paul cannot proceed until Peter exits
the serialized procedure protecting <emphasis>a</emphasis>1.  Each process is stalled
forever, waiting for the other.  This situation is called a <emphasis>deadlock</emphasis>.  Deadlock is always a danger in systems that provide
concurrent access to multiple shared resources.</p>

<p>

One way to avoid the deadlock in this situation is to give each
account a unique identification number and rewrite serialized-exchange so
that a process will always attempt to enter a procedure protecting the
lowest-numbered account first.  Although this method works well for
the exchange problem, there are other situations that require more
sophisticated deadlock-avoidance techniques, or where deadlock cannot
be avoided at all.  (See exercises 3.48
and 3.49.)<sup>48</sup></p>

<p>
<strong>Exercise 3.48.</strong>  Explain in detail why the deadlock-avoidance method described above,
(i.e., the accounts are numbered, and each process attempts to acquire
the smaller-numbered account first) avoids deadlock in the exchange
problem.  Rewrite serialized-exchange to incorporate this idea.
(You will
also need to modify make-account so that each account is created
with a number, which can be accessed by sending an appropriate
message.)</p>

<p>
<strong>Exercise 3.49.</strong>  Give a scenario where the deadlock-avoidance mechanism described
above does not work.  (Hint: In the exchange problem, each process
knows in advance which accounts it will need to get access to.  Consider a
situation where a process must get access to some shared resources before it
can know which additional shared resources it will require.)</p>

<p><strong>Concurrency, time, and communication</strong></p>

<p>

We've seen how programming concurrent systems requires controlling the
ordering of events when different processes access shared
state, and we've seen how to achieve this control through judicious
use of serializers.  But the problems of concurrency
lie deeper than this, because, from a fundamental point of view, it's
not always clear what is meant by "shared state."</p>

<p>

Mechanisms such as test-and-set! require processes to examine a
global shared flag at arbitrary times.  This is problematic and
inefficient to implement in modern high-speed processors, where
due to optimization techniques such as pipelining and cached memory,
the contents of memory
may not be in a consistent state at every instant.  In contemporary
multiprocessing systems, therefore, the serializer paradigm is being
supplanted by new approaches to concurrency control.<sup>49</sup></p>

<p>


The problematic aspects of shared state also arise
in large, distributed systems.  For
instance, imagine a
distributed banking system where individual branch banks maintain
local values for bank balances and periodically compare these with
values maintained by other branches.  In such a system the value of
"the account balance" would be undetermined, except right after
synchronization.
If Peter deposits money in an account he holds
jointly with Paul, when should we say that the account balance has
changed -- when the balance in the local branch changes, or not until
after the synchronization?  
And if Paul accesses the account from a
different branch, what are the reasonable constraints to place on the
banking system such that the behavior is "correct"?  
The only thing that might matter for
correctness is the behavior observed by Peter and Paul individually
and the "state" of the account immediately after synchronization.
Questions about the
"real" account balance or the order of events between synchronizations
may be irrelevant or meaningless.<sup>50</sup></p>

<p>


The basic phenomenon here is that synchronizing different processes,
establishing shared state, or imposing an order on events requires
communication among the processes.  In essence, any notion of time in
concurrency control must be intimately tied to communication.<sup>51</sup>  It is
intriguing that a similar connection between time and communication
also arises in the Theory of Relativity, where the speed of light (the
fastest signal that can be used to synchronize events) is a
fundamental constant relating time and space.  The
complexities we encounter in dealing with time and state in our
computational models may in fact mirror a fundamental complexity of
the physical universe.</p><empty-line /><empty-line /><empty-line /><p><sup>34</sup> Most real processors actually execute a few
operations at a time, following a strategy called <emphasis>pipelining</emphasis>.  Although this technique greatly improves the effective
utilization of the hardware, it is used only to speed up the execution
of a sequential instruction stream, while retaining the behavior of
the sequential program.</p>

<p><sup>35</sup> To quote some graffiti seen on a Cambridge
building wall: "Time is a device that was invented to keep everything
from happening at once."</p>

<p><sup>36</sup> An even worse failure for this system
could occur if the two set! operations attempt to change the
balance simultaneously, in which case the actual data appearing in
memory might end up being a random combination of the information
being written by the two processes.  Most computers have interlocks on
the primitive memory-write operations, which protect against such
simultaneous access.  Even this seemingly simple kind of protection,
however, raises implementation challenges in the design of
multiprocessing computers, where elaborate <emphasis>cache-coherence</emphasis>
protocols are required to ensure that the various processors will
maintain a consistent view of memory contents, despite the fact that
data may be replicated ("cached") among the different processors to
increase the speed of memory access.</p>

<p><sup>37</sup> The factorial program in
section 3.1.3 illustrates this for a single
sequential process.</p>

<p><sup>38</sup> The columns show the contents of Peter's wallet,
the joint account (in Bank1), Paul's wallet, and Paul's private account
(in Bank2), before and after each withdrawal (W) and deposit (D).
Peter withdraws $10 from Bank1; Paul deposits $5 in Bank2,
then withdraws $25 from Bank1.</p>

<p><sup>39</sup> A more formal way to express this idea is to say that
concurrent programs are inherently <emphasis>nondeterministic</emphasis>. That
is, they are described not by single-valued functions, but by
functions whose results are sets of possible values.  In
section 4.3 we will study a
language for expressing nondeterministic
computations.</p>

<p><sup>40</sup> Parallel-execute is not part of standard Scheme, but
it can be implemented in MIT Scheme.  In our implementation, the
new concurrent processes also run concurrently with the original
Scheme process.  Also, in our implementation, the value returned
by parallel-execute is a special control object that can be used
to halt the newly created processes.</p>

<p><sup>41</sup> We have simplified exchange by exploiting the fact
that our deposit message accepts negative amounts.  (This is a
serious bug in our banking system!)</p>

<p><sup>42</sup> If the account balances start out as $10,
$20, and $30, then after any number of concurrent exchanges, the
balances should still be $10, $20, and
$30 in some order.  Serializing the deposits to individual accounts is not
sufficient to guarantee this.  See exercise 3.43.</p>

<p><sup>43</sup> Exercise 3.45 investigates why
deposits and withdrawals are no longer automatically serialized
by the account.</p>

<p><sup>44</sup> The term "mutex" is an abbreviation for <emphasis>mutual
exclusion</emphasis>.  The general problem of arranging a mechanism that permits
concurrent processes to safely share resources is called the mutual
exclusion problem.  Our mutex is a simple variant of the <emphasis>semaphore</emphasis> mechanism (see exercise 3.47), which was
introduced in the "THE" Multiprogramming System developed at the
Technological University of Eindhoven and named for the university's
initials in Dutch (Dijkstra 1968a).  The acquire and
release operations were originally called P and V, from the Dutch
words <emphasis>passeren</emphasis> (to pass) and <emphasis>vrijgeven</emphasis> (to release), in
reference to the semaphores used on railroad systems.  Dijkstra's
classic exposition (1968b) was one of the first to clearly present the
issues of concurrency control, and showed how to use semaphores to
handle a variety of concurrency problems.</p>

<p><sup>45</sup> In most
time-shared operating systems, processes that are blocked by a mutex do
not waste time "busy-waiting" as above.  Instead, the system
schedules another process to run while the first is waiting, and the blocked
process is awakened when the mutex becomes available.</p>

<p><sup>46</sup> In MIT Scheme for a single processor, which uses a time-slicing
model, test-and-set! can be implemented as follows:</p>

<p>(define (test-and-set! cell)</p><empty-line /><p>
  (without-interrupts</p><empty-line /><p>
   (lambda ()</p><empty-line /><p>
     (if (car cell)</p><empty-line /><p>
         true</p><empty-line /><p>
         (begin (set-car! cell true)</p><empty-line /><p>
                false)))))</p><empty-line /><p>
Without-interrupts disables
time-slicing interrupts while its procedure argument is being executed.</p>

<p><sup>47</sup> There are many variants of such
instructions -- including test-and-set, test-and-clear, swap,
compare-and-exchange, load-reserve, and store-conditional -- whose
design must be carefully matched to the machine's processor-memory
interface.
One issue that arises here is to determine what happens
if two processes attempt to acquire the same resource
at exactly the same time by using such an instruction.
This requires some mechanism
for making a decision about which process gets control.  Such a
mechanism is called an <emphasis>arbiter</emphasis>.  Arbiters usually boil down to
some sort of hardware device.
Unfortunately, it is possible to prove that one cannot physically
construct a fair arbiter that works 100% of the time unless one
allows the arbiter an arbitrarily long time to make its decision.  The
fundamental phenomenon here was originally observed by the fourteenth-century
French philosopher Jean Buridan in his commentary on
Aristotle's <emphasis>De caelo</emphasis>.  Buridan argued that a perfectly rational
dog placed between two equally attractive sources of food will starve
to death, because it is incapable of deciding which to go to first.</p>

<p><sup>48</sup> The general technique for avoiding deadlock by numbering the
shared resources and acquiring them in order is due to Havender
(1968).  Situations where deadlock cannot be avoided require <emphasis>deadlock-recovery</emphasis> methods, which entail having processes "back out"
of the deadlocked state and try again.  Deadlock-recovery
mechanisms are widely used in database management systems, a topic that
is treated in detail in Gray and Reuter 1993.</p>

<p><sup>49</sup> One such alternative to serialization is called <emphasis>barrier
synchronization</emphasis>.  The programmer permits concurrent processes to
execute as they please, but establishes certain synchronization points
("barriers") through which no process can proceed until all the
processes have reached the barrier.  Modern processors provide machine
instructions that permit programmers to establish synchronization
points at places where consistency is required.  The PowerPC<sup><emphasis>T</emphasis><emphasis>M</emphasis></sup>, for example, includes for this purpose two instructions called
SYNC and EIEIO (Enforced In-order Execution of Input/Output).</p>

<p><sup>50</sup> This may seem like a strange point of view, but there are
systems that work this way.  International charges to credit-card
accounts, for example, are normally cleared on a per-country basis,
and the charges made in different countries are periodically
reconciled.  Thus the account balance may be different in
different countries.</p>

<p><sup>51</sup> For distributed
systems, this perspective was pursued by Lamport (1978), who showed how
to use communication to establish "global clocks" that can be used
to establish orderings on events in distributed systems.</p>


</section>

<section>


<p><strong>3.5  Streams</strong></p>

<p>



We've gained a good understanding of assignment as a tool in modeling,
as well as an appreciation of the complex problems that assignment
raises. It is time to ask whether we could have gone about things in a
different way, so as to avoid some of these problems.  In this
section, we explore an alternative approach to modeling state, based
on data structures called <emphasis>streams</emphasis>.  As we shall see, streams can
mitigate some of the complexity of modeling state.</p>

<p>

Let's step back and review where this complexity comes from.  In an
attempt to model real-world phenomena, we made some apparently
reasonable decisions: We modeled real-world objects with local state
by computational objects with local variables.  We identified time
variation in the real world with time variation in the computer.  We
implemented the time variation of the states of the model objects in
the computer with assignments to the local variables of the model
objects.</p>

<p>

Is there another approach?  Can we avoid identifying time in the
computer with time in the modeled world?  Must we make the model
change with time in order to model phenomena in a changing world?
Think about the issue in terms of mathematical functions.  We can
describe the time-varying behavior of a quantity <emphasis>x</emphasis> as a function of
time <emphasis>x</emphasis>(<emphasis>t</emphasis>).  If we concentrate on <emphasis>x</emphasis> instant by instant, we think of
it as a changing quantity.  Yet if we concentrate on the entire
time history of values, we do not emphasize change -- the function
itself does not change.<sup>52</sup></p>

<p>

If time is measured in discrete steps, then we can model a time function as
a (possibly infinite) sequence.  In this section, we will see how to
model change in terms of sequences that represent the time histories
of the systems being modeled.  To accomplish this, we introduce new
data structures called <emphasis>streams</emphasis>.  From an abstract point of view,
a stream is simply a sequence.  However, we will find that the
straightforward implementation of streams as lists (as in
section 2.2.1) doesn't fully reveal
the power of stream processing.  As an alternative, we introduce the
technique of <emphasis>delayed evaluation</emphasis>, which enables us to represent
very large (even infinite) sequences as streams.</p>

<p>

Stream processing lets us model systems that have state without ever
using assignment or mutable data.  This has important implications,
both theoretical and practical, because we can build models that avoid
the drawbacks inherent in introducing assignment.  On the other hand,
the stream framework raises difficulties of its own, and the question
of which modeling technique leads to more modular and more easily
maintained systems remains open.</p>

<p><strong>3.5.1  Streams Are Delayed Lists</strong></p>

<p>



As we saw in section 2.2.3,
sequences can serve as standard interfaces for combining program
modules.  We formulated powerful abstractions for manipulating
sequences, such as map, filter, and accumulate, that
capture a wide variety of operations in a manner that is both succinct
and elegant.</p>

<p>

Unfortunately, if we represent sequences as lists, this elegance is
bought at the price of severe inefficiency with respect to both the
time and space required by our computations.
When we represent manipulations on sequences as transformations
of lists, our programs must construct and copy data structures (which
may be huge) at every step of a process.</p>

<p>

To see why this is true, let us compare two programs for computing the
sum of all the prime numbers in an interval.  The first program is
written in standard iterative style:<sup>53</sup></p>

<p>(define (sum-primes a b)</p><empty-line /><p>
  (define (iter count accum)</p><empty-line /><p>
    (cond ((&gt; count b) accum)</p><empty-line /><p>
          ((prime? count) (iter (+ count 1) (+ count accum)))</p><empty-line /><p>
          (else (iter (+ count 1) accum))))</p><empty-line /><p>
  (iter a 0))</p><empty-line /><p>
The second program performs the same computation using the sequence
operations of section 2.2.3:</p>

<p>(define (sum-primes a b)</p><empty-line /><p>
  (accumulate +</p><empty-line /><p>
              0</p><empty-line /><p>
              (filter prime? (enumerate-interval a b))))</p><empty-line /><empty-line /><p>

In carrying out the computation, the first program needs to store only
the sum being accumulated.  In contrast, the filter in the second
program cannot do any testing until enumerate-interval has
constructed a complete list of the numbers in the interval.  The
filter generates another list, which in turn is passed to accumulate before being collapsed to form a sum.  Such large
intermediate storage is not needed by the first program, which we can
think of as enumerating the interval incrementally, adding each prime
to the sum as it is generated.</p>

<p>


The inefficiency in using lists becomes painfully apparent if we use
the sequence paradigm to compute the second prime in the interval from
10,000 to 1,000,000 by evaluating the expression</p>

<p>(car (cdr (filter prime?</p><empty-line /><p>
                  (enumerate-interval 10000 1000000))))</p><empty-line /><p>
This expression does find the second prime, but the computational
overhead is outrageous.  We construct a list of almost a million
integers, filter this list by testing each element for primality, and
then ignore almost all of the result.  In a more traditional
programming style, we would interleave the enumeration and the
filtering, and stop when we reached the second prime.</p>

<p>


Streams are a clever idea that allows one to use sequence
manipulations without incurring the costs of manipulating sequences as
lists.  With streams we can achieve the best of both worlds: We can
formulate programs elegantly as sequence manipulations, while attaining the
efficiency of incremental computation.  The basic idea is to arrange
to construct a stream only partially, and to pass the partial
construction to the program that consumes the stream.  If the consumer
attempts to access a part of the stream that has not yet been
constructed, the stream will automatically construct just enough more
of itself to produce the required part, thus preserving the illusion
that the entire stream exists.  In other words, although we will write
programs as if we were processing complete sequences, we design our
stream implementation to automatically and transparently interleave
the construction of the stream with its use.</p>

<p>

On the surface, streams are just lists with different names for the
procedures that manipulate them.  There is a constructor,
cons-stream, and two selectors, stream-car and stream-cdr, which satisfy the constraints</p>

<p><image xlink:href="#_166.jpg" /></p>

<p>
There is a distinguishable object, the-empty-stream, which
cannot be the result of any cons-stream operation, and which can
be identified with the predicate stream-null?.<sup>54</sup>
Thus we can make and use streams, in just the same way as we can make
and use lists, to represent aggregate data arranged in a sequence.  In
particular, we can build stream analogs of the list operations from
chapter 2, such as list-ref, map, and for-each:<sup>55</sup></p>

<p>(define (stream-ref s n)</p><empty-line /><p>
  (if (= n 0)</p><empty-line /><p>
      (stream-car s)</p><empty-line /><p>
      (stream-ref (stream-cdr s) (- n 1))))</p><empty-line /><p>(define (stream-map proc s)</p><empty-line /><p>
  (if (stream-null? s)</p><empty-line /><p>
      the-empty-stream</p><empty-line /><p>
      (cons-stream (proc (stream-car s))</p><empty-line /><p>
                   (stream-map proc (stream-cdr s)))))</p><empty-line /><p>(define (stream-for-each proc s)</p><empty-line /><p>
  (if (stream-null? s)</p><empty-line /><p>
      'done</p><empty-line /><p>
      (begin (proc (stream-car s))</p><empty-line /><p>
             (stream-for-each proc (stream-cdr s)))))</p><empty-line /><p>
Stream-for-each is useful for viewing streams:</p>

<p>(define (display-stream s)</p><empty-line /><p>
  (stream-for-each display-line s))</p><empty-line /><empty-line /><p>(define (display-line x)</p><empty-line /><p>
  (newline)</p><empty-line /><p>
  (display x))</p><empty-line /><empty-line /><p>

To make the stream implementation automatically and transparently
interleave the construction of a stream with its use, we will arrange
for the cdr of a stream to be evaluated when it is accessed by
the stream-cdr procedure rather than when the stream is
constructed by cons-stream.  This implementation choice is
reminiscent of our discussion of rational numbers in
section 2.1.2, where we saw that we can
choose to implement rational numbers so that the reduction of
numerator and denominator to lowest terms is performed either at
construction time or at selection time.  The two rational-number
implementations produce the same data abstraction, but the choice has
an effect on efficiency.  There is a similar relationship between
streams and ordinary lists.  As a data abstraction, streams are the
same as lists.  The difference is the time at which the elements are
evaluated.  With ordinary lists, both the car and the cdr
are evaluated at construction time.  With streams, the cdr is
evaluated at selection time.</p>

<p>

Our implementation of streams will be based on a special form called
delay.  Evaluating (delay &lt;<emphasis>exp</emphasis>&gt;) does not
evaluate the expression &lt;<emphasis>exp</emphasis>&gt;, but rather returns a so-called <emphasis>delayed object</emphasis>, which we can think of as a "promise" to evaluate
&lt;<emphasis>exp</emphasis>&gt; at some future time.  As a companion to delay, there is
a procedure called force that takes a delayed object as
argument and performs the evaluation -- in effect, forcing the
delay to fulfill its promise.  We will see below how delay
and force can be implemented, but first let us use these to
construct streams.</p>

<p>

Cons-stream is a special form defined so that</p>

<p>(cons-stream &lt;<emphasis>a</emphasis>&gt; &lt;<emphasis>b</emphasis>&gt;)</p><empty-line /><p>
is equivalent to</p>

<p>(cons &lt;<emphasis>a</emphasis>&gt; (delay &lt;<emphasis>b</emphasis>&gt;))</p><empty-line /><p>
What this means is that we will construct streams using pairs.  However,
rather than placing the value of the rest of the stream
into the cdr of the
pair we will put there a promise to compute the rest if it is ever
requested.  Stream-car and stream-cdr can now be defined as
procedures:</p>

<p>(define (stream-car stream) (car stream))</p><empty-line /><empty-line /><p>(define (stream-cdr stream) (force (cdr stream)))</p><empty-line /><p>
Stream-car selects the car of the pair; stream-cdr
selects the cdr of the pair and evaluates the delayed expression
found there to obtain the rest of the stream.<sup>56</sup></p>

<p><strong>The stream implementation in action</strong></p>

<p>

To see how this implementation behaves, let us analyze the
"outrageous" prime computation we saw above, reformulated in terms
of streams:</p>

<p>(stream-car</p><empty-line /><p>
 (stream-cdr</p><empty-line /><p>
  (stream-filter prime?</p><empty-line /><p>
                 (stream-enumerate-interval 10000 1000000))))</p><empty-line /><p>
We will see that it does indeed work efficiently.</p>

<p>


We begin by calling stream-enumerate-interval with
the arguments 10,000 and 1,000,000.  Stream-enumerate-interval
is the stream analog of enumerate-interval
(section 2.2.3):</p>

<p>(define (stream-enumerate-interval low high)</p><empty-line /><p>
  (if (&gt; low high)</p><empty-line /><p>
      the-empty-stream</p><empty-line /><p>
      (cons-stream</p><empty-line /><p>
       low</p><empty-line /><p>
       (stream-enumerate-interval (+ low 1) high))))</p><empty-line /><p>
and thus the result returned by stream-enumerate-interval,
formed by the cons-stream, is<sup>57</sup></p>

<p>(cons 10000</p><empty-line /><p>
      (delay (stream-enumerate-interval 10001 1000000)))</p><empty-line /><p>

That is, stream-enumerate-interval
returns a stream represented as a pair whose car
is 10,000 and whose cdr is a promise to enumerate more of the
interval if so requested.  This stream is now filtered for primes,
using the stream analog of the filter procedure
(section 2.2.3):</p>

<p>(define (stream-filter pred stream)</p><empty-line /><p>
  (cond ((stream-null? stream) the-empty-stream)</p><empty-line /><p>
        ((pred (stream-car stream))</p><empty-line /><p>
         (cons-stream (stream-car stream)</p><empty-line /><p>
                      (stream-filter pred</p><empty-line /><p>
                                     (stream-cdr stream))))</p><empty-line /><p>
        (else (stream-filter pred (stream-cdr stream)))))</p><empty-line /><p>
Stream-filter tests the stream-car of the stream (the car of the pair, which is 10,000).  Since this is not prime,
stream-filter examines the stream-cdr of its input
stream.  The call to stream-cdr forces evaluation of the delayed
stream-enumerate-interval, which now returns</p>

<p>(cons 10001</p><empty-line /><p>
      (delay (stream-enumerate-interval 10002 1000000)))</p><empty-line /><p>
Stream-filter now looks at the stream-car of this stream,
10,001, sees that this is not prime either, forces another stream-cdr, and so on, until stream-enumerate-interval yields
the prime 10,007, whereupon stream-filter, according to its
definition, returns</p>

<p>(cons-stream (stream-car stream)</p><empty-line /><p>
             (stream-filter pred (stream-cdr stream)))</p><empty-line /><p>
which in this case is</p>

<p>(cons 10007</p><empty-line /><p>
      (delay</p><empty-line /><p>
        (stream-filter</p><empty-line /><p>
         prime?</p><empty-line /><p>
         (cons 10008</p><empty-line /><p>
               (delay</p><empty-line /><p>
                 (stream-enumerate-interval 10009</p><empty-line /><p>
                                            1000000))))))</p><empty-line /><p>
This result is now passed to stream-cdr in our
original expression.  This forces the delayed stream-filter, which in turn keeps forcing the delayed stream-enumerate-interval until it finds the next prime, which is
10,009.  Finally, the result passed to stream-car in our
original expression is</p>

<p>(cons 10009</p><empty-line /><p>
      (delay</p><empty-line /><p>
        (stream-filter</p><empty-line /><p>
         prime?</p><empty-line /><p>
         (cons 10010</p><empty-line /><p>
               (delay</p><empty-line /><p>
                 (stream-enumerate-interval 10011</p><empty-line /><p>
                                            1000000))))))</p><empty-line /><p>
Stream-car returns 10,009, and the computation is complete.  Only as
many integers were tested for primality as were necessary to find the
second prime, and the interval was enumerated only as far as was
necessary to feed the prime filter.</p>

<p>

In general, we can think of delayed evaluation as "demand-driven"
programming, whereby each stage in the stream process is activated
only enough to satisfy the next stage.  What we have done is to
decouple the actual order of events in the computation from the
apparent structure of our procedures.  We write procedures as if the
streams existed "all at once" when, in reality, the computation is
performed incrementally, as in traditional programming styles.</p>

<p><strong>Implementing delay and force</strong></p>

<p>

Although delay and force may seem like mysterious
operations, their implementation is really quite straightforward.
Delay must package an expression so that it can be evaluated
later on demand, and we can accomplish this simply by treating the
expression as the body of a procedure.  Delay can be a special
form such that</p>

<p>(delay &lt;<emphasis>exp</emphasis>&gt;)</p><empty-line /><p>
is syntactic sugar for</p>

<p>(lambda () &lt;<emphasis>exp</emphasis>&gt;)</p><empty-line /><p>
Force simply calls the procedure (of no
arguments) produced by delay, so we can implement force as
a procedure:</p>

<p>(define (force delayed-object)</p><empty-line /><p>
  (delayed-object))</p><empty-line /><empty-line /><p>

This implementation suffices for delay and force to work
as advertised, but there is an important optimization that we can
include.  In many applications, we end up forcing the same delayed object
many times.  This can lead to serious inefficiency in recursive
programs involving streams.  (See
exercise 3.57.)  The solution is to build
delayed objects so that the first time they are forced, they store the
value that is computed.  Subsequent forcings will simply return the
stored value without repeating the computation.  In other words, we
implement delay as a special-purpose memoized procedure similar
to the one described in exercise 3.27.  One way to
accomplish this is to use the following procedure, which takes as
argument a procedure (of no arguments) and returns a memoized version
of the procedure.  The first time the memoized procedure is run, it
saves the computed result.  On subsequent evaluations, it simply
returns the result.</p>

<p>(define (memo-proc proc)</p><empty-line /><p>
  (let ((already-run? false) (result false))</p><empty-line /><p>
    (lambda ()</p><empty-line /><p>
      (if (not already-run?)</p><empty-line /><p>
          (begin (set! result (proc))</p><empty-line /><p>
                 (set! already-run? true)</p><empty-line /><p>
                 result)</p><empty-line /><p>
          result))))</p><empty-line /><p>
Delay is then defined so that (delay &lt;<emphasis>exp</emphasis>&gt;) is
equivalent to</p>

<p>(memo-proc (lambda () &lt;<emphasis>exp</emphasis>&gt;))</p><empty-line /><p>
and force is as defined previously.<sup>58</sup></p>

<p>
<strong>Exercise 3.50.</strong>  Complete the following definition, which
generalizes stream-map to allow procedures that
take multiple arguments, analogous to map in
section 2.2.3, footnote 12.</p>

<p>(define (stream-map proc . argstreams)</p><empty-line /><p>
  (if (&lt;<emphasis>??</emphasis>&gt; (car argstreams))</p><empty-line /><p>
      the-empty-stream</p><empty-line /><p>
      (&lt;<emphasis>??</emphasis>&gt;</p><empty-line /><p>
       (apply proc (map &lt;<emphasis>??</emphasis>&gt; argstreams))</p><empty-line /><p>
       (apply stream-map</p><empty-line /><p>
              (cons proc (map &lt;<emphasis>??</emphasis>&gt; argstreams))))))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.51.</strong>  In order to take a closer look at delayed evaluation, we will use the
following procedure, which simply returns its argument after printing it:</p>

<p>(define (show x)</p><empty-line /><p>
  (display-line x)</p><empty-line /><p>
  x)</p><empty-line /><p>
What does the interpreter print in response to evaluating each
expression in the following sequence?<sup>59</sup></p>

<p>(define x (stream-map show (stream-enumerate-interval 0 10)))</p><empty-line /><p>
(stream-ref x 5)</p><empty-line /><p>
(stream-ref x 7)</p><empty-line /><empty-line /><p>
<strong>Exercise 3.52.</strong>  Consider the sequence of expressions</p>

<p>(define sum 0)</p><empty-line /><p>
(define (accum x)</p><empty-line /><p>
  (set! sum (+ x sum))</p><empty-line /><p>
  sum)</p><empty-line /><p>
(define seq (stream-map accum (stream-enumerate-interval 1 20)))</p><empty-line /><p>
(define y (stream-filter even? seq))</p><empty-line /><p>
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))</p><empty-line /><p>
                         seq))</p><empty-line /><p>
(stream-ref y 7)</p><empty-line /><p>
(display-stream z)</p><empty-line /><p>
What is the value of sum after each of the above expressions is
evaluated?  What is the printed response to evaluating the stream-ref and display-stream expressions?  Would these responses
differ if we had implemented (delay &lt;<emphasis>exp</emphasis>&gt;) simply as
(lambda () &lt;<emphasis>exp</emphasis>&gt;) without using the optimization provided by
memo-proc ?  Explain.</p>

<p><strong>3.5.2  Infinite Streams</strong></p>

<p>



We have seen how to support the illusion of manipulating streams
as complete entities even though, in actuality, we compute only
as much of the stream as we need to access.  We can exploit this
technique to represent sequences efficiently as streams, even if the
sequences are very long.  What is more striking, we can use streams to
represent sequences that are infinitely long.  For instance, consider
the following definition of the stream of positive integers:</p>

<p>(define (integers-starting-from n)</p><empty-line /><p>
  (cons-stream n (integers-starting-from (+ n 1))))</p><empty-line /><empty-line /><p>(define integers (integers-starting-from 1))</p><empty-line /><p>
This makes sense because integers will be a pair whose car
is 1 and whose cdr is a promise to produce the integers
beginning with 2.  This is an infinitely long stream, but in any given
time we can examine only a finite portion of it.  Thus, our programs
will never know that the entire infinite stream is not there.</p>

<p>

Using integers we can define other infinite streams, such as
the stream of integers that are not divisible by 7:</p>

<p>(define (divisible? x y) (= (remainder x y) 0))</p><empty-line /><p>
(define no-sevens</p><empty-line /><p>
  (stream-filter (lambda (x) (not (divisible? x 7)))</p><empty-line /><p>
                 integers))</p><empty-line /><p>
Then we can find integers not divisible by 7 simply by accessing
elements of this stream:</p>

<p>(stream-ref no-sevens 100)</p><empty-line /><p><emphasis>117</emphasis></p><empty-line /><empty-line /><p>

In analogy with integers, we can define the infinite stream of
Fibonacci numbers:</p>

<p>(define (fibgen a b)</p><empty-line /><p>
  (cons-stream a (fibgen b (+ a b))))</p><empty-line /><p>(define fibs (fibgen 0 1))</p><empty-line /><p>
Fibs is a pair whose car is 0 and whose cdr is a
promise to evaluate (fibgen 1 1).  When we evaluate this delayed
(fibgen 1 1), it
will produce a pair whose car is 1 and whose cdr is a
promise to evaluate (fibgen 1 2), and so on.</p>

<p>

For a look at a more exciting infinite stream, we can generalize the
no-sevens example to construct the infinite stream of prime
numbers, using a method known as the <emphasis>sieve of
Eratosthenes</emphasis>.<sup>60</sup> We
start with the integers beginning with 2, which is the first prime.
To get the rest of the primes, we start by filtering the multiples of
2 from the rest of the integers.  This leaves a stream beginning with
3, which is the next prime.  Now we filter the multiples of 3 from the
rest of this stream.  This leaves a stream beginning with 5, which is
the next prime, and so on.  In other words, we construct the primes by
a sieving process, described as follows: To sieve a stream S,
form a stream whose first element is the first element of S and
the rest of which is obtained by filtering all multiples of the first element
of S out of the rest of S and sieving the result. This
process is readily described in terms of stream operations:</p>

<p>(define (sieve stream)</p><empty-line /><p>
  (cons-stream</p><empty-line /><p>
   (stream-car stream)</p><empty-line /><p>
   (sieve (stream-filter</p><empty-line /><p>
           (lambda (x)</p><empty-line /><p>
             (not (divisible? x (stream-car stream))))</p><empty-line /><p>
           (stream-cdr stream)))))</p><empty-line /><empty-line /><p>(define primes (sieve (integers-starting-from 2)))</p><empty-line /><p>
Now to find a particular prime we need only ask for it:</p>

<p>(stream-ref primes 50)</p><empty-line /><p><emphasis>233</emphasis></p><empty-line /><empty-line /><p>

It is interesting to contemplate the signal-processing system set up
by sieve, shown in the "Henderson diagram" in
figure 3.31.<sup>61</sup>
The input stream feeds into an
"unconser" that separates the first element of the stream from the
rest of the stream.
The first element is used to construct a divisibility filter, through
which the rest is passed, and the output of the filter is fed to
another sieve box.  Then the original first element is consed onto the
output of the internal sieve to form the output stream.  Thus, not
only is the stream infinite, but the signal processor is also
infinite, because the sieve contains a sieve within it.</p>

<p><image xlink:href="#_167.jpg" /></p>

<p><strong>Figure 3.31:</strong>  The prime sieve viewed as a signal-processing system.</p>

<p><strong>Defining streams implicitly</strong></p>

<p>


The integers and fibs streams above were defined by
specifying "generating" procedures that explicitly compute the
stream elements one by one. An alternative way to specify streams is
to take advantage of delayed evaluation to define streams implicitly.
For example, the following expression defines the stream ones to
be an infinite stream of ones:</p>

<p>(define ones (cons-stream 1 ones))</p><empty-line /><p>
This works much like the definition of a recursive procedure: ones is a pair whose car is 1 and whose cdr is a promise
to evaluate ones.  Evaluating the cdr gives us again a 1
and a promise to evaluate ones, and so on.</p>

<p>

We can do more interesting things by manipulating streams with
operations such as add-streams, which produces the elementwise
sum of two given streams:<sup>62</sup></p>

<p>(define (add-streams s1 s2)</p><empty-line /><p>
  (stream-map + s1 s2))</p><empty-line /><p>
Now we can define the integers as follows:</p>

<p>(define integers (cons-stream 1 (add-streams ones integers)))</p><empty-line /><p>
This defines integers to be a stream whose first element is 1
and the rest of which is the sum of ones and integers.  Thus, the
second element of integers is 1 plus the first element of integers,
or 2; the third element of integers is 1 plus the second
element of integers, or 3; and so on.  This definition works
because, at any point, enough of the integers stream has been
generated so that we can feed it back into the definition to produce
the next integer.</p>

<p>

We can define the Fibonacci numbers in the same style:</p>

<p>(define fibs</p><empty-line /><p>
  (cons-stream 0</p><empty-line /><p>
               (cons-stream 1</p><empty-line /><p>
                            (add-streams (stream-cdr fibs)</p><empty-line /><p>
                                         fibs))))</p><empty-line /><p>
This definition says that fibs is a stream beginning with 0 and
1, such that the rest of the stream can be generated by adding fibs
to itself shifted by one place:</p>

<p>1</p>

<p>1</p>

<p>2</p>

<p>3</p>

<p>5</p>

<p>8</p>

<p>13</p>

<p>21</p>

<p>...</p>

<p> =</p>

<p>(stream-cdr fibs)</p>

<p>0</p>

<p>1</p>

<p>1</p>

<p>2</p>

<p>3</p>

<p>5</p>

<p> 8</p>

<p>13</p>

<p>...</p>

<p> =</p>

<p>fibs</p>

<p>0</p>

<p>1</p>

<p>1</p>

<p>2</p>

<p>3</p>

<p>5</p>

<p>8</p>

<p>13</p>

<p>21</p>

<p>34</p>

<p>...</p>

<p> =</p>

<p>fibs</p>

<p>

Scale-stream is another useful procedure in formulating such stream definitions.
This multiplies each item in a stream by a given
constant:</p>

<p>(define (scale-stream stream factor)</p><empty-line /><p>
  (stream-map (lambda (x) (* x factor)) stream))</p><empty-line /><p>
For example,</p>

<p>(define double (cons-stream 1 (scale-stream double 2)))</p><empty-line /><p>
produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, ....</p>

<p>

An alternate definition of the stream of primes can be given by
starting with the integers and filtering them by testing for
primality.  We will need the first prime, 2, to get started:</p>

<p>(define primes</p><empty-line /><p>
  (cons-stream</p><empty-line /><p>
   2</p><empty-line /><p>
   (stream-filter prime? (integers-starting-from 3))))</p><empty-line /><p>
This definition is not so straightforward as it appears, because we
will test whether a number <emphasis>n</emphasis> is prime by checking whether <emphasis>n</emphasis> is
divisible by a prime (not by just any integer) less than or equal to
<image xlink:href="#_19.jpg" /><emphasis>n</emphasis>:</p>

<p>(define (prime? n)</p><empty-line /><p>
  (define (iter ps)</p><empty-line /><p>
    (cond ((&gt; (square (stream-car ps)) n) true)</p><empty-line /><p>
          ((divisible? n (stream-car ps)) false)</p><empty-line /><p>
          (else (iter (stream-cdr ps)))))</p><empty-line /><p>
  (iter primes))</p><empty-line /><p>
This is a recursive definition, since primes is defined in terms
of the prime? predicate, which itself uses the primes
stream.  The reason this procedure works is that, at any point, enough
of the primes stream has been generated to test the primality of
the numbers we need to check next.  That is, for every <emphasis>n</emphasis> we test for
primality, either <emphasis>n</emphasis> is not prime (in which case there is a prime
already generated that divides it) or <emphasis>n</emphasis> is prime (in which case
there is a prime already generated -- i.e., a prime less than
<emphasis>n</emphasis> -- that is greater than <image xlink:href="#_19.jpg" /><emphasis>n</emphasis>).<sup>63</sup></p>

<p>
<strong>Exercise 3.53.</strong>  Without running the program, describe the elements of the
stream defined by</p>

<p>(define s (cons-stream 1 (add-streams s s)))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.54.</strong>  Define a procedure mul-streams, analogous to add-streams,
that produces the elementwise product of its two input streams.
Use this together with the stream of integers to complete the
following definition of the stream whose <emphasis>n</emphasis>th element (counting from 0)
is <emphasis>n</emphasis> + 1 factorial:</p>

<p>(define factorials (cons-stream 1 (mul-streams &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt;)))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.55.</strong>  Define a procedure partial-sums that takes as argument a
stream <emphasis>S</emphasis> and returns the stream whose
elements are <emphasis>S</emphasis><sub>0</sub>, <emphasis>S</emphasis><sub>0</sub> + <emphasis>S</emphasis><sub>1</sub>, <emphasis>S</emphasis><sub>0</sub> + <emphasis>S</emphasis><sub>1</sub> + <emphasis>S</emphasis><sub>2</sub>, ....  For example, (partial-sums integers) should be the stream
1, 3, 6, 10, 15, ....</p>

<p>
<strong>Exercise 3.56.</strong>  A famous problem, first raised by R. Hamming, is to enumerate, in
ascending order with no repetitions, all positive integers with no
prime factors other than 2, 3, or 5.  One obvious way to do this is to
simply test each integer in turn to see whether it has any factors
other than 2, 3, and 5.  But this is very inefficient, since, as the
integers get larger, fewer and fewer of them fit the requirement.  As
an alternative, let us call the required stream of numbers S and
notice the following facts about it.</p>

<p>S begins with 1.</p>

<p>The elements of (scale-stream S 2) are also 
elements of S.</p>

<p>The same is true for (scale-stream S 3) 
and (scale-stream 5 S).</p>

<p>These are all the elements of S.</p>

<p>

Now all we have to do is combine elements from these sources.
For this we define a procedure merge that combines two ordered
streams into one ordered result stream, eliminating repetitions:</p>

<p>(define (merge s1 s2)</p><empty-line /><p>
  (cond ((stream-null? s1) s2)</p><empty-line /><p>
        ((stream-null? s2) s1)</p><empty-line /><p>
        (else</p><empty-line /><p>
         (let ((s1car (stream-car s1))</p><empty-line /><p>
               (s2car (stream-car s2)))</p><empty-line /><p>
           (cond ((&lt; s1car s2car)</p><empty-line /><p>
                  (cons-stream s1car (merge (stream-cdr s1) s2)))</p><empty-line /><p>
                 ((&gt; s1car s2car)</p><empty-line /><p>
                  (cons-stream s2car (merge s1 (stream-cdr s2))))</p><empty-line /><p>
                 (else</p><empty-line /><p>
                  (cons-stream s1car</p><empty-line /><p>
                               (merge (stream-cdr s1)</p><empty-line /><p>
                                      (stream-cdr s2)))))))))</p><empty-line /><p>
Then the required stream may be constructed with merge, as
follows:</p>

<p>(define S (cons-stream 1 (merge &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt;)))</p><empty-line /><p>
Fill in the missing expressions in the places marked &lt;<emphasis>??</emphasis>&gt; above.</p>

<p>
<strong>Exercise 3.57.</strong>  How many additions are performed when we compute the <emphasis>n</emphasis>th Fibonacci
number using the definition of fibs based on the add-streams procedure?  Show that the number of additions would be
exponentially greater if we had implemented
(delay &lt;<emphasis>exp</emphasis>&gt;) simply as (lambda () &lt;<emphasis>exp</emphasis>&gt;), 
without using the optimization provided by the memo-proc
procedure described in section 3.5.1.<sup>64</sup></p>

<p>
<strong>Exercise 3.58.</strong>  Give an interpretation of the stream computed by the following
procedure:</p>

<p>(define (expand num den radix)</p><empty-line /><p>
  (cons-stream</p><empty-line /><p>
   (quotient (* num radix) den)</p><empty-line /><p>
   (expand (remainder (* num radix) den) den radix)))</p><empty-line /><p>
(Quotient is a primitive that returns the integer quotient of
two integers.)  What are the successive elements produced by (expand 1 7 10) ?  What is produced by (expand 3 8 10) ?</p>

<p>
<strong>Exercise 3.59.</strong>  In section 2.5.3 we saw how to implement a
polynomial arithmetic system representing polynomials as lists of
terms.  In a similar way, we can work with <emphasis>power series</emphasis>, such as</p>

<p><image xlink:href="#_168.jpg" /></p><empty-line /><p><image xlink:href="#_169.jpg" /></p><empty-line /><p><image xlink:href="#_170.jpg" /></p>

<p>

represented as infinite streams.
We will represent the series
<emphasis>a</emphasis><sub>0</sub>  +  <emphasis>a</emphasis><sub>1</sub><emphasis>x</emphasis>  +  <emphasis>a</emphasis><sub>2</sub><emphasis>x</emphasis><sup>2</sup>  +  <emphasis>a</emphasis><sub>3</sub><emphasis>x</emphasis><sup>3</sup>  +  ···
as the stream whose elements are the coefficients <emphasis>a</emphasis><sub>0</sub>, <emphasis>a</emphasis><sub>1</sub>, <emphasis>a</emphasis><sub>2</sub>, <emphasis>a</emphasis><sub>3</sub>, ....</p>

<p>a. The integral of the series <emphasis>a</emphasis><sub>0</sub>  +  <emphasis>a</emphasis><sub>1</sub><emphasis>x</emphasis>  +  <emphasis>a</emphasis><sub>2</sub><emphasis>x</emphasis><sup>2</sup>  +  <emphasis>a</emphasis><sub>3</sub><emphasis>x</emphasis><sup>3</sup>  +  ···
is the series</p>

<p><image xlink:href="#_171.jpg" /></p>

<p>
where <emphasis>c</emphasis> is any constant.
Define a procedure integrate-series that takes as input a stream
<emphasis>a</emphasis><sub>0</sub>, <emphasis>a</emphasis><sub>1</sub>, <emphasis>a</emphasis><sub>2</sub>, ... representing a power series and returns the stream
<emphasis>a</emphasis><sub>0</sub>, (1/2)<emphasis>a</emphasis><sub>1</sub>, (1/3)<emphasis>a</emphasis><sub>2</sub>, ... of coefficients of
the non-constant terms of the integral of the series.
(Since the result has no constant term, it doesn't represent a power
series; when we use integrate-series, we will cons on
the appropriate constant.)</p>

<p>b. The function <emphasis>x</emphasis> <image xlink:href="#_45.jpg" /><emphasis>e</emphasis><sup><emphasis>x</emphasis></sup> is its own
derivative.  This implies that <emphasis>e</emphasis><sup><emphasis>x</emphasis></sup> and the integral of <emphasis>e</emphasis><sup><emphasis>x</emphasis></sup> are the
same series, except for the constant term, which is <emphasis>e</emphasis><sup>0</sup>  = 1.
Accordingly, we can generate the series for 
<emphasis>e</emphasis><sup><emphasis>x</emphasis></sup> as</p>

<p>(define exp-series</p><empty-line /><p>
  (cons-stream 1 (integrate-series exp-series)))</p><empty-line /><p>
Show how to generate the series for sine and cosine, starting from the facts
that the derivative of sine is cosine and the derivative of cosine is
the negative of sine:</p>

<p>(define cosine-series</p><empty-line /><p>
  (cons-stream 1 &lt;<emphasis>??</emphasis>&gt;))</p><empty-line /><p>
(define sine-series</p><empty-line /><p>
  (cons-stream 0 &lt;<emphasis>??</emphasis>&gt;))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.60.</strong>  With power series represented as streams of coefficients as in
exercise 3.59, adding series is implemented by add-streams.  Complete the definition of the following procedure for
multiplying series:</p>

<p>(define (mul-series s1 s2)</p><empty-line /><p>
  (cons-stream &lt;<emphasis>??</emphasis>&gt; (add-streams &lt;<emphasis>??</emphasis>&gt; &lt;<emphasis>??</emphasis>&gt;)))</p><empty-line /><p>
You can test your procedure by verifying that
<emphasis>s</emphasis><emphasis>i</emphasis><emphasis>n</emphasis><sup>2</sup><emphasis>x</emphasis>  +  <emphasis>c</emphasis><emphasis>o</emphasis><emphasis>s</emphasis><sup>2</sup><emphasis>x</emphasis>  =  1, using the series from exercise 3.59.</p>

<p>
<strong>Exercise 3.61.</strong>  Let <emphasis>S</emphasis> be a power series (exercise 3.59)
whose constant term is 1.  Suppose we want
to find the power series 1/<emphasis>S</emphasis>, that is, the series <emphasis>X</emphasis> such that
<emphasis>S</emphasis> ·  <emphasis>X</emphasis> =  1.  Write <emphasis>S</emphasis> = 1 + <emphasis>S</emphasis><sub><emphasis>R</emphasis></sub> where <emphasis>S</emphasis><sub><emphasis>R</emphasis></sub> is the part of <emphasis>S</emphasis> after
the constant term.  Then we can solve for <emphasis>X</emphasis> as follows:</p>

<p><image xlink:href="#_172.jpg" /></p>

<p>
In other words, <emphasis>X</emphasis> is the power series whose constant term is 1 and
whose higher-order terms are given by the negative of <emphasis>S</emphasis><sub><emphasis>R</emphasis></sub> times <emphasis>X</emphasis>.
Use this idea to write a procedure invert-unit-series that computes 1/<emphasis>S</emphasis> for a power series <emphasis>S</emphasis> with
constant term 1.
You will need to use mul-series from exercise 3.60.</p>

<p>
<strong>Exercise 3.62.</strong>  Use the results of exercises 3.60
and 3.61 to define a procedure div-series
that divides two power series.  Div-series should work for any
two series, provided that the denominator series begins with a
nonzero constant term.  (If the denominator has a zero constant term,
then div-series should signal an error.)
Show how to use div-series
together with the result of exercise 3.59 to generate
the power series for tangent.</p>

<p><strong>3.5.3  Exploiting the Stream Paradigm</strong></p>

<p>

Streams with delayed evaluation can be a powerful modeling tool,
providing many of the benefits of local state and assignment.
Moreover, they avoid some of the theoretical tangles that accompany
the introduction of assignment into a programming language.</p>

<p>

The stream approach can be illuminating because it allows us to build
systems with different module boundaries than systems organized around
assignment to state variables.  For example, we can think of an entire
time series (or signal) as a focus of interest, rather than the values
of the state variables at individual moments.  This makes it
convenient to combine and compare components of state from different
moments.</p>

<p><strong>Formulating iterations as stream processes</strong></p>

<p>


In section 1.2.1, we introduced iterative
processes, which proceed by updating state variables.  We know now
that we can represent state as a "timeless" stream of values rather
than as a set of variables to be updated.  Let's adopt this
perspective in revisiting the square-root procedure from
section 1.1.7.  Recall that the idea is to generate a
sequence of better and better guesses for the square root of <emphasis>x</emphasis> by
applying over and over again the procedure that improves guesses:</p>

<p>(define (sqrt-improve guess x)</p><empty-line /><p>
  (average guess (/ x guess)))</p><empty-line /><empty-line /><p>

In our original sqrt procedure, we made these guesses be the
successive values of a state variable. Instead we can generate the
infinite stream of guesses, starting with an initial guess of 1:<sup>65</sup></p>

<p>(define (sqrt-stream x)</p><empty-line /><p>
  (define guesses</p><empty-line /><p>
    (cons-stream 1.0</p><empty-line /><p>
                 (stream-map (lambda (guess)</p><empty-line /><p>
                               (sqrt-improve guess x))</p><empty-line /><p>
                             guesses)))</p><empty-line /><p>
  guesses)</p><empty-line /><p>
(display-stream (sqrt-stream 2))</p><empty-line /><p><emphasis>1.</emphasis></p><empty-line /><p><emphasis>1.5</emphasis></p><empty-line /><p><emphasis>1.4166666666666665</emphasis></p><empty-line /><p><emphasis>1.4142156862745097</emphasis></p><empty-line /><p><emphasis>1.4142135623746899</emphasis></p><empty-line /><p>...</p>

<p>
We can generate more and more terms of the stream to get better and
better guesses.  If we like, we can write a procedure that keeps
generating terms until the answer is good enough.  (See
exercise 3.64.)</p>

<p>

Another iteration that we can treat in the same way is to generate an
approximation to <image xlink:href="#_37.jpg" />, based upon the alternating series that we saw
in section 1.3.1:</p>

<p><image xlink:href="#_173.jpg" /></p>

<p>


We first generate the stream of summands of the series (the reciprocals
of the odd integers, with alternating signs).  Then we take the stream
of sums of more and more terms (using the partial-sums procedure
of exercise 3.55) and scale the result by 4:</p>

<p>(define (pi-summands n)</p><empty-line /><p>
  (cons-stream (/ 1.0 n)</p><empty-line /><p>
               (stream-map - (pi-summands (+ n 2)))))</p><empty-line /><p>(define pi-stream</p><empty-line /><p>
  (scale-stream (partial-sums (pi-summands 1)) 4))</p><empty-line /><p>
(display-stream pi-stream)</p><empty-line /><p><emphasis>4.</emphasis></p><empty-line /><p><emphasis>2.666666666666667</emphasis></p><empty-line /><p><emphasis>3.466666666666667</emphasis></p><empty-line /><p><emphasis>2.8952380952380956</emphasis></p><empty-line /><p><emphasis>3.3396825396825403</emphasis></p><empty-line /><p><emphasis>2.9760461760461765</emphasis></p><empty-line /><p><emphasis>3.2837384837384844</emphasis></p><empty-line /><p><emphasis>3.017071817071818</emphasis></p><empty-line /><p>...</p>

<p>
This gives us a stream of better and better approximations to <image xlink:href="#_37.jpg" />,
although the approximations converge rather slowly.  Eight terms of
the sequence bound the value of <image xlink:href="#_37.jpg" /> between 3.284 and 3.017.</p>

<p>

So far, our use of the stream of states approach is not much different
from updating state variables.  But streams give us an opportunity to
do some interesting tricks.  For example, we can transform a stream
with a <emphasis>sequence accelerator</emphasis> that converts a sequence of
approximations to a new sequence that converges to the same value as
the original, only faster.</p>

<p>

One such accelerator, due to the eighteenth-century Swiss mathematician
Leonhard Euler, works well with sequences that are partial sums of
alternating series (series of terms with alternating signs).
In Euler's technique, if <emphasis>S</emphasis><sub><emphasis>n</emphasis></sub> is the <emphasis>n</emphasis>th term
of the original sum sequence, then the accelerated sequence has terms</p>

<p><image xlink:href="#_174.jpg" /></p>

<p> 
Thus, if the original sequence is represented as a stream of values,
the transformed sequence is given by</p>

<p>(define (euler-transform s)</p><empty-line /><p>
  (let ((s0 (stream-ref s 0))           <emphasis>; S<sub>n-1</sub></emphasis></p><empty-line /><p>
        (s1 (stream-ref s 1))           <emphasis>; S<sub>n</sub></emphasis></p><empty-line /><p>
        (s2 (stream-ref s 2)))          <emphasis>; S<sub>n+1</sub></emphasis></p><empty-line /><p>
    (cons-stream (- s2 (/ (square (- s2 s1))</p><empty-line /><p>
                          (+ s0 (* -2 s1) s2)))</p><empty-line /><p>
                 (euler-transform (stream-cdr s)))))</p><empty-line /><empty-line /><p>

We can demonstrate Euler acceleration with our sequence of
approximations to <image xlink:href="#_37.jpg" />:</p>

<p>(display-stream (euler-transform pi-stream))</p><empty-line /><p><emphasis>3.166666666666667</emphasis></p><empty-line /><p><emphasis>3.1333333333333337</emphasis></p><empty-line /><p><emphasis>3.1452380952380956</emphasis></p><empty-line /><p><emphasis>3.13968253968254</emphasis></p><empty-line /><p><emphasis>3.1427128427128435</emphasis></p><empty-line /><p><emphasis>3.1408813408813416</emphasis></p><empty-line /><p><emphasis>3.142071817071818</emphasis></p><empty-line /><p><emphasis>3.1412548236077655</emphasis></p><empty-line /><p>...</p>

<p>

Even better, we can accelerate the accelerated sequence, and
recursively accelerate that, and so on.  Namely, we create a stream of
streams (a structure we'll call a <emphasis>tableau</emphasis>) in which each stream
is the transform of the preceding one:</p>

<p>(define (make-tableau transform s)</p><empty-line /><p>
  (cons-stream s</p><empty-line /><p>
               (make-tableau transform</p><empty-line /><p>
                             (transform s))))</p><empty-line /><p>
The tableau has the form</p>

<p><image xlink:href="#_175.jpg" /></p>

<p>
Finally, we form a sequence by taking the first term in each row of
the tableau:</p>

<p>(define (accelerated-sequence transform s)</p><empty-line /><p>
  (stream-map stream-car</p><empty-line /><p>
              (make-tableau transform s)))</p><empty-line /><empty-line /><p>

We can demonstrate this kind of "super-acceleration" of the <image xlink:href="#_37.jpg" />
sequence:</p>

<p>(display-stream (accelerated-sequence euler-transform</p><empty-line /><p>
                                      pi-stream))</p><empty-line /><p><emphasis>4.</emphasis></p><empty-line /><p><emphasis>3.166666666666667</emphasis></p><empty-line /><p><emphasis>3.142105263157895</emphasis></p><empty-line /><p><emphasis>3.141599357319005</emphasis></p><empty-line /><p><emphasis>3.1415927140337785</emphasis></p><empty-line /><p><emphasis>3.1415926539752927</emphasis></p><empty-line /><p><emphasis>3.1415926535911765</emphasis></p><empty-line /><p><emphasis>3.141592653589778</emphasis></p><empty-line /><p>...</p>

<p>
The result is impressive.  Taking eight terms of the sequence yields
the correct value of <image xlink:href="#_37.jpg" /> to 14 decimal places.  If we had used only
the original <image xlink:href="#_37.jpg" /> sequence, we would need to compute on the order of
10<sup>13</sup> terms (i.e., expanding the series far enough so that the
individual terms are less then 10<sup>-13</sup>) to get that much accuracy!

We could have implemented these acceleration techniques without
using streams.  But the stream formulation is particularly elegant and
convenient because the entire sequence of states is available to us as a
data structure that can be manipulated with a uniform set of
operations.</p>

<p>
<strong>Exercise 3.63.</strong>  Louis Reasoner asks why the sqrt-stream procedure was not
written in the following more straightforward way, without
the local variable guesses:</p>

<p>(define (sqrt-stream x)</p><empty-line /><p>
  (cons-stream 1.0</p><empty-line /><p>
               (stream-map (lambda (guess)</p><empty-line /><p>
                             (sqrt-improve guess x))</p><empty-line /><p>
                           (sqrt-stream x))))</p><empty-line /><p>
Alyssa P. Hacker replies that this version of the procedure is
considerably less efficient because it performs redundant computation.
Explain Alyssa's answer.  Would the two versions still differ in
efficiency if our implementation of delay used only (lambda
() &lt;<emphasis>exp</emphasis>&gt;) without using the optimization provided by memo-proc (section 3.5.1)?</p>

<p>
<strong>Exercise 3.64.</strong>  Write a procedure stream-limit that takes as arguments a stream
and a number (the tolerance).  It should examine the stream until it
finds two successive elements that differ in absolute value by less
than the tolerance, and return the second of the two elements.  Using
this, we could compute square roots up to a given tolerance by</p>

<p>(define (sqrt x tolerance)</p><empty-line /><p>
  (stream-limit (sqrt-stream x) tolerance))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.65.</strong>  Use the series</p>

<p><image xlink:href="#_176.jpg" /></p>

<p>
to compute three sequences of approximations to the natural logarithm of 2,
in the same way we did above for <image xlink:href="#_37.jpg" />.
How rapidly do these sequences converge?</p>

<p><strong>Infinite streams of pairs</strong></p>

<p>


In section 2.2.3, we saw how the sequence paradigm
handles traditional nested loops as processes defined on sequences of
pairs.  If we generalize this technique to infinite streams, then we
can write programs that are not easily represented as loops, because
the "looping" must range over an infinite set.</p>

<p>

For example, suppose we want to generalize the prime-sum-pairs
procedure of section 2.2.3 to produce the stream
of pairs of <emphasis>all</emphasis> integers (<emphasis>i</emphasis>,<emphasis>j</emphasis>) with <emphasis>i</emphasis> &lt; <emphasis>j</emphasis> such that <emphasis>i</emphasis> + <emphasis>j</emphasis>
is prime.  If int-pairs is the sequence of all pairs of integers (<emphasis>i</emphasis>,<emphasis>j</emphasis>)
with <emphasis>i</emphasis> &lt; <emphasis>j</emphasis>, then our required stream is simply<sup>66</sup></p>

<p>(stream-filter (lambda (pair)</p><empty-line /><p>
                 (prime? (+ (car pair) (cadr pair))))</p><empty-line /><p>
               int-pairs)</p><empty-line /><empty-line /><p>

Our problem, then, is to produce the stream int-pairs.  More
generally, suppose we have two streams <emphasis>S</emphasis>  =  (<emphasis>S</emphasis><sub><emphasis>i</emphasis></sub>) and <emphasis>T</emphasis>  =  (<emphasis>T</emphasis><sub><emphasis>j</emphasis></sub>),
and imagine the infinite rectangular array</p>

<p><image xlink:href="#_177.jpg" /></p>

<p>
We wish to generate a stream that contains all the pairs in the array
that lie on or above the diagonal, i.e., the pairs</p>

<p><image xlink:href="#_178.jpg" /></p>

<p>
(If we take both <emphasis>S</emphasis> and <emphasis>T</emphasis> to be the stream of integers, then this
will be our desired stream int-pairs.)</p>

<p>

Call the general stream of pairs (pairs S T), and consider it to
be composed of three parts: the pair (<emphasis>S</emphasis><sub>0</sub>,<emphasis>T</emphasis><sub>0</sub>), the
rest of the pairs in the first row, and the remaining pairs:<sup>67</sup></p>

<p><image xlink:href="#_179.jpg" /></p>

<p>
Observe that the third piece in this decomposition (pairs that are not in the
first row) is (recursively) the pairs formed from (stream-cdr S)
and (stream-cdr T).  Also note that the second piece (the rest
of the first row) is</p>

<p>(stream-map (lambda (x) (list (stream-car s) x))</p><empty-line /><p>
            (stream-cdr t))</p><empty-line /><p>
Thus we can form our stream of pairs as follows:</p>

<p>(define (pairs s t)</p><empty-line /><p>
  (cons-stream</p><empty-line /><p>
   (list (stream-car s) (stream-car t))</p><empty-line /><p>
   (&lt;<emphasis>combine-in-some-way</emphasis>&gt;</p><empty-line /><p>
       (stream-map (lambda (x) (list (stream-car s) x))</p><empty-line /><p>
                   (stream-cdr t))</p><empty-line /><p>
       (pairs (stream-cdr s) (stream-cdr t)))))</p><empty-line /><empty-line /><p>

In order to complete the procedure, we must choose some way to combine
the two inner streams.  One idea is to use the stream analog of the
append procedure from section 2.2.1:</p>

<p>(define (stream-append s1 s2)</p><empty-line /><p>
  (if (stream-null? s1)</p><empty-line /><p>
      s2</p><empty-line /><p>
      (cons-stream (stream-car s1)</p><empty-line /><p>
                   (stream-append (stream-cdr s1) s2))))</p><empty-line /><p>
This is unsuitable for infinite streams, however,
because it takes all the elements from the first stream before
incorporating the second stream.
In particular, if we try to generate all pairs of positive integers using</p>

<p>(pairs integers integers)</p><empty-line /><p>
our stream of results will first try to run through all pairs with the
first integer equal to 1, and hence will never produce pairs with any
other value of the first integer.</p>

<p>

To handle infinite streams, we need to devise an order of combination
that ensures that every element will eventually be reached if we let
our program run long enough.  An elegant way to accomplish this is
with the following interleave procedure:<sup>68</sup></p>

<p>(define (interleave s1 s2)</p><empty-line /><p>
  (if (stream-null? s1)</p><empty-line /><p>
      s2</p><empty-line /><p>
      (cons-stream (stream-car s1)</p><empty-line /><p>
                   (interleave s2 (stream-cdr s1)))))</p><empty-line /><p>
Since interleave takes elements alternately from the two streams,
every element of the second stream will eventually find its way into
the interleaved stream, even if the first stream is infinite.</p>

<p>

We can thus generate the required stream of pairs as</p>

<p>(define (pairs s t)</p><empty-line /><p>
  (cons-stream</p><empty-line /><p>
   (list (stream-car s) (stream-car t))</p><empty-line /><p>
   (interleave</p><empty-line /><p>
    (stream-map (lambda (x) (list (stream-car s) x))</p><empty-line /><p>
                (stream-cdr t))</p><empty-line /><p>
    (pairs (stream-cdr s) (stream-cdr t)))))</p><empty-line /><empty-line /><p>
<strong>Exercise 3.66.</strong>  Examine the stream (pairs integers integers). Can you make any general
comments about the order in which the pairs are placed into the
stream? For example, about how many pairs precede the pair (1,100)?
the pair (99,100)? the pair (100,100)? (If you can make precise
mathematical statements here, all the better. But feel free to give
more qualitative answers if you find yourself getting bogged down.)</p>

<p>
<strong>Exercise 3.67.</strong>  Modify the pairs procedure so that (pairs integers
integers) will produce the stream of <emphasis>all</emphasis> pairs of integers
(<emphasis>i</emphasis>,<emphasis>j</emphasis>) (without the condition <emphasis>i</emphasis> &lt; <emphasis>j</emphasis>).  Hint: You will need to
mix in an additional stream.</p>

<p>
<strong>Exercise 3.68.</strong>  Louis Reasoner thinks that building a stream of pairs from three
parts is unnecessarily complicated.  Instead of separating the
pair (<emphasis>S</emphasis><sub>0</sub>,<emphasis>T</emphasis><sub>0</sub>) from the rest of the pairs in the first row,
he proposes to work with the whole first row, as follows:</p>

<p>(define (pairs s t)</p><empty-line /><p>
  (interleave</p><empty-line /><p>
   (stream-map (lambda (x) (list (stream-car s) x))</p><empty-line /><p>
               t)</p><empty-line /><p>
   (pairs (stream-cdr s) (stream-cdr t))))</p><empty-line /><p>
Does this work?  Consider what happens if we evaluate
(pairs integers integers) using Louis's definition of pairs.</p>

<p>
<strong>Exercise 3.69.</strong>  Write a procedure triples that takes three infinite
streams, <emphasis>S</emphasis>, <emphasis>T</emphasis>, and <emphasis>U</emphasis>, and produces the stream of triples
(<emphasis>S</emphasis><sub><emphasis>i</emphasis></sub>,<emphasis>T</emphasis><sub><emphasis>j</emphasis></sub>,<emphasis>U</emphasis><sub><emphasis>k</emphasis></sub>) such that <emphasis>i</emphasis> &lt; <emphasis>j</emphasis> &lt; <emphasis>k</emphasis>.
Use triples to
generate the stream of all Pythagorean triples of positive integers,
i.e., the triples (<emphasis>i</emphasis>,<emphasis>j</emphasis>,<emphasis>k</emphasis>) such that <emphasis>i</emphasis> &lt; <emphasis>j</emphasis> and <emphasis>i</emphasis><sup>2</sup>  +  <emphasis>j</emphasis><sup>2</sup>  = <emphasis>k</emphasis><sup>2</sup>.</p>

<p>
<strong>Exercise 3.70.</strong>  It would be nice to be able to generate streams in which the pairs
appear in some useful order, rather than in the order that results
from an <emphasis>ad hoc</emphasis> interleaving process.  We can use a technique
similar to the merge procedure of exercise 3.56, if we
define a way to say that one pair of integers is "less than"
another.  One way to do this is to define a "weighting function"
<emphasis>W</emphasis>(<emphasis>i</emphasis>,<emphasis>j</emphasis>) and stipulate that (<emphasis>i</emphasis><sub>1</sub>,<emphasis>j</emphasis><sub>1</sub>) is less than (<emphasis>i</emphasis><sub>2</sub>,<emphasis>j</emphasis><sub>2</sub>) if
<emphasis>W</emphasis>(<emphasis>i</emphasis><sub>1</sub>,<emphasis>j</emphasis><sub>1</sub>) &lt; <emphasis>W</emphasis>(<emphasis>i</emphasis><sub>2</sub>,<emphasis>j</emphasis><sub>2</sub>).  Write a procedure merge-weighted
that is like merge, except that merge-weighted takes an
additional argument weight, which is a procedure that computes
the weight of a pair, and is used to determine the order in which
elements should appear in the resulting merged stream.<sup>69</sup>
Using this,
generalize pairs to a procedure weighted-pairs that
takes two streams, together with a procedure that computes a weighting
function, and generates the stream of pairs, ordered according to
weight.  Use your procedure to generate</p>

<p>a. the stream of all pairs of positive integers (<emphasis>i</emphasis>,<emphasis>j</emphasis>) with <emphasis>i</emphasis> &lt;
<emphasis>j</emphasis> ordered according to the sum <emphasis>i</emphasis>  +  <emphasis>j</emphasis></p>

<p>b.  the stream of all pairs of positive integers (<emphasis>i</emphasis>,<emphasis>j</emphasis>) with <emphasis>i</emphasis> &lt;
<emphasis>j</emphasis>, where neither <emphasis>i</emphasis> nor <emphasis>j</emphasis> is divisible by 2, 3, or 5, and the
pairs are ordered according to the sum 2 <emphasis>i</emphasis>  +  3 <emphasis>j</emphasis>  +  5 <emphasis>i</emphasis> <emphasis>j</emphasis>.</p>

<p>
<strong>Exercise 3.71.</strong>  Numbers that can be expressed as the sum of two cubes in more than one
way are sometimes called <emphasis>Ramanujan numbers</emphasis>, in honor of the
mathematician Srinivasa Ramanujan.<sup>70</sup>
Ordered streams of pairs provide an elegant solution to the problem of
computing these numbers.  To find a number that can be written as the
sum of two cubes in two different ways, we need only generate the
stream of pairs of integers (<emphasis>i</emphasis>,<emphasis>j</emphasis>) weighted according to the sum <emphasis>i</emphasis><sup>3</sup>
 +  <emphasis>j</emphasis><sup>3</sup> (see exercise 3.70),
then search the stream for two consecutive pairs with the same
weight.  Write a procedure to generate the Ramanujan numbers.  The first
such number is 1,729.  What are the next five?</p>

<p>
<strong>Exercise 3.72.</strong>  In a similar way to exercise 3.71 generate
a stream of
all numbers that can be written as the sum of two squares in three
different ways (showing how they can be so written).</p>

<p><strong>Streams as signals</strong></p>

<p>


We began our discussion of streams by describing them as computational
analogs of the "signals" in signal-processing systems.  In fact, we
can use streams to model signal-processing systems in a very direct
way, representing the values of a signal at successive time intervals
as consecutive elements of a stream.  For instance, we can implement
an <emphasis>integrator</emphasis> or <emphasis>summer</emphasis> that, for an input stream
<emphasis>x</emphasis> = (<emphasis>x</emphasis><sub><emphasis>i</emphasis></sub>), an initial value <emphasis>C</emphasis>, and a small increment <emphasis>d</emphasis><emphasis>t</emphasis>,
accumulates the sum</p>

<p><image xlink:href="#_180.jpg" /></p>

<p>
and returns the stream of values <emphasis>S</emphasis> = (<emphasis>S</emphasis><sub><emphasis>i</emphasis></sub>).  The following integral
procedure is reminiscent of the "implicit style" definition of the
stream of integers (section 3.5.2):</p>

<p>(define (integral integrand initial-value dt)</p><empty-line /><p>
  (define int</p><empty-line /><p>
    (cons-stream initial-value</p><empty-line /><p>
                 (add-streams (scale-stream integrand dt)</p><empty-line /><p>
                              int)))</p><empty-line /><p>
  int)</p><empty-line /><empty-line /><p><image xlink:href="#_181.jpg" /></p>

<p><strong>Figure 3.32:</strong>  The integral procedure viewed as a
signal-processing system.</p>

<p>

Figure 3.32 is a picture of a signal-processing system that
corresponds to the integral procedure.  The input stream is
scaled by <emphasis>d</emphasis><emphasis>t</emphasis> and passed through an adder, whose output is passed
back through the same adder.  The self-reference in the definition of
int is reflected in the figure by the feedback loop that
connects the output of the adder to one of the inputs.</p>

<p>
<strong>Exercise 3.73.</strong></p>

<p> <image xlink:href="#_182.jpg" />
      


<emphasis>v</emphasis>  =  <emphasis>v</emphasis><sub>0</sub>  +  (1/<emphasis>C</emphasis>)<image xlink:href="#_183.jpg" /><sub>0</sub><sup><emphasis>t</emphasis></sup><emphasis>i</emphasis> <emphasis>d</emphasis><emphasis>t</emphasis>  +  <emphasis>R</emphasis> <emphasis>i</emphasis></p>

<p><image xlink:href="#_184.jpg" /></p>

<p><strong>Figure 3.33:</strong>  An RC circuit and the associated signal-flow diagram.</p>

<p>
We can model electrical circuits using streams to represent the values
of currents or voltages at a sequence of times.  For instance, suppose
we have an <emphasis>RC circuit</emphasis> consisting of a resistor of resistance <emphasis>R</emphasis>
and a capacitor of capacitance <emphasis>C</emphasis> in series.  The voltage response
<emphasis>v</emphasis> of the circuit to an injected current <emphasis>i</emphasis> is determined by the
formula in figure 3.33, whose structure is shown by the accompanying
signal-flow diagram.</p>

<p>

Write a procedure RC that models this circuit.  RC should
take as inputs the values of <emphasis>R</emphasis>, <emphasis>C</emphasis>, and <emphasis>d</emphasis><emphasis>t</emphasis> and should return a
procedure that takes as inputs a stream representing the current <emphasis>i</emphasis>
and an initial value for the capacitor voltage <emphasis>v</emphasis><sub>0</sub> and produces as
output the stream of voltages <emphasis>v</emphasis>.  For example, you should be able to
use RC to model an RC circuit with <emphasis>R</emphasis>  =  5 ohms, <emphasis>C</emphasis>  =  1 farad,
and a 0.5-second time step by evaluating (define RC1 (RC 5 1
0.5)).  This defines RC1 as a procedure that takes a stream
representing the time sequence of currents and an initial capacitor
voltage and produces the output stream of voltages.</p>

<p>
<strong>Exercise 3.74.</strong>  Alyssa P. Hacker is designing a system to process signals coming from
physical sensors.  One important feature she wishes to produce is a
signal that describes the <emphasis>zero crossings</emphasis> of the input signal.
That is, the resulting signal should be  + 1 whenever the input signal
changes from negative to positive,  - 1 whenever the input signal
changes from positive to negative, and 0 otherwise.  (Assume that the
sign of a 0 input is positive.)  For example, a typical input signal
with its associated zero-crossing signal would be</p>

<p>...1  2  1.5  1  0.5  -0.1  -2  -3  -2  -0.5  0.2  3  4 ...... 0  0    0  0    0     -1  0   0   0     0    1  0  0 ...</p>

<p>
In Alyssa's system, the signal from the sensor is represented as a
stream sense-data and the stream zero-crossings is
the corresponding stream of zero crossings.  Alyssa first writes a
procedure sign-change-detector that takes two values as
arguments and compares the signs of the values to produce an
appropriate 0, 1, or  - 1.  She then constructs her zero-crossing
stream as follows:</p>

<p>(define (make-zero-crossings input-stream last-value)</p><empty-line /><p>
  (cons-stream</p><empty-line /><p>
   (sign-change-detector (stream-car input-stream) last-value)</p><empty-line /><p>
   (make-zero-crossings (stream-cdr input-stream)</p><empty-line /><p>
                        (stream-car input-stream))))</p><empty-line /><empty-line /><p>
(define zero-crossings (make-zero-crossings sense-data 0))</p><empty-line /><p>
Alyssa's boss, Eva Lu Ator, walks by and suggests that this program is
approximately equivalent to the following one, which
uses the generalized version
of stream-map from exercise 3.50:</p>

<p>(define zero-crossings</p><empty-line /><p>
  (stream-map sign-change-detector sense-data &lt;<emphasis>expression</emphasis>&gt;))</p><empty-line /><p>
Complete the program by supplying the indicated &lt;<emphasis>expression</emphasis>&gt;.</p>

<p>
<strong>Exercise 3.75.</strong>  Unfortunately, Alyssa's zero-crossing detector in
exercise 3.74 proves to be insufficient, because the
noisy signal from the sensor leads to spurious zero crossings.  Lem E.
Tweakit, a hardware specialist, suggests that Alyssa smooth the signal
to filter out the noise before extracting the zero crossings.  Alyssa
takes his advice and decides to extract the zero crossings from the
signal constructed by averaging each value of the sense data with the
previous value.  She explains the problem to her assistant, Louis
Reasoner, who attempts to implement the idea, altering Alyssa's program as
follows:</p>

<p>(define (make-zero-crossings input-stream last-value)</p><empty-line /><p>
  (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))</p><empty-line /><p>
    (cons-stream (sign-change-detector avpt last-value)</p><empty-line /><p>
                 (make-zero-crossings (stream-cdr input-stream)</p><empty-line /><p>
                                      avpt))))</p><empty-line /><p>
This does not correctly implement Alyssa's plan.
Find the bug that Louis has installed
and fix it without changing the structure of the program.  (Hint: You
will need to increase the number of arguments to make-zero-crossings.)</p>

<p>
<strong>Exercise 3.76.</strong>  Eva Lu Ator has a criticism of Louis's approach in
exercise 3.75.  The program he wrote is not modular,
because it intermixes the operation of smoothing with the
zero-crossing extraction.  For example, the extractor should not have
to be changed if Alyssa finds a better way to condition her input
signal.  Help Louis by writing a procedure smooth that takes a
stream as input and produces a stream in which each element is the
average of two successive input stream elements.  Then use smooth as a component to implement the zero-crossing detector in a
more modular style.</p>

<p><strong>3.5.4  Streams and Delayed Evaluation</strong></p>

<p>



The integral procedure at the end of the preceding section shows
how we can use streams to model signal-processing systems that contain
feedback loops.  The feedback loop for the adder shown in
figure 3.32 is modeled by the fact that integral's
internal stream int is defined in terms of itself:</p>

<p>(define int</p><empty-line /><p>
  (cons-stream initial-value</p><empty-line /><p>
               (add-streams (scale-stream integrand dt)</p><empty-line /><p>
                            int)))</p><empty-line /><p>
The interpreter's ability to deal with such an implicit definition
depends on the delay that is incorporated into cons-stream.  Without this delay, the interpreter could not
construct int before evaluating both arguments to cons-stream, which would require that int already be defined.
In general, delay is crucial for using streams to model
signal-processing systems that contain loops.  Without delay,
our models would have to be formulated so that the inputs to any
signal-processing component would be fully evaluated before the output
could be produced.  This would outlaw loops.</p>

<p>

Unfortunately, stream models of systems with loops
may require uses of delay beyond the "hidden" delay
supplied by cons-stream.  For instance,
figure 3.34 shows a signal-processing system for
solving the differential equation <emphasis>d</emphasis><emphasis>y</emphasis>/<emphasis>d</emphasis><emphasis>t</emphasis> = <emphasis>f</emphasis>(<emphasis>y</emphasis>) where <emphasis>f</emphasis> is a given
function.  The figure shows a mapping component, which
applies <emphasis>f</emphasis> to its input signal, linked in a feedback loop to an
integrator in a manner very similar to that of the analog computer
circuits that are actually used to solve such equations.</p>

<p><image xlink:href="#_185.jpg" /></p>

<p><strong>Figure 3.34:</strong>  An "analog computer circuit" that solves the
equation
<emphasis>d</emphasis><emphasis>y</emphasis>/<emphasis>d</emphasis><emphasis>t</emphasis> = <emphasis>f</emphasis>(<emphasis>y</emphasis>).</p>

<p>

Assuming we are given an initial value <emphasis>y</emphasis><sub>0</sub> for <emphasis>y</emphasis>, we
could try to model this system using the procedure</p>

<p>(define (solve f y0 dt)</p><empty-line /><p>
  (define y (integral dy y0 dt))</p><empty-line /><p>
  (define dy (stream-map f y))</p><empty-line /><p>
  y)</p><empty-line /><p>
This procedure does not work, because in the first line of solve
the call to integral requires that the input dy be
defined, which does not happen until the second line of solve.</p>

<p>

On the other hand, the intent of our definition does make sense,
because we can, in principle, begin to generate the y stream
without knowing dy.  Indeed, integral and many other
stream operations have properties similar to those of cons-stream, in that we can generate part of the answer given only
partial information about the arguments.  For integral, the
first element of the output stream is the specified initial-value.  Thus, we can generate the first element of the output
stream without evaluating the integrand dy.  Once we know the
first element of y, the stream-map in the second line of
solve can begin working to generate the first element of dy, which will produce the next element of y, and so on.</p>

<p>

To take advantage of this idea, we will redefine integral to
expect the integrand stream to be a <emphasis>delayed argument</emphasis>.  Integral will force the integrand to be evaluated only when it
is required to generate more than the first element of the output stream:</p>

<p>(define (integral delayed-integrand initial-value dt)</p><empty-line /><p>
  (define int</p><empty-line /><p>
    (cons-stream initial-value</p><empty-line /><p>
                 (let ((integrand (force delayed-integrand)))</p><empty-line /><p>
                   (add-streams (scale-stream integrand dt)</p><empty-line /><p>
                                int))))</p><empty-line /><p>
  int)</p><empty-line /><p>
Now we can implement our solve procedure by delaying the
evaluation of dy in the definition of y:<sup>71</sup></p>

<p>(define (solve f y0 dt)</p><empty-line /><p>
  (define y (integral (delay dy) y0 dt))</p><empty-line /><p>
  (define dy (stream-map f y))</p><empty-line /><p>
  y)</p><empty-line /><p>
In general, every caller of integral must now delay the
integrand argument.  We can demonstrate that the solve procedure
works by approximating <emphasis>e</emphasis> <image xlink:href="#_27.jpg" />  2.718 by computing the value at
<emphasis>y</emphasis> = 1 of the solution to the differential equation <emphasis>d</emphasis><emphasis>y</emphasis>/<emphasis>d</emphasis><emphasis>t</emphasis> = <emphasis>y</emphasis> with
initial condition <emphasis>y</emphasis>(0) = 1:</p>

<p>(stream-ref (solve (lambda (y) y) 1 0.001) 1000)</p><empty-line /><p><emphasis>2.716924</emphasis></p><empty-line /><p>
<strong>Exercise 3.77.</strong>  The integral procedure used above was analogous to the
"implicit" definition of the infinite stream of integers in
section 3.5.2.  Alternatively, we can give a
definition of integral that is more like integers-starting-from (also in section 3.5.2):</p>

<p>(define (integral integrand initial-value dt)</p><empty-line /><p>
  (cons-stream initial-value</p><empty-line /><p>
               (if (stream-null? integrand)</p><empty-line /><p>
                   the-empty-stream</p><empty-line /><p>
                   (integral (stream-cdr integrand)</p><empty-line /><p>
                             (+ (* dt (stream-car integrand))</p><empty-line /><p>
                                initial-value)</p><empty-line /><p>
                             dt))))</p><empty-line /><p>
When used in systems with loops, this procedure has the same problem
as does our original version of integral.  Modify the procedure
so that it expects the integrand as a delayed argument and hence
can be used in the solve procedure shown above.</p>

<p>
<strong>Exercise 3.78.</strong></p>

<p><image xlink:href="#_186.jpg" /></p>

<p><strong>Figure 3.35:</strong>  Signal-flow diagram for the solution to a second-order
linear differential equation.</p>

<p>
Consider the problem of designing a signal-processing system to study
the homogeneous second-order linear differential equation</p>

<p><image xlink:href="#_187.jpg" /></p>

<p>
The output stream, modeling <emphasis>y</emphasis>, is generated by a network that
contains a loop. This is because the value of <emphasis>d</emphasis><sup>2</sup><emphasis>y</emphasis>/<emphasis>d</emphasis><emphasis>t</emphasis><sup>2</sup> depends
upon the values of <emphasis>y</emphasis> and <emphasis>d</emphasis><emphasis>y</emphasis>/<emphasis>d</emphasis><emphasis>t</emphasis> and both of these are determined by
integrating <emphasis>d</emphasis><sup>2</sup><emphasis>y</emphasis>/<emphasis>d</emphasis><emphasis>t</emphasis><sup>2</sup>.  The diagram we would like to encode is
shown in figure 3.35.  Write a procedure solve-2nd that
takes as arguments the constants <emphasis>a</emphasis>, <emphasis>b</emphasis>, and <emphasis>d</emphasis><emphasis>t</emphasis> and the initial
values <emphasis>y</emphasis><sub>0</sub> and <emphasis>d</emphasis><emphasis>y</emphasis><sub>0</sub> for <emphasis>y</emphasis> and <emphasis>d</emphasis><emphasis>y</emphasis>/<emphasis>d</emphasis><emphasis>t</emphasis> and generates the
stream of successive values of <emphasis>y</emphasis>.</p>

<p>
<strong>Exercise 3.79.</strong>  Generalize the solve-2nd procedure of exercise 3.78 so
that it can be used to solve general second-order differential
equations <emphasis>d</emphasis><sup>2</sup><emphasis>y</emphasis>/<emphasis>d</emphasis><emphasis>t</emphasis><sup>2</sup> = <emphasis>f</emphasis>(<emphasis>d</emphasis><emphasis>y</emphasis>/<emphasis>d</emphasis><emphasis>t</emphasis>,  <emphasis>y</emphasis>).</p>

<p>
<strong>Exercise 3.80.</strong>  A <emphasis>series RLC circuit</emphasis> consists of a resistor, a capacitor, and an
inductor connected in series, as shown in figure 3.36.
If <emphasis>R</emphasis>, <emphasis>L</emphasis>, and <emphasis>C</emphasis> are the resistance, inductance, and capacitance,
then the relations between voltage (<emphasis>v</emphasis>) and current (<emphasis>i</emphasis>)
for the three components are described by the equations</p>

<p><image xlink:href="#_188.jpg" /></p>

<p>

and the circuit connections dictate the relations</p>

<p><image xlink:href="#_189.jpg" /></p>

<p>
Combining these equations shows that the state of the circuit
(summarized by <emphasis>v</emphasis><sub><emphasis>C</emphasis></sub>, the voltage across the capacitor, and <emphasis>i</emphasis><sub><emphasis>L</emphasis></sub>, the
current in the inductor)
is described by the pair of differential equations</p>

<p><image xlink:href="#_190.jpg" /></p>

<p>
The signal-flow diagram representing this system of differential
equations is shown in figure 3.37.</p>

<p><image xlink:href="#_191.jpg" /></p>

<p><strong>Figure 3.36:</strong>  A series RLC circuit.</p>

<p><image xlink:href="#_192.jpg" /></p>

<p><strong>Figure 3.37:</strong>  A signal-flow diagram for the solution
to a series RLC circuit.</p>

<p>

Write a procedure RLC that takes as arguments the parameters
<emphasis>R</emphasis>, <emphasis>L</emphasis>, and <emphasis>C</emphasis> of the circuit and the time increment <emphasis>d</emphasis><emphasis>t</emphasis>.  In a
manner similar to that of the RC procedure of
exercise 3.73, RLC should produce a procedure
that takes the initial values of the state variables, <emphasis>v</emphasis><sub><emphasis>C</emphasis>0</sub> and
<emphasis>i</emphasis><sub><emphasis>L</emphasis>0</sub>, and produces a pair (using cons) of the streams of
states <emphasis>v</emphasis><sub><emphasis>C</emphasis></sub> and <emphasis>i</emphasis><sub><emphasis>L</emphasis></sub>.  Using RLC, generate the pair of
streams that models the behavior of a series RLC circuit with <emphasis>R</emphasis>  =  1
ohm, <emphasis>C</emphasis> =  0.2 farad, <emphasis>L</emphasis>  =  1 henry, <emphasis>d</emphasis><emphasis>t</emphasis>  =  0.1 second, and initial
values <emphasis>i</emphasis><sub><emphasis>L</emphasis>0</sub>  =  0 amps and <emphasis>v</emphasis><sub><emphasis>C</emphasis>0</sub>  =  10 volts.</p>

<p><strong>Normal-order evaluation</strong></p>

<p>


The examples in this section illustrate how the explicit use of delay and force provides great programming flexibility, but the
same examples also show how this can make our programs more complex.
Our new integral procedure, for instance, gives us the power to
model systems with loops, but we must now remember that integral
should be called with a delayed integrand, and every procedure that
uses integral must be aware of this.  In effect, we have created
two classes of procedures: ordinary procedures and procedures that
take delayed arguments.  In general, creating separate classes of
procedures forces us to create separate classes of higher-order
procedures as well.<sup>72</sup></p>

<p>

One way to avoid the need for two different classes of procedures is
to make all procedures take delayed arguments.  We could adopt a model
of evaluation in which all arguments to procedures are automatically
delayed and arguments are forced only when they are actually needed
(for example, when they are required by a primitive operation).  This
would transform our language to use normal-order evaluation, which we
first described when we introduced the substitution model for
evaluation in section 1.1.5.  Converting to
normal-order evaluation provides a uniform and elegant way to simplify
the use of delayed evaluation, and this would be a natural strategy to
adopt if we were concerned only with stream processing.  In
section 4.2, after we have studied the evaluator, we
will see how to transform our language in just this way.
Unfortunately, including delays in procedure calls wreaks havoc with
our ability to design programs that depend on the order of events,
such as programs that use assignment, mutate data, or perform input or
output.  Even the single delay in cons-stream can cause
great confusion, as illustrated by exercises 3.51
and 3.52.  As far as anyone knows, mutability and delayed
evaluation do not mix well in programming languages, and devising ways
to deal with both of these at once is an active area of research.</p>

<p><strong>3.5.5  Modularity of Functional Programs and Modularity of Objects</strong></p>

<p>



As we saw in section 3.1.2, one of the
major benefits of introducing assignment is that we can increase the
modularity of our systems by encapsulating, or "hiding", parts of
the state of a large system within local variables.  Stream models can
provide an equivalent modularity without the use of assignment.  As an
illustration, we can reimplement the Monte Carlo estimation of <image xlink:href="#_37.jpg" />,
which we examined in section 3.1.2, from a
stream-processing point of view.</p>

<p>


The key modularity issue was that we wished to hide the internal state
of a random-number generator from programs that used random numbers.
We began with a procedure rand-update, whose successive values
furnished our supply of random numbers, and used this to produce a
random-number generator:</p>

<p>(define rand</p><empty-line /><p>
  (let ((x random-init))</p><empty-line /><p>
    (lambda ()</p><empty-line /><p>
      (set! x (rand-update x))</p><empty-line /><p>
      x)))</p><empty-line /><empty-line /><p>

In the stream formulation there is no random-number generator <emphasis>per
se</emphasis>, just a stream of random numbers produced by successive calls to
rand-update:</p>

<p>(define random-numbers</p><empty-line /><p>
  (cons-stream random-init</p><empty-line /><p>
               (stream-map rand-update random-numbers)))</p><empty-line /><p>
We use this to construct the stream of outcomes of the Cesàro
experiment performed on consecutive pairs in the random-numbers
stream:</p>

<p>(define cesaro-stream</p><empty-line /><p>
  (map-successive-pairs (lambda (r1 r2) (= (gcd r1 r2) 1))</p><empty-line /><p>
                        random-numbers))</p><empty-line /><empty-line /><p>(define (map-successive-pairs f s)</p><empty-line /><p>
  (cons-stream</p><empty-line /><p>
   (f (stream-car s) (stream-car (stream-cdr s)))</p><empty-line /><p>
   (map-successive-pairs f (stream-cdr (stream-cdr s)))))</p><empty-line /><p>
The cesaro-stream is now fed to a monte-carlo procedure,
which produces a stream of estimates of probabilities.  The results
are then converted into a stream of estimates of <image xlink:href="#_37.jpg" />.  This version
of the program doesn't need a parameter telling how many trials to
perform.  Better estimates of <image xlink:href="#_37.jpg" /> (from performing more experiments)
are obtained by looking farther into the pi stream:</p>

<p>(define (monte-carlo experiment-stream passed failed)</p><empty-line /><p>
  (define (next passed failed)</p><empty-line /><p>
    (cons-stream</p><empty-line /><p>
     (/ passed (+ passed failed))</p><empty-line /><p>
     (monte-carlo</p><empty-line /><p>
      (stream-cdr experiment-stream) passed failed)))</p><empty-line /><p>
  (if (stream-car experiment-stream)</p><empty-line /><p>
      (next (+ passed 1) failed)</p><empty-line /><p>
      (next passed (+ failed 1))))</p><empty-line /><empty-line /><p>
(define pi</p><empty-line /><p>
  (stream-map (lambda (p) (sqrt (/ 6 p)))</p><empty-line /><p>
              (monte-carlo cesaro-stream 0 0)))</p><empty-line /><p>
There is considerable modularity in this approach, because we still
can formulate a general monte-carlo procedure that can deal with
arbitrary experiments.  Yet there is no assignment or local state.</p>

<p>
<strong>Exercise 3.81.</strong>  Exercise 3.6
discussed generalizing the random-number generator to
allow one to reset the random-number sequence so as to produce
repeatable sequences of "random" numbers.  Produce a stream
formulation of this same generator that operates on an input stream of
requests to generate a new random number or to reset the
sequence to a specified value and that produces the desired stream of
random numbers.  Don't use assignment in your solution.</p>

<p>
<strong>Exercise 3.82.</strong>  Redo exercise 3.5 on Monte Carlo
integration in terms of streams.  The stream version of estimate-integral will not have an argument telling how many trials
to perform.  Instead, it will produce a stream of estimates based on
successively more trials.</p>

<p><strong>A functional-programming view of time</strong></p>

<p>


Let us now return to the issues of objects and state that were raised
at the beginning of this chapter and examine them in a new light.  We
introduced assignment and mutable objects to provide a mechanism for
modular construction of programs that model systems with state.
We constructed computational
objects with local state variables and used assignment to modify these
variables.  We modeled the temporal behavior of the objects in the
world by the temporal behavior of the corresponding computational
objects.</p>

<p>

Now we have seen that streams provide an alternative way to model
objects with local state.  We can model a changing quantity, such as
the local state of some object, using a stream that represents the
time history of successive states.  In essence, we represent time
explicitly, using streams, so that we decouple time in our simulated
world from the sequence of events that take place during evaluation.
Indeed, because of the presence of delay there may be little
relation between simulated time in the model and the order of events
during the evaluation.</p>

<p>

In order to contrast these two approaches to modeling, let us
reconsider the implementation of a "withdrawal processor" that
monitors the balance in a bank account.  In
section 3.1.3 we implemented a simplified
version of such a processor:</p>

<p>(define (make-simplified-withdraw balance)</p><empty-line /><p>
  (lambda (amount)</p><empty-line /><p>
    (set! balance (- balance amount))</p><empty-line /><p>
    balance))</p><empty-line /><p>
Calls to make-simplified-withdraw produce computational objects,
each with a local state variable balance that is decremented by
successive calls to the object.  The object takes an amount as
an argument and returns the new balance.  We can imagine the user of a
bank account typing a sequence of inputs to such an object and
observing the sequence of returned values shown on a display screen.</p>

<p>

Alternatively, we can model a withdrawal processor as a procedure that
takes as input a balance and a stream of amounts to withdraw and
produces the stream of successive balances in the account:</p>

<p>(define (stream-withdraw balance amount-stream)</p><empty-line /><p>
  (cons-stream</p><empty-line /><p>
   balance</p><empty-line /><p>
   (stream-withdraw (- balance (stream-car amount-stream))</p><empty-line /><p>
                    (stream-cdr amount-stream))))</p><empty-line /><p>
Stream-withdraw implements a well-defined mathematical function whose
output is fully determined by its input.  Suppose, however, that the
input amount-stream is the stream of successive values typed by
the user and that the resulting stream of balances is displayed.
Then, from the perspective of the user who is typing values and
watching results, the stream process has the same behavior as the
object created by make-simplified-withdraw.  However, with the
stream version, there is no assignment, no local state variable, and
consequently none of the theoretical difficulties that we encountered
in section 3.1.3.  Yet the system has state!</p>

<p>

This is really remarkable.  Even though stream-withdraw implements a
well-defined mathematical function whose behavior does not change, the
user's perception here is one of interacting with a system that has a
changing state.  One way to resolve this paradox is to realize that it
is the user's temporal existence that imposes state on the system.  If
the user could step back from the interaction and think in terms of
streams of balances rather than individual transactions, the system
would appear stateless.<sup>73</sup></p>

<p>

From the point of view of one part of a complex process, the other
parts appear to change with time.  They have hidden time-varying local
state.  If we wish to write programs that model this kind of natural
decomposition in our world (as we see it from our viewpoint as a part of
that world) with
structures in our computer, we make computational objects that are not
functional -- they must change with time.  We model state with local
state variables, and we model the changes of state with assignments to
those variables.  By doing this we make the time of execution of a
computation model time in the world that we are part of, and thus we
get "objects" in our computer.</p>

<p>

Modeling with objects is powerful and intuitive, largely because this
matches the perception of interacting with a world of which we are
part.  However, as we've seen repeatedly throughout this chapter,
these models raise thorny problems of constraining the order of events
and of synchronizing multiple processes.  The possibility of avoiding
these problems has stimulated the development of <emphasis>functional
programming languages</emphasis>, which do not include any provision for
assignment or mutable data.  In such a language, all procedures
implement well-defined mathematical functions of their arguments,
whose behavior does not change.  The functional approach is extremely
attractive for dealing with concurrent systems.<sup>74</sup></p>

<p>

On the other hand, if we look closely, we can see time-related
problems creeping into functional models as well.  One particularly
troublesome area arises when we wish to design interactive systems,
especially ones that model interactions between independent entities.
For instance, consider once more the implementation a banking system
that permits joint bank accounts.  In a conventional system using
assignment and objects, we would model the fact that Peter and Paul
share an account by having both Peter and Paul send their transaction
requests to the same bank-account object, as we saw in
section 3.1.3.
From the stream point of view, where there are no "objects" <emphasis>per
se</emphasis>, we have already indicated that a bank account can be modeled as a
process that operates on a stream of transaction requests to produce a
stream of responses.  Accordingly, we could model the fact that Peter
and Paul have a joint bank account by merging Peter's stream of
transaction requests with Paul's stream of requests and feeding the
result to the bank-account stream process, as shown in
figure 3.38.</p>

<p><image xlink:href="#_193.jpg" /></p>

<p><strong>Figure 3.38:</strong>  A joint bank account, modeled by merging two streams of
transaction requests.</p>

<p>

The trouble with this formulation is in the notion of <emphasis>merge</emphasis>.  It
will not do to merge the two streams by simply taking alternately one
request from Peter and one request from Paul. Suppose Paul accesses
the account only very rarely.  We could hardly force Peter to wait for
Paul to access the account before he could issue a second transaction.
However such a merge is implemented, it must interleave the two
transaction streams in some way that is constrained by "real
time" as perceived by Peter and Paul, in the sense that, if Peter and
Paul meet, they can agree that certain transactions were processed
before the meeting, and other transactions were processed after the
meeting.<sup>75</sup>
This is precisely the same constraint that we had to deal with in
section 3.4.1, where we found the need to introduce
explicit synchronization to ensure a "correct" order of events in
concurrent processing of objects with state.  Thus, in an attempt to
support the functional style, the need to merge inputs from different
agents reintroduces the same problems that the functional style was
meant to eliminate.</p>

<p>

We began this chapter with the goal of building computational models
whose structure matches our perception of the real world we are trying
to model.  We can model the world as a collection of separate,
time-bound, interacting objects with state, or we can model the world
as a single, timeless, stateless unity.  Each view has powerful
advantages, but neither view alone is completely satisfactory.  A
grand unification has yet to emerge.<sup>76</sup></p><empty-line /><empty-line /><empty-line /><p><sup>52</sup> Physicists sometimes adopt this view by introducing the
"world lines" of particles as a device for reasoning about motion.
We've also already mentioned
(section 2.2.3) that this is the
natural way to think about signal-processing systems.  We will explore
applications of streams to signal processing in
section 3.5.3.</p>

<p><sup>53</sup> Assume that we have a
predicate prime? (e.g., as in section 1.2.6) that
tests for primality.</p>

<p><sup>54</sup> In the MIT implementation, the-empty-stream is the
same as the empty list '(), and stream-null? is the same
as null?.</p>

<p><sup>55</sup> This should bother you.  The fact that we are defining such
similar procedures for streams and lists indicates that we are missing some
underlying abstraction.  Unfortunately, in order to exploit this
abstraction, we will need to exert finer control over the process of
evaluation than we can at present.  We will discuss this point further
at the end of section 3.5.4.
In section 4.2, we'll develop a framework that
unifies lists and streams.</p>

<p><sup>56</sup> Although stream-car and
stream-cdr can be defined as procedures, cons-stream must
be a special form.  If cons-stream were a procedure, then,
according to our model of evaluation, evaluating (cons-stream
&lt;<emphasis>a</emphasis>&gt; &lt;<emphasis>b</emphasis>&gt;) would automatically cause &lt;<emphasis>b</emphasis>&gt; to be evaluated, which is
precisely what we do not want to happen.  For the same reason, delay must be a special form, though force can be an ordinary
procedure.</p>

<p><sup>57</sup> The numbers shown here do
not really appear in the delayed expression.  What actually appears is
the original expression, in an environment in which the variables are
bound to the appropriate numbers.  For example, (+ low 1) with
low bound to 10,000 actually appears where 10001 is
shown.</p>

<p><sup>58</sup> There are many
possible implementations of streams other than the one described in
this section.  Delayed evaluation, which is the key to making streams
practical, was inherent in Algol 60's <emphasis>call-by-name</emphasis>
parameter-passing method.  The use of this mechanism to implement
streams was first described by Landin (1965).  Delayed evaluation for
streams was introduced into Lisp by Friedman and Wise (1976). In their
implementation, cons always delays evaluating its arguments, so
that lists automatically behave as streams.  The memoizing
optimization is also known as <emphasis>call-by-need</emphasis>.  The Algol community
would refer to our original delayed objects as <emphasis>call-by-name
thunks</emphasis> and to the optimized versions as <emphasis>call-by-need thunks</emphasis>.</p>

<p><sup>59</sup> Exercises such as 3.51 and 3.52
are valuable for testing our understanding of how delay works.
On the other hand, intermixing delayed evaluation with printing -- and,
even worse, with assignment -- is extremely confusing, and instructors
of courses on computer languages have traditionally tormented their
students with examination questions such as the ones in this section.
Needless to say, writing programs that depend on such subtleties is
odious programming style.  Part of the power of stream processing is
that it lets us ignore the order in which events actually happen in
our programs.  Unfortunately, this is precisely what we cannot afford
to do in the presence of assignment, which forces us to be concerned
with time and change.</p>

<p><sup>60</sup> Eratosthenes, a third-century B.C.
Alexandrian Greek philosopher, is famous for giving the first accurate
estimate of the circumference of the Earth, which he computed by
observing shadows cast at noon on the day of the summer solstice.
Eratosthenes's sieve method, although ancient, has formed the basis
for special-purpose hardware "sieves" that, until recently, were the
most powerful tools in existence for locating large primes.  Since the
70s, however, these methods have been superseded by outgrowths of the
probabilistic techniques discussed in section 1.2.6.</p>

<p><sup>61</sup> We have named these figures after Peter Henderson, who
was the first person to show us diagrams of this sort as a way of
thinking about stream processing.  Each solid line represents a stream
of values being transmitted.  The dashed line from the car to
the cons and the filter indicates that this is a single
value rather than a stream.</p>

<p><sup>62</sup> This uses the generalized version
of stream-map from exercise 3.50.</p>

<p><sup>63</sup> This last point is
very subtle and relies on the fact that <emphasis>p</emphasis><sub><emphasis>n</emphasis>+1</sub>&lt; <emphasis>p</emphasis><sub><emphasis>n</emphasis></sub><sup>2</sup>.
(Here, <emphasis>p</emphasis><sub><emphasis>k</emphasis></sub> denotes the <emphasis>k</emphasis>th prime.)  Estimates such as these are
very difficult to establish.  The ancient proof by Euclid that there
are an infinite number of primes shows that <emphasis>p</emphasis><sub><emphasis>n</emphasis>+1</sub>&lt; <emphasis>p</emphasis><sub>1</sub><emphasis>p</emphasis><sub>2</sub>···   <emphasis>p</emphasis><sub><emphasis>n</emphasis></sub>  + 1, and no substantially better result was proved
until 1851, when the Russian mathematician P. L. Chebyshev established
that <emphasis>p</emphasis><sub><emphasis>n</emphasis>+1</sub>&lt; 2<emphasis>p</emphasis><sub><emphasis>n</emphasis></sub> for all <emphasis>n</emphasis>.  This result, originally
conjectured in 1845, is known as <emphasis>Bertrand's hypothesis</emphasis>.  A proof
can be found in section 22.3 of Hardy and Wright 1960.</p>

<p><sup>64</sup> This exercise shows how call-by-need is closely related to
ordinary memoization as described in exercise 3.27.
In that exercise, we used assignment to explicitly construct a local
table.  Our call-by-need stream optimization effectively constructs
such a table automatically, storing values in the previously forced
parts of the stream.</p>

<p><sup>65</sup> We can't use let to bind the local variable
guesses, because the value of guesses depends on guesses itself.  Exercise 3.63 addresses why
we want a local variable here.</p>

<p><sup>66</sup> As in section 2.2.3,
we represent a pair of integers as a list rather than a Lisp pair.</p>

<p><sup>67</sup> See exercise 3.68 for some insight
into why we chose this decomposition.</p>

<p><sup>68</sup> The precise statement of the
required property on the order of combination is as follows: There
should be a function <emphasis>f</emphasis> of two arguments such that the pair
corresponding to element <emphasis>i</emphasis> of the first stream and element <emphasis>j</emphasis> of
the second stream will appear as element number <emphasis>f</emphasis>(<emphasis>i</emphasis>,<emphasis>j</emphasis>) of the output
stream.  The trick of using interleave to accomplish this was
shown to us by David Turner, who employed it in the language KRC
(Turner 1981).</p>

<p><sup>69</sup> We will require that the weighting function be such that
the weight of a pair increases as we move out along a row or down
along a column of the array of pairs.</p>

<p><sup>70</sup> To quote from G. H. Hardy's obituary of
Ramanujan (Hardy 1921): "It was Mr. Littlewood (I believe) who remarked that
`every positive integer was one of his friends.'  I remember once
going to see him when he was lying ill at Putney.  I had ridden in
taxi-cab No. 1729, and remarked that the number seemed to me a rather
dull one, and that I hoped it was not an unfavorable omen.  `No,' he
replied, `it is a very interesting number; it is the smallest number
expressible as the sum of two cubes in two different ways.' "
The trick of using weighted pairs to generate the Ramanujan numbers
was shown to us by Charles Leiserson.</p>

<p><sup>71</sup> This procedure is not guaranteed to work in all Scheme
implementations, although for any implementation there is a simple
variation that will work.  The problem has to do with subtle
differences in the ways that Scheme implementations handle internal
definitions.  (See section 4.1.6.)</p>

<p><sup>72</sup> This is a small reflection, in Lisp, of the difficulties
that conventional strongly typed languages such as Pascal have in
coping with higher-order procedures.  In such languages, the
programmer must specify the data types of the arguments and the result
of each procedure: number, logical value, sequence, and so on.
Consequently, we could not express an abstraction such as "map a
given procedure proc over all the elements in a sequence" by a
single higher-order procedure such as stream-map.  Rather, we
would need a different mapping procedure for each different
combination of argument and result data types that might be specified
for a proc.  Maintaining a practical notion of "data type" in
the presence of higher-order procedures raises many difficult issues.
One way of dealing with this problem is illustrated by the language ML
(Gordon, Milner, and Wadsworth 1979), whose "polymorphic data types"
include templates for higher-order transformations between data types.
Moreover, data types for most procedures in ML are never explicitly
declared by the programmer.  Instead, ML includes a <emphasis>type-inferencing</emphasis> mechanism that uses information in the environment
to deduce the data types for newly defined procedures.</p>

<p><sup>73</sup> Similarly in physics, when we observe a moving particle, we
say that the position (state) of the particle is changing.  However,
from the perspective of the particle's world line in space-time there
is no change involved.</p>

<p><sup>74</sup> John Backus, the inventor of Fortran, gave high
visibility to functional programming when he was awarded
the ACM Turing award in 1978.  His acceptance speech (Backus 1978)
strongly advocated the functional approach.  A good overview of
functional programming is given in Henderson 1980 and in Darlington,
Henderson, and Turner 1982.</p>

<p><sup>75</sup> Observe that, for any two streams, there is in general more than one
acceptable order of interleaving.  Thus, technically, "merge" is a
relation rather than a function -- the answer is not a deterministic
function of the inputs.  We already mentioned
(footnote 39) that nondeterminism is
essential when dealing with concurrency.  The merge relation
illustrates the same essential nondeterminism, from the functional
perspective.  In section 4.3, we
will look at nondeterminism from yet another point of view.</p>

<p><sup>76</sup> The object model approximates the world by
dividing it into separate pieces.  The functional model does not
modularize along object boundaries.  The object model is useful when
the unshared state of the "objects" is much larger than the state
that they share.  An example of a place where the object viewpoint
fails is quantum
mechanics, where thinking of things as individual particles leads to
paradoxes and confusions.  Unifying the object view with the
functional view may have little to do with programming, but rather
with fundamental epistemological issues.</p>


</section>

<section>


<p><strong>
</strong></p>

<p><strong>Chapter 4</strong></p>

<p>
Metalinguistic Abstraction</p><empty-line /><p>

... It's in words that the magic
is -- Abracadabra, Open Sesame, and the rest -- but the magic words in
one story aren't magical in the next.  The real magic is to understand
which words work, and when, and for what; the trick is to learn the
trick.</p><empty-line /><p>... And those words are made from the letters of our
alphabet: a couple-dozen squiggles we can draw with the pen.  This is
the key!  And the treasure, too, if we can only get our hands on it!
It's as if -- as if the key to the treasure <emphasis>is</emphasis> the treasure!</p>

<p>

John Barth, <emphasis>Chimera</emphasis></p><empty-line /><p>

In our study of program design, we have seen that expert programmers
control the complexity of their designs with the same general
techniques used by designers of all complex systems.  They combine
primitive elements to form compound objects, they abstract compound
objects to form higher-level building blocks, and they preserve
modularity by adopting appropriate large-scale views of system
structure.  In illustrating these techniques, we have used Lisp as a
language for describing processes and for constructing computational
data objects and processes to model complex phenomena in the real
world.  However, as we confront increasingly complex problems, we will
find that Lisp, or indeed any fixed programming language, is not
sufficient for our needs.  We must constantly turn to new languages in
order to express our ideas more effectively.  Establishing new
languages is a powerful strategy for controlling complexity in
engineering design; we can often enhance our ability to deal with a
complex problem by adopting a new language that enables us to describe
(and hence to think about) the problem in a different way, using
primitives, means of combination, and means of abstraction that are
particularly well suited to the problem at hand.<sup>1</sup></p>

<p>

Programming is endowed with a multitude of languages.  There are
physical languages, such as the machine languages for particular
computers.  These languages are concerned with the representation of
data and control in terms of individual bits of storage and primitive
machine instructions.  The machine-language programmer is concerned
with using the given hardware to erect systems and utilities for the
efficient implementation of resource-limited computations.  High-level
languages, erected on a machine-language substrate, hide concerns
about the representation of data as collections of bits and the
representation of programs as sequences of primitive instructions.
These languages have means of combination and abstraction, such as
procedure definition, that are appropriate to the larger-scale
organization of systems.</p>

<p>

<emphasis>Metalinguistic abstraction</emphasis> -- establishing new
languages -- plays an important role in all branches of engineering
design.  It is particularly important to computer programming, because
in programming not only can we formulate new languages but we can also
implement these languages by constructing evaluators.  An <emphasis>evaluator</emphasis> (or <emphasis>interpreter</emphasis>) for a programming language is a procedure
that, when applied to an expression of the language, performs the
actions required to evaluate that expression.</p>

<p>

It is no exaggeration to regard this as the most fundamental idea in
programming:</p>

<p>
The evaluator, which determines the meaning of expressions in a
programming language, is just another program.</p>

<p>
To appreciate this point is to change our images of ourselves as
programmers.  We come to see ourselves as designers of languages,
rather than only users of languages designed by others.</p>

<p>


In fact, we can regard almost any program as the evaluator for some
language.  For instance, the polynomial manipulation system of
section 2.5.3 embodies the rules of polynomial
arithmetic and implements them in terms of operations on
list-structured data.  If we augment this system with procedures to
read and print polynomial expressions, we have the core of a
special-purpose language for dealing with problems in symbolic
mathematics.  The digital-logic simulator of
section 3.3.4 and the constraint propagator of
section 3.3.5 are legitimate languages in their own
right, each with its own primitives, means of combination, and means
of abstraction.  Seen from this perspective, the technology for coping
with large-scale computer systems merges with the technology for
building new computer languages, and computer science itself becomes
no more (and no less) than the discipline of constructing appropriate
descriptive languages.</p>

<p>

We now embark on a tour of the technology by which languages are
established in terms of other languages.  In this chapter we shall use
Lisp as a base, implementing evaluators as Lisp procedures.  Lisp is
particularly well suited to this task, because of its ability to
represent and manipulate symbolic expressions.  We will take the first
step in understanding how languages are implemented by building an
evaluator for Lisp itself.  The language implemented by our evaluator
will be a subset of the Scheme dialect of Lisp that we use in this
book.  Although the evaluator described in this chapter is written for
a particular dialect of Lisp, it contains the essential structure of
an evaluator for any expression-oriented language designed for writing
programs for a sequential machine.  (In fact, most language processors
contain, deep within them, a little "Lisp" evaluator.)  The
evaluator has been simplified for the purposes of illustration and
discussion, and some features have been left out that would be
important to include in a production-quality Lisp system.
Nevertheless, this simple evaluator is adequate to execute most of the
programs in this book.<sup>2</sup></p>

<p>


An important advantage of making the evaluator accessible as a Lisp
program is that we can implement alternative evaluation rules by
describing these as modifications to the evaluator program.  One place
where we can use this power to good effect is to gain extra control
over the ways in which computational models embody the notion of time,
which was so central to the discussion in chapter 3.  There, we
mitigated some of the complexities of state and assignment by using
streams to decouple the representation of time in the world from time
in the computer.  Our stream programs, however, were
sometimes cumbersome, because they were constrained by
the applicative-order evaluation of Scheme.
In section 4.2, we'll change
the underlying language to provide for a more elegant approach, by modifying
the evaluator to provide for <emphasis>normal-order evaluation</emphasis>.</p>

<p>

Section 4.3 implements a more
ambitious linguistic change, whereby expressions have many values,
rather than just a single value.  In this language of <emphasis>nondeterministic computing</emphasis>, it is natural to express processes that
generate all possible values for expressions and then search for those
values that satisfy certain constraints.  In terms of models of
computation and time, this is like having time branch into a set of
"possible futures" and then searching for appropriate time lines.
With our nondeterministic evaluator, keeping track of multiple values
and performing searches are handled automatically by the underlying
mechanism of the language.</p>

<p>

In section 4.4 we implement a <emphasis>logic-programming</emphasis> language in which knowledge is expressed in terms
of relations, rather than in terms of computations with inputs and
outputs.  Even though this makes the language drastically different
from Lisp, or indeed from any conventional language, we will see that
the logic-programming evaluator shares the essential structure of the
Lisp evaluator.</p><empty-line /><empty-line /><empty-line /><p><sup>1</sup> The same idea
is pervasive throughout all of engineering.  For example, electrical
engineers use many different languages for describing circuits.  Two
of these are the language of electrical <emphasis>networks</emphasis> and the
language of electrical <emphasis>systems</emphasis>.  The network language emphasizes
the physical modeling of devices in terms of discrete electrical
elements.  The primitive objects of the network language are primitive
electrical components such as resistors, capacitors, inductors, and
transistors, which are characterized in terms of physical variables
called voltage and current.  When describing circuits in the network
language, the engineer is concerned with the physical characteristics
of a design.  In contrast, the primitive objects of the system
language are signal-processing modules such as filters and amplifiers.
Only the functional behavior of the modules is relevant, and signals
are manipulated without concern for their physical realization as
voltages and currents.  The system language is erected on the network
language, in the sense that the elements of signal-processing systems
are constructed from electrical networks.  Here, however, the concerns
are with the large-scale organization of electrical devices to solve a
given application problem; the physical feasibility of the parts is
assumed.  This layered collection of languages is another example of
the stratified design technique illustrated by the picture
language of section 2.2.4.</p>

<p><sup>2</sup> The most important features that our evaluator leaves out
are mechanisms for handling errors and supporting debugging.  For a
more extensive discussion of evaluators, see Friedman, Wand, and Haynes
1992, which gives an exposition of programming languages that proceeds
via a sequence of evaluators written in Scheme.</p>


</section>

<section>


<p><strong>4.1  The Metacircular Evaluator</strong></p>

<p>



Our evaluator for Lisp will be implemented as a Lisp program.  It may
seem circular to think about evaluating Lisp programs using an
evaluator that is itself implemented in Lisp.  However, evaluation is
a process, so it is appropriate to describe the evaluation process
using Lisp, which, after all, is our tool for describing
processes.<sup>3</sup>  An evaluator that is written in the same language
that it evaluates is said to be <emphasis>metacircular</emphasis>.</p>

<p>


The metacircular evaluator is essentially a Scheme formulation of the
environment model of evaluation described in
section 3.2.  Recall that the model has two
basic parts:</p>

<p>1. To evaluate a combination (a compound expression other than a 
special form), evaluate the subexpressions and then apply the value of
the operator subexpression to the values of the operand
subexpressions.</p>

<p>2. To apply a compound procedure to a set of arguments, evaluate the
body of the procedure in a new environment.  To construct this
environment, extend the environment part of the procedure object by a
frame in which the formal parameters of the procedure are bound to the
arguments to which the procedure is applied.</p>

<p>

These two rules describe the essence of the evaluation process, a
basic cycle in which expressions to be evaluated in environments are
reduced to procedures to be applied to arguments, which in turn are
reduced to new expressions to be evaluated in new environments, and so
on, until we get down to symbols, whose values are looked
up in the environment, and to primitive procedures, which are applied
directly (see figure 4.1).<sup>4</sup>
This evaluation cycle will be embodied by the interplay between the two
critical procedures in the evaluator, eval and apply,
which are described in section 4.1.1
(see figure 4.1).</p>

<p>

The implementation of the evaluator will depend upon procedures that
define the <emphasis>syntax</emphasis> of the expressions to be evaluated.  We will
use data abstraction to make the evaluator independent of the
representation of the language.  For example, rather than committing
to a choice that an assignment is to be represented by a list
beginning with the symbol set! we use an abstract predicate
assignment? to test for an assignment, and we use abstract
selectors assignment-variable and assignment-value to
access the parts of an assignment.  Implementation of expressions will
be described in detail in section 4.1.2.
There are also operations, described in
section 4.1.3, that specify the
representation of procedures and environments.  For example, make-procedure constructs compound procedures, lookup-variable-value accesses the values of variables, and apply-primitive-procedure applies a primitive procedure to a given list
of arguments.</p>

<p><strong>4.1.1  The Core of the Evaluator</strong></p>

<p><image xlink:href="#_194.jpg" /></p>

<p><strong>Figure 4.1:</strong>  The eval-apply cycle exposes the essence
of a computer language.</p>

<p>

The evaluation process can be described as the interplay between two
procedures: eval and apply.</p>

<p><strong>Eval</strong></p>

<p>

Eval takes as arguments an expression and an environment.  It
classifies the expression and directs its evaluation.  Eval is
structured as a case analysis of the syntactic type of the expression
to be evaluated.  In order to keep the procedure general, we express
the determination of the type of an expression abstractly, making no
commitment to any particular representation for the various types of
expressions.  Each type of expression has a predicate that tests for
it and an abstract means for selecting its parts.  This <emphasis>abstract
syntax</emphasis> makes it easy to see how we can change the syntax of the
language by using the same evaluator, but with a different collection of
syntax procedures.</p>

<p><strong>Primitive expressions</strong></p>

<p>For self-evaluating expressions, such as numbers, eval returns
the expression itself.</p>

<p>Eval must look up variables in the environment to find their values.</p>

<p><strong>Special forms</strong></p><empty-line /><p>For quoted expressions, eval returns the expression that was
quoted.</p>

<p>An assignment to (or a definition of) a variable must recursively call
eval to compute the new value to be associated with the
variable.  The environment must be modified to change (or create) the
binding of the variable.</p>

<p>An if expression requires special processing of its parts, so as to
evaluate the consequent if the predicate is true, and otherwise to
evaluate the alternative.</p>

<p>A lambda expression must be transformed into an
applicable procedure by packaging together the parameters and body
specified by the lambda expression with the environment of the
evaluation.</p>

<p>A begin expression requires evaluating its sequence of
expressions in the order in which they appear.</p>

<p>A case analysis (cond) is transformed into a nest of if
expressions and then evaluated.</p>

<p><strong>Combinations</strong></p>

<p>For a procedure application, eval must recursively
evaluate the operator part and the operands of the combination.  The
resulting procedure and arguments are passed to apply, which
handles the actual procedure application.</p><empty-line /><p>Here is the definition of eval:</p>

<p>(define (eval exp env)</p><empty-line /><p>
  (cond ((self-evaluating? exp) exp)</p><empty-line /><p>
        ((variable? exp) (lookup-variable-value exp env))</p><empty-line /><p>
        ((quoted? exp) (text-of-quotation exp))</p><empty-line /><p>
        ((assignment? exp) (eval-assignment exp env))</p><empty-line /><p>
        ((definition? exp) (eval-definition exp env))</p><empty-line /><p>
        ((if? exp) (eval-if exp env))</p><empty-line /><p>
        ((lambda? exp)</p><empty-line /><p>
         (make-procedure (lambda-parameters exp)</p><empty-line /><p>
                         (lambda-body exp)</p><empty-line /><p>
                         env))</p><empty-line /><p>
        ((begin? exp)</p><empty-line /><p>
         (eval-sequence (begin-actions exp) env))</p><empty-line /><p>
        ((cond? exp) (eval (cond-&gt;if exp) env))</p><empty-line /><p>
        ((application? exp)</p><empty-line /><p>
         (apply (eval (operator exp) env)</p><empty-line /><p>
                (list-of-values (operands exp) env)))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (error "Unknown expression type -- EVAL" exp))))</p><empty-line /><empty-line /><p>

For clarity, eval has been implemented as a case analysis using
cond.  The disadvantage of this is that our procedure handles
only a few distinguishable types of expressions, and no new ones can
be defined without editing the definition of eval.  In most Lisp
implementations, dispatching on the type of an expression is done in a
data-directed style.  This allows a user to add new types of
expressions that eval can distinguish, without modifying the
definition of eval itself.
(See exercise 4.3.)</p>

<p><strong>Apply</strong></p>

<p>

Apply takes two arguments, a procedure and a list of arguments
to which the procedure should be applied.  Apply classifies
procedures into two kinds: It calls apply-primitive-procedure to apply primitives; it applies compound
procedures by sequentially evaluating the expressions that
make up the body of the procedure.  The environment for the
evaluation of the body of a compound procedure
is constructed by extending the base environment carried by
the procedure to include a frame that binds the parameters of the
procedure to the arguments to which the procedure is to be applied.
Here is the definition of apply:</p>

<p>(define (apply procedure arguments)</p><empty-line /><p>
  (cond ((primitive-procedure? procedure)</p><empty-line /><p>
         (apply-primitive-procedure procedure arguments))</p><empty-line /><p>
        ((compound-procedure? procedure)</p><empty-line /><p>
         (eval-sequence</p><empty-line /><p>
           (procedure-body procedure)</p><empty-line /><p>
           (extend-environment</p><empty-line /><p>
             (procedure-parameters procedure)</p><empty-line /><p>
             arguments</p><empty-line /><p>
             (procedure-environment procedure))))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (error</p><empty-line /><p>
          "Unknown procedure type -- APPLY" procedure))))</p><empty-line /><empty-line /><p><strong>Procedure arguments</strong></p>

<p>

When eval processes a
procedure application, it uses list-of-values to produce the
list of arguments to which the procedure is to be applied. List-of-values takes as an argument the operands of the combination.
It evaluates each operand and returns a list of the corresponding
values:<sup>5</sup></p>

<p>(define (list-of-values exps env)</p><empty-line /><p>
  (if (no-operands? exps)</p><empty-line /><p>
      '()</p><empty-line /><p>
      (cons (eval (first-operand exps) env)</p><empty-line /><p>
            (list-of-values (rest-operands exps) env))))</p><empty-line /><empty-line /><p><strong>Conditionals</strong></p>

<p>

Eval-if evaluates the predicate part of an if expression
in the given environment.  If
the result is true, eval-if evaluates the consequent, otherwise
it evaluates the alternative:</p>

<p>(define (eval-if exp env)</p><empty-line /><p>
  (if (true? (eval (if-predicate exp) env))</p><empty-line /><p>
      (eval (if-consequent exp) env)</p><empty-line /><p>
      (eval (if-alternative exp) env)))</p><empty-line /><empty-line /><p>

The use of true? in eval-if highlights the issue of the
connection between an implemented language and an implementation
language.  The if-predicate is evaluated in the language being
implemented and thus yields a value in that language.  The interpreter
predicate true? translates that value into a value that can be
tested by the if in the implementation language: The
metacircular representation of truth might not be the same as that of
the underlying Scheme.<sup>6</sup></p>

<p><strong>Sequences</strong></p>

<p>

Eval-sequence is used by apply to evaluate the sequence of
expressions in a procedure body and by eval to evaluate the
sequence of expressions in a begin
expression.  It takes as arguments a sequence of expressions and an
environment, and evaluates the expressions in the order in which they
occur.  The value returned is the value of the final expression.</p>

<p>(define (eval-sequence exps env)</p><empty-line /><p>
  (cond ((last-exp? exps) (eval (first-exp exps) env))</p><empty-line /><p>
        (else (eval (first-exp exps) env)</p><empty-line /><p>
              (eval-sequence (rest-exps exps) env))))</p><empty-line /><empty-line /><p><strong>Assignments and definitions</strong></p>

<p>

The following procedure handles assignments to variables.  It calls
eval to find the value to be assigned and transmits the variable
and the resulting value to set-variable-value! to be installed
in the designated environment.</p>

<p>(define (eval-assignment exp env)</p><empty-line /><p>
  (set-variable-value! (assignment-variable exp)</p><empty-line /><p>
                       (eval (assignment-value exp) env)</p><empty-line /><p>
                       env)</p><empty-line /><p>
  'ok)</p><empty-line /><p>
Definitions of variables are handled in a similar
manner.<sup>7</sup></p>

<p>(define (eval-definition exp env)</p><empty-line /><p>
  (define-variable! (definition-variable exp)</p><empty-line /><p>
                    (eval (definition-value exp) env)</p><empty-line /><p>
                    env)</p><empty-line /><p>
  'ok)</p><empty-line /><p>
We have chosen here to return the symbol ok as the value
of an assignment or a definition.<sup>8</sup></p>

<p>
<strong>Exercise 4.1.</strong>  Notice that we cannot tell whether the metacircular evaluator
evaluates operands from left to right or from right to left.  Its evaluation
order is inherited from the underlying Lisp:
If the arguments to cons in list-of-values
are evaluated from left to right, then list-of-values will
evaluate operands from left to right; and 
if the arguments to cons
are evaluated from right to left, then list-of-values will
evaluate operands from right to left.</p>

<p>

Write a version of list-of-values that evaluates operands
from left to right regardless of the order of evaluation in the underlying
Lisp.  Also write a version of list-of-values that evaluates operands
from right to left.</p>

<p><strong>4.1.2  Representing Expressions</strong></p>

<p>



The evaluator is reminiscent of the symbolic differentiation program
discussed in section 2.3.2.  Both
programs operate on symbolic expressions.  In both programs, the
result of operating on a compound expression is determined by
operating recursively on the pieces of the expression and combining
the results in a way that depends on the type of the expression.  In
both programs we used data abstraction to decouple the general rules
of operation from the details of how expressions are represented.  In
the differentiation program this meant that the same differentiation
procedure could deal with algebraic expressions in prefix form, in
infix form, or in some other form.  For the evaluator, this means that
the syntax of the language being evaluated is determined solely by the
procedures that classify and extract pieces of expressions.</p>

<p>Here is the specification of the syntax of our language:</p>

<p>

¤ The only self-evaluating items are numbers and
strings:</p>

<p>(define (self-evaluating? exp)</p><empty-line /><p>
  (cond ((number? exp) true)</p><empty-line /><p>
        ((string? exp) true)</p><empty-line /><p>
        (else false)))</p><empty-line /><p>
¤ Variables are represented by symbols:</p>

<p>(define (variable? exp) (symbol? exp))</p><empty-line /><p>
¤ Quotations have the form (quote
&lt;<emphasis>text-of-quotation</emphasis>&gt;):<sup>9</sup></p>

<p>(define (quoted? exp)</p><empty-line /><p>
  (tagged-list? exp 'quote))</p><empty-line /><empty-line /><p>(define (text-of-quotation exp) (cadr exp))</p><empty-line /><p>
Quoted? is defined in terms of the procedure tagged-list?, which identifies lists beginning with a designated
symbol:</p>

<p>(define (tagged-list? exp tag)</p><empty-line /><p>
  (if (pair? exp)</p><empty-line /><p>
      (eq? (car exp) tag)</p><empty-line /><p>
      false))</p><empty-line /><p>
¤ Assignments have the form (set!
&lt;<emphasis>var</emphasis>&gt; &lt;<emphasis>value</emphasis>&gt;):</p>

<p>(define (assignment? exp)</p><empty-line /><p>
  (tagged-list? exp 'set!))</p><empty-line /><p>(define (assignment-variable exp) (cadr exp))</p><empty-line /><p>(define (assignment-value exp) (caddr exp))</p><empty-line /><p>
¤ Definitions have the form</p>

<p>(define &lt;<emphasis>var</emphasis>&gt; &lt;<emphasis>value</emphasis>&gt;)</p><empty-line /><p>
or the form</p>

<p>(define (&lt;<emphasis>var</emphasis>&gt; &lt;<emphasis>parameter<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>parameter<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
  &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
The latter form (standard procedure definition) is syntactic sugar for</p>

<p>(define &lt;<emphasis>var</emphasis>&gt;</p><empty-line /><p>
  (lambda (&lt;<emphasis>parameter<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>parameter<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
    &lt;<emphasis>body</emphasis>&gt;))</p><empty-line /><p>
The corresponding syntax procedures are the following:</p>

<p>(define (definition? exp)</p><empty-line /><p>
  (tagged-list? exp 'define))</p><empty-line /><p>(define (definition-variable exp)</p><empty-line /><p>
  (if (symbol? (cadr exp))</p><empty-line /><p>
      (cadr exp)</p><empty-line /><p>
      (caadr exp)))</p><empty-line /><p>(define (definition-value exp)</p><empty-line /><p>
  (if (symbol? (cadr exp))</p><empty-line /><p>
      (caddr exp)</p><empty-line /><p>
      (make-lambda (cdadr exp)   <emphasis>; formal parameters</emphasis></p><empty-line /><p>
                   (cddr exp)))) <emphasis>; body</emphasis></p><empty-line /><p>
¤ Lambda expressions are lists that begin with the
symbol lambda:</p>

<p>(define (lambda? exp) (tagged-list? exp 'lambda))</p><empty-line /><p>(define (lambda-parameters exp) (cadr exp))</p><empty-line /><p>(define (lambda-body exp) (cddr exp))</p><empty-line /><p>
We also provide a constructor for lambda expressions,
which is used by definition-value, above:</p>

<p>(define (make-lambda parameters body)</p><empty-line /><p>
  (cons 'lambda (cons parameters body)))</p><empty-line /><p>
¤ Conditionals begin with if and have a predicate, a
consequent, and an (optional) alternative.  If the expression has no
alternative part, we provide false as the alternative.<sup>10</sup></p>

<p>(define (if? exp) (tagged-list? exp 'if))</p><empty-line /><p>(define (if-predicate exp) (cadr exp))</p><empty-line /><p>(define (if-consequent exp) (caddr exp))</p><empty-line /><p>(define (if-alternative exp)</p><empty-line /><p>
  (if (not (null? (cdddr exp)))</p><empty-line /><p>
      (cadddr exp)</p><empty-line /><p>
      'false))</p><empty-line /><p>
We also provide a constructor for if expressions,
to be used by cond-&gt;if to transform cond expressions
into if expressions:</p>

<p>(define (make-if predicate consequent alternative)</p><empty-line /><p>
  (list 'if predicate consequent alternative))</p><empty-line /><p>
¤ Begin packages a sequence of expressions into a single
expression.  We include syntax operations on begin expressions
to extract the actual sequence from the begin expression, as
well as selectors that return the first expression and the rest of the
expressions in the sequence.<sup>11</sup></p>

<p>(define (begin? exp) (tagged-list? exp 'begin))</p><empty-line /><p>(define (begin-actions exp) (cdr exp))</p><empty-line /><p>(define (last-exp? seq) (null? (cdr seq)))</p><empty-line /><p>(define (first-exp seq) (car seq))</p><empty-line /><p>(define (rest-exps seq) (cdr seq))</p><empty-line /><p>
We also include a constructor sequence-&gt;exp (for use by
cond-&gt;if) that transforms a sequence into a single expression,
using begin if necessary:</p>

<p>(define (sequence-&gt;exp seq)</p><empty-line /><p>
  (cond ((null? seq) seq)</p><empty-line /><p>
        ((last-exp? seq) (first-exp seq))</p><empty-line /><p>
        (else (make-begin seq))))</p><empty-line /><p>(define (make-begin seq) (cons 'begin seq))</p><empty-line /><p>
¤ A procedure application is any compound expression
that is not one of the above expression types.  The car of the
expression is the operator, and the cdr is the list of operands:</p>

<p>(define (application? exp) (pair? exp))</p><empty-line /><p>(define (operator exp) (car exp))</p><empty-line /><p>(define (operands exp) (cdr exp))</p><empty-line /><p>(define (no-operands? ops) (null? ops))</p><empty-line /><p>(define (first-operand ops) (car ops))</p><empty-line /><p>(define (rest-operands ops) (cdr ops))</p><empty-line /><empty-line /><p><strong>Derived expressions</strong></p>

<p>


Some special forms in our language can be defined in terms of
expressions involving other special forms, rather than being
implemented directly.  One example is cond, which can be
implemented as a nest of if expressions.  For example,
we can reduce the problem of evaluating the expression</p>

<p>(cond ((&gt; x 0) x)</p><empty-line /><p>
      ((= x 0) (display 'zero) 0)</p><empty-line /><p>
      (else (- x)))</p><empty-line /><p>
to the problem of evaluating the following
expression involving if and begin expressions:</p>

<p>(if (&gt; x 0)</p><empty-line /><p>
    x</p><empty-line /><p>
    (if (= x 0)</p><empty-line /><p>
        (begin (display 'zero)</p><empty-line /><p>
               0)</p><empty-line /><p>
        (- x)))</p><empty-line /><p>

Implementing the evaluation of cond in this way
simplifies the evaluator because it reduces the number of special
forms for which the evaluation process must be explicitly specified.</p>

<p>

We include syntax procedures that extract the parts of a cond
expression, and a procedure cond-&gt;if that transforms cond
expressions into if expressions.  A case analysis begins with cond and has a list of predicate-action clauses.  A clause is an else clause if its predicate is the symbol else.<sup>12</sup></p>

<p>(define (cond? exp) (tagged-list? exp 'cond))</p><empty-line /><p>(define (cond-clauses exp) (cdr exp))</p><empty-line /><p>(define (cond-else-clause? clause)</p><empty-line /><p>
  (eq? (cond-predicate clause) 'else))</p><empty-line /><p>(define (cond-predicate clause) (car clause))</p><empty-line /><p>(define (cond-actions clause) (cdr clause))</p><empty-line /><p>(define (cond-&gt;if exp)</p><empty-line /><p>
  (expand-clauses (cond-clauses exp)))</p><empty-line /><empty-line /><p>(define (expand-clauses clauses)</p><empty-line /><p>
  (if (null? clauses)</p><empty-line /><p>
      'false                          <emphasis>; no else clause</emphasis></p><empty-line /><p>
      (let ((first (car clauses))</p><empty-line /><p>
            (rest (cdr clauses)))</p><empty-line /><p>
        (if (cond-else-clause? first)</p><empty-line /><p>
            (if (null? rest)</p><empty-line /><p>
                (sequence-&gt;exp (cond-actions first))</p><empty-line /><p>
                (error "ELSE clause isn't last -- COND-&gt;IF"</p><empty-line /><p>
                       clauses))</p><empty-line /><p>
            (make-if (cond-predicate first)</p><empty-line /><p>
                     (sequence-&gt;exp (cond-actions first))</p><empty-line /><p>
                     (expand-clauses rest))))))</p><empty-line /><empty-line /><p>

Expressions (such as cond) that we choose to implement as syntactic
transformations are called <emphasis>derived expressions</emphasis>.
Let expressions are also derived expressions
(see exercise 4.6).<sup>13</sup></p>

<p>
<strong>Exercise 4.2.</strong>  Louis Reasoner plans to reorder the cond clauses
in eval so that the clause for procedure applications appears
before the clause for assignments.  He argues that this will make the
interpreter more efficient:  Since programs usually contain more
applications than assignments, definitions, and so on,
his modified eval will usually check fewer
clauses than the original eval before identifying the type of an
expression.</p>

<p>a. What is wrong with Louis's plan?  (Hint: What will
Louis's evaluator do with the expression (define x 3)?)</p>

<p>b. Louis is upset that his plan didn't work.
He is willing to go to any lengths to make his evaluator
recognize procedure applications before it checks for most other
kinds of expressions.
Help him by changing the syntax of the evaluated language so that
procedure applications start with call.  For example, instead of
(factorial 3) we will now have to write (call factorial 3)
and instead of (+ 1 2) we will have to write (call + 1 2).</p>

<p>
<strong>Exercise 4.3.</strong>  Rewrite eval so that the dispatch is done in data-directed
style.  Compare this with the data-directed
differentiation procedure of
exercise 2.73.
(You may use the car of a compound expression as the
type of the expression, as is appropriate for the syntax implemented
in this section.)
.</p>

<p>
<strong>Exercise 4.4.</strong>  Recall the definitions of the special forms and and or
from chapter 1:</p>

<p>and: The expressions are evaluated from
left to right.  If any expression evaluates to
false, false is returned; any remaining expressions are not
evaluated.  If all the expressions evaluate to true values, the value
of the last expression is returned.  If there are no expressions then
true is returned.</p>

<p>or: The expressions are evaluated from left to right.  If any
expression evaluates to a true value, that value is
returned; any remaining expressions are not evaluated.  If all
expressions evaluate to false, or if there are no expressions,
then false is returned.</p>

<p>
Install and and or as new special forms for the evaluator
by defining appropriate syntax procedures and evaluation
procedures eval-and and eval-or.  Alternatively, show how
to implement and and or as derived expressions.</p>

<p>
<strong>Exercise 4.5.</strong>  Scheme allows an additional syntax for cond clauses, (&lt;<emphasis>test</emphasis>&gt; =&gt; &lt;<emphasis>recipient</emphasis>&gt;).  If &lt;<emphasis>test</emphasis>&gt;
evaluates to a true value, then &lt;<emphasis>recipient</emphasis>&gt; is evaluated.  Its
value must be a procedure of one argument; this procedure is then
invoked on the value of the &lt;<emphasis>test</emphasis>&gt;, and the result is returned as
the value of the cond expression.  For example</p>

<p>(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)</p><empty-line /><p>
      (else false))</p><empty-line /><p>
returns 2.
Modify the handling of cond so that it supports this extended
syntax.</p>

<p>
<strong>Exercise 4.6.</strong>  Let expressions are derived expressions, because</p>

<p>(let ((&lt;<emphasis>var<sub>1</sub></emphasis>&gt; &lt;<emphasis>exp<sub>1</sub></emphasis>&gt;) ... (&lt;<emphasis>var<sub>n</sub></emphasis>&gt; &lt;<emphasis>exp<sub>n</sub></emphasis>&gt;))</p><empty-line /><p>
  &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
is equivalent to</p>

<p>((lambda (&lt;<emphasis>var<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>var<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
   &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
 &lt;<emphasis>exp<sub>1</sub></emphasis>&gt;</p><empty-line /><p>
 <image xlink:href="#_5.jpg" /></p><empty-line /><p>
 &lt;<emphasis>exp<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
Implement a syntactic transformation let-&gt;combination that
reduces evaluating let expressions to evaluating combinations of
the type shown above, and add the appropriate clause to eval to
handle let expressions.</p>

<p>
<strong>Exercise 4.7.</strong>  Let* is similar to let, except that the bindings of the let variables are performed sequentially from left to right, and each
binding is made in an environment in which all of the preceding
bindings are visible.  For example</p>

<p>(let* ((x 3)</p><empty-line /><p>
       (y (+ x 2))</p><empty-line /><p>
       (z (+ x y 5)))</p><empty-line /><p>
  (* x z))</p><empty-line /><p>
returns 39.  Explain how a let* expression can be rewritten as a
set of nested let expressions, and write a procedure let*-&gt;nested-lets that performs this transformation.  If we
have already implemented let (exercise 4.6)
and we want to
extend the evaluator to handle let*, is it sufficient to add
a clause to eval whose action is</p>

<p>(eval (let*-&gt;nested-lets exp) env)</p><empty-line /><p>
or must we
explicitly expand let* in terms of non-derived expressions?</p>

<p>
<strong>Exercise 4.8.</strong>  "Named let" is a variant of let that has the form</p>

<p>(let &lt;<emphasis>var</emphasis>&gt; &lt;<emphasis>bindings</emphasis>&gt; &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
The &lt;<emphasis>bindings</emphasis>&gt; and &lt;<emphasis>body</emphasis>&gt; are just as in ordinary let, except that &lt;<emphasis>var</emphasis>&gt; is bound within &lt;<emphasis>body</emphasis>&gt; to a
procedure whose body is &lt;<emphasis>body</emphasis>&gt; and whose parameters are the
variables in the &lt;<emphasis>bindings</emphasis>&gt;.  Thus, one can repeatedly execute the
&lt;<emphasis>body</emphasis>&gt; by invoking the procedure named &lt;<emphasis>var</emphasis>&gt;.  For example,
the iterative Fibonacci procedure (section 1.2.2)
can be rewritten using named let as follows:</p>

<p>(define (fib n)</p><empty-line /><p>
  (let fib-iter ((a 1)</p><empty-line /><p>
                 (b 0)</p><empty-line /><p>
                 (count n))</p><empty-line /><p>
    (if (= count 0)</p><empty-line /><p>
        b</p><empty-line /><p>
        (fib-iter (+ a b) a (- count 1)))))</p><empty-line /><p>
Modify let-&gt;combination of exercise 4.6 to
also support named let.</p>

<p>
<strong>Exercise 4.9.</strong>  Many languages support a variety of iteration constructs, such as do, for, while, and until.  In Scheme,
iterative processes can be expressed in terms of ordinary procedure
calls, so special iteration constructs provide no essential gain in
computational power.  On the other hand, such constructs are often
convenient.  Design some iteration constructs, give examples of their
use, and show how to implement them as derived expressions.</p>

<p>
<strong>Exercise 4.10.</strong>  By using data abstraction, we were able to write an eval
procedure that is independent of the particular syntax of the language
to be evaluated.  To illustrate this, design and implement a new
syntax for Scheme by modifying the procedures in this section, without
changing eval or apply.</p>

<p><strong>4.1.3  Evaluator Data Structures</strong></p>

<p>

In addition to defining the external syntax of expressions, the
evaluator implementation must also define the data structures that the
evaluator manipulates internally, as part of the execution of a
program, such as the representation of procedures and environments and
the representation of true and false.</p>

<p><strong>Testing of predicates</strong></p>

<p>

For conditionals, we accept anything to be true that is not
the explicit false object.</p>

<p>(define (true? x)</p><empty-line /><p>
  (not (eq? x false)))</p><empty-line /><p>(define (false? x)</p><empty-line /><p>
  (eq? x false))</p><empty-line /><empty-line /><p><strong>Representing procedures</strong></p>

<p>


To handle primitives, we assume that we have available the
following procedures:</p>

<p>(apply-primitive-procedure &lt;<emphasis>proc</emphasis>&gt; &lt;<emphasis>args</emphasis>&gt;)</p><empty-line /><p>
applies the given primitive procedure to the argument values in the
list &lt;<emphasis>args</emphasis>&gt; and returns the result of the application.</p>

<p>(primitive-procedure? &lt;<emphasis>proc</emphasis>&gt;)</p><empty-line /><p>
tests whether &lt;<emphasis>proc</emphasis>&gt; is a primitive procedure.</p>

<p>

These mechanisms for handling primitives are further described in
section 4.1.4.</p>

<p>

Compound procedures are constructed from parameters, procedure
bodies, and environments using the constructor make-procedure:</p>

<p>(define (make-procedure parameters body env)</p><empty-line /><p>
  (list 'procedure parameters body env))</p><empty-line /><p>(define (compound-procedure? p)</p><empty-line /><p>
  (tagged-list? p 'procedure))</p><empty-line /><p>(define (procedure-parameters p) (cadr p))</p><empty-line /><p>(define (procedure-body p) (caddr p))</p><empty-line /><p>(define (procedure-environment p) (cadddr p))</p><empty-line /><empty-line /><p><strong>Operations on Environments</strong></p>

<p>



The evaluator needs operations for manipulating environments.  As
explained in section 3.2, an environment is a
sequence of frames, where each frame is a table of bindings that
associate variables with their corresponding values.  We use
the following operations for manipulating environments:</p>

<p>(lookup-variable-value &lt;<emphasis>var</emphasis>&gt; &lt;<emphasis>env</emphasis>&gt;)</p><empty-line /><p>
returns the value that is bound to the symbol &lt;<emphasis>var</emphasis>&gt; in the
environment &lt;<emphasis>env</emphasis>&gt;, or signals an error if the variable is unbound.</p>

<p>(extend-environment &lt;<emphasis>variables</emphasis>&gt; &lt;<emphasis>values</emphasis>&gt; &lt;<emphasis>base-env</emphasis>&gt;)</p><empty-line /><p>
returns a new environment, consisting of a new frame in which the
symbols in the list &lt;<emphasis>variables</emphasis>&gt; are bound to the corresponding
elements in the list &lt;<emphasis>values</emphasis>&gt;, where the enclosing environment is
the environment &lt;<emphasis>base-env</emphasis>&gt;.</p>

<p>(define-variable! &lt;<emphasis>var</emphasis>&gt; &lt;<emphasis>value</emphasis>&gt; &lt;<emphasis>env</emphasis>&gt;)</p><empty-line /><p>
adds to the first frame in the environment &lt;<emphasis>env</emphasis>&gt; a new binding that
associates the variable &lt;<emphasis>var</emphasis>&gt; with the value &lt;<emphasis>value</emphasis>&gt;.</p>

<p>(set-variable-value! &lt;<emphasis>var</emphasis>&gt; &lt;<emphasis>value</emphasis>&gt; &lt;<emphasis>env</emphasis>&gt;)</p><empty-line /><p>
changes the binding of the variable &lt;<emphasis>var</emphasis>&gt; in the environment &lt;<emphasis>env</emphasis>&gt;
so that the variable is now bound to the value &lt;<emphasis>value</emphasis>&gt;, or signals
an error if the variable is unbound.</p>

<p>

To implement these operations we represent an environment as a list of
frames.  The enclosing environment of an environment is the cdr of
the list.  The empty environment is simply the empty list.</p>

<p>(define (enclosing-environment env) (cdr env))</p><empty-line /><p>(define (first-frame env) (car env))</p><empty-line /><p>
(define the-empty-environment '())</p><empty-line /><p>
Each frame of an environment is represented as a pair of lists: a list
of the variables bound in that frame and a list of the associated values.<sup>14</sup></p>

<p>(define (make-frame variables values)</p><empty-line /><p>
  (cons variables values))</p><empty-line /><p>(define (frame-variables frame) (car frame))</p><empty-line /><p>(define (frame-values frame) (cdr frame))</p><empty-line /><p>(define (add-binding-to-frame! var val frame)</p><empty-line /><p>
  (set-car! frame (cons var (car frame)))</p><empty-line /><p>
  (set-cdr! frame (cons val (cdr frame))))</p><empty-line /><empty-line /><p>

To extend an environment by a new frame that associates variables with
values, we make a frame consisting of the list of variables and the
list of values, and we adjoin this to the environment.  We signal
an error if the number of variables does not match the number of values.</p>

<p>(define (extend-environment vars vals base-env)</p><empty-line /><p>
  (if (= (length vars) (length vals))</p><empty-line /><p>
      (cons (make-frame vars vals) base-env)</p><empty-line /><p>
      (if (&lt; (length vars) (length vals))</p><empty-line /><p>
          (error "Too many arguments supplied" vars vals)</p><empty-line /><p>
          (error "Too few arguments supplied" vars vals))))</p><empty-line /><empty-line /><p>


To look up a variable in an environment, we scan the list of variables
in the first frame.  If we find the desired variable, we return
the corresponding element in the list of values.  If we do not find
the variable in the current frame, we search the enclosing environment,
and so on.  If we reach the empty environment, we signal an "unbound
variable" error.</p>

<p>(define (lookup-variable-value var env)</p><empty-line /><p>
  (define (env-loop env)</p><empty-line /><p>
    (define (scan vars vals)</p><empty-line /><p>
      (cond ((null? vars)</p><empty-line /><p>
             (env-loop (enclosing-environment env)))</p><empty-line /><p>
            ((eq? var (car vars))</p><empty-line /><p>
             (car vals))</p><empty-line /><p>
            (else (scan (cdr vars) (cdr vals)))))</p><empty-line /><p>
    (if (eq? env the-empty-environment)</p><empty-line /><p>
        (error "Unbound variable" var)</p><empty-line /><p>
        (let ((frame (first-frame env)))</p><empty-line /><p>
          (scan (frame-variables frame)</p><empty-line /><p>
                (frame-values frame)))))</p><empty-line /><p>
  (env-loop env))</p><empty-line /><empty-line /><p>

To set a variable to a new value in a specified environment, we scan
for the variable, just as in lookup-variable-value, and change
the corresponding value when we find it.</p>

<p>(define (set-variable-value! var val env)</p><empty-line /><p>
  (define (env-loop env)</p><empty-line /><p>
    (define (scan vars vals)</p><empty-line /><p>
      (cond ((null? vars)</p><empty-line /><p>
             (env-loop (enclosing-environment env)))</p><empty-line /><p>
            ((eq? var (car vars))</p><empty-line /><p>
             (set-car! vals val))</p><empty-line /><p>
            (else (scan (cdr vars) (cdr vals)))))</p><empty-line /><p>
    (if (eq? env the-empty-environment)</p><empty-line /><p>
        (error "Unbound variable -- SET!" var)</p><empty-line /><p>
        (let ((frame (first-frame env)))</p><empty-line /><p>
          (scan (frame-variables frame)</p><empty-line /><p>
                (frame-values frame)))))</p><empty-line /><p>
  (env-loop env))</p><empty-line /><empty-line /><p>

To define a variable, we search the first frame for a binding for
the variable, and change the binding if it exists
(just as in set-variable-value!).  If no such binding
exists, we adjoin one to the first frame.</p>

<p>(define (define-variable! var val env)</p><empty-line /><p>
  (let ((frame (first-frame env)))</p><empty-line /><p>
    (define (scan vars vals)</p><empty-line /><p>
      (cond ((null? vars)</p><empty-line /><p>
             (add-binding-to-frame! var val frame))</p><empty-line /><p>
            ((eq? var (car vars))</p><empty-line /><p>
             (set-car! vals val))</p><empty-line /><p>
            (else (scan (cdr vars) (cdr vals)))))</p><empty-line /><p>
    (scan (frame-variables frame)</p><empty-line /><p>
          (frame-values frame))))</p><empty-line /><empty-line /><p>

The method described here is only one of many plausible ways to
represent environments.  Since we used data abstraction to isolate the
rest of the evaluator from the detailed choice of representation, we
could change the environment representation if we wanted to.  (See
exercise 4.11.)  In a
production-quality Lisp system, the speed of the evaluator's
environment operations -- especially that of variable lookup -- has a
major impact on the performance of the system.  The representation
described here, although conceptually simple, is not efficient and
would not ordinarily be used in a production system.<sup>15</sup></p>

<p>
<strong>Exercise 4.11.</strong>  Instead of representing a frame as a pair of lists, we can represent a
frame as a list of bindings, where each binding is a name-value pair.
Rewrite the environment operations to use this alternative
representation.</p>

<p>
<strong>Exercise 4.12.</strong>  The procedures set-variable-value!, define-variable!,
and lookup-variable-value can be expressed in terms of
more abstract procedures for traversing the environment structure.
Define abstractions that capture the common patterns and redefine
the three procedures in terms of these abstractions.</p>

<p>
<strong>Exercise 4.13.</strong>  Scheme allows us to create new bindings for variables by means of define, but provides no way to get rid of bindings.  Implement for
the evaluator a special form make-unbound! that removes the
binding of a given symbol from the environment in which the
make-unbound! expression is evaluated.
This problem is not completely specified.  For example,
should we remove only the binding in the first frame of the
environment?  Complete the specification and justify any choices you
make.</p>

<p><strong>4.1.4  Running the Evaluator as a Program</strong></p>

<p>



Given the evaluator, we have in our hands a description
(expressed in Lisp) of the process
by which Lisp expressions are evaluated.  One advantage of expressing the
evaluator as a program is that we can run the program.  This gives us,
running within Lisp, a working model of how Lisp itself evaluates
expressions.  This can serve as a framework for experimenting with
evaluation rules, as we shall do later in this chapter.</p>

<p>

Our evaluator program reduces expressions ultimately to the
application of primitive procedures.  Therefore, all that we need to
run the evaluator is to create a mechanism that calls on the underlying
Lisp system to model the application of primitive procedures.</p>

<p>

There must be a binding for each primitive procedure name, so that when
eval evaluates the operator of an application of a primitive, it
will find an object to pass to apply.  We thus set up a global
environment that associates unique objects with the names of the
primitive procedures that can appear
in the expressions we will be evaluating.  The
global environment also includes bindings for the symbols true and
false, so that they can be used as variables in expressions
to be evaluated.</p>

<p>(define (setup-environment)</p><empty-line /><p>
  (let ((initial-env</p><empty-line /><p>
         (extend-environment (primitive-procedure-names)</p><empty-line /><p>
                             (primitive-procedure-objects)</p><empty-line /><p>
                             the-empty-environment)))</p><empty-line /><p>
    (define-variable! 'true true initial-env)</p><empty-line /><p>
    (define-variable! 'false false initial-env)</p><empty-line /><p>
    initial-env))</p><empty-line /><p>(define the-global-environment (setup-environment))</p><empty-line /><empty-line /><p>

It does not matter how we represent the primitive procedure objects,
so long as apply can identify and apply them by using the
procedures primitive-procedure? and apply-primitive-procedure.  We have chosen to represent a primitive
procedure as a list beginning with the symbol primitive and
containing a procedure in the underlying Lisp that implements that primitive.</p>

<p>(define (primitive-procedure? proc)</p><empty-line /><p>
  (tagged-list? proc 'primitive))</p><empty-line /><empty-line /><p>(define (primitive-implementation proc) (cadr proc))</p><empty-line /><empty-line /><p>

Setup-environment will get the primitive names and implementation
procedures from a list:<sup>16</sup></p>

<p>(define primitive-procedures</p><empty-line /><p>
  (list (list 'car car)</p><empty-line /><p>
        (list 'cdr cdr)</p><empty-line /><p>
        (list 'cons cons)</p><empty-line /><p>
        (list 'null? null?)</p><empty-line /><p>
        &lt;<emphasis>more primitives</emphasis>&gt;</p><empty-line /><p>
        ))</p><empty-line /><p>(define (primitive-procedure-names)</p><empty-line /><p>
  (map car</p><empty-line /><p>
       primitive-procedures))</p><empty-line /><empty-line /><p>
(define (primitive-procedure-objects)</p><empty-line /><p>  (map (lambda (proc) (list 'primitive (cadr proc)))</p><empty-line /><p>
       primitive-procedures))</p><empty-line /><empty-line /><p>

To apply a primitive procedure, we simply apply the implementation
procedure to the arguments, using the underlying Lisp system:<sup>17</sup></p>

<p>(define (apply-primitive-procedure proc args)</p><empty-line /><p>
  (apply-in-underlying-scheme</p><empty-line /><p>
   (primitive-implementation proc) args))</p><empty-line /><empty-line /><p>

For convenience in running the metacircular evaluator, we provide a <emphasis>driver loop</emphasis> that models the read-eval-print loop of the underlying
Lisp system.  It prints a <emphasis>prompt</emphasis>, reads an input expression,
evaluates this expression in the global environment, and prints the
result.  We precede each printed result by an <emphasis>output prompt</emphasis> so
as to distinguish the value of the expression from other
output that may be printed.<sup>18</sup></p>

<p>(define input-prompt ";;; M-Eval input:")</p><empty-line /><p>
(define output-prompt ";;; M-Eval value:")</p><empty-line /><p>(define (driver-loop)</p><empty-line /><p>
  (prompt-for-input input-prompt)</p><empty-line /><p>
  (let ((input (read)))</p><empty-line /><p>
    (let ((output (eval input the-global-environment)))</p><empty-line /><p>
      (announce-output output-prompt)</p><empty-line /><p>
      (user-print output)))</p><empty-line /><p>
  (driver-loop))</p><empty-line /><p>(define (prompt-for-input string)</p><empty-line /><p>
  (newline) (newline) (display string) (newline))</p><empty-line /><empty-line /><p>(define (announce-output string)</p><empty-line /><p>
  (newline) (display string) (newline))</p><empty-line /><p>
We use a special printing procedure, user-print, to avoid printing the
environment part of a compound procedure, which may be a very long list
(or may even contain cycles).</p>

<p>(define (user-print object)</p><empty-line /><p>
  (if (compound-procedure? object)</p><empty-line /><p>
      (display (list 'compound-procedure</p><empty-line /><p>
                     (procedure-parameters object)</p><empty-line /><p>
                     (procedure-body object)</p><empty-line /><p>
                     '&lt;procedure-env&gt;))</p><empty-line /><p>
      (display object)))</p><empty-line /><empty-line /><p>

Now all we need to do to run the evaluator is to initialize the
global environment and start the driver loop.  Here is a sample
interaction:</p>

<p>(define the-global-environment (setup-environment))</p><empty-line /><p>
(driver-loop)</p><empty-line /><p><emphasis>;;; M-Eval input:</emphasis></p><empty-line /><p>
(define (append x y)</p><empty-line /><p>
  (if (null? x)</p><empty-line /><p>
      y</p><empty-line /><p>
      (cons (car x)</p><empty-line /><p>
            (append (cdr x) y))))</p><empty-line /><p><emphasis>;;; M-Eval value:</emphasis></p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><p><emphasis>;;; M-Eval input:</emphasis></p><empty-line /><p>
(append '(a b c) '(d e f))</p><empty-line /><p><emphasis>;;; M-Eval value:</emphasis></p><empty-line /><p><emphasis>(a b c d e f)</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 4.14.</strong>  Eva Lu Ator and Louis Reasoner are each experimenting with the
metacircular evaluator.  Eva types in the definition of map, and
runs some test programs that use it.  They work fine.  Louis, in contrast,
has installed the system version of map as a primitive for the
metacircular evaluator.  When he tries it, things go terribly
wrong.  Explain why Louis's map fails even though Eva's works.</p>

<p><strong>4.1.5  Data as Programs</strong></p>

<p>



In thinking about a Lisp program that evaluates Lisp expressions, an
analogy might be helpful.  One operational view of the meaning of a
program is that a program is a description of an abstract (perhaps
infinitely large) machine.  For example, consider the familiar
program to compute factorials:</p>

<p>(define (factorial n)</p><empty-line /><p>
  (if (= n 1)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* (factorial (- n 1)) n)))</p><empty-line /><p>
We may regard this program as the description of a machine containing
parts that decrement, multiply, and test for equality, together with a
two-position switch and another factorial machine. (The factorial
machine is infinite because it contains another factorial machine
within it.)  Figure 4.2 is a flow diagram for the
factorial machine, showing how the parts are wired together.</p>

<p><image xlink:href="#_195.jpg" /></p>

<p><strong>Figure 4.2:</strong>  The factorial program, viewed as an abstract machine.</p>

<p>


In a similar way, we can regard the evaluator as a very special
machine that takes as input a description of a machine.  Given this
input, the evaluator configures itself to emulate the machine
described.  For example, if we feed our evaluator the definition of
factorial, as shown in figure 4.3, the
evaluator will be able to compute factorials.</p>

<p><image xlink:href="#_196.jpg" /></p>

<p><strong>Figure 4.3:</strong>  The evaluator emulating a factorial machine.</p>

<p>

From this perspective, our evaluator is seen to be a <emphasis>universal machine</emphasis>.
It mimics other machines when these are described as Lisp programs.<sup>19</sup>
This is striking. Try to imagine an analogous evaluator for electrical
circuits.  This would be a circuit that takes as input a signal
encoding the plans for some other circuit, such as a filter.  Given
this input, the circuit evaluator would then behave like a filter with
the same description.  Such a universal electrical circuit is
almost unimaginably complex.  It is remarkable that the program
evaluator is a rather simple program.<sup>20</sup></p>

<p>

Another striking aspect of the evaluator is that it acts as a bridge
between the data objects that are manipulated by our programming
language and the programming language itself.  Imagine that the
evaluator program (implemented in Lisp) is running, and that a user is
typing expressions to the evaluator and observing the results.  From
the perspective of the user, an input expression such as (* x x)
is an expression in the programming language, which the evaluator
should execute.  From the perspective of the evaluator, however, the
expression is simply a list (in this case, a list of three symbols:
*, x, and x) that is to be manipulated according to
a well-defined set of rules.</p>

<p>

That the user's programs are the evaluator's data need not be a source
of confusion.  In fact, it is sometimes convenient to ignore this
distinction, and to give the user the ability to explicitly evaluate a
data object as a Lisp expression, by making eval available for
use in programs.  Many Lisp dialects provide a primitive eval
procedure that takes as arguments an expression and an environment and
evaluates the expression relative to the environment.<sup>21</sup>
Thus,</p>

<p>(eval '(* 5 5) user-initial-environment)</p><empty-line /><p>
and</p>

<p>(eval (cons '* (list 5 5)) user-initial-environment)</p><empty-line /><p>
will both return 25.<sup>22</sup></p>

<p>
<strong>Exercise 4.15.</strong>  Given a one-argument procedure p and an object a, p
is said to "halt" on a if evaluating the expression (p
a) returns a value (as opposed to terminating with an error message
or running forever).  Show that it is impossible to write a procedure
halts? that correctly determines whether p halts on a for any procedure p and object a.  Use the following
reasoning: If you had such a procedure halts?, you could
implement the following program:</p>

<p>(define (run-forever) (run-forever))</p><empty-line /><empty-line /><p>
(define (try p)</p><empty-line /><p>
  (if (halts? p p)</p><empty-line /><p>
      (run-forever)</p><empty-line /><p>
      'halted))</p><empty-line /><p>
Now consider evaluating the expression (try try) and show that
any possible outcome (either halting or running forever) violates the
intended behavior of halts?.<sup>23</sup></p>

<p><strong>4.1.6  Internal Definitions</strong></p>

<p>



Our environment model of evaluation and our metacircular evaluator execute
definitions in sequence, extending the environment frame one
definition at a time.  This is particularly convenient for interactive
program development, in which the programmer needs to freely mix the
application of procedures with the definition of new procedures.
However, if we think carefully about the internal definitions
used to implement block structure (introduced in
section 1.1.8), we will find that name-by-name extension
of the environment may not be the best way to define local variables.</p>

<p>

Consider a procedure with internal definitions, such as</p>

<p>(define (f x)</p><empty-line /><p>
  (define (even? n)</p><empty-line /><p>
    (if (= n 0)</p><empty-line /><p>
        true</p><empty-line /><p>
        (odd? (- n 1))))</p><empty-line /><p>
  (define (odd? n)</p><empty-line /><p>
    (if (= n 0)</p><empty-line /><p>
        false</p><empty-line /><p>
        (even? (- n 1))))</p><empty-line /><p>
  &lt;<emphasis>rest of body of f</emphasis>&gt;)</p><empty-line /><p>
Our intention here is that the name odd? in the body of the
procedure even? should refer to the procedure odd? that is
defined after even?.  The scope of the name odd? is the
entire body of f, not just the portion of the body of f
starting at the point where the define for odd? occurs.
Indeed, when we consider that odd? is itself defined in terms of
even? -- so that even? and odd? are mutually
recursive procedures -- we see that the only satisfactory
interpretation of the two defines is to regard them as if the
names even? and odd? were being added to the environment
simultaneously.
More generally, in block structure, the scope of a local name is the
entire procedure body in which the define is evaluated.</p>

<p>


As it happens, our interpreter will evaluate calls to f
correctly, but for an "accidental" reason: Since the definitions of
the internal procedures come first, no calls to these procedures will
be evaluated until all of them have been defined.  Hence, odd?
will have been defined by the time even? is executed.  In fact,
our sequential evaluation mechanism will give the same result as a
mechanism that directly implements simultaneous definition for any
procedure in which the internal definitions come first in a body and
evaluation of the value expressions for the defined variables doesn't
actually use any of the defined variables.
(For an example of a procedure that doesn't obey these restrictions,
so that sequential definition isn't equivalent to simultaneous definition,
see exercise 4.19.)<sup>24</sup></p>

<p>

There is, however, a simple way to treat definitions so that
internally defined names have truly simultaneous scope -- just create
all local variables that will be in the current environment before
evaluating any of the value expressions.  One way to do this is by a
syntax transformation on lambda expressions.  Before evaluating
the body of a lambda expression, we "scan out" and eliminate
all the internal definitions in the body.  The internally defined
variables will be created with a let and then set to their
values by assignment.  For example, the procedure</p>

<p>(lambda &lt;<emphasis>vars</emphasis>&gt;</p><empty-line /><p>
  (define u &lt;<emphasis>e1</emphasis>&gt;)</p><empty-line /><p>
  (define v &lt;<emphasis>e2</emphasis>&gt;)</p><empty-line /><p>
  &lt;<emphasis>e3</emphasis>&gt;)</p><empty-line /><p>
would be transformed into</p>

<p>(lambda &lt;<emphasis>vars</emphasis>&gt;</p><empty-line /><p>
  (let ((u '*unassigned*)</p><empty-line /><p>
        (v '*unassigned*))</p><empty-line /><p>
    (set! u &lt;<emphasis>e1</emphasis>&gt;)</p><empty-line /><p>
    (set! v &lt;<emphasis>e2</emphasis>&gt;)</p><empty-line /><p>
    &lt;<emphasis>e3</emphasis>&gt;))</p><empty-line /><p>
where *unassigned* is a special symbol that causes looking up a
variable to signal an error if an attempt is made to use the value of
the not-yet-assigned variable.</p>

<p>

An alternative strategy for scanning out internal definitions is shown
in exercise 4.18.  Unlike the transformation
shown above, this enforces the restriction that the defined variables'
values can be evaluated without using any of the variables' values.<sup>25</sup></p>

<p>
<strong>Exercise 4.16.</strong>  In this exercise we implement the method just described for
interpreting internal definitions.
We assume that the evaluator supports let
(see exercise 4.6).</p>

<p>

a.  Change lookup-variable-value
(section 4.1.3) to signal an error if
the value it finds is the symbol *unassigned*.</p>

<p>

b.  Write a procedure scan-out-defines that takes a
procedure body and returns an equivalent one that has no internal
definitions, by making the transformation described above.</p>

<p>

c.  Install scan-out-defines in the interpreter, either in make-procedure or in procedure-body (see
section 4.1.3).  Which place is better?
Why?</p>

<p>
<strong>Exercise 4.17.</strong>  Draw diagrams of the environment in effect when evaluating the
expression &lt;<emphasis>e3</emphasis>&gt; in the procedure in the text, comparing how this
will be structured when definitions are interpreted sequentially with
how it will be structured if definitions are scanned out as described.
Why is there an extra frame in the transformed program?  Explain why
this difference in environment structure can never make a difference
in the behavior of a correct program.  Design a way to make the
interpreter implement the "simultaneous" scope rule for internal
definitions without constructing the extra frame.</p>

<p>
<strong>Exercise 4.18.</strong>  Consider an alternative strategy for scanning out definitions that
translates the example in the text to</p>

<p>(lambda &lt;<emphasis>vars</emphasis>&gt;</p><empty-line /><p>
  (let ((u '*unassigned*)</p><empty-line /><p>
        (v '*unassigned*))</p><empty-line /><p>
    (let ((a &lt;<emphasis>e1</emphasis>&gt;)</p><empty-line /><p>
          (b &lt;<emphasis>e2</emphasis>&gt;))</p><empty-line /><p>
      (set! u a)</p><empty-line /><p>
      (set! v b))</p><empty-line /><p>
    &lt;<emphasis>e3</emphasis>&gt;))</p><empty-line /><p>
Here a and b are meant to represent new variable names,
created by the interpreter, that do not appear in the user's
program.
Consider the solve procedure from
section 3.5.4:</p>

<p>(define (solve f y0 dt)</p><empty-line /><p>
  (define y (integral (delay dy) y0 dt))</p><empty-line /><p>
  (define dy (stream-map f y))</p><empty-line /><p>
  y)</p><empty-line /><p>
Will this procedure work if internal definitions are scanned out as
shown in this exercise?  What if they are scanned out as shown in the
text?  Explain.</p>

<p>
<strong>Exercise 4.19.</strong>  Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing about
the desired result of evaluating the expression</p>

<p>(let ((a 1))</p><empty-line /><p>
  (define (f x)</p><empty-line /><p>
    (define b (+ a x))</p><empty-line /><p>
    (define a 5)</p><empty-line /><p>
    (+ a b))</p><empty-line /><p>
  (f 10))</p><empty-line /><p>
Ben asserts that the result should be obtained using the sequential
rule for define: b is defined to be 11, then a is
defined to be 5, so the result is 16.  Alyssa objects that mutual
recursion requires the simultaneous scope rule for internal procedure
definitions, and that it is unreasonable to treat procedure names
differently from other names.  Thus, she argues for the mechanism
implemented in exercise 4.16.  This would lead to
a being unassigned at the time that the value for b is to
be computed.  Hence, in Alyssa's view the procedure should produce an
error.  Eva has a third opinion.  She says that if the definitions of
a and b are truly meant to be simultaneous, then the value
5 for a should be used in evaluating b.  Hence, in Eva's
view a should be 5, b should be 15, and the result should
be 20.  Which (if any) of these viewpoints do you support?  Can you
devise a way to implement internal definitions so that they behave as
Eva prefers?<sup>26</sup></p>

<p>
<strong>Exercise 4.20.</strong>  Because internal definitions look sequential but are actually
simultaneous, some people prefer to avoid them entirely, and use the
special form letrec instead.  Letrec looks like let,
so it is not surprising that the variables it binds are bound
simultaneously and have the same scope as each other.  The sample
procedure f above can be written without internal definitions,
but with exactly the same meaning, as</p>

<p>(define (f x)</p><empty-line /><p>
  (letrec ((even?</p><empty-line /><p>
            (lambda (n)</p><empty-line /><p>
              (if (= n 0)</p><empty-line /><p>
                  true</p><empty-line /><p>
                  (odd? (- n 1)))))</p><empty-line /><p>
           (odd?</p><empty-line /><p>
            (lambda (n)</p><empty-line /><p>
              (if (= n 0)</p><empty-line /><p>
                  false</p><empty-line /><p>
                  (even? (- n 1))))))</p><empty-line /><p>
    &lt;<emphasis>rest of body of f</emphasis>&gt;))</p><empty-line /><p>
Letrec expressions, which have the form</p>

<p>(letrec ((&lt;<emphasis>var<sub>1</sub></emphasis>&gt; &lt;<emphasis>exp<sub>1</sub></emphasis>&gt;) ... (&lt;<emphasis>var<sub>n</sub></emphasis>&gt; &lt;<emphasis>exp<sub>n</sub></emphasis>&gt;))</p><empty-line /><p>
  &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
are a variation on let in which the expressions
&lt;<emphasis>exp<sub>k</sub></emphasis>&gt; that provide the initial values for the variables &lt;<emphasis>var<sub>k</sub></emphasis>&gt;
are evaluated in an environment that includes all the letrec
bindings.  This permits recursion in the bindings, such as the mutual
recursion of even? and odd? in the example above, or
the evaluation of 10 factorial with</p>

<p>(letrec ((fact</p><empty-line /><p>
          (lambda (n)</p><empty-line /><p>
            (if (= n 1)</p><empty-line /><p>
                1</p><empty-line /><p>
                (* n (fact (- n 1)))))))</p><empty-line /><p>
  (fact 10))</p><empty-line /><empty-line /><p>a. Implement letrec as a derived expression, by transforming
a letrec expression into a let expression as shown in
the text above or in exercise 4.18.
That is, the letrec variables should be created with a let
and then be assigned their values with set!.</p>

<p>b. Louis Reasoner is confused by all this fuss about internal
definitions.  The way he sees it, if you don't like to use define inside a procedure, you can just use let.  Illustrate
what is loose about his reasoning by drawing an environment diagram
that shows the environment in which the &lt;<emphasis>rest of body of f</emphasis>&gt;
is evaluated during evaluation of the expression (f 5), with
f defined as in this exercise.  Draw
an environment diagram for the same evaluation, but with let in
place of letrec in the definition of f.</p>

<p>
<strong>Exercise 4.21.</strong>  Amazingly, Louis's intuition in exercise 4.20
is correct.  It is indeed possible to specify recursive procedures
without using letrec (or even define), although the method
for accomplishing this is much more subtle than Louis imagined.  The
following expression computes 10 factorial by applying a recursive
factorial procedure:<sup>27</sup></p>

<p>((lambda (n)</p><empty-line /><p>
   ((lambda (fact)</p><empty-line /><p>
      (fact fact n))</p><empty-line /><p>
    (lambda (ft k)</p><empty-line /><p>
      (if (= k 1)</p><empty-line /><p>
          1</p><empty-line /><p>
          (* k (ft ft (- k 1)))))))</p><empty-line /><p>
 10)</p><empty-line /><empty-line /><p>a. Check (by evaluating the expression) that this really does compute
factorials.  Devise an analogous expression for computing Fibonacci numbers.</p>

<p>b. Consider the following procedure, which includes mutually recursive
internal definitions:</p>

<p>(define (f x)</p><empty-line /><p>
  (define (even? n)</p><empty-line /><p>
    (if (= n 0)</p><empty-line /><p>
        true</p><empty-line /><p>
        (odd? (- n 1))))</p><empty-line /><p>
  (define (odd? n)</p><empty-line /><p>
    (if (= n 0)</p><empty-line /><p>
        false</p><empty-line /><p>
        (even? (- n 1))))</p><empty-line /><p>
  (even? x))</p><empty-line /><p>
Fill in the missing expressions to complete an alternative definition
of f, which uses neither internal definitions nor letrec:</p>

<p>(define (f x)</p><empty-line /><p>
  ((lambda (even? odd?)</p><empty-line /><p>
     (even? even? odd? x))</p><empty-line /><p>
   (lambda (ev? od? n)</p><empty-line /><p>
     (if (= n 0) true (od? &lt;??&gt; &lt;??&gt; &lt;??&gt;)))</p><empty-line /><p>
   (lambda (ev? od? n)</p><empty-line /><p>
     (if (= n 0) false (ev? &lt;??&gt; &lt;??&gt; &lt;??&gt;)))))</p><empty-line /><empty-line /><p><strong>4.1.7  Separating Syntactic Analysis from Execution</strong></p>

<p>



The evaluator implemented above is simple, but it is very
inefficient, because the syntactic analysis of expressions is interleaved
with their execution.  Thus if a program is executed many times, its
syntax is analyzed many times.  Consider, for example, evaluating (factorial 4) using the following definition of factorial:</p>

<p>(define (factorial n)</p><empty-line /><p>
  (if (= n 1)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* (factorial (- n 1)) n)))</p><empty-line /><empty-line /><p>

Each time factorial is called, the evaluator must determine that
the body is an if expression and extract the predicate.
Only then can it evaluate the
predicate and dispatch on its value.  Each time it evaluates the
expression (* (factorial (- n 1)) n),
or the subexpressions (factorial (- n 1)) and (- n 1),
the evaluator must perform
the case analysis in eval to determine that the expression is an
application, and must extract its operator and operands.  This
analysis is expensive.  Performing it repeatedly is wasteful.</p>

<p>

We can transform the evaluator to be significantly more efficient by
arranging things so that syntactic analysis is performed only
once.<sup>28</sup> We split eval, which takes an
expression and an environment, into two parts.  The procedure analyze takes only the expression.  It performs the syntactic
analysis and returns a new procedure, the <emphasis>execution procedure</emphasis>, that
encapsulates the work to be done in executing the analyzed
expression.  The execution procedure takes an environment as its
argument and completes the evaluation.  This saves work because analyze will be called only once on an expression, while the
execution procedure may be called many times.</p>

<p>

With the separation into analysis and execution, eval now becomes</p>

<p>(define (eval exp env)</p><empty-line /><p>
  ((analyze exp) env))</p><empty-line /><empty-line /><p>

The result of calling analyze is the execution procedure to
be applied to the environment.  The analyze procedure is
the same case analysis as performed by the original eval of
section 4.1.1, except that the procedures to
which we dispatch perform only analysis, not full evaluation:</p>

<p>(define (analyze exp)</p><empty-line /><p>
  (cond ((self-evaluating? exp)</p><empty-line /><p>
         (analyze-self-evaluating exp))</p><empty-line /><p>
        ((quoted? exp) (analyze-quoted exp))</p><empty-line /><p>
        ((variable? exp) (analyze-variable exp))</p><empty-line /><p>
        ((assignment? exp) (analyze-assignment exp))</p><empty-line /><p>
        ((definition? exp) (analyze-definition exp))</p><empty-line /><p>
        ((if? exp) (analyze-if exp))</p><empty-line /><p>
        ((lambda? exp) (analyze-lambda exp))</p><empty-line /><p>
        ((begin? exp) (analyze-sequence (begin-actions exp)))</p><empty-line /><p>
        ((cond? exp) (analyze (cond-&gt;if exp)))</p><empty-line /><p>
        ((application? exp) (analyze-application exp))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (error "Unknown expression type -- ANALYZE" exp))))</p><empty-line /><empty-line /><p>

Here is the simplest syntactic analysis procedure, which handles
self-evaluating expressions.  It returns an execution procedure that
ignores its environment argument and just returns the expression:</p>

<p>(define (analyze-self-evaluating exp)</p><empty-line /><p>
  (lambda (env) exp))</p><empty-line /><empty-line /><p>

For a quoted expression, we can gain a little efficiency by
extracting the text of the quotation only once, in the analysis phase,
rather than in the execution phase.</p>

<p>(define (analyze-quoted exp)</p><empty-line /><p>
  (let ((qval (text-of-quotation exp)))</p><empty-line /><p>
    (lambda (env) qval)))</p><empty-line /><empty-line /><p>

Looking up a variable value must still be done in the execution phase,
since this depends upon knowing the environment.<sup>29</sup></p>

<p>(define (analyze-variable exp)</p><empty-line /><p>
  (lambda (env) (lookup-variable-value exp env)))</p><empty-line /><empty-line /><p>

Analyze-assignment also must defer actually setting the variable
until the execution, when the environment has been supplied.  However,
the fact that the assignment-value expression can be
analyzed (recursively) during analysis is a major gain in efficiency,
because the assignment-value expression will now be analyzed
only once.  The same holds true for definitions.</p>

<p>(define (analyze-assignment exp)</p><empty-line /><p>
  (let ((var (assignment-variable exp))</p><empty-line /><p>
        (vproc (analyze (assignment-value exp))))</p><empty-line /><p>
    (lambda (env)</p><empty-line /><p>
      (set-variable-value! var (vproc env) env)</p><empty-line /><p>
      'ok)))</p><empty-line /><p>
(define (analyze-definition exp)</p><empty-line /><p>
  (let ((var (definition-variable exp))</p><empty-line /><p>
        (vproc (analyze (definition-value exp))))</p><empty-line /><p>
    (lambda (env)</p><empty-line /><p>
      (define-variable! var (vproc env) env)</p><empty-line /><p>
      'ok)))</p><empty-line /><empty-line /><p>

For if expressions, we extract and analyze the predicate,
consequent, and alternative at analysis time.</p>

<p>(define (analyze-if exp)</p><empty-line /><p>
  (let ((pproc (analyze (if-predicate exp)))</p><empty-line /><p>
        (cproc (analyze (if-consequent exp)))</p><empty-line /><p>
        (aproc (analyze (if-alternative exp))))</p><empty-line /><p>
    (lambda (env)</p><empty-line /><p>
      (if (true? (pproc env))</p><empty-line /><p>
          (cproc env)</p><empty-line /><p>
          (aproc env)))))</p><empty-line /><empty-line /><p>

Analyzing a lambda expression also achieves a major
gain in efficiency: We analyze the lambda body only once, even though
procedures resulting from evaluation of the lambda
may be applied many times.</p>

<p>(define (analyze-lambda exp)</p><empty-line /><p>
  (let ((vars (lambda-parameters exp))</p><empty-line /><p>
        (bproc (analyze-sequence (lambda-body exp))))</p><empty-line /><p>
    (lambda (env) (make-procedure vars bproc env))))</p><empty-line /><empty-line /><p>

Analysis of a sequence of expressions (as in a begin or the body
of a lambda expression) is more involved.<sup>30</sup>
Each expression
in the sequence is analyzed, yielding an execution
procedure.  These execution procedures are combined to produce an
execution
procedure that takes an environment as argument and sequentially calls
each individual execution procedure with the environment as argument.</p>

<p>(define (analyze-sequence exps)</p><empty-line /><p>
  (define (sequentially proc1 proc2)</p><empty-line /><p>
    (lambda (env) (proc1 env) (proc2 env)))</p><empty-line /><p>
  (define (loop first-proc rest-procs)</p><empty-line /><p>
    (if (null? rest-procs)</p><empty-line /><p>
        first-proc</p><empty-line /><p>
        (loop (sequentially first-proc (car rest-procs))</p><empty-line /><p>
              (cdr rest-procs))))</p><empty-line /><p>
  (let ((procs (map analyze exps)))</p><empty-line /><p>
    (if (null? procs)</p><empty-line /><p>
        (error "Empty sequence -- ANALYZE"))</p><empty-line /><p>
    (loop (car procs) (cdr procs))))</p><empty-line /><empty-line /><p>

To analyze an application, we analyze the operator and operands and
construct an execution procedure that
calls the operator execution procedure (to obtain the
actual procedure to be applied) and the operand execution
procedures (to obtain the actual arguments).  We then pass these to execute-application, which is the analog of apply in
section 4.1.1.
Execute-application differs from apply in that the procedure body for a compound procedure has already
been analyzed, so there is no need to do further analysis.  Instead,
we just call the execution procedure for the body on the extended
environment.</p>

<p>(define (analyze-application exp)</p><empty-line /><p>
  (let ((fproc (analyze (operator exp)))</p><empty-line /><p>
        (aprocs (map analyze (operands exp))))</p><empty-line /><p>
    (lambda (env)</p><empty-line /><p>
      (execute-application (fproc env)</p><empty-line /><p>
                           (map (lambda (aproc) (aproc env))</p><empty-line /><p>
                                aprocs)))))</p><empty-line /><p>(define (execute-application proc args)</p><empty-line /><p>
  (cond ((primitive-procedure? proc)</p><empty-line /><p>
         (apply-primitive-procedure proc args))</p><empty-line /><p>
        ((compound-procedure? proc)</p><empty-line /><p>
         ((procedure-body proc)</p><empty-line /><p>
          (extend-environment (procedure-parameters proc)</p><empty-line /><p>
                              args</p><empty-line /><p>
                              (procedure-environment proc))))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (error</p><empty-line /><p>
          "Unknown procedure type -- EXECUTE-APPLICATION"</p><empty-line /><p>
          proc))))</p><empty-line /><empty-line /><p>

Our new evaluator uses the same data structures, syntax
procedures, and run-time support procedures as in
sections 4.1.2,
 4.1.3, and 4.1.4.</p>

<p>
<strong>Exercise 4.22.</strong>  Extend the evaluator in this section to support the special form let.
(See exercise 4.6.)</p>

<p>
<strong>Exercise 4.23.</strong>  Alyssa P. Hacker doesn't understand why analyze-sequence needs to be
so complicated.  All the other analysis procedures
are straightforward transformations of the corresponding evaluation
procedures (or eval clauses) in section 4.1.1.
She expected analyze-sequence to look like this:</p>

<p>(define (analyze-sequence exps)</p><empty-line /><p>
  (define (execute-sequence procs env)</p><empty-line /><p>
    (cond ((null? (cdr procs)) ((car procs) env))</p><empty-line /><p>
          (else ((car procs) env)</p><empty-line /><p>
                (execute-sequence (cdr procs) env))))</p><empty-line /><p>
  (let ((procs (map analyze exps)))</p><empty-line /><p>
    (if (null? procs)</p><empty-line /><p>
        (error "Empty sequence -- ANALYZE"))</p><empty-line /><p>
    (lambda (env) (execute-sequence procs env))))</p><empty-line /><p>
Eva Lu Ator explains to Alyssa that the version in the text does more
of the work of evaluating a sequence at analysis time.  Alyssa's
sequence-execution procedure, rather than having the calls to the
individual execution procedures built in, loops through the procedures
in order to call them: In effect, although the individual expressions
in the sequence have been analyzed, the sequence itself has not been.</p>

<p>

Compare the two versions of analyze-sequence.  For example,
consider the common case (typical of procedure bodies) where the
sequence has just one expression.  What work will the execution
procedure produced by Alyssa's program do?  What about the execution
procedure produced by the program in the text above?  How do the two
versions compare for a sequence with two expressions?</p>

<p>
<strong>Exercise 4.24.</strong>  Design and carry out some experiments to 
compare the speed of the original metacircular evaluator
with the version in this section.  Use your results to estimate the fraction
of time that is spent in analysis versus execution for various
procedures.</p><empty-line /><empty-line /><empty-line /><p><sup>3</sup> Even so, there will remain important aspects of
the evaluation process that are not elucidated by our evaluator.  The
most important of these are the detailed mechanisms by which
procedures call other procedures and return values to their callers.
We will address these issues in chapter 5, where we take a closer look
at the evaluation process by implementing the evaluator as a simple
register machine.</p>

<p><sup>4</sup> If we grant ourselves the ability to apply primitives,
then what remains for us to implement in the evaluator?  The job of
the evaluator is not to specify the primitives of the language, but rather
to provide the connective tissue -- the means of combination and the
means of abstraction -- that binds a collection of primitives to form a
language.  Specifically:</p>

<p>The evaluator enables us to deal with nested expressions.  For
example, although simply applying primitives
would suffice for evaluating
the expression (+ 1 6), it is not adequate for handling (+ 1 (* 2
3)).  As far as the primitive procedure + is concerned,
its arguments must be numbers, and it would choke if we passed it the
expression (* 2 3) as an argument.  One important role of the
evaluator is to choreograph procedure composition so that (* 2
3) is reduced to 6 before being passed as an argument to +.</p>

<p>The evaluator allows us to use variables.  For example, the
primitive procedure for addition has no way to deal with expressions such
as (+ x 1).  We need an evaluator to keep track of variables and
obtain their values before invoking the primitive
procedures.</p>

<p>The evaluator allows us to define compound procedures.  This
involves keeping track of procedure definitions, knowing how to use
these definitions in evaluating expressions, and providing a mechanism
that enables procedures to accept arguments.</p>

<p>The evaluator provides the special forms, which must be
evaluated differently from procedure calls.</p>

<p><sup>5</sup> We could have simplified the application? clause in eval by using map
(and stipulating that operands returns a list) rather than
writing an explicit list-of-values procedure.  We chose not to
use map here to emphasize the fact that the evaluator can be
implemented without any use of higher-order procedures
(and thus could be written in a language that doesn't have
higher-order procedures), even though
the language that it supports will include higher-order procedures.</p>

<p><sup>6</sup> In this case, the language being implemented and the
implementation language are the same.  Contemplation of the meaning of
true? here yields expansion of consciousness without the abuse
of substance.</p>

<p><sup>7</sup> This implementation of define ignores a subtle
issue in the handling of internal definitions, although it works
correctly in most cases.  We will see what the problem is and how to
solve it in section 4.1.6.</p>

<p><sup>8</sup> As we said when we
introduced define and set!, these values
are implementation-dependent in Scheme -- that is, the implementor
can choose what value to return.</p>

<p><sup>9</sup> As mentioned in
section 2.3.1, the evaluator sees a quoted expression as
a list beginning with quote, even if the
expression is typed with the quotation mark.  For example, the
expression 'a would be seen by the evaluator as (quote a).
See exercise 2.55.</p>

<p><sup>10</sup> The value of an if expression when the predicate
is false and there is no alternative
is unspecified in Scheme; we have chosen here to make it false.
We will support the use of the variables true and false
in expressions to be evaluated by binding them in the global
environment.  See section 4.1.4.</p>

<p><sup>11</sup> These selectors for a list of expressions -- and the
corresponding ones for a list of operands -- are not intended as a data
abstraction.  They are introduced as mnemonic names for the basic list
operations in order to make it easier to understand the explicit-control
evaluator in section 5.4.</p>

<p><sup>12</sup> The value of a cond expression when all the predicates
are false and there is no else clause
is unspecified in Scheme; we have chosen here to make it false.</p>

<p><sup>13</sup> Practical Lisp systems provide a
mechanism that allows a user to add new derived expressions and
specify their implementation as syntactic transformations without
modifying the evaluator.  Such a user-defined transformation is called a
<emphasis>macro</emphasis>.
Although it is easy to add an elementary mechanism for defining macros,
the resulting language has subtle name-conflict problems.
There has been much research on mechanisms for macro definition
that do not cause these difficulties.  See,
for example, Kohlbecker 1986, Clinger and Rees 1991, and Hanson 1991.</p>

<p><sup>14</sup> Frames are not really a data abstraction in the following code:
Set-variable-value! and define-variable! use set-car!
to directly modify the values in a frame.  The purpose of the frame
procedures is to make the environment-manipulation procedures easy to read.</p>

<p><sup>15</sup> The drawback of this representation (as well as the variant in
exercise 4.11) is that the evaluator
may have to search through many frames in order to find the binding
for a given variable.
(Such an approach is referred to as <emphasis>deep binding</emphasis>.) 
One way to avoid
this inefficiency is to make use of a strategy called <emphasis>lexical
addressing</emphasis>, which will be discussed in
section 5.5.6.</p>

<p><sup>16</sup> Any procedure defined in the underlying Lisp can be used as
a primitive for the metacircular evaluator.  The name of a
primitive installed in the evaluator need not be the same as the name
of its implementation in the underlying Lisp; the names are the same
here because the metacircular evaluator implements Scheme itself.
Thus, for example, we could put (list 'first car) or (list
'square (lambda (x) (* x x))) in the list of primitive-procedures.</p>

<p><sup>17</sup> Apply-in-underlying-scheme is the apply procedure
we have used in earlier chapters.  The metacircular evaluator's apply procedure (section 4.1.1) models the
working of this primitive.  Having two different things called apply leads to a technical problem in running the metacircular
evaluator, because defining the metacircular evaluator's apply
will mask the definition of the primitive.  One way around this is to
rename the metacircular apply to avoid conflict with the name of
the primitive procedure.  We have assumed instead that we have saved a
reference to the underlying apply by doing</p>

<p>(define apply-in-underlying-scheme apply)</p><empty-line /><p>
before defining the metacircular apply.  This allows us to
access the original version of apply under a different name.</p>

<p><sup>18</sup> The primitive procedure read waits for input from the user,
and returns the next complete expression that is typed.
For example, if the user types (+ 23 x), read returns
a three-element list containing the symbol +, the number 23,
and the symbol x.
If the user types 'x, read returns a two-element list
containing the symbol quote and the symbol x.</p>

<p><sup>19</sup> The fact that the machines are described in Lisp is
inessential.  If we give our evaluator a Lisp program
that behaves as an evaluator for
some other language, say C, the Lisp evaluator will emulate the C
evaluator, which in turn can emulate any machine described as a C
program.  Similarly, writing a Lisp evaluator in C produces a C
program that can execute any Lisp program.  The deep idea here is that
any evaluator can emulate any other.  Thus, the notion of "what can
in principle be computed" (ignoring practicalities of time and
memory required) is independent of the language or the computer, and
instead reflects an underlying notion of <emphasis>computability</emphasis>.  This
was first demonstrated in a clear way by Alan M. Turing (1912-1954),
whose 1936 paper laid the foundations for theoretical computer
science.  In the paper, Turing presented a simple computational
model -- now known as a <emphasis>Turing machine</emphasis> -- and argued that any
"effective process" can be formulated as a program for such a
machine.  (This argument is known as the <emphasis>Church-Turing thesis</emphasis>.)
Turing then implemented a universal machine, i.e., a Turing machine
that behaves as an evaluator for Turing-machine programs.  He used
this framework to demonstrate that there are well-posed problems that
cannot be computed by Turing machines (see
exercise 4.15), and so by implication cannot be
formulated as "effective processes."  Turing went on to make
fundamental contributions to practical computer science as well.  For
example, he invented the idea of structuring programs using
general-purpose subroutines.  See Hodges 1983 for a biography of
Turing.</p>

<p><sup>20</sup> Some people find it
counterintuitive that an evaluator, which is implemented by a
relatively simple procedure, can emulate programs that are more
complex than the evaluator itself.  The existence of a universal
evaluator machine is a deep and wonderful property of computation.
<emphasis>Recursion theory</emphasis>, a branch of mathematical logic, is concerned
with logical limits of computation.  Douglas Hofstadter's beautiful
book <emphasis>Gödel, Escher, Bach</emphasis> (1979) explores some of these ideas.</p>

<p><sup>21</sup> Warning:
This eval primitive is not
identical to the eval procedure we implemented in
section 4.1.1, because it uses <emphasis>actual</emphasis>
Scheme environments rather than the sample environment structures we
built in section 4.1.3.  These actual
environments cannot be manipulated by the user as ordinary lists; they
must be accessed via eval or other special operations.
Similarly, the apply primitive we saw earlier is not identical
to the metacircular apply, because it uses actual Scheme procedures
rather than the procedure objects we constructed in
sections 4.1.3 and 4.1.4.</p>

<p><sup>22</sup> The MIT
implementation of Scheme includes eval, as well as a symbol user-initial-environment that is bound to the initial environment in
which the user's input expressions are evaluated.</p>

<p><sup>23</sup> Although we stipulated that halts? is given a procedure object,
notice that this reasoning still applies even if halts? can gain
access to the procedure's text and its environment.
This is Turing's celebrated <emphasis>Halting Theorem</emphasis>, which gave
the first clear example of a <emphasis>non-computable</emphasis> problem, i.e., a
well-posed task that cannot be carried out as a computational
procedure.</p>

<p><sup>24</sup> Wanting programs to not depend on this evaluation
mechanism is the reason for the "management is not
responsible" remark in footnote 28 of chapter 1.
By insisting that internal definitions come first and do not use each
other while the definitions are being evaluated, the IEEE standard
for Scheme leaves implementors some choice in the mechanism used to
evaluate these definitions.  The choice of one evaluation rule rather
than another here may seem like a small issue, affecting only the
interpretation of "badly formed" programs.  However, we will see in
section 5.5.6 that moving to a model of
simultaneous scoping for internal definitions avoids some nasty
difficulties that would otherwise arise in implementing a compiler.</p>

<p><sup>25</sup> The IEEE standard for Scheme
allows for different implementation strategies by specifying that it
is up to the programmer to obey this restriction, not up to the
implementation to enforce it.  Some Scheme implementations, including
MIT Scheme, use the transformation shown above.  Thus, some programs
that don't obey this restriction will in fact run in such implementations.</p>

<p><sup>26</sup> The MIT implementors of Scheme support Alyssa on
the following grounds: Eva is in principle correct -- the definitions
should be regarded as simultaneous.  But it seems difficult to
implement a general, efficient mechanism that does what Eva requires.
In the absence of such a mechanism, it is better to generate an error
in the difficult cases of simultaneous definitions (Alyssa's notion)
than to produce an incorrect answer (as Ben would have it).</p>

<p><sup>27</sup> This example illustrates a programming trick for
formulating recursive procedures without using define.  The
most general trick of this sort is the <emphasis>Y</emphasis> <emphasis>operator</emphasis>, which can
be used to give a "pure <image xlink:href="#_51.jpg" />-calculus" implementation of
recursion.  (See Stoy 1977 for details on the lambda calculus, and
Gabriel 1988 for an exposition of the <emphasis>Y</emphasis> operator in Scheme.)</p>

<p><sup>28</sup> This technique is an integral part of the compilation
process, which we shall discuss in chapter 5.  Jonathan Rees wrote a Scheme
interpreter like this in about 1982 for the T project (Rees and Adams
1982).  Marc Feeley (1986) (see also Feeley and Lapalme 1987)
independently invented this technique
in his master's thesis.</p>

<p><sup>29</sup> There is,
however, an important part of the variable search that <emphasis>can</emphasis> be
done as part of the syntactic analysis.  As we will show in
section 5.5.6, one can determine the position
in the environment structure where the value of the variable will be
found, thus obviating the need to scan the environment for the entry
that matches the variable.</p>

<p><sup>30</sup> See exercise 4.23 for some insight
into the processing of sequences.</p>


</section>

<section>


<p><strong>4.2  Variations on a Scheme -- Lazy Evaluation</strong></p>

<p>



Now that we have an evaluator expressed as a Lisp program, we can
experiment with alternative choices in language design simply by
modifying the evaluator.  Indeed, new languages are often invented by
first writing an evaluator that embeds the new language within an
existing high-level language.  For example, if we wish to discuss some
aspect of a proposed modification to Lisp with another member of the
Lisp community, we can supply an evaluator that embodies
the change.  The recipient can then experiment with the new
evaluator and send back comments as further modifications.  Not only
does the high-level implementation base make it easier to test and
debug the evaluator; in addition, the embedding enables the designer
to snarf<sup>31</sup> features
from the underlying language, just as our embedded Lisp evaluator
uses primitives and control structure from the underlying Lisp.  Only
later (if ever) need the designer go to the trouble of building a
complete implementation in a low-level language or in hardware.  In
this section and the next we explore some variations on Scheme that
provide significant additional expressive power.</p>

<p><strong>4.2.1  Normal Order and Applicative Order</strong></p>

<p>

In section 1.1, where we began our discussion
of models of evaluation, we noted that Scheme is an <emphasis>applicative-order</emphasis> language, namely, that all the arguments to Scheme
procedures are evaluated when the procedure is applied.  In
contrast, <emphasis>normal-order</emphasis> languages delay evaluation of procedure arguments
until the actual argument values are needed.
Delaying evaluation of procedure arguments until the
last possible moment (e.g., until they are required by a primitive
operation) is called <emphasis>lazy evaluation</emphasis>.<sup>32</sup>
Consider the procedure</p>

<p>(define (try a b)</p><empty-line /><p>
  (if (= a 0) 1 b))</p><empty-line /><p>
Evaluating (try 0 (/ 1 0)) generates an error in Scheme.  With
lazy evaluation, there would be no error.  Evaluating the expression
would return 1, because the argument (/ 1 0) would
never be evaluated.</p>

<p>

An example that exploits lazy evaluation is the 
definition of a procedure unless</p>

<p>(define (unless condition usual-value exceptional-value)</p><empty-line /><p>
  (if condition exceptional-value usual-value))</p><empty-line /><p>
that can be used in expressions such as</p>

<p>(unless (= b 0)</p><empty-line /><p>
        (/ a b)</p><empty-line /><p>
        (begin (display "exception: returning 0")</p><empty-line /><p>
               0))</p><empty-line /><p>
This won't work in an applicative-order language because both the
usual value and the exceptional value will be evaluated before
unless is called (compare exercise 1.6).  An
advantage of lazy evaluation is that some procedures, such as unless, can do useful computation even if evaluation of some of their
arguments would produce errors or would not terminate.</p>

<p>

If the body of a procedure is entered before an argument has been
evaluated we say that the procedure is <emphasis>non-strict</emphasis> in that
argument.  If the argument is evaluated before the body of the
procedure is entered we say that the procedure is <emphasis>strict</emphasis> in that
argument.<sup>33</sup>
In a purely applicative-order language, all procedures are strict in
each argument.  In a purely normal-order language, all compound
procedures are non-strict in each argument, and primitive procedures may be
either strict or non-strict.  There are also languages (see
exercise 4.31) that give programmers
detailed control over the strictness of the procedures they define.</p>

<p>

A striking example of a procedure that can usefully be made non-strict
is cons (or, in general, almost any constructor for data
structures).  One can do useful computation, combining elements to
form data structures and operating on the resulting data structures,
even if the values of the elements are not known.  It makes perfect
sense, for instance, to compute the length of a list without knowing
the values of the individual elements in the list.  We will exploit
this idea in section 4.2.3 to implement the
streams of chapter 3 as lists formed of non-strict cons
pairs.</p>

<p>
<strong>Exercise 4.25.</strong>  Suppose that (in ordinary applicative-order Scheme) we define unless
as shown above and then define factorial in terms of unless as</p>

<p>(define (factorial n)</p><empty-line /><p>
  (unless (= n 1)</p><empty-line /><p>
          (* n (factorial (- n 1)))</p><empty-line /><p>
          1))</p><empty-line /><p>
What happens if we attempt to evaluate (factorial 5)?  Will our
definitions work in a normal-order language?</p>

<p>
<strong>Exercise 4.26.</strong>  Ben Bitdiddle and Alyssa P. Hacker disagree over the importance of
lazy evaluation for implementing things such as unless.  Ben
points out that it's possible to implement unless in applicative
order as a special form.
Alyssa counters that, if one did that, unless would be merely
syntax, not a procedure that could be used in conjunction with
higher-order procedures.  Fill in the details on both sides of the
argument.  Show how to implement unless as a derived expression
(like cond or let),
and give an example of a situation where it might be useful to have
unless available as a procedure, rather than as a special form.</p>

<p><strong>4.2.2  An Interpreter with Lazy Evaluation</strong></p>

<p>

In this section we will implement a normal-order language that is
the same as Scheme except that compound procedures are non-strict
in each argument.  Primitive procedures will still be strict.
It is not difficult to modify the evaluator of
section 4.1.1 so that the language it interprets behaves
this way.  Almost all the required changes center around procedure
application.</p>

<p>

The basic idea is that, when applying a procedure, the interpreter
must determine which arguments are to be
evaluated and which are to be
delayed.  The delayed arguments are not
evaluated; instead, they are transformed into objects called <emphasis>thunk</emphasis>s.<sup>34</sup>
The thunk must contain the information required to produce the value
of the argument when it is needed, as if it had been evaluated at
the time of the application.  Thus, the thunk must contain the
argument expression and the environment in
which the procedure application is being evaluated.</p>

<p>

The process of evaluating the expression in a thunk is called <emphasis>forcing</emphasis>.<sup>35</sup>
In general, a thunk will be forced only when its value is needed:
when it is passed to a primitive procedure that
will use the value of the thunk; when it is the
value of a predicate of a conditional; and when it
is the value of an operator that is about to be applied as a procedure.
One design choice we have available is whether or not to <emphasis>memoize</emphasis> thunks, as we did with delayed objects in
section 3.5.1.  With memoization, the first time a
thunk is forced, it stores the value that is computed.  Subsequent
forcings simply return the stored value without repeating the
computation.  We'll make our interpreter memoize, because this is
more efficient for many applications.  There are tricky
considerations here, however.<sup>36</sup></p>

<p><strong>Modifying the evaluator</strong></p>

<p>

The main difference between the lazy evaluator and the one in
section 4.1 is in the handling of procedure
applications in eval and apply.</p>

<p>

The application? clause of eval becomes</p>

<p>((application? exp)</p><empty-line /><p>
 (apply (actual-value (operator exp) env)</p><empty-line /><p>
        (operands exp)</p><empty-line /><p>
        env))</p><empty-line /><p>
This is almost the same as the application? clause of eval
in section 4.1.1.  For lazy evaluation, however,
we call apply with the operand expressions, rather than the
arguments produced by evaluating them.  Since we will need the environment to
construct thunks if the arguments are to be delayed, we must pass this as well.
We still evaluate the
operator, because apply needs the actual procedure to be applied
in order to dispatch on its type (primitive versus compound) and apply it.</p>

<p>

Whenever we need the actual value of an expression, we use</p>

<p>(define (actual-value exp env)</p><empty-line /><p>
  (force-it (eval exp env)))</p><empty-line /><p>
instead of just eval, so that if the expression's value
is a thunk, it will be forced.</p>

<p>

Our new version of apply is also almost the same as the
version in section 4.1.1.  The difference is
that eval has passed in unevaluated operand expressions:
For primitive procedures (which are strict), we evaluate all the
arguments before applying the primitive;
for compound procedures (which are non-strict) we delay all the
arguments before applying the procedure.</p>

<p>(define (apply procedure arguments env)</p><empty-line /><p>
  (cond ((primitive-procedure? procedure)</p><empty-line /><p>
         (apply-primitive-procedure</p><empty-line /><p>
          procedure</p><empty-line /><p>
          (list-of-arg-values arguments env)))  <emphasis>; changed</emphasis></p><empty-line /><p>
        ((compound-procedure? procedure)</p><empty-line /><p>
         (eval-sequence</p><empty-line /><p>
          (procedure-body procedure)</p><empty-line /><p>
          (extend-environment</p><empty-line /><p>
           (procedure-parameters procedure)</p><empty-line /><p>
           (list-of-delayed-args arguments env) <emphasis>; changed</emphasis></p><empty-line /><p>
           (procedure-environment procedure))))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (error</p><empty-line /><p>
          "Unknown procedure type -- APPLY" procedure))))</p><empty-line /><p>
The procedures that process the arguments are just like list-of-values from section 4.1.1, except that
list-of-delayed-args delays the arguments instead of evaluating
them, and list-of-arg-values uses actual-value instead
of eval:</p>

<p>(define (list-of-arg-values exps env)</p><empty-line /><p>
  (if (no-operands? exps)</p><empty-line /><p>
      '()</p><empty-line /><p>
      (cons (actual-value (first-operand exps) env)</p><empty-line /><p>
            (list-of-arg-values (rest-operands exps)</p><empty-line /><p>
                                env))))</p><empty-line /><p>(define (list-of-delayed-args exps env)</p><empty-line /><p>
  (if (no-operands? exps)</p><empty-line /><p>
      '()</p><empty-line /><p>
      (cons (delay-it (first-operand exps) env)</p><empty-line /><p>
            (list-of-delayed-args (rest-operands exps)</p><empty-line /><p>
                                  env))))</p><empty-line /><empty-line /><p>

The other place we must change the evaluator is in the handling of
if, where we must use actual-value instead
of eval to get the value of the predicate expression
before testing whether it is true or false:</p>

<p>(define (eval-if exp env)</p><empty-line /><p>
  (if (true? (actual-value (if-predicate exp) env))</p><empty-line /><p>
      (eval (if-consequent exp) env)</p><empty-line /><p>
      (eval (if-alternative exp) env)))</p><empty-line /><empty-line /><p>

Finally, we must change the driver-loop
procedure (section 4.1.4) to use actual-value instead
of eval, so that if a delayed value
is propagated back to the read-eval-print loop, it will be forced
before being printed.  We also change the prompts to indicate that
this is the lazy evaluator:</p>

<p>(define input-prompt ";;; L-Eval input:")</p><empty-line /><p>
(define output-prompt ";;; L-Eval value:")</p><empty-line /><p>(define (driver-loop)</p><empty-line /><p>
  (prompt-for-input input-prompt)</p><empty-line /><p>
  (let ((input (read)))</p><empty-line /><p>
    (let ((output</p><empty-line /><p>
           (actual-value input the-global-environment)))</p><empty-line /><p>
      (announce-output output-prompt)</p><empty-line /><p>
      (user-print output)))</p><empty-line /><p>
  (driver-loop))</p><empty-line /><empty-line /><p>

With these changes made, we can start the evaluator and test it.  The
successful evaluation of the try expression discussed in
section 4.2.1 indicates that the interpreter is
performing lazy evaluation:</p>

<p>(define the-global-environment (setup-environment))</p><empty-line /><p>
(driver-loop)</p><empty-line /><p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
(define (try a b)</p><empty-line /><p>
  (if (= a 0) 1 b))</p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
(try 0 (/ 1 0))</p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p><emphasis>1</emphasis></p><empty-line /><empty-line /><p><strong>Representing thunks</strong></p>

<p>


Our evaluator must arrange to create thunks when procedures are
applied to arguments and to force these thunks later.  A thunk must
package an expression together with the environment, so that the
argument can be produced later.
To force the thunk, we simply extract the expression and environment
from the thunk and evaluate the expression in the environment.
We use actual-value rather than eval so that in case the
value of the expression is itself a thunk, we will force that, and so
on, until we reach something that is not a thunk:</p>

<p>(define (force-it obj)</p><empty-line /><p>
  (if (thunk? obj)</p><empty-line /><p>
      (actual-value (thunk-exp obj) (thunk-env obj))</p><empty-line /><p>
      obj))</p><empty-line /><empty-line /><p>

One easy way to package an expression with an environment is to make a
list containing the expression and the environment.
Thus, we create a thunk as follows:</p>

<p>(define (delay-it exp env)</p><empty-line /><p>
  (list 'thunk exp env))</p><empty-line /><empty-line /><p>
(define (thunk? obj)</p><empty-line /><p>
  (tagged-list? obj 'thunk))</p><empty-line /><empty-line /><p>
(define (thunk-exp thunk) (cadr thunk))</p><empty-line /><empty-line /><p>
(define (thunk-env thunk) (caddr thunk))</p><empty-line /><empty-line /><p>

Actually, what we want for our interpreter is not quite this, but
rather thunks that have been memoized.
When a thunk is forced, we will turn it into an evaluated thunk
by replacing the stored expression with its value and
changing the thunk tag so that it can be recognized as
already evaluated.<sup>37</sup></p>

<p>(define (evaluated-thunk? obj)</p><empty-line /><p>
  (tagged-list? obj 'evaluated-thunk))</p><empty-line /><empty-line /><p>
(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))</p><empty-line /><p>(define (force-it obj)</p><empty-line /><p>
  (cond ((thunk? obj)</p><empty-line /><p>
         (let ((result (actual-value</p><empty-line /><p>
                        (thunk-exp obj)</p><empty-line /><p>
                        (thunk-env obj))))</p><empty-line /><p>
           (set-car! obj 'evaluated-thunk)</p><empty-line /><p>
           (set-car! (cdr obj) result)  <emphasis>; replace exp with its value</emphasis></p><empty-line /><p>
           (set-cdr! (cdr obj) '())     <emphasis>; forget unneeded env</emphasis></p><empty-line /><p>
           result))</p><empty-line /><p>
        ((evaluated-thunk? obj)</p><empty-line /><p>
         (thunk-value obj))</p><empty-line /><p>
        (else obj)))</p><empty-line /><p>
Notice that the same delay-it procedure works both with and
without memoization.</p>

<p>
<strong>Exercise 4.27.</strong>  Suppose we type in the following definitions to the lazy evaluator:</p>

<p>(define count 0)</p><empty-line /><p>
(define (id x)</p><empty-line /><p>
  (set! count (+ count 1))</p><empty-line /><p>
  x)</p><empty-line /><p>
Give the missing values in the following sequence of
interactions, and explain your answers.<sup>38</sup></p>

<p>(define w (id (id 10)))</p><empty-line /><p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
count</p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p>
&lt;<emphasis>response</emphasis>&gt;</p><empty-line /><p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
w</p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p>
&lt;<emphasis>response</emphasis>&gt;</p><empty-line /><p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
count</p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p>
&lt;<emphasis>response</emphasis>&gt;</p><empty-line /><empty-line /><p>
<strong>Exercise 4.28.</strong>  Eval uses actual-value rather than eval
to evaluate the operator before passing it to apply,
in order to force the value of the operator.
Give an example that demonstrates the need for this forcing.</p>

<p>
<strong>Exercise 4.29.</strong>  Exhibit a program that you would expect to run much more slowly
without memoization than with memoization.  Also, consider the
following interaction, where the id procedure is defined as in
exercise 4.27 and count starts at 0:</p>

<p>(define (square x)</p><empty-line /><p>
  (* x x))</p><empty-line /><p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
(square (id 10))</p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p>
&lt;<emphasis>response</emphasis>&gt;</p><empty-line /><p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
count</p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p>
&lt;<emphasis>response</emphasis>&gt;</p><empty-line /><p>
Give the responses both when the evaluator memoizes and when it does not.</p>

<p>
<strong>Exercise 4.30.</strong>  Cy D. Fect, a reformed C programmer, is worried that some side effects
may never take place, because the lazy evaluator doesn't force the
expressions in a sequence.
Since the value of an expression in a sequence other than the last one
is not used (the expression is there only for its effect, such as
assigning to a variable or printing), there can be no subsequent use
of this value (e.g., as an argument to a primitive procedure) that
will cause it to be forced.  Cy thus thinks that when evaluating
sequences, we must force all expressions in the sequence except the
final one.  He proposes to modify eval-sequence from
section 4.1.1 to use actual-value rather
than eval:</p>

<p>(define (eval-sequence exps env)</p><empty-line /><p>
  (cond ((last-exp? exps) (eval (first-exp exps) env))</p><empty-line /><p>
        (else (actual-value (first-exp exps) env)</p><empty-line /><p>
              (eval-sequence (rest-exps exps) env))))</p><empty-line /><empty-line /><p>a. Ben Bitdiddle thinks Cy is wrong.
He shows Cy the for-each procedure described in
exercise 2.23, which gives an important example of
a sequence with side effects:</p>

<p>(define (for-each proc items)</p><empty-line /><p>
  (if (null? items)</p><empty-line /><p>
      'done</p><empty-line /><p>
      (begin (proc (car items))</p><empty-line /><p>
             (for-each proc (cdr items)))))</p><empty-line /><p>
He claims that the evaluator in the text (with the original eval-sequence) handles this correctly:</p>

<p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
(for-each (lambda (x) (newline) (display x))</p><empty-line /><p>
          (list 57 321 88))</p><empty-line /><p><emphasis>57</emphasis></p><empty-line /><p><emphasis>321</emphasis></p><empty-line /><p><emphasis>88</emphasis></p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
Explain why Ben is right about the behavior of for-each.</p>

<p>b. Cy agrees that Ben is right about the for-each example,
but says that that's not the kind of program he was thinking about
when he proposed his change to eval-sequence.
He defines the following two procedures in the lazy evaluator:</p>

<p>(define (p1 x)</p><empty-line /><p>
  (set! x (cons x '(2)))</p><empty-line /><p>
  x)</p><empty-line /><empty-line /><p>
(define (p2 x)</p><empty-line /><p>
  (define (p e)</p><empty-line /><p>
    e</p><empty-line /><p>
    x)</p><empty-line /><p>
  (p (set! x (cons x '(2)))))</p><empty-line /><p>
What are the values of (p1 1) and (p2 1) with the
original eval-sequence?
What would the values be with Cy's proposed change to eval-sequence?</p>

<p>c. Cy also points out that changing eval-sequence as he proposes
does not affect the behavior of the example in part a.
Explain why this is true.</p>

<p>d. How do you think sequences ought to be treated in the lazy evaluator?
Do you like Cy's approach, the approach in the text, or some other approach?</p>

<p>
<strong>Exercise 4.31.</strong>  The approach taken in this section is somewhat unpleasant, because it
makes an incompatible change to Scheme.  It might be nicer to
implement lazy evaluation as an <emphasis>upward-compatible extension</emphasis>,
that is, so that ordinary Scheme programs will work as before.  We can
do this by extending the syntax of procedure declarations to let the user
control whether or not arguments are to be delayed.  While we're at
it, we may as well also give the user the choice between delaying with
and without memoization.  For example, the definition</p>

<p>(define (f a (b lazy) c (d lazy-memo))</p><empty-line /><p>
  ...)</p><empty-line /><p>
would define f to be a procedure of four arguments, where the
first and third arguments are evaluated when the procedure is called,
the second argument is delayed, and the fourth argument is both
delayed and memoized.  Thus, ordinary procedure definitions will
produce the same behavior as ordinary Scheme, while adding the lazy-memo declaration to each parameter of every compound procedure
will produce the behavior of the lazy evaluator defined in this
section. Design and implement the changes required to produce such an
extension to Scheme.  You will have to implement new syntax procedures
to handle the new syntax for define.  You must also arrange for
eval or apply to determine when arguments are to be delayed, and to
force or delay arguments accordingly, and you must arrange for forcing
to memoize or not, as appropriate.</p>

<p><strong>4.2.3  Streams as Lazy Lists</strong></p>

<p>



In section 3.5.1, we showed how to implement streams
as delayed lists.  We introduced special forms delay and cons-stream, which allowed us to construct a "promise" to compute
the cdr of a stream, without actually fulfilling that promise
until later.  We could use this general technique of introducing
special forms whenever we need more control over the evaluation process,
but this is awkward.  For one thing, a special form is not a
first-class object like a procedure, so we cannot use it together with
higher-order procedures.<sup>39</sup>  Additionally,
we were forced to create streams as a new kind of data object
similar but not identical to lists, and this required us to
reimplement many ordinary list operations (map, append, and
so on) for use with streams.</p>

<p>


With lazy evaluation, streams and lists can be identical, so there is
no need for special forms or for separate list and stream operations.
All we need to do is to arrange matters so that cons is
non-strict.  One way to accomplish this is to extend the lazy
evaluator to allow for non-strict primitives, and to implement cons as one of these.  An easier way is to recall
(section 2.1.3) that there is no fundamental need to
implement cons as a primitive at all.  Instead, we can represent
pairs as procedures:<sup>40</sup></p>

<p>(define (cons x y)</p><empty-line /><p>
  (lambda (m) (m x y)))</p><empty-line /><p>(define (car z)</p><empty-line /><p>
  (z (lambda (p q) p)))</p><empty-line /><p>(define (cdr z)</p><empty-line /><p>
  (z (lambda (p q) q)))</p><empty-line /><empty-line /><p>

In terms of these basic operations, the standard definitions of the
list operations will work with infinite lists (streams) as well as
finite ones, and the stream operations can be implemented as list operations.
Here are some examples:</p>

<p>(define (list-ref items n)</p><empty-line /><p>
  (if (= n 0)</p><empty-line /><p>
      (car items)</p><empty-line /><p>
      (list-ref (cdr items) (- n 1))))</p><empty-line /><p>(define (map proc items)</p><empty-line /><p>
  (if (null? items)</p><empty-line /><p>
      '()</p><empty-line /><p>
      (cons (proc (car items))</p><empty-line /><p>
            (map proc (cdr items)))))</p><empty-line /><p>(define (scale-list items factor)</p><empty-line /><p>
  (map (lambda (x) (* x factor))</p><empty-line /><p>
       items))</p><empty-line /><p>(define (add-lists list1 list2)</p><empty-line /><p>
  (cond ((null? list1) list2)</p><empty-line /><p>
        ((null? list2) list1)</p><empty-line /><p>
        (else (cons (+ (car list1) (car list2))</p><empty-line /><p>
                    (add-lists (cdr list1) (cdr list2))))))</p><empty-line /><p>(define ones (cons 1 ones))</p><empty-line /><p>(define integers (cons 1 (add-lists ones integers)))</p><empty-line /><p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
(list-ref integers 17)</p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p><emphasis>18</emphasis></p><empty-line /><empty-line /><p>


Note that these lazy lists are even lazier than the streams of
chapter 3:  The car of the list, as well as the cdr, is
delayed.<sup>41</sup>
In fact, even accessing the car or cdr of a lazy
pair need not force the value of a list element.  The value will be
forced only when it is really needed -- e.g., for use as the
argument of a primitive, or to be printed as an answer.</p>

<p>

Lazy pairs also help with the problem that arose with streams in
section 3.5.4, where we found that
formulating stream models of systems with loops may require us to
sprinkle our programs with explicit delay operations, beyond the
ones supplied by cons-stream.  With lazy evaluation, all
arguments to procedures are delayed uniformly.  For instance, we can
implement procedures to integrate lists and solve differential
equations as we originally intended in
section 3.5.4:</p>

<p>(define (integral integrand initial-value dt)</p><empty-line /><p>
  (define int</p><empty-line /><p>
    (cons initial-value</p><empty-line /><p>
          (add-lists (scale-list integrand dt)</p><empty-line /><p>
                    int)))</p><empty-line /><p>
  int)</p><empty-line /><p>(define (solve f y0 dt)</p><empty-line /><p>
  (define y (integral dy y0 dt))</p><empty-line /><p>
  (define dy (map f y))</p><empty-line /><p>
  y)</p><empty-line /><p><emphasis>;;; L-Eval input:</emphasis></p><empty-line /><p>
(list-ref (solve (lambda (x) x) 1 0.001) 1000)</p><empty-line /><p><emphasis>;;; L-Eval value:</emphasis></p><empty-line /><p><emphasis>2.716924</emphasis></p><empty-line /><p>
<strong>Exercise 4.32.</strong>  Give some examples that illustrate the difference between the streams
of chapter 3 and the "lazier" lazy lists described in this section.
How can you take advantage of this extra laziness?</p>

<p>
<strong>Exercise 4.33.</strong>  Ben Bitdiddle tests the lazy list implementation given above by
evaluating the expression</p>

<p>(car '(a b c))</p><empty-line /><p>
To his surprise, this produces an error.  After some thought, he
realizes that the "lists" obtained by reading in quoted expressions
are different from the lists manipulated by the new definitions of
cons, car, and cdr.  Modify the evaluator's
treatment of quoted expressions so that quoted lists typed at the
driver loop will produce true lazy lists.</p>

<p>
<strong>Exercise 4.34.</strong>  Modify the driver loop for the evaluator so that lazy pairs and lists
will print in some reasonable way.  (What are you going to do about
infinite lists?)  You may also need to modify the representation of
lazy pairs so that the evaluator can identify them in order
to print them.</p><empty-line /><empty-line /><empty-line /><p><sup>31</sup> Snarf: "To grab, especially a large document or
file for the purpose of using it either with or without the owner's
permission."  Snarf down: "To snarf, sometimes with the connotation
of absorbing, processing, or understanding."  (These definitions were
snarfed from Steele et al. 1983.  See also Raymond 1993.)</p>

<p><sup>32</sup> The difference between the "lazy" terminology and
the "normal-order" terminology is somewhat fuzzy.  Generally, "lazy"
refers to the mechanisms of particular evaluators, while "normal-order"
refers to the semantics of languages, independent of any particular
evaluation strategy.  But this is not a hard-and-fast distinction, and
the two terminologies are often used interchangeably.</p>

<p><sup>33</sup> The "strict" versus "non-strict" terminology means essentially the
same thing as "applicative-order" versus "normal-order", except that
it refers to individual procedures and arguments rather than to the
language as a whole.  At a conference on programming languages you
might hear someone say, "The normal-order language Hassle has certain
strict primitives.  Other procedures take their arguments by lazy
evaluation."</p>

<p><sup>34</sup> The word <emphasis>thunk</emphasis> was invented by an informal
working group that was discussing the implementation of call-by-name
in Algol 60.  They observed that most of the analysis of ("thinking
about") the expression could be done at compile time; thus, at run
time, the expression would already have been "thunk" about (Ingerman
et al. 1960).</p>

<p><sup>35</sup> This is analogous to the use of force
on the delayed objects that were introduced in chapter 3 to represent
streams.  The critical difference between what we are
doing here and what we did in chapter 3 is that we are building
delaying and forcing into the evaluator, and thus making this uniform
and automatic throughout the language.</p>

<p><sup>36</sup> Lazy evaluation combined with memoization is sometimes
referred to as <emphasis>call-by-need</emphasis> argument passing, in contrast to
<emphasis>call-by-name</emphasis> argument passing.  (Call-by-name, introduced in
Algol 60, is similar to non-memoized lazy evaluation.)
As language designers, we can build our evaluator to memoize,
not to memoize, or leave this an option for programmers
(exercise 4.31).  As you might expect
from chapter 3, these choices raise issues that become both subtle and
confusing in the presence of assignments.  (See
exercises 4.27 and 4.29.)
An excellent article by Clinger (1982) attempts to clarify the
multiple dimensions of confusion that arise here.</p>

<p><sup>37</sup> Notice that we also erase the env from the thunk once the
expression's value has been computed.  This makes no difference in the
values returned by the interpreter.  It does help save space,
however, because removing the reference from the thunk to the env
once it is no longer needed allows this structure to be
<emphasis>garbage-collected</emphasis> and its
space recycled, as we will discuss in section 5.3.</p>

<p>

Similarly, we could have allowed unneeded environments in the memoized
delayed objects of section 3.5.1 to be garbage-collected,
by having memo-proc do something like (set! proc '())
to discard the procedure proc (which includes the environment
in which the delay was evaluated) after storing its value.</p>

<p><sup>38</sup> This exercise
demonstrates that the interaction between lazy evaluation and side
effects can be very confusing.  This is just what you might expect
from the discussion in chapter 3.</p>

<p><sup>39</sup> This is precisely the issue with the unless procedure,
as in exercise 4.26.</p>

<p><sup>40</sup> This is the procedural representation described in
exercise 2.4.  Essentially any procedural representation
(e.g., a message-passing implementation) would do as well.  Notice
that we can install these definitions in the lazy evaluator simply by
typing them at the driver loop.  If we had originally included cons, car, and cdr as primitives in the global
environment, they will be redefined.  (Also see
exercises 4.33 and 4.34.)</p>

<p><sup>41</sup> This permits us to create delayed versions of more general kinds of
list structures, not just sequences.  Hughes 1990 discusses some
applications of "lazy trees."</p>


</section>

<section>


<p><strong>4.3  Variations on a Scheme -- Nondeterministic Computing</strong></p>

<p>



In this section, we extend the Scheme evaluator to support a
programming paradigm called <emphasis>nondeterministic computing</emphasis> by
building into the evaluator a facility to support automatic search.
This is a much more profound change to the language than the
introduction of lazy evaluation in section 4.2.</p>

<p>

Nondeterministic computing, like stream processing, is useful for
"generate and test" applications.  Consider the task of starting with
two lists of positive integers and finding a pair of integers -- one
from the first list and one from the second list -- whose sum is prime.
We saw how to handle this with finite sequence operations in
section 2.2.3 and with infinite streams in
section 3.5.3.  Our approach was to generate
the sequence of all possible pairs and filter these to select the
pairs whose sum is prime.  Whether we actually generate the entire
sequence of pairs first as in chapter 2, or interleave the generating
and filtering as in chapter 3, is immaterial to the essential image of
how the computation is organized.</p>

<p>

The nondeterministic approach evokes a different image.  Imagine simply
that we choose (in some way) a number from the first list and a number
from the second list and require (using some mechanism) that their sum
be prime.  This is expressed by following procedure:</p>

<p>(define (prime-sum-pair list1 list2)</p><empty-line /><p>
  (let ((a (an-element-of list1))</p><empty-line /><p>
        (b (an-element-of list2)))</p><empty-line /><p>
    (require (prime? (+ a b)))</p><empty-line /><p>
    (list a b)))</p><empty-line /><p>
It might seem as if this procedure merely restates the problem,
rather than specifying a way to solve it.  Nevertheless, this is
a legitimate nondeterministic program.<sup>42</sup></p>

<p>


The key idea here is that expressions in a nondeterministic language
can have more than one possible value.  For instance,
an-element-of might return any element of the given list.  Our
nondeterministic program evaluator will work by automatically choosing
a possible value and keeping track of the choice.  If a subsequent
requirement is not met, the evaluator will try a different choice, and
it will keep trying new choices until the evaluation succeeds, or
until we run out of choices.  Just as the lazy evaluator freed the
programmer from the details of how values are delayed and forced, the
nondeterministic program evaluator will free the programmer from the
details of how choices are made.</p>

<p>

It is instructive to contrast the different images of time evoked by
nondeterministic evaluation and stream processing.  Stream processing
uses lazy evaluation to decouple the time when the stream of possible
answers is assembled from the time when the actual stream elements are
produced.  The evaluator supports the illusion that all the possible
answers are laid out before us in a timeless sequence.  With
nondeterministic evaluation, an expression represents the exploration
of a set of possible worlds, each determined by a set of choices.
Some of the possible worlds lead to dead ends, while others have
useful values.  The nondeterministic program evaluator supports the
illusion that time branches, and that our programs have different
possible execution histories.  When we reach a dead end, we can
revisit a previous choice point and proceed along a different branch.</p>

<p>

The nondeterministic program evaluator implemented below is called the
amb evaluator because it is based on a new special form called
amb.  We can type the above definition of prime-sum-pair
at the amb evaluator driver loop (along with definitions of prime?, an-element-of, and require) and run the
procedure as follows:</p>

<p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
(prime-sum-pair '(1 3 5 8) '(20 35 110))</p><empty-line /><p><emphasis>;;; Starting a new problem</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>(3 20)</emphasis></p><empty-line /><p>
The value returned was obtained after the evaluator repeatedly chose
elements from each of the lists, until a successful choice was made.</p>

<p>

Section 4.3.1 introduces amb and explains how it
supports nondeterminism through the evaluator's automatic search
mechanism.  Section 4.3.2 presents examples of
nondeterministic programs, and section 4.3.3
gives the details of how to implement the amb evaluator by
modifying the ordinary Scheme evaluator.</p>

<p><strong>4.3.1  Amb and Search</strong></p>

<p>

To extend Scheme to support nondeterminism, we introduce a new special
form called amb.<sup>43</sup>
The expression (amb &lt;<emphasis>e<sub>1</sub></emphasis>&gt; &lt;<emphasis>e<sub>2</sub></emphasis>&gt; ... &lt;<emphasis>e<sub>n</sub></emphasis>&gt;)
returns the value of one of the <emphasis>n</emphasis> expressions &lt;<emphasis>e<sub>i</sub></emphasis>&gt; "ambiguously."
For example, the expression</p>

<p>(list (amb 1 2 3) (amb 'a 'b))</p><empty-line /><p>
can have six possible values:</p>

<p>(1 a)</p>

<p>(1 b)</p>

<p>(2 a)</p>

<p>(2 b)</p>

<p>(3 a)</p>

<p>(3 b)</p>

<p>Amb</p>

<p> with a single choice produces an ordinary (single) value.</p>

<p>

Amb with no choices -- the expression (amb) -- is an
expression with no acceptable values.  Operationally, we can think of
(amb) as an expression that when evaluated causes the
computation to "fail": The computation aborts and no value is
produced.  Using this idea, we can express the requirement that a
particular predicate expression p must be true as follows:</p>

<p>(define (require p)</p><empty-line /><p>
  (if (not p) (amb)))</p><empty-line /><empty-line /><p>

With amb and require, we can implement the an-element-of procedure used above:</p>

<p>(define (an-element-of items)</p><empty-line /><p>
  (require (not (null? items)))</p><empty-line /><p>
  (amb (car items) (an-element-of (cdr items))))</p><empty-line /><p>
An-element-of fails if the list is empty.  Otherwise it
ambiguously returns either the first element of the list or an element
chosen from the rest of the list.</p>

<p>

We can also express infinite ranges of choices.  The following
procedure potentially returns any integer greater than or equal to
some given <emphasis>n</emphasis>:</p>

<p>(define (an-integer-starting-from n)</p><empty-line /><p>
  (amb n (an-integer-starting-from (+ n 1))))</p><empty-line /><p>
This is like the stream procedure integers-starting-from
described in section 3.5.2, but with an important
difference: The stream procedure returns an object that represents the
sequence of all integers beginning with <emphasis>n</emphasis>, whereas the amb
procedure returns a single integer.<sup>44</sup></p>

<p>

Abstractly, we can imagine that evaluating an amb expression
causes time to split into branches, where the computation continues on
each branch with one of the possible values of the expression.  We say
that amb represents a <emphasis>nondeterministic choice point</emphasis>.
If we had a machine with a sufficient number of processors that could
be dynamically allocated, we could implement the search in a
straightforward way.  Execution would proceed as in a sequential
machine, until an amb expression is encountered.  At this point,
more processors would be allocated and initialized to continue all of
the parallel executions implied by the choice.  Each processor would
proceed sequentially as if it were the only choice, until it either
terminates by encountering a failure, or it further subdivides, or
it finishes.<sup>45</sup></p>

<p>

On the other hand, if we have a machine that can execute
only one process (or a few concurrent processes),
we must consider the alternatives sequentially.
One could imagine modifying an evaluator
to pick at random a branch to follow whenever it encounters a choice
point.  Random choice, however, can easily lead to failing values.
We might try running the evaluator over and over, making random
choices and hoping to find a non-failing value, but it is better to <emphasis>systematically search</emphasis> all possible execution paths.
The amb evaluator that we will develop and work with in this section
implements a systematic search as follows: When the evaluator
encounters an application of amb, it initially selects the first
alternative.  This selection may itself lead to a further choice.  The
evaluator will always initially choose the first alternative at each
choice point.  If a choice results in a failure, then the evaluator
automagically<sup>46</sup> <emphasis>backtracks</emphasis>
to the most recent choice point and tries the next
alternative.  If it runs out of alternatives at any choice point, the
evaluator will back up to the previous choice point and resume from
there.  This process leads to a search strategy known as <emphasis>depth-first search</emphasis> or <emphasis>chronological backtracking</emphasis>.<sup>47</sup></p>

<p><strong>Driver loop</strong></p>

<p>

The driver loop for the amb evaluator
has some unusual properties.  It reads an
expression and prints the value of the first non-failing execution, as
in the prime-sum-pair example shown above.  If we
want to see the value of the next successful execution, we can
ask the interpreter to backtrack and attempt to generate a second
non-failing execution.  This is signaled by typing the symbol try-again.  If any expression except try-again is given, the
interpreter will start a new problem, discarding the unexplored
alternatives in the previous problem.  Here is a sample
interaction:</p>

<p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
(prime-sum-pair '(1 3 5 8) '(20 35 110))</p><empty-line /><p><emphasis>;;; Starting a new problem</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>(3 20)</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
try-again</p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>(3 110)</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
try-again</p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>(8 35)</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
try-again</p><empty-line /><p><emphasis>;;; There are no more values of</emphasis></p><empty-line /><p><emphasis>(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
(prime-sum-pair '(19 27 30) '(11 36 58))</p><empty-line /><p><emphasis>;;; Starting a new problem</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>(30 11)</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 4.35.</strong>  Write a procedure an-integer-between that returns an integer
between two given bounds.  This can be used to implement a
procedure that finds Pythagorean triples,
i.e., triples of integers (<emphasis>i</emphasis>,<emphasis>j</emphasis>,<emphasis>k</emphasis>) between the given bounds such
that <emphasis>i</emphasis> &lt; <emphasis>j</emphasis> and <emphasis>i</emphasis><sup>2</sup>  +  <emphasis>j</emphasis><sup>2</sup>  = <emphasis>k</emphasis><sup>2</sup>, as follows:</p>

<p>(define (a-pythagorean-triple-between low high)</p><empty-line /><p>
  (let ((i (an-integer-between low high)))</p><empty-line /><p>
    (let ((j (an-integer-between i high)))</p><empty-line /><p>
      (let ((k (an-integer-between j high)))</p><empty-line /><p>
        (require (= (+ (* i i) (* j j)) (* k k)))</p><empty-line /><p>
        (list i j k)))))</p><empty-line /><empty-line /><p>
<strong>Exercise 4.36.</strong>  Exercise 3.69 discussed how to generate
the stream of <emphasis>all</emphasis> Pythagorean triples, with no upper bound on the
size of the integers to be searched.  Explain why simply replacing
an-integer-between by an-integer-starting-from in the procedure in
exercise 4.35 is not an adequate way to
generate arbitrary Pythagorean triples.  Write a procedure that
actually will accomplish this.  (That is, write a procedure for which
repeatedly typing try-again would in principle eventually
generate all Pythagorean triples.)</p>

<p>
<strong>Exercise 4.37.</strong>  Ben Bitdiddle claims that the following method for generating
Pythagorean triples is more efficient than the one in
exercise 4.35.  Is he correct?  (Hint: Consider
the number of possibilities that must be explored.)</p>

<p>(define (a-pythagorean-triple-between low high)</p><empty-line /><p>
  (let ((i (an-integer-between low high))</p><empty-line /><p>
        (hsq (* high high)))</p><empty-line /><p>
    (let ((j (an-integer-between i high)))</p><empty-line /><p>
      (let ((ksq (+ (* i i) (* j j))))</p><empty-line /><p>
        (require (&gt;= hsq ksq))</p><empty-line /><p>
        (let ((k (sqrt ksq)))</p><empty-line /><p>
          (require (integer? k))</p><empty-line /><p>
          (list i j k))))))</p><empty-line /><empty-line /><p><strong>4.3.2  Examples of Nondeterministic Programs</strong></p>

<p>

Section 4.3.3 describes the implementation of
the amb evaluator.  First, however, we give some examples of how
it can be used.  The advantage of nondeterministic programming is that
we can suppress the details of how search is carried out, thereby
expressing our programs at a higher level of abstraction.</p>

<p><strong>Logic Puzzles</strong></p>

<p>


The following puzzle (taken from Dinesman 1968) is typical of a large
class of simple logic puzzles:</p>

<p>
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of
an apartment house that contains only five floors.  Baker does not
live on the top floor.  Cooper does not live on the bottom floor.
Fletcher does not live on either the top or the bottom floor.  Miller
lives on a higher floor than does Cooper.  Smith does not live on a
floor adjacent to Fletcher's.  Fletcher does not live on a floor
adjacent to Cooper's.  Where does everyone live?</p>

<p>

We can determine who lives on each floor in a straightforward way by
enumerating all the possibilities and imposing the given
restrictions:<sup>48</sup></p>

<p>(define (multiple-dwelling)</p><empty-line /><p>
  (let ((baker (amb 1 2 3 4 5))</p><empty-line /><p>
        (cooper (amb 1 2 3 4 5))</p><empty-line /><p>
        (fletcher (amb 1 2 3 4 5))</p><empty-line /><p>
        (miller (amb 1 2 3 4 5))</p><empty-line /><p>
        (smith (amb 1 2 3 4 5)))</p><empty-line /><p>
    (require</p><empty-line /><p>
     (distinct? (list baker cooper fletcher miller smith)))</p><empty-line /><p>
    (require (not (= baker 5)))</p><empty-line /><p>
    (require (not (= cooper 1)))</p><empty-line /><p>
    (require (not (= fletcher 5)))</p><empty-line /><p>
    (require (not (= fletcher 1)))</p><empty-line /><p>
    (require (&gt; miller cooper))</p><empty-line /><p>
    (require (not (= (abs (- smith fletcher)) 1)))</p><empty-line /><p>
    (require (not (= (abs (- fletcher cooper)) 1)))</p><empty-line /><p>
    (list (list 'baker baker)</p><empty-line /><p>
          (list 'cooper cooper)</p><empty-line /><p>
          (list 'fletcher fletcher)</p><empty-line /><p>
          (list 'miller miller)</p><empty-line /><p>
          (list 'smith smith))))</p><empty-line /><empty-line /><p>


Evaluating the expression (multiple-dwelling) produces the
result</p>

<p>((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))</p><empty-line /><p>
Although this simple procedure works, it is very slow.
Exercises 4.39
and 4.40 discuss some possible
improvements.</p>

<p>
<strong>Exercise 4.38.</strong>  Modify the multiple-dwelling procedure to omit the requirement that
Smith and Fletcher do not live on adjacent floors.  How many solutions
are there to this modified puzzle?</p>

<p>
<strong>Exercise 4.39.</strong>  Does the order of the restrictions in the multiple-dwelling procedure
affect the answer? Does it affect the time to find an answer?  If you
think it matters, demonstrate a faster program obtained from the given
one by reordering the restrictions.  If you think it does not matter,
argue your case.</p>

<p>
<strong>Exercise 4.40.</strong>  In the multiple dwelling problem, how many sets of assignments are
there of people to floors, both before and after the requirement that
floor assignments be distinct?  It is very inefficient to generate all
possible assignments of people to floors and then leave it to
backtracking to eliminate them.  For example, most of the restrictions
depend on only one or two of the person-floor variables, and can thus
be imposed before floors have been selected for all the people.
Write and demonstrate a much more efficient
nondeterministic procedure that solves this problem based upon
generating only those possibilities that are not already ruled out by
previous restrictions.  (Hint: This will require a nest of let
expressions.)</p>

<p>
<strong>Exercise 4.41.</strong>  Write an ordinary Scheme program to solve the multiple dwelling puzzle.</p>

<p>
<strong>Exercise 4.42.</strong>  Solve the following "Liars" puzzle (from Phillips 1934):</p>

<p>
Five schoolgirls sat for an examination.  Their parents -- so they
thought -- showed an undue degree of interest in the result.  They
therefore agreed that, in writing home about the examination, each 
girl should make one true statement and one untrue one.  The following
are the relevant passages from their letters:</p>

<p>Betty: "Kitty was second in the examination.  I was only third."</p>

<p>Ethel: "You'll be glad to hear that I was on top.  Joan was second."</p>

<p>Joan: "I was third, and poor old Ethel was bottom."</p>

<p>Kitty: "I came out second.  Mary was only fourth."</p>

<p>Mary: "I was fourth.  Top place was taken by Betty."</p>

<p>
What in fact was the order in which the five girls were placed?</p><empty-line /><p>
<strong>Exercise 4.43.</strong>  Use the amb evaluator to solve the following puzzle:<sup>49</sup></p>

<p>
Mary Ann Moore's father has a yacht and so has each of his four
friends:  Colonel Downing, Mr. Hall, Sir Barnacle Hood, and Dr.
Parker.  Each of the five also has one daughter and each has named his
yacht after a daughter of one of the others.  Sir Barnacle's yacht is
the Gabrielle, Mr. Moore owns the Lorna; Mr. Hall the Rosalind.  The
Melissa, owned by Colonel Downing, is named after Sir Barnacle's
daughter.  Gabrielle's father owns the yacht that is named after Dr.
Parker's daughter.  Who is Lorna's father?</p>

<p>
Try to write the program so that it runs efficiently (see
exercise</p>

<p>4.40</p>

<p>).  Also determine how many
solutions there are if we are not told that Mary Ann's last name is
Moore.</p>

<p>
<strong>Exercise 4.44.</strong>  Exercise 2.42 described the "eight-queens puzzle" of
placing queens on a chessboard so that no two attack each other.
Write a nondeterministic program to solve this puzzle.</p>

<p><strong>Parsing natural language</strong></p>

<p>


Programs designed to accept natural language as input usually start by
attempting to <emphasis>parse</emphasis> the input, that is, to match the input
against some grammatical structure.  For example, we might try to
recognize simple sentences consisting of an article followed by a noun
followed by a verb, such as "The cat eats."  To accomplish such an
analysis, we must be able to identify the parts of speech of
individual words.  We could start with some lists that classify
various words:<sup>50</sup></p>

<p>(define nouns '(noun student professor cat class))</p><empty-line /><p>(define verbs '(verb studies lectures eats sleeps))</p><empty-line /><p>(define articles '(article the a))</p><empty-line /><p>
We also need a <emphasis>grammar</emphasis>, that is, a set of rules describing how
grammatical elements are composed from simpler elements.  A very
simple grammar might stipulate that a sentence always consists of two
pieces -- a noun phrase followed by a verb -- and that a noun phrase
consists of an article followed by a noun.  With this grammar, the
sentence "The cat eats" is parsed as follows:</p>

<p>(sentence (noun-phrase (article the) (noun cat))</p><empty-line /><p>
          (verb eats))</p><empty-line /><empty-line /><p>

We can generate such a parse with a simple program that has separate
procedures for each of the grammatical rules.  To parse a sentence, we
identify its two constituent pieces and return a list of
these two elements, tagged with the symbol sentence:</p>

<p>(define (parse-sentence)</p><empty-line /><p>
  (list 'sentence</p><empty-line /><p>
         (parse-noun-phrase)</p><empty-line /><p>
         (parse-word verbs)))</p><empty-line /><p>
A noun phrase, similarly, is parsed by finding an article followed by a
noun:</p>

<p>(define (parse-noun-phrase)</p><empty-line /><p>
  (list 'noun-phrase</p><empty-line /><p>
        (parse-word articles)</p><empty-line /><p>
        (parse-word nouns)))</p><empty-line /><empty-line /><p>

At the lowest level, parsing boils down to repeatedly checking that
the next unparsed word is a member of the list of words for the
required part of speech.  To implement this, we maintain a global
variable *unparsed*, which is the input that has not yet been
parsed.  Each time we check a word, we require that *unparsed*
must be non-empty and that it should begin with a word from the
designated list.  If so, we remove that word from *unparsed* and
return the word together with its part of speech (which is found at
the head of the list):<sup>51</sup></p>

<p>(define (parse-word word-list)</p><empty-line /><p>
  (require (not (null? *unparsed*)))</p><empty-line /><p>
  (require (memq (car *unparsed*) (cdr word-list)))</p><empty-line /><p>
  (let ((found-word (car *unparsed*)))</p><empty-line /><p>
    (set! *unparsed* (cdr *unparsed*))</p><empty-line /><p>
    (list (car word-list) found-word)))</p><empty-line /><empty-line /><p>

To start the parsing, all we need to do is set *unparsed* to be
the entire input, try to parse a sentence, and check that nothing is
left over:</p>

<p>(define *unparsed* '())</p><empty-line /><p>(define (parse input)</p><empty-line /><p>
  (set! *unparsed* input)</p><empty-line /><p>
  (let ((sent (parse-sentence)))</p><empty-line /><p>
    (require (null? *unparsed*))</p><empty-line /><p>
    sent))</p><empty-line /><empty-line /><p>

We can now try the parser and verify that it works for our simple test
sentence:</p>

<p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
(parse '(the cat eats))</p><empty-line /><p><emphasis>;;; Starting a new problem</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>(sentence (noun-phrase (article the) (noun cat)) (verb eats))</emphasis></p><empty-line /><empty-line /><p>

The amb evaluator is useful here because it is convenient to
express the parsing constraints with the aid of require.
Automatic search and backtracking really pay off, however, when we
consider more complex grammars where there are choices for how the
units can be decomposed.</p>

<p>


Let's add to our grammar a list of prepositions:</p>

<p>(define prepositions '(prep for to in by with))</p><empty-line /><p>

and define a prepositional phrase (e.g., "for the cat") to be
a preposition followed by a noun phrase:</p>

<p>(define (parse-prepositional-phrase)</p><empty-line /><p>
  (list 'prep-phrase</p><empty-line /><p>
        (parse-word prepositions)</p><empty-line /><p>
        (parse-noun-phrase)))</p><empty-line /><p>
Now we can define a sentence to be a noun phrase followed by a verb
phrase, where a verb phrase can be either a verb or a verb phrase
extended by a prepositional phrase:<sup>52</sup></p>

<p>(define (parse-sentence)</p><empty-line /><p>
  (list 'sentence</p><empty-line /><p>
         (parse-noun-phrase)</p><empty-line /><p>
         (parse-verb-phrase)))</p><empty-line /><p>
(define (parse-verb-phrase)</p><empty-line /><p>
  (define (maybe-extend verb-phrase)</p><empty-line /><p>
    (amb verb-phrase</p><empty-line /><p>
         (maybe-extend (list 'verb-phrase</p><empty-line /><p>
                             verb-phrase</p><empty-line /><p>
                             (parse-prepositional-phrase)))))</p><empty-line /><p>
  (maybe-extend (parse-word verbs)))</p><empty-line /><empty-line /><p>

While we're at it, we can also elaborate the definition of noun
phrases to permit such things as "a cat in the class."  What we used
to call a noun phrase, we'll now call a simple noun phrase, and a noun
phrase will now be either a simple noun phrase or a noun phrase
extended by a prepositional phrase:</p>

<p>(define (parse-simple-noun-phrase)</p><empty-line /><p>
  (list 'simple-noun-phrase</p><empty-line /><p>
        (parse-word articles)</p><empty-line /><p>
        (parse-word nouns)))</p><empty-line /><p>
(define (parse-noun-phrase)</p><empty-line /><p>
  (define (maybe-extend noun-phrase)</p><empty-line /><p>
    (amb noun-phrase</p><empty-line /><p>
         (maybe-extend (list 'noun-phrase</p><empty-line /><p>
                             noun-phrase</p><empty-line /><p>
                             (parse-prepositional-phrase)))))</p><empty-line /><p>
  (maybe-extend (parse-simple-noun-phrase)))</p><empty-line /><empty-line /><p>

Our new grammar lets us parse more complex sentences.  For example</p>

<p>(parse '(the student with the cat sleeps in the class))</p><empty-line /><p>
produces</p>

<p>(sentence</p><empty-line /><p>
 (noun-phrase</p><empty-line /><p>
  (simple-noun-phrase (article the) (noun student))</p><empty-line /><p>
  (prep-phrase (prep with)</p><empty-line /><p>
               (simple-noun-phrase</p><empty-line /><p>
                (article the) (noun cat))))</p><empty-line /><p>
 (verb-phrase</p><empty-line /><p>
  (verb sleeps)</p><empty-line /><p>
  (prep-phrase (prep in)</p><empty-line /><p>
               (simple-noun-phrase</p><empty-line /><p>
                (article the) (noun class)))))</p><empty-line /><empty-line /><p>

Observe that a given input may have more than one legal parse.  In
the sentence "The professor lectures to the student with the cat",
it may be that the professor is lecturing with the cat, or that the
student has the cat.  Our nondeterministic program finds both
possibilities:</p>

<p>(parse '(the professor lectures to the student with the cat))</p><empty-line /><p>
produces</p>

<p>(sentence</p><empty-line /><p>
 (simple-noun-phrase (article the) (noun professor))</p><empty-line /><p>
 (verb-phrase</p><empty-line /><p>
  (verb-phrase</p><empty-line /><p>
   (verb lectures)</p><empty-line /><p>
   (prep-phrase (prep to)</p><empty-line /><p>
                (simple-noun-phrase</p><empty-line /><p>
                 (article the) (noun student))))</p><empty-line /><p>
  (prep-phrase (prep with)</p><empty-line /><p>
               (simple-noun-phrase</p><empty-line /><p>
                (article the) (noun cat)))))</p><empty-line /><p>
Asking the evaluator to try again yields</p>

<p>(sentence</p><empty-line /><p>
 (simple-noun-phrase (article the) (noun professor))</p><empty-line /><p>
 (verb-phrase</p><empty-line /><p>
  (verb lectures)</p><empty-line /><p>
  (prep-phrase (prep to)</p><empty-line /><p>
               (noun-phrase</p><empty-line /><p>
                (simple-noun-phrase</p><empty-line /><p>
                 (article the) (noun student))</p><empty-line /><p>
                (prep-phrase (prep with)</p><empty-line /><p>
                             (simple-noun-phrase</p><empty-line /><p>
                              (article the) (noun cat)))))))</p><empty-line /><empty-line /><p>
<strong>Exercise 4.45.</strong>  With the grammar given above, the following sentence can be parsed in
five different ways:
"The professor lectures to the student in the class with the cat."
Give the five parses and explain the differences in shades of
meaning among them.</p>

<p>
<strong>Exercise 4.46.</strong>  The evaluators in sections 4.1 and 4.2
do not determine what order operands are evaluated in.
We will see that the amb evaluator evaluates them from left to right.
Explain why our parsing program wouldn't work if the operands were evaluated
in some other order.</p>

<p>
<strong>Exercise 4.47.</strong>  Louis Reasoner suggests that, since a verb phrase is either a verb or
a verb phrase followed by a prepositional phrase, it would be much more
straightforward to define the procedure parse-verb-phrase as
follows (and similarly for noun phrases):</p>

<p>(define (parse-verb-phrase)</p><empty-line /><p>
  (amb (parse-word verbs)</p><empty-line /><p>
       (list 'verb-phrase</p><empty-line /><p>
             (parse-verb-phrase)</p><empty-line /><p>
             (parse-prepositional-phrase))))</p><empty-line /><p>
Does this work?  Does the program's behavior change if we interchange
the order of expressions in the amb?</p>

<p>
<strong>Exercise 4.48.</strong>  Extend the grammar given above to handle more complex sentences.  For
example, you could extend noun phrases and verb phrases to include
adjectives and adverbs, or you could handle compound sentences.<sup>53</sup></p>

<p>
<strong>Exercise 4.49.</strong>  Alyssa P. Hacker is more interested in generating interesting
sentences than in parsing them.  She reasons that by simply changing
the procedure parse-word so that it ignores the "input
sentence" and instead always succeeds and generates an appropriate
word, we can use the programs we had built for parsing to do
generation instead.  Implement Alyssa's idea, and show the first
half-dozen or so sentences generated.<sup>54</sup></p>

<p><strong>4.3.3  Implementing the Amb Evaluator</strong></p>

<p>



The evaluation of an ordinary Scheme expression may return a value,
may never terminate, or may signal an error.  In nondeterministic
Scheme the evaluation of an expression may in addition result in the
discovery of a dead end, in which case evaluation must backtrack to a previous
choice point.  The interpretation of nondeterministic Scheme is
complicated by this extra case.</p>

<p>

We will construct the amb evaluator for nondeterministic Scheme
by modifying the analyzing evaluator of section 4.1.7.<sup>55</sup>
As in the analyzing evaluator, evaluation of an expression is
accomplished by calling an execution procedure produced by analysis of
that expression.  The difference between the interpretation of ordinary
Scheme and the interpretation of nondeterministic Scheme will be entirely
in the execution procedures.</p>

<p><strong>Execution procedures and continuations</strong></p>

<p>


Recall that the execution procedures for the ordinary evaluator take
one argument: the environment of execution.  In contrast, the
execution procedures in the amb evaluator take three arguments:
the environment, and two procedures called <emphasis>continuation
procedures</emphasis>.  The evaluation of an expression will finish by calling
one of these two continuations: If the evaluation results in a value,
the <emphasis>success continuation</emphasis> is called with that value; if the
evaluation results in the discovery of a dead end, the <emphasis>failure
continuation</emphasis> is called.  Constructing and calling appropriate
continuations is the mechanism by which the nondeterministic evaluator
implements backtracking.</p>

<p>

It is the job of the success continuation to receive a value and
proceed with the computation.  Along with that value, the success
continuation is passed another failure continuation, which is to be
called subsequently if the use of that value leads to a dead end.</p>

<p>

It is the job of the failure continuation to try another branch of the
nondeterministic process.  The essence of the nondeterministic
language is in the fact that expressions may represent choices among
alternatives.  The evaluation of such an expression must proceed with
one of the indicated alternative choices, even though it is not known
in advance which choices will lead to acceptable results.  To deal
with this, the evaluator picks one of the alternatives and passes this
value to the success continuation.  Together with this value, the
evaluator constructs and passes along a failure continuation that can
be called later to choose a different alternative.</p>

<p>

A failure is triggered during evaluation (that is, a failure
continuation is called) when a user program explicitly rejects the
current line of attack (for example, a call to require may
result in execution of (amb), an expression that always
fails -- see section 4.3.1).  The failure continuation in hand
at that point will cause the most recent choice point to choose
another alternative.  If there are no more alternatives to be
considered at that choice point, a failure at an earlier choice point
is triggered, and so on.  Failure continuations are also invoked by
the driver loop in response to a try-again request, to find
another value of the expression.</p>

<p>

In addition, if a side-effect operation (such as assignment to a
variable) occurs on a branch of the process resulting from a choice,
it may be necessary, when the process finds a dead end, to undo the
side effect before making a new choice.  This is accomplished by
having the side-effect operation produce a failure continuation that
undoes the side effect and propagates the failure.</p>

<p>


In summary, failure continuations are constructed by</p>

<p>amb expressions -- to provide a mechanism to make
alternative choices if the current choice made by the amb
expression leads to a dead end;</p>

<p>the top-level driver -- to provide a mechanism to report failure
when the choices are exhausted;</p>

<p>assignments -- to intercept failures and undo assignments
during backtracking.</p>

<p>

Failures are initiated only when a dead end is encountered.
This occurs</p>

<p>if the user program executes (amb);</p>

<p>if the user types try-again at the top-level driver.</p>

<p>

Failure continuations are also called during processing of a failure:</p>

<p>When the failure continuation created by an assignment finishes
undoing a side effect, it calls the failure continuation it intercepted,
in order to propagate the failure back to the choice point that
led to this assignment or to the top level.</p>

<p>When the failure continuation for an amb runs out of choices,
it calls the failure continuation that was originally given to the amb,
in order to propagate the failure back to the previous choice point
or to the top level.</p>

<p><strong>Structure of the evaluator</strong></p>

<p>

The syntax- and data-representation procedures for the amb
evaluator, and also the basic analyze procedure, are identical
to those in the evaluator of section 4.1.7,
except for the fact that we need additional syntax procedures to
recognize the amb special form:<sup>56</sup></p>

<p>(define (amb? exp) (tagged-list? exp 'amb))</p><empty-line /><p>
(define (amb-choices exp) (cdr exp))</p><empty-line /><p>
We must also add to the dispatch in analyze a clause that will
recognize this special form and generate an appropriate execution procedure:</p>

<p>((amb? exp) (analyze-amb exp))</p><empty-line /><empty-line /><p>

The top-level procedure ambeval (similar to the version of eval given in section 4.1.7) analyzes the
given expression and applies the resulting execution procedure to the
given environment, together with two given continuations:</p>

<p>(define (ambeval exp env succeed fail)</p><empty-line /><p>
  ((analyze exp) env succeed fail))</p><empty-line /><empty-line /><p>

A success continuation is a procedure of two arguments: the value just
obtained and another failure continuation to be used if that value leads
to a subsequent failure. A failure continuation is a procedure of no
arguments.  So the general form of an execution procedure is</p>

<p>(lambda (env succeed fail)</p><empty-line /><p>
  <emphasis>;; succeed is (lambda (value fail) ...)</emphasis></p><empty-line /><p>
  <emphasis>;; fail is (lambda () ...)</emphasis></p><empty-line /><p>
  ...)</p><empty-line /><empty-line /><p>

For example, executing</p>

<p>(ambeval &lt;<emphasis>exp</emphasis>&gt;</p><empty-line /><p>
         the-global-environment</p><empty-line /><p>
         (lambda (value fail) value)</p><empty-line /><p>
         (lambda () 'failed))</p><empty-line /><p>
will attempt to evaluate the given expression and will return
either the expression's value (if the evaluation succeeds) or
the symbol failed (if the evaluation fails).
The call to ambeval in the driver loop shown below uses
much more complicated continuation procedures, which continue the
loop and support the try-again request.</p>

<p>

Most of the complexity of the amb evaluator results
from the mechanics of passing the continuations around as the
execution procedures call each other.  In going through the following code,
you should compare each of the execution procedures with the
corresponding procedure for the ordinary evaluator given in
section 4.1.7.</p>

<p><strong>Simple expressions</strong></p>

<p>

The execution procedures for the simplest kinds of expressions are
essentially the same as those for the ordinary evaluator, except for the
need to manage the continuations.  The execution procedures simply
succeed with the value of the expression, passing along the failure
continuation that was passed to them.</p>

<p>(define (analyze-self-evaluating exp)</p><empty-line /><p>
  (lambda (env succeed fail)</p><empty-line /><p>
    (succeed exp fail)))</p><empty-line /><p>
(define (analyze-quoted exp)</p><empty-line /><p>
  (let ((qval (text-of-quotation exp)))</p><empty-line /><p>
    (lambda (env succeed fail)</p><empty-line /><p>
      (succeed qval fail))))</p><empty-line /><p>
(define (analyze-variable exp)</p><empty-line /><p>
  (lambda (env succeed fail)</p><empty-line /><p>
    (succeed (lookup-variable-value exp env)</p><empty-line /><p>
             fail)))</p><empty-line /><p>
(define (analyze-lambda exp)</p><empty-line /><p>
  (let ((vars (lambda-parameters exp))</p><empty-line /><p>
        (bproc (analyze-sequence (lambda-body exp))))</p><empty-line /><p>
    (lambda (env succeed fail)</p><empty-line /><p>
      (succeed (make-procedure vars bproc env)</p><empty-line /><p>
               fail))))</p><empty-line /><empty-line /><p>


Notice that looking up a variable always "succeeds."  If lookup-variable-value fails to find the variable, it signals an
error, as usual.  Such a "failure" indicates a program bug -- a
reference to an unbound variable; it is not an indication that we
should try another nondeterministic choice instead of the one that is
currently being tried.</p>

<p><strong>Conditionals and sequences</strong></p>

<p>

Conditionals are also handled in a similar way as in the ordinary
evaluator.  The execution procedure generated by analyze-if
invokes the predicate execution procedure pproc with a success
continuation that checks whether the predicate value is true and goes
on to execute either the consequent or the alternative.  If the
execution of pproc fails, the original failure continuation for
the if expression is called.</p>

<p>(define (analyze-if exp)</p><empty-line /><p>
  (let ((pproc (analyze (if-predicate exp)))</p><empty-line /><p>
        (cproc (analyze (if-consequent exp)))</p><empty-line /><p>
        (aproc (analyze (if-alternative exp))))</p><empty-line /><p>
    (lambda (env succeed fail)</p><empty-line /><p>
      (pproc env</p><empty-line /><p>
             <emphasis>;; success continuation for evaluating the predicate</emphasis></p><empty-line /><p>
             <emphasis>;; to obtain pred-value</emphasis></p><empty-line /><p>
             (lambda (pred-value fail2)</p><empty-line /><p>
               (if (true? pred-value)</p><empty-line /><p>
                   (cproc env succeed fail2)</p><empty-line /><p>
                   (aproc env succeed fail2)))</p><empty-line /><p>
             <emphasis>;; failure continuation for evaluating the predicate</emphasis></p><empty-line /><p>
             fail))))</p><empty-line /><empty-line /><p>

Sequences are also handled in the same way as in the previous
evaluator, except for the machinations in the subprocedure sequentially that are required for passing the continuations.
Namely, to sequentially execute a and then b, we call a with a success continuation that calls b.</p>

<p>(define (analyze-sequence exps)</p><empty-line /><p>
  (define (sequentially a b)</p><empty-line /><p>
    (lambda (env succeed fail)</p><empty-line /><p>
      (a env</p><empty-line /><p>
         <emphasis>;; success continuation for calling a</emphasis></p><empty-line /><p>
         (lambda (a-value fail2)</p><empty-line /><p>
           (b env succeed fail2))</p><empty-line /><p>
         <emphasis>;; failure continuation for calling a</emphasis></p><empty-line /><p>
         fail)))</p><empty-line /><p>
  (define (loop first-proc rest-procs)</p><empty-line /><p>
    (if (null? rest-procs)</p><empty-line /><p>
        first-proc</p><empty-line /><p>
        (loop (sequentially first-proc (car rest-procs))</p><empty-line /><p>
              (cdr rest-procs))))</p><empty-line /><p>
  (let ((procs (map analyze exps)))</p><empty-line /><p>
    (if (null? procs)</p><empty-line /><p>
        (error "Empty sequence -- ANALYZE"))</p><empty-line /><p>
    (loop (car procs) (cdr procs))))</p><empty-line /><empty-line /><p><strong>Definitions and assignments</strong></p>

<p>

Definitions are another case where we must go to some trouble to
manage the continuations, because it is necessary to evaluate the
definition-value expression before actually defining the new variable.
To accomplish this, the definition-value execution procedure vproc is called with the environment, a success continuation, and the
failure continuation.  If the execution of vproc succeeds,
obtaining a value val for the defined variable, the variable is
defined and the success is propagated:</p>

<p>(define (analyze-definition exp)</p><empty-line /><p>
  (let ((var (definition-variable exp))</p><empty-line /><p>
        (vproc (analyze (definition-value exp))))</p><empty-line /><p>
    (lambda (env succeed fail)</p><empty-line /><p>
      (vproc env</p><empty-line /><p>
             (lambda (val fail2)</p><empty-line /><p>
               (define-variable! var val env)</p><empty-line /><p>
               (succeed 'ok fail2))</p><empty-line /><p>
             fail))))</p><empty-line /><empty-line /><p>


Assignments are more interesting.  This is the first place where we
really use the continuations, rather than just passing them around.
The execution procedure for assignments starts out like the one for
definitions.  It first attempts to obtain the new value to be assigned
to the variable. If this evaluation of vproc fails, the
assignment fails.</p>

<p>

If vproc succeeds, however, and we go on to make the assignment,
we must consider the possibility that this branch of the computation
might later fail, which will require us to backtrack out of the
assignment.  Thus, we must arrange to undo the assignment as
part of the backtracking process.<sup>57</sup></p>

<p>

This is accomplished by giving vproc a success continuation
(marked with the comment "*1*" below) that saves the old value of
the variable before assigning the new value to the
variable and proceeding from the assignment.  The failure continuation
that is passed along with the value of the assignment (marked with the
comment "*2*" below) restores the old value of the variable
before continuing the failure.
That is, a successful assignment provides a failure continuation that
will intercept a subsequent failure; whatever failure would otherwise
have called fail2 calls this procedure instead, to undo the
assignment before actually calling fail2.</p>

<p>(define (analyze-assignment exp)</p><empty-line /><p>
  (let ((var (assignment-variable exp))</p><empty-line /><p>
        (vproc (analyze (assignment-value exp))))</p><empty-line /><p>
    (lambda (env succeed fail)</p><empty-line /><p>
      (vproc env</p><empty-line /><p>
             (lambda (val fail2)        <emphasis>; *1*</emphasis></p><empty-line /><p>
               (let ((old-value</p><empty-line /><p>
                      (lookup-variable-value var env)))</p><empty-line /><p>
                 (set-variable-value! var val env)</p><empty-line /><p>
                 (succeed 'ok</p><empty-line /><p>
                          (lambda ()    <emphasis>; *2*</emphasis></p><empty-line /><p>
                            (set-variable-value! var</p><empty-line /><p>
                                                 old-value</p><empty-line /><p>
                                                 env)</p><empty-line /><p>
                            (fail2)))))</p><empty-line /><p>
             fail))))</p><empty-line /><empty-line /><p><strong>Procedure applications</strong></p>

<p>

The execution procedure for applications contains no new ideas except
for the technical complexity of managing the continuations.  This
complexity arises in analyze-application, due to the need to
keep track of the success and failure continuations as we evaluate the
operands.  We use a procedure get-args to evaluate the list of
operands, rather than a simple map as in the ordinary evaluator.</p>

<p>(define (analyze-application exp)</p><empty-line /><p>
  (let ((fproc (analyze (operator exp)))</p><empty-line /><p>
        (aprocs (map analyze (operands exp))))</p><empty-line /><p>
    (lambda (env succeed fail)</p><empty-line /><p>
      (fproc env</p><empty-line /><p>
             (lambda (proc fail2)</p><empty-line /><p>
               (get-args aprocs</p><empty-line /><p>
                         env</p><empty-line /><p>
                         (lambda (args fail3)</p><empty-line /><p>
                           (execute-application</p><empty-line /><p>
                            proc args succeed fail3))</p><empty-line /><p>
                         fail2))</p><empty-line /><p>
             fail))))</p><empty-line /><empty-line /><p>

In get-args, notice how cdring down the list of aproc execution procedures and consing up the resulting list of
args is accomplished by calling each aproc in the list
with a success continuation that recursively calls get-args.
Each of these recursive calls to get-args has a success
continuation whose value is the cons of the newly obtained
argument onto the list of accumulated arguments:</p>

<p>(define (get-args aprocs env succeed fail)</p><empty-line /><p>
  (if (null? aprocs)</p><empty-line /><p>
      (succeed '() fail)</p><empty-line /><p>
      ((car aprocs) env</p><empty-line /><p>
                    <emphasis>;; success continuation for this aproc</emphasis></p><empty-line /><p>
                    (lambda (arg fail2)</p><empty-line /><p>
                      (get-args (cdr aprocs)</p><empty-line /><p>
                                env</p><empty-line /><p>
                                <emphasis>;; success continuation for recursive</emphasis></p><empty-line /><p>
                                <emphasis>;; call to get-args</emphasis></p><empty-line /><p>
                                (lambda (args fail3)</p><empty-line /><p>
                                  (succeed (cons arg args)</p><empty-line /><p>
                                           fail3))</p><empty-line /><p>
                                fail2))</p><empty-line /><p>
                    fail)))</p><empty-line /><empty-line /><p>

The actual procedure application, which is
performed by execute-application, is
accomplished in the same way as for the ordinary evaluator, except for
the need to manage the continuations.</p>

<p>(define (execute-application proc args succeed fail)</p><empty-line /><p>
  (cond ((primitive-procedure? proc)</p><empty-line /><p>
         (succeed (apply-primitive-procedure proc args)</p><empty-line /><p>
                  fail))</p><empty-line /><p>
        ((compound-procedure? proc)</p><empty-line /><p>
         ((procedure-body proc)</p><empty-line /><p>
          (extend-environment (procedure-parameters proc)</p><empty-line /><p>
                              args</p><empty-line /><p>
                              (procedure-environment proc))</p><empty-line /><p>
          succeed</p><empty-line /><p>
          fail))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (error</p><empty-line /><p>
          "Unknown procedure type -- EXECUTE-APPLICATION"</p><empty-line /><p>
          proc))))</p><empty-line /><empty-line /><p><strong>Evaluating amb expressions</strong></p>

<p>


The amb special form is the key element in the nondeterministic
language.  Here we see the essence of the interpretation process and
the reason for keeping track of the continuations.  The execution
procedure for amb defines a loop try-next that cycles
through the execution procedures for all the possible values of the
amb expression.  Each execution procedure is called with a
failure continuation that will try the next one.  When there are no
more alternatives to try, the entire amb expression fails.</p>

<p>(define (analyze-amb exp)</p><empty-line /><p>
  (let ((cprocs (map analyze (amb-choices exp))))</p><empty-line /><p>
    (lambda (env succeed fail)</p><empty-line /><p>
      (define (try-next choices)</p><empty-line /><p>
        (if (null? choices)</p><empty-line /><p>
            (fail)</p><empty-line /><p>
            ((car choices) env</p><empty-line /><p>
                           succeed</p><empty-line /><p>
                           (lambda ()</p><empty-line /><p>
                             (try-next (cdr choices))))))</p><empty-line /><p>
      (try-next cprocs))))</p><empty-line /><empty-line /><p><strong>Driver loop</strong></p>

<p>


The driver loop for the amb evaluator is complex, due to
the mechanism that permits the user to try again in evaluating an
expression.  The driver uses a procedure called internal-loop,
which takes as argument a procedure try-again.  The intent is
that calling try-again should go on to the next untried
alternative in the nondeterministic evaluation.  Internal-loop
either calls try-again in response to the user typing try-again at the driver loop, or else starts a new evaluation by
calling ambeval.</p>

<p>

The failure continuation for this call to ambeval
informs the user that there are no more values and re-invokes the driver loop.</p>

<p>


The success continuation for the call to ambeval
is more subtle.  We print the obtained value and then invoke
the internal loop again with a try-again procedure that will be
able to try the next alternative.  This next-alternative
procedure is the second argument that was passed to the
success continuation.  Ordinarily, we think of this second argument
as a failure continuation to be used if the current evaluation branch
later fails.  In this case, however, we have completed a successful
evaluation, so we can invoke the "failure" alternative branch in
order to search for additional successful evaluations.</p>

<p>(define input-prompt ";;; Amb-Eval input:")</p><empty-line /><p>
(define output-prompt ";;; Amb-Eval value:")</p><empty-line /><p>(define (driver-loop)</p><empty-line /><p>
  (define (internal-loop try-again)</p><empty-line /><p>
    (prompt-for-input input-prompt)</p><empty-line /><p>
    (let ((input (read)))</p><empty-line /><p>
      (if (eq? input 'try-again)</p><empty-line /><p>
          (try-again)</p><empty-line /><p>
          (begin</p><empty-line /><p>
            (newline)</p><empty-line /><p>
            (display ";;; Starting a new problem ")</p><empty-line /><p>
            (ambeval input</p><empty-line /><p>
                     the-global-environment</p><empty-line /><p>
                     <emphasis>;; ambeval success</emphasis></p><empty-line /><p>
                     (lambda (val next-alternative)</p><empty-line /><p>
                       (announce-output output-prompt)</p><empty-line /><p>
                       (user-print val)</p><empty-line /><p>
                       (internal-loop next-alternative))</p><empty-line /><p>
                     <emphasis>;; ambeval failure</emphasis></p><empty-line /><p>
                     (lambda ()</p><empty-line /><p>
                       (announce-output</p><empty-line /><p>
                        ";;; There are no more values of")</p><empty-line /><p>
                       (user-print input)</p><empty-line /><p>
                       (driver-loop)))))))</p><empty-line /><p>
  (internal-loop</p><empty-line /><p>
   (lambda ()</p><empty-line /><p>
     (newline)</p><empty-line /><p>
     (display ";;; There is no current problem")</p><empty-line /><p>
     (driver-loop))))</p><empty-line /><p>
The initial call to internal-loop uses a try-again procedure that complains that there is no current
problem and restarts the driver loop.  This is the behavior that will
happen if the user types try-again when there is no evaluation
in progress.</p>

<p>
<strong>Exercise 4.50.</strong>  Implement a new special form ramb that is like amb except that it searches alternatives in a random order, rather 
than from left to right.  Show how this can help with Alyssa's problem
in exercise 4.49.</p>

<p>
<strong>Exercise 4.51.</strong>  Implement a new kind of assignment called permanent-set! that
is not undone upon failure.  For example, we can choose two distinct
elements from a list and count the number of trials required to make a
successful choice as follows:</p>

<p>(define count 0)</p><empty-line /><p>
(let ((x (an-element-of '(a b c)))</p><empty-line /><p>
      (y (an-element-of '(a b c))))</p><empty-line /><p>
  (permanent-set! count (+ count 1))</p><empty-line /><p>
  (require (not (eq? x y)))</p><empty-line /><p>
  (list x y count))</p><empty-line /><p><emphasis>;;; Starting a new problem</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>(a b 2)</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
try-again</p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>(a c 3)</emphasis></p><empty-line /><p>
What values would have been displayed if we had used set! here
rather than permanent-set! ?</p>

<p>
<strong>Exercise 4.52.</strong>  Implement a new construct called if-fail that permits the user to
catch the failure of an expression.  If-fail takes two
expressions.  It evaluates the first expression as usual and returns
as usual if the evaluation succeeds.  If the evaluation fails,
however, the value of the second expression is returned, as in the
following example:</p>

<p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
(if-fail (let ((x (an-element-of '(1 3 5))))</p><empty-line /><p>
           (require (even? x))</p><empty-line /><p>
           x)</p><empty-line /><p>
         'all-odd)</p><empty-line /><p><emphasis>;;; Starting a new problem</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>all-odd</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval input:</emphasis></p><empty-line /><p>
(if-fail (let ((x (an-element-of '(1 3 5 8))))</p><empty-line /><p>
           (require (even? x))</p><empty-line /><p>
           x)</p><empty-line /><p>
         'all-odd)</p><empty-line /><p><emphasis>;;; Starting a new problem</emphasis></p><empty-line /><p><emphasis>;;; Amb-Eval value:</emphasis></p><empty-line /><p><emphasis>8</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 4.53.</strong>  With permanent-set! as described in
exercise 4.51 and if-fail as in
exercise 4.52, what will be the result of evaluating</p>

<p>(let ((pairs '()))</p><empty-line /><p>
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))</p><empty-line /><p>
             (permanent-set! pairs (cons p pairs))</p><empty-line /><p>
             (amb))</p><empty-line /><p>
           pairs))</p><empty-line /><empty-line /><p>
<strong>Exercise 4.54.</strong>  If we had not realized that require could be implemented as an
ordinary procedure that uses amb, to be defined by the user as
part of a nondeterministic program, we would have had to implement it
as a special form.  This would require syntax procedures</p>

<p>(define (require? exp) (tagged-list? exp 'require))</p><empty-line /><empty-line /><p>
(define (require-predicate exp) (cadr exp))</p><empty-line /><p>
and a new clause in the dispatch in analyze</p>

<p>((require? exp) (analyze-require exp))</p><empty-line /><p>
as well the procedure analyze-require that handles require
expressions.  Complete the following definition of analyze-require.</p>

<p>(define (analyze-require exp)</p><empty-line /><p>
  (let ((pproc (analyze (require-predicate exp))))</p><empty-line /><p>
    (lambda (env succeed fail)</p><empty-line /><p>
      (pproc env</p><empty-line /><p>
             (lambda (pred-value fail2)</p><empty-line /><p>
               (if &lt;<emphasis>??</emphasis>&gt;</p><empty-line /><p>
                   &lt;<emphasis>??</emphasis>&gt;</p><empty-line /><p>
                   (succeed 'ok fail2)))</p><empty-line /><p>
             fail))))</p><empty-line /><empty-line /><empty-line /><empty-line /><p><sup>42</sup> We assume that we have previously defined a
procedure prime? that tests whether numbers are prime.  Even with
prime? defined, the prime-sum-pair procedure may look
suspiciously like the unhelpful "pseudo-Lisp" attempt to define the
square-root function, which we described at the beginning of
section 1.1.7.  In fact, a square-root procedure along those
lines can actually be formulated as a nondeterministic program.
By incorporating a search mechanism into the evaluator, we
are eroding the distinction between purely declarative descriptions
and imperative specifications of how to compute answers.  We'll go
even farther in this direction in
section 4.4.</p>

<p><sup>43</sup> The idea of amb for nondeterministic programming was
first described in 1961 by John McCarthy (see McCarthy 1967).</p>

<p><sup>44</sup> In actuality, the distinction between nondeterministically
returning a single choice and returning all choices depends somewhat
on our point of view.  From the perspective of the code that uses the
value, the nondeterministic choice returns a single value.  From the
perspective of the programmer designing the code, the nondeterministic
choice potentially returns all possible values, and the computation
branches so that each value is investigated separately.</p>

<p><sup>45</sup> One might object that this is a hopelessly
inefficient mechanism.  It might require millions of processors to
solve some easily stated problem this way, and most of the time most
of those processors would be idle.  This objection should be taken in
the context of history.  Memory used to be considered just such an
expensive commodity.  In 1964 a megabyte of RAM cost about $400,000.
Now every personal computer has many megabytes of RAM, and most of the
time most of that RAM is unused.  It is hard to underestimate the cost
of mass-produced electronics.</p>

<p><sup>46</sup> Automagically: "Automatically, but in a way
which, for some reason (typically because it is too complicated, or
too ugly, or perhaps even too trivial), the speaker doesn't feel like
explaining."  (Steele 1983, Raymond 1993)</p>

<p><sup>47</sup> The integration of automatic search strategies
into programming languages has had a long and checkered history.  The
first suggestions that nondeterministic algorithms might be elegantly
encoded in a programming language with search and automatic
backtracking came from Robert Floyd (1967).  Carl Hewitt
(1969) invented a programming language called Planner that explicitly
supported automatic chronological backtracking, providing for a
built-in depth-first search strategy.  Sussman, Winograd, and Charniak 
(1971) implemented a subset of this language, called MicroPlanner,
which was used to support work in problem solving and robot planning.
Similar ideas, arising from logic and theorem proving, led to the
genesis in Edinburgh and Marseille of the elegant language Prolog
(which we will discuss in section 4.4).  After
sufficient frustration with automatic search, McDermott and Sussman
(1972) developed a language called Conniver, which included mechanisms
for placing the search strategy under programmer control.  This proved
unwieldy, however, and Sussman and Stallman (1975) found a more
tractable approach while investigating methods of symbolic analysis
for electrical circuits.  They developed a non-chronological
backtracking scheme that was based on tracing out the logical
dependencies connecting facts, a technique that has come to be known
as <emphasis>dependency-directed backtracking</emphasis>.  Although their method was
complex, it produced reasonably efficient programs because it did
little redundant search.  Doyle (1979) and McAllester (1978, 1980)
generalized and clarified the methods of Stallman and Sussman,
developing a new paradigm for formulating search that is now called
<emphasis>truth maintenance</emphasis>.  Modern problem-solving systems all
use some form of truth-maintenance system as a substrate.  See Forbus
and deKleer 1993 for a discussion of elegant ways to build
truth-maintenance systems and applications using truth maintenance.
Zabih, McAllester, and
Chapman 1987 describes a nondeterministic extension to Scheme that
is based on amb; it is similar to the interpreter described in
this section, but more sophisticated, because it uses
dependency-directed backtracking rather than chronological
backtracking.  Winston 1992 gives an introduction to both kinds of
backtracking.</p>

<p><sup>48</sup> Our program uses the following procedure to determine 
if the elements of a list are distinct:</p>

<p>(define (distinct? items)</p><empty-line /><p>
  (cond ((null? items) true)</p><empty-line /><p>
        ((null? (cdr items)) true)</p><empty-line /><p>
        ((member (car items) (cdr items)) false)</p><empty-line /><p>
        (else (distinct? (cdr items)))))</p><empty-line /><p>
Member is like memq except that it uses equal? instead
of eq? to test for equality.</p>

<p><sup>49</sup> This is taken from a booklet called "Problematical
Recreations", published in the 1960s by Litton Industries, where it
is attributed to the <emphasis>Kansas State Engineer</emphasis>.</p>

<p><sup>50</sup> Here we use the convention that the first element of each list
designates the part of speech for the rest of the words in the list.</p>

<p><sup>51</sup> Notice that parse-word uses set! to modify the
unparsed input list.  For this to work, our amb evaluator must
undo the effects of set! operations when it backtracks.</p>

<p><sup>52</sup> Observe that this
definition is recursive -- a verb may be followed by any number
of prepositional phrases.</p>

<p><sup>53</sup> This kind of grammar can become arbitrarily complex, but it
is only a toy as far as real language understanding is concerned.
Real natural-language understanding by computer requires an elaborate
mixture of syntactic analysis and interpretation of meaning.  On the
other hand, even toy parsers can be useful in supporting flexible
command languages for programs such as information-retrieval systems.
Winston 1992 discusses computational approaches to real
language understanding and also the applications of simple grammars to
command languages.</p>

<p><sup>54</sup> Although Alyssa's idea works just fine (and is
surprisingly simple), the sentences that it generates are a bit
boring -- they don't sample the possible sentences of this language in
a very interesting way.  In fact, the grammar is highly recursive in
many places, and Alyssa's technique "falls into" one of these recursions and
gets stuck.  See exercise 4.50 for a way to deal with this.</p>

<p><sup>55</sup> We chose to implement the lazy evaluator in
section 4.2 as a modification of the ordinary
metacircular evaluator of section 4.1.1.  In
contrast, we will base the amb evaluator on the analyzing evaluator
of section 4.1.7, because the execution procedures
in that evaluator provide a convenient framework for implementing
backtracking.</p>

<p><sup>56</sup> We assume that the evaluator supports let
(see exercise 4.22),
which we have used in our nondeterministic programs.</p>

<p><sup>57</sup> We didn't worry about undoing definitions, since we can
assume that internal definitions are scanned out
(section 4.1.6).</p>


</section>

<section>


<p><strong>4.4  Logic Programming</strong></p>

<p>



In chapter 1 we stressed that computer science deals with imperative
(how to) knowledge, whereas mathematics deals with declarative (what
is) knowledge.  Indeed, programming languages require that the
programmer express knowledge in a form that indicates the step-by-step
methods for solving particular problems.  On the other hand,
high-level languages provide, as part of the language implementation,
a substantial amount of methodological knowledge that frees
the user from concern with numerous details of how a specified
computation will progress.</p>

<p>

Most programming languages, including Lisp, are organized around
computing the values of mathematical functions.  Expression-oriented
languages (such as Lisp, Fortran, and Algol) capitalize on the "pun"
that an expression that describes the value of a function may also be
interpreted as a means of computing that value.  Because of this, most
programming languages are strongly biased toward unidirectional
computations (computations with well-defined inputs and outputs).
There are, however, radically different programming languages that
relax this bias.  We saw one such example in
section 3.3.5, where the objects of computation were
arithmetic constraints.  In a constraint system the direction and the
order of computation are not so well specified; in carrying out a
computation the system must therefore provide more detailed "how to"
knowledge than would be the case with an ordinary arithmetic
computation.  This does not mean, however, that the user is released
altogether from the responsibility of providing imperative knowledge.
There are many constraint networks that implement the same set of
constraints, and the user must choose from the set of mathematically
equivalent networks a suitable network to specify a particular
computation.</p>

<p>


The nondeterministic program evaluator of
section 4.3 also moves away from the
view that programming is about constructing algorithms for computing
unidirectional functions.  In a nondeterministic language, expressions
can have more than one value, and, as a result, the computation is
dealing with relations rather than with
single-valued functions.  Logic programming extends this idea by
combining a relational vision of programming with a powerful kind of
symbolic pattern matching called <emphasis>unification</emphasis>.<sup>58</sup></p>

<p>

This approach, when it works, can be a very powerful way to write
programs.  Part of the power comes from the fact that a single "what
is" fact can be used to solve a number of different problems that
would have different "how to" components.  As an example, consider
the append operation, which takes two lists as arguments and
combines their elements to form a single list.  In a procedural
language such as Lisp, we could define append in terms of the
basic list constructor cons, as we did in
section 2.2.1:</p>

<p>(define (append x y)</p><empty-line /><p>
  (if (null? x)</p><empty-line /><p>
      y</p><empty-line /><p>
      (cons (car x) (append (cdr x) y))))</p><empty-line /><p>
This procedure can be regarded as a translation into Lisp of the
following two rules, the first of which covers the case where the
first list is empty and the second of which handles the case of a
nonempty list, which is a cons of two parts:</p>

<p>For any list y, the empty list and y append to form y.</p>

<p>For any u,  v,  y, and z,
 (cons u v) and y append to form (cons u z)
if v and y append to form z.<sup>59</sup></p>

<p>

Using the append procedure, we can answer questions such as</p>

<p>
Find the</p>

<p>append</p>

<p> of</p>

<p>(a b)</p>

<p> and</p>

<p>(c d)</p>

<p>.</p>

<p>

But the same two rules are also sufficient for answering the following
sorts of questions, which the procedure can't answer:</p>

<p>
Find a list</p>

<p>y</p>

<p> that</p>

<p>append</p>

<p>s with</p>

<p>(a b)</p>

<p> 
to produce</p>

<p>(a b c d)</p>

<p>.</p>

<p>

Find all x and y that append to form (a b c
d).</p>

<p>

In a logic programming language, the programmer writes an append
"procedure" by stating the two rules about append given above.
"How to" knowledge is provided automatically by the interpreter to
allow this single pair of rules to be used to answer all three types
of questions about append.<sup>60</sup></p>

<p>

Contemporary logic programming languages (including the one we
implement here) have substantial deficiencies, in that their general
"how to" methods can lead them into spurious infinite loops or other
undesirable behavior.
Logic programming is an active field of research in computer science.<sup>61</sup></p>

<p>

Earlier in this chapter we explored the technology of implementing
interpreters and described the elements that are essential to an
interpreter for a Lisp-like language (indeed, to an interpreter for
any conventional language).  Now we will apply these ideas to discuss
an interpreter for a logic programming language.  We call this
language the <emphasis>query language</emphasis>, because it is very useful for
retrieving information from data bases by formulating <emphasis>queries</emphasis>,
or questions, expressed in the language.  Even though the query
language is very different from Lisp, we will find it convenient to
describe the language in terms of the same general framework we have
been using all along: as a collection of primitive elements, together
with means of combination that enable us to combine simple elements to
create more complex elements and means of abstraction that enable us
to regard complex elements as single conceptual units.  An interpreter
for a logic programming language is considerably more complex than an
interpreter for a language like Lisp.  Nevertheless, we will see
that our query-language interpreter contains many of the same elements
found in the interpreter of section 4.1.  In particular,
there will be an "eval" part that classifies expressions according
to type and an "apply" part that implements the language's
abstraction mechanism (procedures in the case of Lisp, and <emphasis>rules</emphasis>
in the case of logic programming).  Also, a central role is played in
the implementation by a frame data structure, which determines the
correspondence between symbols and their associated values.  One
additional interesting aspect of our query-language implementation is
that we make substantial use of streams, which were introduced in
chapter 3.</p>

<p><strong>4.4.1  Deductive Information Retrieval</strong></p>

<p>



Logic programming excels in providing interfaces to data bases for
information retrieval.  The query language we shall implement in this
chapter is designed to be used in this way.</p>

<p>

In order to illustrate what the query system does, we will show how it
can be used to manage the data base of personnel records for
Microshaft, a thriving high-technology company in the
Boston area.  The language provides pattern-directed access to
personnel information and can also take advantage of general rules in
order to make logical deductions.</p>

<p><strong>A sample data base</strong></p>

<p>


The personnel data base for Microshaft
contains <emphasis>assertions</emphasis> about company personnel.  Here is the
information about Ben Bitdiddle, the resident computer wizard:</p>

<p>(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))</p><empty-line /><p>
(job (Bitdiddle Ben) (computer wizard))</p><empty-line /><p>
(salary (Bitdiddle Ben) 60000)</p><empty-line /><p>
Each assertion is a list (in this case a triple) whose elements can
themselves be lists.</p>

<p>

As resident wizard, Ben is in charge of the company's computer
division, and he supervises two programmers and one technician.  Here
is the information about them:</p>

<p>(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))</p><empty-line /><p>
(job (Hacker Alyssa P) (computer programmer))</p><empty-line /><p>
(salary (Hacker Alyssa P) 40000)</p><empty-line /><p>
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))</p><empty-line /><p>
(address (Fect Cy D) (Cambridge (Ames Street) 3))</p><empty-line /><p>
(job (Fect Cy D) (computer programmer))</p><empty-line /><p>
(salary (Fect Cy D) 35000)</p><empty-line /><p>
(supervisor (Fect Cy D) (Bitdiddle Ben))</p><empty-line /><p>
(address (Tweakit Lem E) (Boston (Bay State Road) 22))</p><empty-line /><p>
(job (Tweakit Lem E) (computer technician))</p><empty-line /><p>
(salary (Tweakit Lem E) 25000)</p><empty-line /><p>
(supervisor (Tweakit Lem E) (Bitdiddle Ben))</p><empty-line /><p>
There is also a programmer trainee, who is supervised by Alyssa:</p>

<p>(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))</p><empty-line /><p>
(job (Reasoner Louis) (computer programmer trainee))</p><empty-line /><p>
(salary (Reasoner Louis) 30000)</p><empty-line /><p>
(supervisor (Reasoner Louis) (Hacker Alyssa P))</p><empty-line /><p>
All of these people are in the computer division, as indicated by the
word computer as the first item in their job descriptions.</p>

<p>

Ben is a high-level employee.  His supervisor is the company's big
wheel himself:</p>

<p>(supervisor (Bitdiddle Ben) (Warbucks Oliver))</p><empty-line /><p>
(address (Warbucks Oliver) (Swellesley (Top Heap Road)))</p><empty-line /><p>
(job (Warbucks Oliver) (administration big wheel))</p><empty-line /><p>
(salary (Warbucks Oliver) 150000)</p><empty-line /><empty-line /><p>

Besides the computer division supervised by Ben, the company has an
accounting division, consisting of a chief accountant and his
assistant:</p>

<p>(address (Scrooge Eben) (Weston (Shady Lane) 10))</p><empty-line /><p>
(job (Scrooge Eben) (accounting chief accountant))</p><empty-line /><p>
(salary (Scrooge Eben) 75000)</p><empty-line /><p>
(supervisor (Scrooge Eben) (Warbucks Oliver))</p><empty-line /><p>
(address (Cratchet Robert) (Allston (N Harvard Street) 16))</p><empty-line /><p>
(job (Cratchet Robert) (accounting scrivener))</p><empty-line /><p>
(salary (Cratchet Robert) 18000)</p><empty-line /><p>
(supervisor (Cratchet Robert) (Scrooge Eben))</p><empty-line /><p>
There is also a secretary for the big wheel:</p>

<p>(address (Aull DeWitt) (Slumerville (Onion Square) 5))</p><empty-line /><p>
(job (Aull DeWitt) (administration secretary))</p><empty-line /><p>
(salary (Aull DeWitt) 25000)</p><empty-line /><p>
(supervisor (Aull DeWitt) (Warbucks Oliver))</p><empty-line /><empty-line /><p>

The data base also contains assertions about which kinds of jobs can
be done by people holding other kinds of jobs.  For instance, a
computer wizard can do the jobs of both a computer programmer and a
computer technician:</p>

<p>(can-do-job (computer wizard) (computer programmer))</p><empty-line /><p>
(can-do-job (computer wizard) (computer technician))</p><empty-line /><p>
A computer programmer could fill in for a trainee:</p>

<p>(can-do-job (computer programmer)</p><empty-line /><p>
            (computer programmer trainee))</p><empty-line /><p>
Also, as is well known,</p>

<p>(can-do-job (administration secretary)</p><empty-line /><p>
            (administration big wheel))</p><empty-line /><empty-line /><p><strong>Simple queries</strong></p>

<p>


The query language allows users to retrieve information from the data
base by posing queries in response to the system's prompt.  For
example, to find all computer programmers one can say</p>

<p><emphasis>;;; Query input:</emphasis></p><empty-line /><p>
(job ?x (computer programmer))</p><empty-line /><p>
The system will respond with the following items:</p>

<p><emphasis>;;; Query results:</emphasis></p><empty-line /><p>
(job (Hacker Alyssa P) (computer programmer))</p><empty-line /><p>
(job (Fect Cy D) (computer programmer))</p><empty-line /><empty-line /><p>


The input query specifies that we are looking for entries in the data
base that match a certain <emphasis>pattern</emphasis>.  In this example, the pattern
specifies entries consisting of three items, of which the first is the
literal symbol job, the second can be anything, and the third is
the literal list (computer programmer).  The "anything" that
can be the second item in the matching list is specified by a <emphasis>pattern variable</emphasis>, ?x.  The general form of a pattern variable
is a symbol, taken to be the name of the variable, preceded by a
question mark.  We will see below why it is useful to specify names
for pattern variables rather than just putting ? into patterns
to represent "anything."  The system responds to a simple query by
showing all entries in the data base that match the specified pattern.</p>

<p>

A pattern can have more than one variable.  For example, the query</p>

<p>(address ?x ?y)</p><empty-line /><p>
will list all the employees' addresses.</p>

<p>

A pattern can have no variables, in which case the query simply
determines whether that pattern is an entry in the data base.  If so,
there will be one match; if not, there will be no matches.</p>

<p>

The same pattern variable can appear more than once in a query,
specifying that the same "anything" must appear in each position.
This is why variables have names.  For example,</p>

<p>(supervisor ?x ?x)</p><empty-line /><p>
finds all people who supervise themselves (though there are no such
assertions in our sample data base).</p>

<p>

The query</p>

<p>(job ?x (computer ?type))</p><empty-line /><p>
matches all job entries whose third item is a two-element list whose
first item is computer:</p>

<p>(job (Bitdiddle Ben) (computer wizard))</p><empty-line /><p>
(job (Hacker Alyssa P) (computer programmer))</p><empty-line /><p>
(job (Fect Cy D) (computer programmer))</p><empty-line /><p>
(job (Tweakit Lem E) (computer technician))</p><empty-line /><p>
This same pattern does <emphasis>not</emphasis> match</p>

<p>(job (Reasoner Louis) (computer programmer trainee))</p><empty-line /><p>
because the third item in the entry is a list of three elements, and
the pattern's third item specifies that there should be two elements.
If we wanted to change the pattern so that the third item could be any
list beginning with computer, we could specify<sup>62</sup></p>

<p>(job ?x (computer . ?type))</p><empty-line /><p>
For example,</p>

<p>(computer . ?type)</p><empty-line /><p>
matches the data</p>

<p>(computer programmer trainee)</p><empty-line /><p>
with ?type as the list (programmer trainee).  It also
matches the data</p>

<p>(computer programmer)</p><empty-line /><p>
with ?type as the list (programmer), and matches the data</p>

<p>(computer)</p><empty-line /><p>
with ?type as the empty list ().</p>

<p>

We can describe the query language's processing of simple queries as
follows:</p>

<p>The system finds all assignments to variables in the query
pattern that <emphasis>satisfy</emphasis> the pattern -- that is, all sets of values
for the variables such that if the pattern variables are <emphasis>instantiated with</emphasis> (replaced by) the values, the result is in the data
base.</p>

<p>The system responds to the query by listing all instantiations of the
query pattern with the variable assignments that satisfy it.</p>

<p>

Note that if the pattern has no variables, the query reduces to a
determination of whether that pattern is in the data base.  If so, the
empty assignment, which assigns no values to variables, satisfies that
pattern for that data base.</p>

<p>
<strong>Exercise 4.55.</strong>  Give simple queries that retrieve the following information from the
data base:</p>

<p>a. all people supervised by Ben Bitdiddle;</p>

<p>b. the names and jobs of all people in the accounting division;</p>

<p>c. the names and addresses of all people who live 
in Slumerville.</p>

<p><strong>Compound queries</strong></p>

<p>


Simple queries form the primitive operations of the query language.
In order to form compound operations, the query language provides
means of combination.  One thing that makes the query language a logic
programming language is that the means of combination mirror the means
of combination used in forming logical expressions: and, or, and not.  (Here and, or, and not are not
the Lisp primitives, but rather operations built into the query
language.)</p>

<p>

We can use and as follows to find the addresses of all the
computer programmers:</p>

<p>(and (job ?person (computer programmer))</p><empty-line /><p>
     (address ?person ?where))</p><empty-line /><p>
The resulting output is</p>

<p>(and (job (Hacker Alyssa P) (computer programmer))</p><empty-line /><p>
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))</p><empty-line /><p>
(and (job (Fect Cy D) (computer programmer))</p><empty-line /><p>
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))</p><empty-line /><p>
In general,</p>

<p>(and &lt;<emphasis>query<sub>1</sub></emphasis>&gt; &lt;<emphasis>query<sub>2</sub></emphasis>&gt; ... &lt;<emphasis>query<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
is satisfied by all sets of values for the pattern variables that
simultaneously satisfy &lt;<emphasis>query<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>query<sub>n</sub></emphasis>&gt;.</p>

<p>

As for simple queries, the system processes a compound query by
finding all assignments to the pattern variables that satisfy the
query, then displaying instantiations of the query with those values.</p>

<p>

Another means of constructing compound queries is through or.
For example,</p>

<p>(or (supervisor ?x (Bitdiddle Ben))</p><empty-line /><p>
    (supervisor ?x (Hacker Alyssa P)))</p><empty-line /><p>

will find all employees supervised by Ben Bitdiddle or Alyssa P.
Hacker:</p>

<p>(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))</p><empty-line /><p>
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))</p><empty-line /><p>
(or (supervisor (Fect Cy D) (Bitdiddle Ben))</p><empty-line /><p>
    (supervisor (Fect Cy D) (Hacker Alyssa P)))</p><empty-line /><p>
(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))</p><empty-line /><p>
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))</p><empty-line /><p>
(or (supervisor (Reasoner Louis) (Bitdiddle Ben))</p><empty-line /><p>
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))</p><empty-line /><p>
In general,</p>

<p>(or &lt;<emphasis>query<sub>1</sub></emphasis>&gt; &lt;<emphasis>query<sub>2</sub></emphasis>&gt; ... &lt;<emphasis>query<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
is satisfied by all sets of values for the pattern variables that
satisfy at least one of &lt;<emphasis>query<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>query<sub>n</sub></emphasis>&gt;.</p>

<p>

Compound queries can also be formed with not. For example,</p>

<p>(and (supervisor ?x (Bitdiddle Ben))</p><empty-line /><p>
     (not (job ?x (computer programmer))))</p><empty-line /><p>
finds all people supervised by Ben Bitdiddle who are not computer
programmers.  In general,</p>

<p>(not &lt;<emphasis>query<sub>1</sub></emphasis>&gt;)</p><empty-line /><p>
is satisfied by all assignments to the pattern variables that do not
satisfy &lt;<emphasis>query<sub>1</sub></emphasis>&gt;.<sup>63</sup></p>

<p>

The final combining form is called lisp-value.  When lisp-value is the first element of a pattern, it specifies that the
next element is a Lisp predicate to be applied to the rest of the
(instantiated) elements as arguments.  In general,</p>

<p>(lisp-value &lt;<emphasis>predicate</emphasis>&gt; &lt;<emphasis>arg<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>arg<sub>n</sub></emphasis>&gt;)</p><empty-line /><p>
will be satisfied by assignments to the pattern variables for which the
&lt;<emphasis>predicate</emphasis>&gt; applied to the instantiated
&lt;<emphasis>arg<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>arg<sub>n</sub></emphasis>&gt;
is true.  For example, to find all people whose salary is greater than
$30,000 we could write<sup>64</sup></p>

<p>(and (salary ?person ?amount)</p><empty-line /><p>
     (lisp-value &gt; ?amount 30000))</p><empty-line /><empty-line /><p>
<strong>Exercise 4.56.</strong>  Formulate compound queries that retrieve the following information:</p>

<p>a. the names of all people who are supervised by Ben Bitdiddle, together
with their addresses;</p>

<p>b. all people whose salary is less than Ben Bitdiddle's, together with
their salary and Ben Bitdiddle's salary;</p>

<p>c. all people who are supervised by someone who is not in the computer
division, together with the supervisor's name and job.</p>

<p><strong>Rules</strong></p>

<p>


In addition to primitive queries and compound queries, the query
language provides means for abstracting queries.  These are given by
<emphasis>rules</emphasis>.  The rule</p>

<p>(rule (lives-near ?person-1 ?person-2)</p><empty-line /><p>
      (and (address ?person-1 (?town . ?rest-1))</p><empty-line /><p>
           (address ?person-2 (?town . ?rest-2))</p><empty-line /><p>
           (not (same ?person-1 ?person-2))))</p><empty-line /><p>
specifies that two people live near each other if they live in the
same town.  The final not clause prevents the rule from saying
that all people live near themselves.  The same relation is
defined by a very simple rule:<sup>65</sup></p>

<p>(rule (same ?x ?x))</p><empty-line /><empty-line /><p>

The following rule declares that a person is a "wheel" in an
organization if he supervises someone who is in turn a supervisor:</p>

<p>(rule (wheel ?person)</p><empty-line /><p>
      (and (supervisor ?middle-manager ?person)</p><empty-line /><p>
           (supervisor ?x ?middle-manager)))</p><empty-line /><empty-line /><p>

The general form of a rule is</p>

<p>(rule &lt;<emphasis>conclusion</emphasis>&gt; &lt;<emphasis>body</emphasis>&gt;)</p><empty-line /><p>
where &lt;<emphasis>conclusion</emphasis>&gt; is a pattern and &lt;<emphasis>body</emphasis>&gt; is any
query.<sup>66</sup> We can think
of a rule as representing a large (even infinite) set of assertions,
namely all instantiations of the rule conclusion with variable
assignments that satisfy the rule body.  When we described simple
queries (patterns), we said that an assignment to variables satisfies
a pattern if the instantiated pattern is in the data base.  But the
pattern needn't be explicitly in the data base as an assertion.  It
can be an implicit assertion implied by a rule.  For example, the
query</p>

<p>(lives-near ?x (Bitdiddle Ben))</p><empty-line /><p>
results in</p>

<p>(lives-near (Reasoner Louis) (Bitdiddle Ben))</p><empty-line /><p>
(lives-near (Aull DeWitt) (Bitdiddle Ben))</p><empty-line /><p>
To find all computer programmers who live near Ben Bitdiddle, we can
ask</p>

<p>(and (job ?x (computer programmer))</p><empty-line /><p>
     (lives-near ?x (Bitdiddle Ben)))</p><empty-line /><empty-line /><p>


As in the case of compound procedures, rules can be used as parts of
other rules (as we saw with the lives-near rule above)
or even be defined recursively.  For instance, the rule</p>

<p>(rule (outranked-by ?staff-person ?boss)</p><empty-line /><p>
      (or (supervisor ?staff-person ?boss)</p><empty-line /><p>
          (and (supervisor ?staff-person ?middle-manager)</p><empty-line /><p>
               (outranked-by ?middle-manager ?boss))))</p><empty-line /><p>
says that a staff person is outranked by a boss in the organization if
the boss is the person's supervisor or (recursively) if the person's
supervisor is outranked by the boss.</p>

<p>
<strong>Exercise 4.57.</strong>  Define a rule that says that person 1 can replace person 2 if either
person 1 does the same job as person 2 or someone who does person 1's
job can also do person 2's job, and if person 1 and person 2 are not
the same person. Using your rule, give queries that find the
following:</p>

<p>

a.  all people who can replace Cy D. Fect;</p>

<p>

b.  all people who can replace someone who is being paid more than they
are, together with the two salaries.</p>

<p>
<strong>Exercise 4.58.</strong>  Define a rule that says that a person is a "big shot" in a division
if the person works in the division but does not have a supervisor who
works in the division.</p>

<p>
<strong>Exercise 4.59.</strong>  Ben Bitdiddle has missed one meeting too many.
Fearing that his habit of forgetting meetings could cost him his
job, Ben decides to do something about it.  He adds all the weekly
meetings of the firm to the Microshaft data base by
asserting the following:</p>

<p>(meeting accounting (Monday 9am))</p><empty-line /><p>
(meeting administration (Monday 10am))</p><empty-line /><p>
(meeting computer (Wednesday 3pm))</p><empty-line /><p>
(meeting administration (Friday 1pm))</p><empty-line /><p>
Each of the above assertions is for a meeting of an entire division.
Ben also adds an entry for the company-wide meeting that spans all the
divisions.  All of the company's employees attend this meeting.</p>

<p>(meeting whole-company (Wednesday 4pm))</p><empty-line /><empty-line /><p>a. On Friday morning, Ben wants to query the data base for all the meetings
that occur that day.  What query should he use?</p>

<p>b. Alyssa P. Hacker is unimpressed.  She thinks it would be much more
useful to be able to ask for her meetings by specifying her name.  So
she designs a rule that says that a person's meetings include all whole-company meetings plus all meetings of that person's division.
Fill in the body of Alyssa's rule.</p>

<p>(rule (meeting-time ?person ?day-and-time)</p><empty-line /><p>
      &lt;<emphasis>rule-body</emphasis>&gt;)</p><empty-line /><empty-line /><p>

c. Alyssa arrives at work on Wednesday morning and wonders what meetings she 
has to attend that day.  Having defined the above rule,
what query should she make to find this out?</p>

<p>
<strong>Exercise 4.60.</strong>  By giving the query</p>

<p>(lives-near ?person (Hacker Alyssa P))</p><empty-line /><p>
Alyssa P. Hacker is able to find people who live near her, with whom
she can ride to work.  On the other hand, when she tries to find all
pairs of people who live near each other by querying</p>

<p>(lives-near ?person-1 ?person-2)</p><empty-line /><p>
she notices that each pair of people who live near each other is
listed twice; for example,</p>

<p>(lives-near (Hacker Alyssa P) (Fect Cy D))</p><empty-line /><p>
(lives-near (Fect Cy D) (Hacker Alyssa P))</p><empty-line /><p>
Why does this happen?
Is there a way to find a list of people who live near each other, in
which each pair appears only once?  Explain.</p>

<p><strong>Logic as programs</strong></p>

<p>


We can regard a rule as a kind of logical implication: <emphasis>If</emphasis> an
assignment of values to pattern variables satisfies the body, <emphasis>then</emphasis> it satisfies the conclusion.  Consequently, we can regard the
query language as having the ability to perform <emphasis>logical
deductions</emphasis> based upon the rules.  As an example, consider the append operation described at the beginning of
section 4.4.  As we said, append can be
characterized by the following two rules:</p>

<p>For any list y, the empty list and y append to form y.</p>

<p>For any u,  v,  y, and z,
 (cons u v) and y append to form (cons u z)
if v and y append to form z.</p>

<p>


To express this in our query language, we define two rules for a
relation</p>

<p>(append-to-form x y z)</p><empty-line /><p>
which we can interpret to mean "x and y append to
form z":</p>

<p>(rule (append-to-form () ?y ?y))</p><empty-line /><p>
(rule (append-to-form (?u . ?v) ?y (?u . ?z))</p><empty-line /><p>
      (append-to-form ?v ?y ?z))</p><empty-line /><p>
The first rule has no body, which means that the conclusion holds for
any value of ?y.  Note how the second rule makes use of
dotted-tail notation to name the car and cdr of a list.</p>

<p>

Given these two rules, we can formulate queries that compute the append of two lists:</p>

<p><emphasis>;;; Query input:</emphasis></p><empty-line /><p>
(append-to-form (a b) (c d) ?z)</p><empty-line /><p><emphasis>;;; Query results:</emphasis></p><empty-line /><p>
(append-to-form (a b) (c d) (a b c d))</p><empty-line /><p>
What is more striking, we can use the same rules to ask the question
"Which list, when appended to (a b), yields (a b c d)?"
This is done as follows:</p>

<p><emphasis>;;; Query input:</emphasis></p><empty-line /><p>
(append-to-form (a b) ?y (a b c d))</p><empty-line /><p><emphasis>;;; Query results:</emphasis></p><empty-line /><p>
(append-to-form (a b) (c d) (a b c d))</p><empty-line /><p>
We can also ask for all pairs of lists that append to form (a b c d):</p>

<p><emphasis>;;; Query input:</emphasis></p><empty-line /><p>
(append-to-form ?x ?y (a b c d))</p><empty-line /><p><emphasis>;;; Query results:</emphasis></p><empty-line /><p>
(append-to-form () (a b c d) (a b c d))</p><empty-line /><p>
(append-to-form (a) (b c d) (a b c d))</p><empty-line /><p>
(append-to-form (a b) (c d) (a b c d))</p><empty-line /><p>
(append-to-form (a b c) (d) (a b c d))</p><empty-line /><p>
(append-to-form (a b c d) () (a b c d))</p><empty-line /><empty-line /><p>


The query system may seem to exhibit quite a bit of intelligence in
using the rules to deduce the answers to the queries above.  Actually,
as we will see in the next section, the system is following a
well-determined algorithm in unraveling the rules.  Unfortunately,
although the system works impressively in the append case, the
general methods may break down in more complex cases, as we will see
in section 4.4.3.</p>

<p>
<strong>Exercise 4.61.</strong>  The following rules implement a next-to relation that finds
adjacent elements of a list:</p>

<p>(rule (?x next-to ?y in (?x ?y . ?u)))</p><empty-line /><empty-line /><p>
(rule (?x next-to ?y in (?v . ?z))</p><empty-line /><p>
      (?x next-to ?y in ?z))</p><empty-line /><p>
What will the response be to the following queries?</p>

<p>(?x next-to ?y in (1 (2 3) 4))</p><empty-line /><empty-line /><p>
(?x next-to 1 in (2 1 3 1))</p><empty-line /><empty-line /><p>
<strong>Exercise 4.62.</strong>  Define rules to implement the last-pair operation of
exercise 2.17, which returns a list containing the last
element of a nonempty list.  Check your rules on queries such as
(last-pair (3) ?x), (last-pair (1 2 3) ?x), and (last-pair (2 ?x) (3)).
Do your rules work correctly on queries such as (last-pair ?x (3)) ?</p>

<p>
<strong>Exercise 4.63.</strong>  The following data base (see Genesis 4) traces the genealogy of the
descendants of Ada back to Adam, by way of Cain:</p>

<p>(son Adam Cain)</p><empty-line /><p>
(son Cain Enoch)</p><empty-line /><p>
(son Enoch Irad)</p><empty-line /><p>
(son Irad Mehujael)</p><empty-line /><p>
(son Mehujael Methushael)</p><empty-line /><p>
(son Methushael Lamech)</p><empty-line /><p>
(wife Lamech Ada)</p><empty-line /><p>
(son Ada Jabal)</p><empty-line /><p>
(son Ada Jubal)</p><empty-line /><p>
Formulate rules such as "If <emphasis>S</emphasis> is the son of <emphasis>F</emphasis>, and <emphasis>F</emphasis> is the son of <emphasis>G</emphasis>, then <emphasis>S</emphasis> is the grandson of <emphasis>G</emphasis>"
and "If <emphasis>W</emphasis> is the wife of <emphasis>M</emphasis>, and <emphasis>S</emphasis> is the son of
<emphasis>W</emphasis>, then <emphasis>S</emphasis> is the son of <emphasis>M</emphasis>" (which was supposedly
more true in biblical times than today) that will enable the query
system to find the grandson of Cain; the sons of Lamech; the grandsons
of Methushael.
(See exercise 4.69 for some rules to
deduce more complicated relationships.)</p>

<p><strong>4.4.2  How the Query System Works</strong></p>

<p>



In section 4.4.4 we will present an
implementation of the query interpreter as a collection of procedures.
In this section we give an overview that explains the general
structure of the system independent of low-level implementation
details.  After describing the implementation of the interpreter, we
will be in a position to understand some of its limitations and some
of the subtle ways in which the query language's logical operations
differ from the operations of mathematical logic.</p>

<p>

It should be apparent that the query evaluator must perform some kind
of search in order to match queries against facts and rules in the
data base.  One way to do this would be to implement the query system
as a nondeterministic program, using the amb evaluator of
section 4.3 (see
exercise 4.78).  Another possibility is to manage
the search with the aid of streams.  Our implementation follows this
second approach.</p>

<p>

The query system is organized around two central operations called
<emphasis>pattern matching</emphasis> and <emphasis>unification</emphasis>.  We first describe
pattern matching and explain how this operation, together with the
organization of information in terms of streams of frames, enables us
to implement both simple and compound queries.  We next discuss
unification, a generalization of pattern matching needed to implement
rules.  Finally, we show how the entire query interpreter fits
together through a procedure that classifies expressions in a manner
analogous to the way eval classifies expressions for the
interpreter described in section 4.1.</p>

<p><strong>Pattern matching</strong></p>

<p>


A <emphasis>pattern matcher</emphasis> is a program that tests whether some datum
fits a specified pattern.  For example, the data list ((a b) c (a
b)) matches the pattern (?x c ?x) with the pattern variable
?x bound to (a b).  The same data list matches the pattern
(?x ?y ?z) with ?x and ?z both bound to (a b)
and ?y bound to c.  It also matches the pattern ((?x ?y) c (?x ?y)) with ?x bound to a and ?y bound
to b.  However, it does not match the pattern (?x a ?y),
since that pattern specifies a list whose second element is the symbol
a.</p>

<p>

The pattern matcher used by the query system takes as inputs a
pattern, a datum, and a <emphasis>frame</emphasis> that specifies bindings for
various pattern variables.  It checks whether the datum matches the
pattern in a way that is consistent with the bindings already in the
frame.  If so, it returns the given frame augmented by any bindings
that may have been determined by the match.  Otherwise, it indicates
that the match has failed.</p>

<p>

For example, using the pattern (?x ?y ?x) to match (a b a)
given an empty frame will return a frame specifying that ?x is
bound to a and ?y is bound to b.  Trying the match
with the same pattern, the same datum, and a frame specifying that
?y is bound to a will fail.  Trying the match with the
same pattern, the same datum, and a frame in which ?y is bound
to b and ?x is unbound will return the given frame
augmented by a binding of ?x to a.</p>

<p>

The pattern matcher is all the mechanism that is needed to process
simple queries that don't involve rules.  For instance, to process the
query</p>

<p>(job ?x (computer programmer))</p><empty-line /><p>
we scan through all assertions in the data base and select those that
match the pattern with respect to an initially empty frame.  For each
match we find, we use the frame returned by the match to instantiate
the pattern with a value for ?x.</p>

<p><strong>Streams of frames</strong></p>

<p>


The testing of patterns against frames is organized through the use of
streams.  Given a single frame, the matching process runs through the
data-base entries one by one.  For each data-base entry, the matcher
generates either a special symbol indicating that the match has failed
or an extension to the frame.  The results for all the data-base
entries are collected into a stream, which is passed through a filter
to weed out the failures.  The result is a stream of all the frames
that extend the given frame via a match to some assertion in the data
base.<sup>67</sup></p>

<p>

In our system, a query takes an input stream of frames and performs
the above matching operation for every frame in the stream, as
indicated in figure 4.4.  That is, for each frame in
the input stream, the query generates a new stream consisting of all
extensions to that frame by matches to assertions in the data base.
All these streams are then combined to form one huge stream, which
contains all possible extensions of every frame in the input stream.
This stream is the output of the query.</p>

<p><image xlink:href="#_197.jpg" /></p>

<p><strong>Figure 4.4:</strong>  A query processes a stream of frames.</p>

<p>

To answer a simple query, we use the query with an input stream
consisting of a single empty frame.  The resulting output stream
contains all extensions to the empty frame (that is, all answers to
our query).  This stream of frames is then used to generate a stream
of copies of the original query pattern with the variables
instantiated by the values in each frame, and this is the stream that
is finally printed.</p>

<p><strong>Compound queries</strong></p>

<p>


The real elegance of the stream-of-frames implementation is evident
when we deal with compound queries.  The processing of compound
queries makes use of the ability of our matcher to demand that a match
be consistent with a specified frame.  For example, to handle the and of two queries, such as</p>

<p>(and (can-do-job ?x (computer programmer trainee))</p><empty-line /><p>
     (job ?person ?x))</p><empty-line /><p>
(informally, "Find all people who can do the job of a computer
programmer trainee"), we first find all entries that match the
pattern</p>

<p>(can-do-job ?x (computer programmer trainee))</p><empty-line /><p>
This produces a stream of frames, each of which contains a binding for
?x.  Then for each frame in the stream we find all entries that
match</p>

<p>(job ?person ?x)</p><empty-line /><p>
in a way that is consistent with the given binding for ?x.  Each
such match will produce a frame containing bindings for ?x and
?person.  The and of two queries can be viewed as a series
combination of the two component queries, as shown in
figure 4.5.  The frames that pass through the first
query filter are filtered and further extended by the second query.</p>

<p><image xlink:href="#_198.jpg" /></p>

<p><strong>Figure 4.5:</strong>  The and combination of two queries is
produced by operating on the stream of frames in series.</p>

<p>

Figure 4.6 shows the analogous method for computing the
or of two queries as a parallel combination of the two component
queries.  The input stream of frames is extended separately by each
query.  The two resulting streams are then merged to produce the final
output stream.</p>

<p><image xlink:href="#_199.jpg" /></p>

<p><strong>Figure 4.6:</strong>  The or combination of two queries is produced by 
operating on the stream of frames in parallel and merging the
results.</p>

<p>

Even from this high-level description, it is apparent that the
processing of compound queries can be slow.
For example, since a query may produce more than one output frame for
each input frame, and each query in an and gets its input frames
from the previous query, an and query could, in the worst case,
have to perform a number of matches that is exponential in the number
of queries (see exercise 4.76).<sup>68</sup>
Though systems for handling only simple queries are quite practical,
dealing with complex queries is extremely difficult.<sup>69</sup></p>

<p>

From the stream-of-frames viewpoint, the not of some query acts
as a filter that removes all frames for which the query can be
satisfied.  For instance, given the pattern</p>

<p>(not (job ?x (computer programmer)))</p><empty-line /><p>
we attempt, for each frame in the input stream, to produce extension
frames that satisfy (job ?x (computer programmer)).  We remove
from the input stream all frames for which such extensions exist.  The
result is a stream consisting of only those frames in which the
binding for ?x does not satisfy (job ?x (computer
programmer)).  For example, in processing the query</p>

<p>(and (supervisor ?x ?y)</p><empty-line /><p>
     (not (job ?x (computer programmer))))</p><empty-line /><p>
the first clause will generate frames with bindings for ?x and
?y.  The not clause will then filter
these by removing all frames in which the binding for ?x
satisfies the restriction that ?x is a computer
programmer.<sup>70</sup></p>

<p>

The lisp-value special form is implemented as a similar filter
on frame streams.  We use each frame in the stream to instantiate any
variables in the pattern, then apply the Lisp predicate.  We remove
from the input stream all frames for which the predicate fails.</p>

<p><strong>Unification</strong></p>

<p>


In order to handle rules in the query language, we must be able to
find the rules whose conclusions match a given query pattern.  Rule
conclusions are like assertions except that they can contain
variables, so we will need a generalization of pattern
matching -- called <emphasis>unification</emphasis> -- in which both the "pattern"
and the "datum" may contain variables.</p>

<p>

A unifier takes two patterns, each containing constants and variables,
and determines whether it is possible to assign values to the
variables that will make the two patterns equal.  If so, it returns a
frame containing these bindings.  For example, unifying (?x a
?y) and (?y ?z a) will specify a frame in which ?x, 
?y, and ?z must all be bound to a.  On the other
hand, unifying (?x ?y a) and (?x b ?y) will fail, because
there is no value for ?y that can make the two patterns equal.
(For the second elements of the patterns to be equal, ?y would
have to be b; however, for the third elements to be equal, ?y would have to be a.)  The unifier used in the query system,
like the pattern matcher, takes a frame as input and performs
unifications that are consistent with this frame.</p>

<p>

The unification algorithm is the most technically difficult part of
the query system.  With complex patterns, performing unification may
seem to require deduction.  To unify (?x ?x) and ((a ?y c)
(a b ?z)), for example, the algorithm must infer that ?x should
be (a b c),   ?y should be b, and ?z should
be c.  We may think of this process as solving a set of
equations among the pattern components.  In general, these are
simultaneous equations, which may require substantial manipulation to
solve.<sup>71</sup>  For example, unifying (?x
?x) and ((a ?y c) (a b ?z)) may be thought of as specifying the
simultaneous equations</p>

<p>?x  =  (a ?y c)</p><empty-line /><p>
?x  =  (a b ?z)</p><empty-line /><p>
These equations imply that</p>

<p>(a ?y c)  =  (a b ?z)</p><empty-line /><p>
which in turn implies that</p>

<p>a  =  a, ?y  =  b, c  =  ?z,</p><empty-line /><p>
and hence that</p>

<p>?x  =  (a b c)</p><empty-line /><empty-line /><p>

In a successful pattern match, all pattern variables become bound, and
the values to which they are bound contain only constants.  This is
also true of all the examples of unification we have seen so far.  In
general, however, a successful unification may not completely
determine the variable values; some variables may remain unbound and
others may be bound to values that contain variables.</p>

<p>

Consider the unification of (?x a) and ((b ?y) ?z).  We
can deduce that ?x  =  (b ?y) and a  =  ?z, but we cannot
further solve for ?x or ?y.  The unification doesn't fail,
since it is certainly possible to make the two patterns equal by
assigning values to ?x and ?y.  Since this match in no way
restricts the values ?y can take on, no binding for ?y is
put into the result frame.  The match does, however, restrict the
value of ?x.  Whatever value ?y has, ?x must be (b ?y).  A binding of ?x to the pattern (b ?y) is thus
put into the frame.  If a value for ?y is later determined and
added to the frame (by a pattern match or unification that is required
to be consistent with this frame), the previously bound ?x will
refer to this value.<sup>72</sup></p>

<p><strong>Applying rules</strong></p>

<p>


Unification is the key to the component of the query system that makes
inferences from rules. To see how this is accomplished, consider
processing a query that involves applying a rule, such as</p>

<p>(lives-near ?x (Hacker Alyssa P))</p><empty-line /><p>
To process this query, we first use the ordinary pattern-match
procedure described above to see if there are any assertions in the
data base that match this pattern.  (There will not be any in this
case, since our data base includes no direct assertions about who
lives near whom.)  The next step is to attempt to unify the query
pattern with the conclusion of each rule.  We find that the pattern
unifies with the conclusion of the rule</p>

<p>(rule (lives-near ?person-1 ?person-2)</p><empty-line /><p>
      (and (address ?person-1 (?town . ?rest-1))</p><empty-line /><p>
           (address ?person-2 (?town . ?rest-2))</p><empty-line /><p>
           (not (same ?person-1 ?person-2))))</p><empty-line /><p>
resulting in a frame specifying that ?person-2 is bound
to (Hacker Alyssa P) and that ?x should be bound to (have
the same value as) ?person-1.  Now, relative to this frame, we
evaluate the compound query given by the body of the rule.  Successful
matches will extend this frame by providing a binding for ?person-1, and consequently a value for ?x, which we can use to
instantiate the original query pattern.</p>

<p>

In general, the query evaluator uses the following method to apply a
rule when trying to establish a query pattern in a frame that
specifies bindings for some of the pattern variables:</p>

<p>Unify the query with the conclusion of the rule to form, if
successful, an extension of the original frame.</p>

<p>Relative to the extended frame, evaluate the query formed by
the body of the rule.</p>

<p>

Notice how similar this is to the method for applying a procedure in
the eval/apply evaluator for Lisp:</p>

<p>Bind the procedure's parameters to its arguments to form a
frame that extends the original procedure environment.</p>

<p>Relative to the extended environment, evaluate the expression
formed by the body of the procedure.</p>

<p>

The similarity between the two evaluators should come as no surprise.
Just as procedure definitions are the means of abstraction in Lisp,
rule definitions are the means of abstraction in the query language.
In each case, we unwind the abstraction by creating appropriate
bindings and evaluating the rule or procedure body relative to these.</p>

<p><strong>Simple queries</strong></p>

<p>


We saw earlier in this section how to evaluate simple queries in the
absence of rules.  Now that we have seen how to apply rules, we can
describe how to evaluate simple queries by using both rules and
assertions.</p>

<p>

Given the query pattern and a stream of frames, we produce, for each
frame in the input stream, two streams:</p>

<p>a stream of extended frames obtained by matching the pattern
against all assertions in the data base (using the pattern matcher),
and</p>

<p>a stream of extended frames obtained by applying all
possible rules (using the unifier).<sup>73</sup></p>

<p>

Appending these two streams produces a stream that consists of all the
ways that the given pattern can be satisfied consistent with the
original frame.  These streams (one for each frame in the input
stream) are now all combined to form one large stream, which therefore
consists of all the ways that any of the frames in the original input
stream can be extended to produce a match with the given pattern.</p>

<p><strong>The query evaluator and the driver loop</strong></p>

<p>


Despite the complexity of the underlying matching operations, the
system is organized much like an evaluator for any language.  The
procedure that coordinates the matching operations is called qeval, and it plays a role analogous to that of the eval
procedure for Lisp.  Qeval takes as inputs a query and a stream
of frames.  Its output is a stream of frames, corresponding to
successful matches to the query pattern, that extend some frame in the
input stream, as indicated in figure 4.4.  Like
eval, qeval classifies the different types of expressions
(queries) and dispatches to an appropriate procedure for each.  There
is a procedure for each special form (and, or, not,
and lisp-value) and one for simple queries.</p>

<p>

The driver loop, which is analogous to the driver-loop procedure
for the other evaluators in this chapter, reads queries from the
terminal.  For each query, it calls qeval with the query and a
stream that consists of a single empty frame.  This will produce the
stream of all possible matches (all possible extensions to the empty
frame).  For each frame in the resulting stream, it instantiates the
original query using the values of the variables found in the frame.
This stream of instantiated queries is then printed.<sup>74</sup></p>

<p>

The driver also checks for the special command assert!, which
signals that the input is not a query but rather an assertion or rule
to be added to the data base.  For instance,</p>

<p>(assert! (job (Bitdiddle Ben) (computer wizard)))</p><empty-line /><p>
(assert! (rule (wheel ?person)</p><empty-line /><p>
               (and (supervisor ?middle-manager ?person)</p><empty-line /><p>
                    (supervisor ?x ?middle-manager))))</p><empty-line /><empty-line /><p><strong>4.4.3  Is Logic Programming Mathematical Logic?</strong></p>

<p>



The means of combination used in the query language may at first seem
identical to the operations and, or, and not of
mathematical logic, and the application of query-language rules is in
fact accomplished through a legitimate method of
inference.<sup>75</sup> This identification of the query language with mathematical
logic is not really valid, though, because the query language provides
a <emphasis>control structure</emphasis> that interprets the logical statements
procedurally.  We can often take advantage of this control structure.
For example, to find all of the supervisors of programmers we could
formulate a query in either of two logically equivalent forms:</p>

<p>(and (job ?x (computer programmer))</p><empty-line /><p>
     (supervisor ?x ?y))</p><empty-line /><p>
or</p>

<p>(and (supervisor ?x ?y)</p><empty-line /><p>
     (job ?x (computer programmer)))</p><empty-line /><p>
If a company has many more supervisors than programmers (the usual
case), it is better to use the first form rather than the second
because the data base must be scanned for each intermediate result
(frame) produced by the first clause of the and.</p>

<p>

The aim of logic programming is to provide the programmer with
techniques for decomposing a computational problem into two separate
problems: "what" is to be computed, and "how" this should be
computed.  This is accomplished by selecting a subset of the
statements of mathematical logic that is powerful enough to be able to
describe anything one might want to compute, yet weak enough to have a
controllable procedural interpretation.  The intention here is that,
on the one hand, a program specified in a logic programming language
should be an effective program that can be carried out by a computer.
Control ("how" to compute) is effected by using the order of
evaluation of the language.  We should be able to arrange the order of
clauses and the order of subgoals within each clause so that the
computation is done in an order deemed to be effective and efficient.
At the same time, we should be able to view the result of the
computation ("what" to compute) as a simple consequence of the laws
of logic.</p>

<p>

Our query language can be regarded as just such a procedurally
interpretable subset of mathematical logic.  An assertion represents a
simple fact (an atomic proposition).  A rule represents the
implication that the rule conclusion holds for those cases where the
rule body holds.  A rule has a natural procedural interpretation: To
establish the conclusion of the rule, establish the body of the rule.
Rules, therefore, specify computations.  However, because rules can
also be regarded as statements of mathematical logic, we can justify
any "inference" accomplished by a logic program by asserting that
the same result could be obtained by working entirely within
mathematical logic.<sup>76</sup></p>

<p><strong>Infinite loops</strong></p>

<p>


A consequence of the procedural interpretation of logic programs is
that it is possible to construct hopelessly inefficient programs for
solving certain problems.  An extreme case of inefficiency occurs when
the system falls into infinite loops in making deductions.  As a
simple example, suppose we are setting up a data base of famous
marriages, including</p>

<p>(assert! (married Minnie Mickey))</p><empty-line /><p>
If we now ask</p>

<p>(married Mickey ?who)</p><empty-line /><p>
we will get no response, because the system doesn't know that if <emphasis>A</emphasis>
is married to <emphasis>B</emphasis>, then <emphasis>B</emphasis> is married to <emphasis>A</emphasis>.  So we assert the rule</p>

<p>(assert! (rule (married ?x ?y)</p><empty-line /><p>
               (married ?y ?x)))</p><empty-line /><p>
and again query</p>

<p>(married Mickey ?who)</p><empty-line /><p>

Unfortunately, this will drive the system into an infinite loop, as
follows:</p>

<p>The system finds that the married rule is applicable;
that is, the rule conclusion (married ?x ?y) successfully
unifies with the query pattern (married Mickey ?who) to produce
a frame in which ?x is bound to Mickey and ?y is
bound to ?who.  So the interpreter proceeds to evaluate the rule
body (married ?y ?x) in this frame -- in effect, to process the
query (married ?who Mickey).</p>

<p>One answer appears directly as an assertion in the data
base: (married Minnie Mickey).</p>

<p>The married rule is also applicable, so the
interpreter again evaluates the rule body, which this time is
equivalent to (married Mickey ?who).</p>

<p>

The system is now in an infinite loop.  Indeed, whether the system
will find the simple answer (married Minnie Mickey) before it
goes into the loop depends on implementation details concerning the
order in which the system checks the items in the data base.  This is
a very simple example of the kinds of loops that can occur.
Collections of interrelated rules can lead to loops that are much
harder to anticipate, and the appearance of a loop can depend on the order
of clauses in an and (see exercise 4.64)
or on low-level details concerning the order in which the system
processes queries.<sup>77</sup></p>

<p><strong>Problems with not</strong></p>

<p>


Another quirk in the query system concerns not.  Given the data
base of section 4.4.1, consider the
following two queries:</p>

<p>(and (supervisor ?x ?y)</p><empty-line /><p>
     (not (job ?x (computer programmer))))</p><empty-line /><p>
(and (not (job ?x (computer programmer)))</p><empty-line /><p>
     (supervisor ?x ?y))</p><empty-line /><p>
These two queries do not produce the same result.  The first query
begins by finding all entries in the data base that match (supervisor ?x ?y), and then filters the resulting frames by removing
the ones in which the value of ?x satisfies (job ?x
(computer programmer)).  The second query begins by filtering the
incoming frames to remove those that can satisfy (job ?x
(computer programmer)).  Since the only incoming frame is empty, it
checks the data base to see if there are any patterns that satisfy
(job ?x (computer programmer)).  Since there generally are
entries of this form, the not clause filters out the empty frame
and returns an empty stream of frames.  Consequently, the entire
compound query returns an empty stream.</p>

<p>

The trouble is that our implementation of not really is meant to
serve as a filter on values for the variables.  If a not clause
is processed with a frame in which some of the variables remain
unbound (as does ?x in the example above), the system will
produce unexpected results. Similar problems occur with the use of
lisp-value -- the Lisp predicate can't work if some of its
arguments are unbound.  See exercise 4.77.</p>

<p>

There is also a much more serious way in which the not of the
query language differs from the not of mathematical logic.  In
logic, we interpret the statement "not <emphasis>P</emphasis>" to mean that <emphasis>P</emphasis> is not
true.  In the query system, however, "not <emphasis>P</emphasis>" means that <emphasis>P</emphasis> is not
deducible from the knowledge in the data base.  For example, given the
personnel data base of section 4.4.1, the
system would happily deduce all sorts of not statements, such as
that Ben Bitdiddle is not a baseball fan, that it is not raining
outside, and that 2 + 2 is not 4.<sup>78</sup> In other words, the not
of logic programming languages reflects the so-called <emphasis>closed
world assumption</emphasis> that all relevant information has been included in
the data base.<sup>79</sup></p>

<p>
<strong>Exercise 4.64.</strong>  Louis Reasoner mistakenly deletes the outranked-by rule
(section 4.4.1) from the data base.  When
he realizes this, he quickly reinstalls it.  Unfortunately, he makes a
slight change in the rule, and types it in as</p>

<p>(rule (outranked-by ?staff-person ?boss)</p><empty-line /><p>
      (or (supervisor ?staff-person ?boss)</p><empty-line /><p>
          (and (outranked-by ?middle-manager ?boss)</p><empty-line /><p>
               (supervisor ?staff-person ?middle-manager))))</p><empty-line /><p>
Just after Louis types this information into the system, DeWitt
Aull comes by to find out who outranks Ben Bitdiddle. He issues
the query</p>

<p>(outranked-by (Bitdiddle Ben) ?who)</p><empty-line /><p>
After answering, the system goes into an infinite loop.  Explain why.</p>

<p>
<strong>Exercise 4.65.</strong>  Cy D. Fect, looking forward to the day when he will rise in the
organization, gives a query to find all the wheels
(using the wheel rule of section 4.4.1):</p>

<p>(wheel ?who)</p><empty-line /><p>
To his surprise, the system responds</p>

<p><emphasis>;;; Query results:</emphasis></p><empty-line /><p>
(wheel (Warbucks Oliver))</p><empty-line /><p>
(wheel (Bitdiddle Ben))</p><empty-line /><p>
(wheel (Warbucks Oliver))</p><empty-line /><p>
(wheel (Warbucks Oliver))</p><empty-line /><p>
(wheel (Warbucks Oliver))</p><empty-line /><p>
Why is Oliver Warbucks listed four times?</p>

<p>
<strong>Exercise 4.66.</strong>  Ben has been generalizing the query system to provide statistics
about the company.  For example, to find the total salaries of all the
computer programmers one will be able to say</p>

<p>(sum ?amount</p><empty-line /><p>
     (and (job ?x (computer programmer))</p><empty-line /><p>
          (salary ?x ?amount)))</p><empty-line /><p>
In general, Ben's new system allows expressions of the form</p>

<p>(accumulation-function &lt;<emphasis>variable</emphasis>&gt;</p><empty-line /><p>
                       &lt;<emphasis>query pattern</emphasis>&gt;)</p><empty-line /><p>
where accumulation-function can be things like sum,  
average, or maximum.  Ben reasons that it should be a
cinch to implement this.  He will simply feed the query pattern to
qeval.  This will produce a stream of frames.  He will then pass
this stream through a mapping function that extracts the value of the
designated variable from each frame in the stream and feed the
resulting stream of values to the accumulation function.  Just as Ben
completes the implementation and is about to try it out, Cy walks by,
still puzzling over the wheel query result in
exercise 4.65.  When Cy shows Ben the system's
response, Ben groans, "Oh, no, my simple accumulation scheme won't
work!"</p>

<p>

What has Ben just realized?  Outline a method he can use to
salvage the situation.</p>

<p>
<strong>Exercise 4.67.</strong>  Devise a way to install a loop detector in the query system so as to
avoid the kinds of simple loops illustrated in the text and in
exercise 4.64.  The general idea is that the
system should maintain some sort of history of its current chain of
deductions and should not begin processing a query that it is already
working on.  Describe what kind of information (patterns and frames)
is included in this history, and how the check should be made.  (After
you study the details of the query-system implementation in
section 4.4.4, you may want to
modify the system to include your loop detector.)</p>

<p>
<strong>Exercise 4.68.</strong>  Define rules to implement the reverse operation of
exercise 2.18, which returns a list containing the same
elements as a given list in reverse order.  (Hint: Use append-to-form.)
Can your rules answer both
(reverse (1 2 3) ?x) and (reverse ?x (1 2 3)) ?</p>

<p>
<strong>Exercise 4.69.</strong>  Beginning with the data base and the rules you formulated in
exercise 4.63, devise a rule for adding "greats" to
a grandson relationship. This should enable the system to deduce that
Irad is the great-grandson of Adam, or that Jabal and Jubal are
the great-great-great-great-great-grandsons of Adam.  (Hint: Represent
the fact about Irad, for example, as ((great grandson) Adam
Irad).  Write rules that determine if a list ends in the word
grandson.  Use this to express a rule that allows one to derive
the relationship ((great .  ?rel) ?x ?y), where ?rel is a
list ending in grandson.)
Check your rules on queries such as
((great grandson) ?g ?ggs) and (?relationship Adam Irad).</p>

<p><strong>4.4.4  Implementing the Query System</strong></p>

<p>

Section 4.4.2 described how the query system
works. Now we fill in the details by presenting a complete
implementation of the system.</p>

<p><strong>4.4.4.1  The Driver Loop and Instantiation</strong></p>

<p>

The driver loop for the query system repeatedly reads input
expressions.  If the expression is a rule or assertion to be added to
the data base, then the information is added.  Otherwise the
expression is assumed to be a query.  The driver passes this query to
the evaluator qeval together with an initial frame stream
consisting of a single empty frame.  The result of the evaluation is a
stream of frames generated by satisfying the query with variable
values found in the data base.  These frames are used to form a new
stream consisting of copies of the original query in which the
variables are instantiated with values supplied by the stream of
frames, and this final stream is printed at the terminal:</p>

<p>(define input-prompt ";;; Query input:")</p><empty-line /><p>
(define output-prompt ";;; Query results:")</p><empty-line /><p>(define (query-driver-loop)</p><empty-line /><p>
  (prompt-for-input input-prompt)</p><empty-line /><p>
  (let ((q (query-syntax-process (read))))</p><empty-line /><p>
    (cond ((assertion-to-be-added? q)</p><empty-line /><p>
           (add-rule-or-assertion! (add-assertion-body q))</p><empty-line /><p>
           (newline)</p><empty-line /><p>
           (display "Assertion added to data base.")</p><empty-line /><p>
           (query-driver-loop))</p><empty-line /><p>
          (else</p><empty-line /><p>
           (newline)</p><empty-line /><p>
           (display output-prompt)</p><empty-line /><p>
           (display-stream</p><empty-line /><p>
            (stream-map</p><empty-line /><p>
             (lambda (frame)</p><empty-line /><p>
               (instantiate q</p><empty-line /><p>
                            frame</p><empty-line /><p>
                            (lambda (v f)</p><empty-line /><p>
                              (contract-question-mark v))))</p><empty-line /><p>
             (qeval q (singleton-stream '()))))</p><empty-line /><p>
           (query-driver-loop)))))</p><empty-line /><p>
Here, as in the other evaluators in this chapter, we use an abstract
syntax for the expressions of the query language.
The implementation of the expression syntax, including the predicate
assertion-to-be-added? and the selector add-assertion-body,
is given in section 4.4.4.7.
Add-rule-or-assertion! is defined in section 4.4.4.5.</p>

<p>

Before doing any processing on an input expression, the driver loop
transforms it syntactically into a form that makes the processing more
efficient.  This involves changing the representation of pattern
variables.  When the query is instantiated, any variables that remain
unbound are transformed back to the input representation before being
printed.  These transformations are performed by the two procedures
query-syntax-process and contract-question-mark
(section  4.4.4.7).</p>

<p>

To instantiate an expression, we copy it, replacing any variables in
the expression by their values in a given frame.  The values are
themselves instantiated, since they could contain variables (for
example, if ?x in exp is bound to ?y as the result
of unification and ?y is in turn bound to 5).  The action to
take if a variable cannot be instantiated is given by a procedural
argument to instantiate.</p>

<p>(define (instantiate exp frame unbound-var-handler)</p><empty-line /><p>
  (define (copy exp)</p><empty-line /><p>
    (cond ((var? exp)</p><empty-line /><p>
           (let ((binding (binding-in-frame exp frame)))</p><empty-line /><p>
             (if binding</p><empty-line /><p>
                 (copy (binding-value binding))</p><empty-line /><p>
                 (unbound-var-handler exp frame))))</p><empty-line /><p>
          ((pair? exp)</p><empty-line /><p>
           (cons (copy (car exp)) (copy (cdr exp))))</p><empty-line /><p>
          (else exp)))</p><empty-line /><p>
  (copy exp))</p><empty-line /><p>
The procedures that manipulate bindings are defined in
section 4.4.4.8.</p>

<p><strong>4.4.4.2  The Evaluator</strong></p>

<p>

The qeval procedure, called by the query-driver-loop, is
the basic evaluator of the query system.  It takes as inputs a query
and a stream of frames, and it returns a stream of extended frames.
It identifies special forms by a data-directed dispatch using get and put, just as we did in implementing generic operations
in chapter 2.  Any query that is not identified as a special form is
assumed to be a simple query, to be processed by simple-query.</p>

<p>(define (qeval query frame-stream)</p><empty-line /><p>
  (let ((qproc (get (type query) 'qeval)))</p><empty-line /><p>
    (if qproc</p><empty-line /><p>
        (qproc (contents query) frame-stream)</p><empty-line /><p>
        (simple-query query frame-stream))))</p><empty-line /><p>
Type and contents, defined in section 4.4.4.7,
implement the abstract syntax of the special forms.</p>

<p><strong>Simple queries</strong></p>

<p>


The simple-query procedure handles simple queries.  It takes as
arguments a simple query (a pattern) together with a stream of frames,
and it returns the stream formed by extending each frame by all
data-base matches of the query.</p>

<p>(define (simple-query query-pattern frame-stream)</p><empty-line /><p>
  (stream-flatmap</p><empty-line /><p>
   (lambda (frame)</p><empty-line /><p>
     (stream-append-delayed</p><empty-line /><p>
      (find-assertions query-pattern frame)</p><empty-line /><p>
      (delay (apply-rules query-pattern frame))))</p><empty-line /><p>
   frame-stream))</p><empty-line /><empty-line /><p>

For each frame in the input stream, we use find-assertions
(section 4.4.4.3) to match the pattern against all
assertions in the data base, producing a stream of extended frames,
and we use apply-rules (section 4.4.4.4) to apply
all possible rules, producing another stream of extended frames.
These two streams are combined (using stream-append-delayed,
section 4.4.4.6) to make a stream of all the ways that
the given pattern can be satisfied consistent with the original frame
(see exercise 4.71).  The streams for the
individual input frames are combined using stream-flatmap
(section 4.4.4.6) to form one large stream of all the
ways that any of the frames in the original input stream can be
extended to produce a match with the given pattern.</p>

<p><strong>Compound queries</strong></p>

<p>


And queries are handled as illustrated in
figure 4.5 by the conjoin procedure.  Conjoin takes as inputs the conjuncts and the frame stream and
returns the stream of extended frames.  First, conjoin processes
the stream of frames to find the stream of all possible frame extensions
that satisfy the first query in the conjunction.  Then, using this as the new
frame stream, it recursively applies conjoin to the rest of the
queries.</p>

<p>(define (conjoin conjuncts frame-stream)</p><empty-line /><p>
  (if (empty-conjunction? conjuncts)</p><empty-line /><p>
      frame-stream</p><empty-line /><p>
      (conjoin (rest-conjuncts conjuncts)</p><empty-line /><p>
               (qeval (first-conjunct conjuncts)</p><empty-line /><p>
                      frame-stream))))</p><empty-line /><p>
The expression</p>

<p>(put 'and 'qeval conjoin)</p><empty-line /><p>
sets up qeval to dispatch to conjoin when an and
form is encountered.</p>

<p>


Or queries are handled similarly, as shown in
figure 4.6.  The output streams for the various
disjuncts of the or are computed separately and merged using the
interleave-delayed procedure from section 4.4.4.6.
(See exercises 4.71 and 4.72.)</p>

<p>(define (disjoin disjuncts frame-stream)</p><empty-line /><p>
  (if (empty-disjunction? disjuncts)</p><empty-line /><p>
      the-empty-stream</p><empty-line /><p>
      (interleave-delayed</p><empty-line /><p>
       (qeval (first-disjunct disjuncts) frame-stream)</p><empty-line /><p>
       (delay (disjoin (rest-disjuncts disjuncts)</p><empty-line /><p>
                       frame-stream)))))</p><empty-line /><p>
(put 'or 'qeval disjoin)</p><empty-line /><p>
The predicates and selectors for the syntax of conjuncts and disjuncts
are given in section 4.4.4.7.</p>

<p><strong>Filters</strong></p>

<p>

Not is handled by the method outlined in
section 4.4.2.  We attempt to extend each frame in
the input stream to satisfy the query being negated, and we include a
given frame in the output stream only if it cannot be extended.</p>

<p>(define (negate operands frame-stream)</p><empty-line /><p>
  (stream-flatmap</p><empty-line /><p>
   (lambda (frame)</p><empty-line /><p>
     (if (stream-null? (qeval (negated-query operands)</p><empty-line /><p>
                              (singleton-stream frame)))</p><empty-line /><p>
         (singleton-stream frame)</p><empty-line /><p>
         the-empty-stream))</p><empty-line /><p>
   frame-stream))</p><empty-line /><p>
(put 'not 'qeval negate)</p><empty-line /><empty-line /><p>

Lisp-value is a filter similar to not.  Each frame in the
stream is used to instantiate the variables in the pattern, the
indicated predicate is applied, and the frames for which the predicate
returns false are filtered out of the input stream.  An error results
if there are unbound pattern variables.</p>

<p>(define (lisp-value call frame-stream)</p><empty-line /><p>
  (stream-flatmap</p><empty-line /><p>
   (lambda (frame)</p><empty-line /><p>
     (if (execute</p><empty-line /><p>
          (instantiate</p><empty-line /><p>
           call</p><empty-line /><p>
           frame</p><empty-line /><p>
           (lambda (v f)</p><empty-line /><p>
             (error "Unknown pat var -- LISP-VALUE" v))))</p><empty-line /><p>
         (singleton-stream frame)</p><empty-line /><p>
         the-empty-stream))</p><empty-line /><p>
   frame-stream))</p><empty-line /><p>
(put 'lisp-value 'qeval lisp-value)</p><empty-line /><empty-line /><p>

Execute, which applies the predicate to the arguments, must eval the predicate expression to get the procedure to apply.
However, it must not evaluate the arguments, since they are already
the actual arguments, not expressions whose evaluation (in Lisp) will
produce the arguments.  Note that execute is implemented using
eval and apply from the underlying Lisp system.</p>

<p>(define (execute exp)</p><empty-line /><p>
  (apply (eval (predicate exp) user-initial-environment)</p><empty-line /><p>
         (args exp)))</p><empty-line /><empty-line /><p>

The always-true special form provides for a query that is always
satisfied.  It ignores its contents (normally empty) and simply passes
through all the frames in the input stream.  Always-true is used
by the rule-body selector (section 4.4.4.7)
to provide bodies for rules that were
defined without bodies (that is, rules whose conclusions are always
satisfied).</p>

<p>(define (always-true ignore frame-stream) frame-stream)</p><empty-line /><p>
(put 'always-true 'qeval always-true)</p><empty-line /><p>
The selectors that define the syntax of not and lisp-value
are given in section 4.4.4.7.</p>

<p><strong>4.4.4.3  Finding Assertions by Pattern Matching</strong></p>

<p>

Find-assertions, called by simple-query
(section 4.4.4.2), takes as input a pattern and a frame.
It returns a stream of frames, each extending the given one by a
data-base match of the given pattern.  It uses fetch-assertions
(section 4.4.4.5) to get a stream of all the assertions in
the data base that should be checked for a match against the pattern
and the frame.  The reason for fetch-assertions here is that we
can often apply simple tests that will eliminate many of the entries
in the data base from the pool of candidates for a successful match.
The system would still work if we eliminated fetch-assertions
and simply checked a stream of all assertions in the data base, but
the computation would be less efficient because we would need to make
many more calls to the matcher.</p>

<p>(define (find-assertions pattern frame)</p><empty-line /><p>
  (stream-flatmap (lambda (datum)</p><empty-line /><p>
                    (check-an-assertion datum pattern frame))</p><empty-line /><p>
                  (fetch-assertions pattern frame)))</p><empty-line /><empty-line /><p>

Check-an-assertion takes as arguments a pattern, a data object
(assertion), and a frame and returns either a one-element stream
containing the extended frame or the-empty-stream if the match
fails.</p>

<p>(define (check-an-assertion assertion query-pat query-frame)</p><empty-line /><p>
  (let ((match-result</p><empty-line /><p>
         (pattern-match query-pat assertion query-frame)))</p><empty-line /><p>
    (if (eq? match-result 'failed)</p><empty-line /><p>
        the-empty-stream</p><empty-line /><p>
        (singleton-stream match-result))))</p><empty-line /><p>
The basic pattern matcher returns either the symbol failed or an
extension of the given frame.  The basic idea of the matcher is to
check the pattern against the data, element by element, accumulating
bindings for the pattern variables.  If the pattern and the data
object are the same, the match succeeds and we return the frame of
bindings accumulated so far.  Otherwise, if the pattern is a variable
we extend the current frame by binding the variable to the data, so
long as this is consistent with the bindings already in the frame.  If
the pattern and the data are both pairs, we (recursively) match the
car of the pattern against the car of the data to produce
a frame; in this frame we then match the cdr of the pattern
against the cdr of the data.  If none of these cases are
applicable, the match fails and we return the symbol failed.</p>

<p>(define (pattern-match pat dat frame)</p><empty-line /><p>
  (cond ((eq? frame 'failed) 'failed)</p><empty-line /><p>
        ((equal? pat dat) frame)</p><empty-line /><p>
        ((var? pat) (extend-if-consistent pat dat frame))</p><empty-line /><p>
        ((and (pair? pat) (pair? dat))</p><empty-line /><p>
         (pattern-match (cdr pat)</p><empty-line /><p>
                        (cdr dat)</p><empty-line /><p>
                        (pattern-match (car pat)</p><empty-line /><p>
                                       (car dat)</p><empty-line /><p>
                                       frame)))</p><empty-line /><p>
        (else 'failed)))</p><empty-line /><empty-line /><p>

Here is the procedure that extends a frame by adding a new binding, if
this is consistent with the bindings already in the frame:</p>

<p>(define (extend-if-consistent var dat frame)</p><empty-line /><p>
  (let ((binding (binding-in-frame var frame)))</p><empty-line /><p>
    (if binding</p><empty-line /><p>
        (pattern-match (binding-value binding) dat frame)</p><empty-line /><p>
        (extend var dat frame))))</p><empty-line /><p>
If there is no binding for the variable in the frame, we simply add
the binding of the variable to the data.  Otherwise we match, in the
frame, the data against the value of the variable in the frame.  If
the stored value contains only constants, as it must if it was stored
during pattern matching by extend-if-consistent, then the match
simply tests whether the stored and new values are the same.  If so,
it returns the unmodified frame; if not, it returns a failure
indication.  The stored value may, however, contain pattern variables
if it was stored during unification (see section 4.4.4.4).
The recursive match of the stored pattern against the new data will add or
check bindings for the variables in this pattern.  For example,
suppose we have a frame in which ?x is bound to (f ?y) and
?y is unbound, and we wish to augment this frame by a binding of
?x to (f b).  We look up ?x and find that it is
bound to (f ?y).  This leads us to match (f ?y) against
the proposed new value (f b) in the same frame.  Eventually
this match extends the frame by adding a binding of ?y to b.  ?X remains bound to (f ?y).  We never modify a stored
binding and we never store more than one binding for a given variable.</p>

<p>

The procedures used by extend-if-consistent to manipulate
bindings are defined in section 4.4.4.8.</p>

<p><strong>Patterns with dotted tails</strong></p>

<p>



If a pattern contains a dot followed by a pattern variable, the
pattern variable matches the rest of the data list (rather than the
next element of the data list), just as one would expect with the
dotted-tail notation described in exercise 2.20.
Although the pattern matcher we have just implemented doesn't look for
dots, it does behave as we want.  This is because the Lisp read
primitive, which is used by query-driver-loop to read the query
and represent it as a list structure, treats dots in a special way.</p>

<p>

When read sees a dot, instead of making the next item be the
next element of a list (the car of a cons whose cdr
will be the rest of the list) it makes the next item be the cdr
of the list structure.  For example, the list structure produced by
read for the pattern (computer ?type) could be constructed
by evaluating the expression (cons 'computer (cons '?type '())),
and that for (computer . ?type) could be constructed by
evaluating the expression (cons 'computer '?type).</p>

<p>


Thus, as pattern-match recursively compares cars and cdrs of a data list and a pattern that had a dot, it eventually
matches the variable after the dot (which is a cdr of the
pattern) against a sublist of the data list, binding the variable to
that list.  For example, matching the pattern (computer . ?type) against
(computer programmer trainee) will match ?type against the
list (programmer trainee).</p>

<p><strong>4.4.4.4  Rules and Unification</strong></p>

<p>

Apply-rules is the rule analog of find-assertions
(section 4.4.4.3).  It
takes as input a pattern and a frame, and it forms a stream of
extension frames by applying rules from the data base.  Stream-flatmap maps apply-a-rule down the stream of possibly
applicable rules (selected by fetch-rules, section 4.4.4.5)
and combines the resulting streams of frames.</p>

<p>(define (apply-rules pattern frame)</p><empty-line /><p>
  (stream-flatmap (lambda (rule)</p><empty-line /><p>
                    (apply-a-rule rule pattern frame))</p><empty-line /><p>
                  (fetch-rules pattern frame)))</p><empty-line /><empty-line /><p>

Apply-a-rule applies rules using the method outlined in
section 4.4.2.  It first augments its argument
frame by unifying the rule conclusion with the pattern in the given
frame.  If this succeeds, it evaluates the rule body in this new
frame.</p>

<p>

Before any of this happens, however, the program renames all the
variables in the rule with unique new names.  The reason for this is
to prevent the variables for different rule applications from becoming
confused with each other.  For instance, if two rules both use a
variable named ?x, then each one may add a binding for ?x
to the frame when it is applied.  These two ?x's have nothing to
do with each other, and we should not be fooled into thinking that the
two bindings must be consistent.  Rather than rename variables, we
could devise a more clever environment structure; however, the
renaming approach we have chosen here is the most straightforward,
even if not the most efficient.  (See
exercise 4.79.)  Here is the apply-a-rule
procedure:</p>

<p>(define (apply-a-rule rule query-pattern query-frame)</p><empty-line /><p>
  (let ((clean-rule (rename-variables-in rule)))</p><empty-line /><p>
    (let ((unify-result</p><empty-line /><p>
           (unify-match query-pattern</p><empty-line /><p>
                        (conclusion clean-rule)</p><empty-line /><p>
                        query-frame)))</p><empty-line /><p>
      (if (eq? unify-result 'failed)</p><empty-line /><p>
          the-empty-stream</p><empty-line /><p>
          (qeval (rule-body clean-rule)</p><empty-line /><p>
                 (singleton-stream unify-result))))))</p><empty-line /><p>
The selectors rule-body and conclusion that extract parts
of a rule are defined in section 4.4.4.7.</p>

<p>

We generate unique variable names by associating a unique identifier
(such as a number) with each rule application and combining this
identifier with the original variable names.  For example, if the
rule-application identifier is 7, we might change each ?x in
the rule to ?x-7 and each ?y in the rule to ?y-7.
(Make-new-variable and new-rule-application-id are
included with the syntax procedures in section 4.4.4.7.)</p>

<p>(define (rename-variables-in rule)</p><empty-line /><p>
  (let ((rule-application-id (new-rule-application-id)))</p><empty-line /><p>
    (define (tree-walk exp)</p><empty-line /><p>
      (cond ((var? exp)</p><empty-line /><p>
             (make-new-variable exp rule-application-id))</p><empty-line /><p>
            ((pair? exp)</p><empty-line /><p>
             (cons (tree-walk (car exp))</p><empty-line /><p>
                   (tree-walk (cdr exp))))</p><empty-line /><p>
            (else exp)))</p><empty-line /><p>
    (tree-walk rule)))</p><empty-line /><p>

The unification algorithm is implemented as a procedure that takes as
inputs two patterns and a frame and returns either the extended frame
or the symbol failed.
The unifier is like the pattern matcher except that it is
symmetrical -- variables are allowed on both sides of the match.
Unify-match is basically the same as pattern-match,
except that there is extra code (marked "***" below) to handle
the case where the object on the right side of the match is a variable.</p>

<p>(define (unify-match p1 p2 frame)</p><empty-line /><p>
  (cond ((eq? frame 'failed) 'failed)</p><empty-line /><p>
        ((equal? p1 p2) frame)</p><empty-line /><p>
        ((var? p1) (extend-if-possible p1 p2 frame))</p><empty-line /><p>
        ((var? p2) (extend-if-possible p2 p1 frame))  <emphasis>; ***</emphasis></p><empty-line /><p>
        ((and (pair? p1) (pair? p2))</p><empty-line /><p>
         (unify-match (cdr p1)</p><empty-line /><p>
                      (cdr p2)</p><empty-line /><p>
                      (unify-match (car p1)</p><empty-line /><p>
                                   (car p2)</p><empty-line /><p>
                                   frame)))</p><empty-line /><p>
        (else 'failed)))</p><empty-line /><empty-line /><p>

In unification, as in one-sided pattern matching, we want to accept a
proposed extension of the frame only if it is consistent with existing
bindings.  The procedure extend-if-possible used in unification
is the same as the extend-if-consistent used in pattern matching
except for two special checks, marked "***" in the program
below.  In the first case, if the variable we are trying to match is
not bound, but the value we are trying to match it with
is itself a (different) variable, it is
necessary to check to see if the value is bound, and if so, to match
its value.  If both parties to the match are unbound, we may bind
either to the other.</p>

<p>

The second check deals with attempts to bind a variable to a pattern
that includes that variable.  Such a situation can occur whenever a
variable is repeated in both patterns.  Consider, for example,
unifying the two patterns (?x ?x) and (?y
&lt;<emphasis>expression involving ?y</emphasis>&gt;) in a frame where both ?x
and ?y are unbound.  First ?x is matched
against ?y, making a binding of ?x to ?y.  Next, the same ?x is matched against the given expression
involving ?y.
Since ?x is already bound to ?y, this
results in matching ?y against the expression.
If we think of the
unifier as finding a set of values for the pattern variables that make
the patterns the same, then these patterns imply instructions to find
a ?y such that ?y is equal to the expression involving ?y.
There is no general method for solving such
equations, so we reject such bindings; these cases are recognized by
the predicate depends-on?.<sup>80</sup>
On the other hand, we do not want to reject attempts
to bind a variable to itself.  For example, consider unifying (?x ?x)
and (?y ?y).  The second attempt to bind ?x to ?y matches ?y (the stored value of ?x) against ?y
(the new value of ?x).  This is taken care of by the equal? clause
of unify-match.</p>

<p>(define (extend-if-possible var val frame)</p><empty-line /><p>
  (let ((binding (binding-in-frame var frame)))</p><empty-line /><p>
    (cond (binding</p><empty-line /><p>
           (unify-match</p><empty-line /><p>
            (binding-value binding) val frame))</p><empty-line /><p>
          ((var? val)                      <emphasis>; ***</emphasis></p><empty-line /><p>
           (let ((binding (binding-in-frame val frame)))</p><empty-line /><p>
             (if binding</p><empty-line /><p>
                 (unify-match</p><empty-line /><p>
                  var (binding-value binding) frame)</p><empty-line /><p>
                 (extend var val frame))))</p><empty-line /><p>
          ((depends-on? val var frame)     <emphasis>; ***</emphasis></p><empty-line /><p>
           'failed)</p><empty-line /><p>
          (else (extend var val frame)))))</p><empty-line /><empty-line /><p>

Depends-on? is a predicate that tests whether an expression
proposed to be the value of a pattern variable depends on the variable.
This must be done relative to the current frame because the expression
may contain occurrences of a variable that already has a value that
depends on our test variable.  The structure of depends-on? is a
simple recursive tree walk in which we substitute for the values of
variables whenever necessary.</p>

<p>(define (depends-on? exp var frame)</p><empty-line /><p>
  (define (tree-walk e)</p><empty-line /><p>
    (cond ((var? e)</p><empty-line /><p>
           (if (equal? var e)</p><empty-line /><p>
               true</p><empty-line /><p>
               (let ((b (binding-in-frame e frame)))</p><empty-line /><p>
                 (if b</p><empty-line /><p>
                     (tree-walk (binding-value b))</p><empty-line /><p>
                     false))))</p><empty-line /><p>
          ((pair? e)</p><empty-line /><p>
           (or (tree-walk (car e))</p><empty-line /><p>
               (tree-walk (cdr e))))</p><empty-line /><p>
          (else false)))</p><empty-line /><p>
  (tree-walk exp))</p><empty-line /><empty-line /><p><strong>4.4.4.5  Maintaining the Data Base</strong></p>

<p>



One important problem in designing logic programming languages is that
of arranging things so that as few irrelevant data-base entries as
possible will be examined in checking a given pattern.  In our
system, in addition to storing all assertions in one big stream,
we store all assertions whose cars are constant symbols
in separate streams, in a table indexed by the symbol.  To fetch an
assertion that may match a pattern, we first check to see if the car of the pattern is a constant symbol.  If so, we return (to be
tested using the matcher) all the stored assertions that have the same
car.  If the pattern's car is not a constant symbol, we
return all the stored assertions.  Cleverer methods could also take
advantage of information in the frame, or try also to optimize the
case where the car of the pattern is not a constant symbol.  We
avoid building our criteria for indexing (using the car,
handling only the case of constant symbols) into the program; instead
we call on predicates and selectors that embody our criteria.</p>

<p>(define THE-ASSERTIONS the-empty-stream)</p><empty-line /><p>(define (fetch-assertions pattern frame)</p><empty-line /><p>
  (if (use-index? pattern)</p><empty-line /><p>
      (get-indexed-assertions pattern)</p><empty-line /><p>
      (get-all-assertions)))</p><empty-line /><p>
(define (get-all-assertions) THE-ASSERTIONS)</p><empty-line /><p>
(define (get-indexed-assertions pattern)</p><empty-line /><p>
  (get-stream (index-key-of pattern) 'assertion-stream))</p><empty-line /><p>
Get-stream looks up a stream in the table and returns an empty
stream if nothing is stored there.</p>

<p>(define (get-stream key1 key2)</p><empty-line /><p>
  (let ((s (get key1 key2)))</p><empty-line /><p>
    (if s s the-empty-stream)))</p><empty-line /><empty-line /><p>

Rules are stored similarly, using the car of the rule
conclusion.  Rule conclusions are arbitrary patterns, however, so they
differ from assertions in that they can contain variables.  A pattern
whose car is a constant symbol can match rules whose conclusions
start with a variable as well as rules whose conclusions have the same
car.  Thus, when fetching rules that might match a pattern whose
car is a constant symbol we fetch all rules whose conclusions
start with a variable as well as those whose conclusions have the same
car as the pattern.  For this purpose we store all rules whose
conclusions start with a variable in a separate stream in our table,
indexed by the symbol ?.</p>

<p>(define THE-RULES the-empty-stream)</p><empty-line /><p>(define (fetch-rules pattern frame)</p><empty-line /><p>
  (if (use-index? pattern)</p><empty-line /><p>
      (get-indexed-rules pattern)</p><empty-line /><p>
      (get-all-rules)))</p><empty-line /><p>
(define (get-all-rules) THE-RULES)</p><empty-line /><p>
(define (get-indexed-rules pattern)</p><empty-line /><p>
  (stream-append</p><empty-line /><p>
   (get-stream (index-key-of pattern) 'rule-stream)</p><empty-line /><p>
   (get-stream '? 'rule-stream)))</p><empty-line /><empty-line /><p>


Add-rule-or-assertion! is used by query-driver-loop to
add assertions and rules to the data base.  Each item is stored in the
index, if appropriate, and in a stream of all assertions or rules in
the data base.</p>

<p>(define (add-rule-or-assertion! assertion)</p><empty-line /><p>
  (if (rule? assertion)</p><empty-line /><p>
      (add-rule! assertion)</p><empty-line /><p>
      (add-assertion! assertion)))</p><empty-line /><p>
(define (add-assertion! assertion)</p><empty-line /><p>
  (store-assertion-in-index assertion)</p><empty-line /><p>
  (let ((old-assertions THE-ASSERTIONS))</p><empty-line /><p>
    (set! THE-ASSERTIONS</p><empty-line /><p>
          (cons-stream assertion old-assertions))</p><empty-line /><p>
    'ok))</p><empty-line /><p>
(define (add-rule! rule)</p><empty-line /><p>
  (store-rule-in-index rule)</p><empty-line /><p>
  (let ((old-rules THE-RULES))</p><empty-line /><p>
    (set! THE-RULES (cons-stream rule old-rules))</p><empty-line /><p>
    'ok))</p><empty-line /><empty-line /><p>

To actually store an assertion or a rule, we check to see if it can be
indexed.  If so, we store it in the appropriate stream.</p>

<p>(define (store-assertion-in-index assertion)</p><empty-line /><p>
  (if (indexable? assertion)</p><empty-line /><p>
      (let ((key (index-key-of assertion)))</p><empty-line /><p>
        (let ((current-assertion-stream</p><empty-line /><p>
               (get-stream key 'assertion-stream)))</p><empty-line /><p>
          (put key</p><empty-line /><p>
               'assertion-stream</p><empty-line /><p>
               (cons-stream assertion</p><empty-line /><p>
                            current-assertion-stream))))))</p><empty-line /><p>
(define (store-rule-in-index rule)</p><empty-line /><p>
  (let ((pattern (conclusion rule)))</p><empty-line /><p>
    (if (indexable? pattern)</p><empty-line /><p>
        (let ((key (index-key-of pattern)))</p><empty-line /><p>
          (let ((current-rule-stream</p><empty-line /><p>
                 (get-stream key 'rule-stream)))</p><empty-line /><p>
            (put key</p><empty-line /><p>
                 'rule-stream</p><empty-line /><p>
                 (cons-stream rule</p><empty-line /><p>
                              current-rule-stream)))))))</p><empty-line /><empty-line /><p>

The following procedures define how the data-base index is used.  A
pattern (an assertion or a rule conclusion) will be stored in the
table if it starts with a variable or a constant symbol.</p>

<p>(define (indexable? pat)</p><empty-line /><p>
  (or (constant-symbol? (car pat))</p><empty-line /><p>
      (var? (car pat))))</p><empty-line /><p>
The key under which a pattern is stored in the table is either ? (if it starts with a variable) or the constant symbol with which
it starts.</p>

<p>(define (index-key-of pat)</p><empty-line /><p>
  (let ((key (car pat)))</p><empty-line /><p>
    (if (var? key) '? key)))</p><empty-line /><p>
The index will be used to retrieve items that might match a pattern if
the pattern starts with a constant symbol.</p>

<p>(define (use-index? pat)</p><empty-line /><p>
  (constant-symbol? (car pat)))</p><empty-line /><empty-line /><p>
<strong>Exercise 4.70.</strong>  What is the purpose of the let bindings in the procedures add-assertion! and add-rule! ?  What would be wrong with the
following implementation of add-assertion! ?
Hint: Recall the definition of the infinite stream of ones in
section 3.5.2: (define ones (cons-stream 1 ones)).</p>

<p>(define (add-assertion! assertion)</p><empty-line /><p>
  (store-assertion-in-index assertion)</p><empty-line /><p>
  (set! THE-ASSERTIONS</p><empty-line /><p>
        (cons-stream assertion THE-ASSERTIONS))</p><empty-line /><p>
  'ok)</p><empty-line /><empty-line /><p><strong>4.4.4.6  Stream Operations</strong></p>

<p>



The query system uses a few stream operations that were not presented
in chapter 3.</p>

<p>


Stream-append-delayed and interleave-delayed
are just like stream-append and interleave
(section 3.5.3),
except that they take a delayed argument (like the integral
procedure in section 3.5.4).
This postpones looping in some cases (see exercise 4.71).</p>

<p>(define (stream-append-delayed s1 delayed-s2)</p><empty-line /><p>
  (if (stream-null? s1)</p><empty-line /><p>
      (force delayed-s2)</p><empty-line /><p>
      (cons-stream</p><empty-line /><p>
       (stream-car s1)</p><empty-line /><p>
       (stream-append-delayed (stream-cdr s1) delayed-s2))))</p><empty-line /><p>(define (interleave-delayed s1 delayed-s2)</p><empty-line /><p>
  (if (stream-null? s1)</p><empty-line /><p>
      (force delayed-s2)</p><empty-line /><p>
      (cons-stream</p><empty-line /><p>
       (stream-car s1)</p><empty-line /><p>
       (interleave-delayed (force delayed-s2)</p><empty-line /><p>
                           (delay (stream-cdr s1))))))</p><empty-line /><empty-line /><p>

Stream-flatmap, which is used throughout the query evaluator to
map a procedure over a stream of frames and combine the resulting
streams of frames, is the stream analog of the flatmap procedure
introduced for ordinary lists in section 2.2.3.
Unlike ordinary flatmap, however, we accumulate the streams with
an interleaving process, rather than simply appending them (see
exercises 4.72 and  4.73).</p>

<p>(define (stream-flatmap proc s)</p><empty-line /><p>
  (flatten-stream (stream-map proc s)))</p><empty-line /><p>(define (flatten-stream stream)</p><empty-line /><p>
  (if (stream-null? stream)</p><empty-line /><p>
      the-empty-stream</p><empty-line /><p>
      (interleave-delayed</p><empty-line /><p>
       (stream-car stream)</p><empty-line /><p>
       (delay (flatten-stream (stream-cdr stream))))))</p><empty-line /><empty-line /><p>

The evaluator also uses the following simple procedure
to generate a stream consisting of a single element:</p>

<p>(define (singleton-stream x)</p><empty-line /><p>
  (cons-stream x the-empty-stream))</p><empty-line /><empty-line /><p><strong>4.4.4.7  Query Syntax Procedures</strong></p>

<p>



Type and contents, used by qeval
(section 4.4.4.2), specify that a
special form is identified by the symbol in its car.
They are the same as the type-tag and contents procedures in
section 2.4.2, except for the error message.</p>

<p>(define (type exp)</p><empty-line /><p>
  (if (pair? exp)</p><empty-line /><p>
      (car exp)</p><empty-line /><p>
      (error "Unknown expression TYPE" exp)))</p><empty-line /><p>
(define (contents exp)</p><empty-line /><p>
  (if (pair? exp)</p><empty-line /><p>
      (cdr exp)</p><empty-line /><p>
      (error "Unknown expression CONTENTS" exp)))</p><empty-line /><empty-line /><p>

The following procedures, used by query-driver-loop
(in section 4.4.4.1), specify
that rules and assertions are added to the data base by expressions of
the form (assert! &lt;<emphasis>rule-or-assertion</emphasis>&gt;):</p>

<p>(define (assertion-to-be-added? exp)</p><empty-line /><p>
  (eq? (type exp) 'assert!))</p><empty-line /><p>
(define (add-assertion-body exp)</p><empty-line /><p>
  (car (contents exp)))</p><empty-line /><empty-line /><p>

Here are the syntax definitions for the and,  or,  not, and lisp-value special forms
(section 4.4.4.2):</p>

<p>(define (empty-conjunction? exps) (null? exps))</p><empty-line /><p>
(define (first-conjunct exps) (car exps))</p><empty-line /><p>
(define (rest-conjuncts exps) (cdr exps))</p><empty-line /><p>
(define (empty-disjunction? exps) (null? exps))</p><empty-line /><p>
(define (first-disjunct exps) (car exps))</p><empty-line /><p>
(define (rest-disjuncts exps) (cdr exps))</p><empty-line /><p>
(define (negated-query exps) (car exps))</p><empty-line /><p>
(define (predicate exps) (car exps))</p><empty-line /><p>
(define (args exps) (cdr exps))</p><empty-line /><empty-line /><p>

The following three procedures define the syntax of rules:</p>

<p>(define (rule? statement)</p><empty-line /><p>
  (tagged-list? statement 'rule))</p><empty-line /><p>
(define (conclusion rule) (cadr rule))</p><empty-line /><p>
(define (rule-body rule)</p><empty-line /><p>
  (if (null? (cddr rule))</p><empty-line /><p>
      '(always-true)</p><empty-line /><p>
      (caddr rule)))</p><empty-line /><empty-line /><p>

Query-driver-loop (section 4.4.4.1)
calls query-syntax-process to
transform pattern variables in the expression, which have the form
?symbol, into the internal format (? symbol).  That is to
say, a pattern such as (job ?x ?y) is actually represented
internally by the system as (job (? x) (? y)).  This increases
the efficiency of query processing, since it means that the system can
check to see if an expression is a pattern variable by checking
whether the car of the expression is the symbol ?, rather
than having to extract characters from the symbol.  The syntax
transformation is accomplished by the following
procedure:<sup>81</sup></p>

<p>(define (query-syntax-process exp)</p><empty-line /><p>
  (map-over-symbols expand-question-mark exp))</p><empty-line /><p>(define (map-over-symbols proc exp)</p><empty-line /><p>
  (cond ((pair? exp)</p><empty-line /><p>
         (cons (map-over-symbols proc (car exp))</p><empty-line /><p>
               (map-over-symbols proc (cdr exp))))</p><empty-line /><p>
        ((symbol? exp) (proc exp))</p><empty-line /><p>
        (else exp)))</p><empty-line /><p>
(define (expand-question-mark symbol)</p><empty-line /><p>
  (let ((chars (symbol-&gt;string symbol)))</p><empty-line /><p>
    (if (string=? (substring chars 0 1) "?")</p><empty-line /><p>
        (list '?</p><empty-line /><p>
              (string-&gt;symbol</p><empty-line /><p>
               (substring chars 1 (string-length chars))))</p><empty-line /><p>
        symbol)))</p><empty-line /><empty-line /><p>

Once the variables are transformed in this way, the variables in a
pattern are lists starting with ?,
and the constant symbols (which need to be recognized for
data-base indexing, section 4.4.4.5) are just the symbols.</p>

<p>(define (var? exp)</p><empty-line /><p>
  (tagged-list? exp '?))</p><empty-line /><p>
(define (constant-symbol? exp) (symbol? exp))</p><empty-line /><empty-line /><p>

Unique variables are constructed during rule application
(in section 4.4.4.4) by means of
the following procedures.  The unique identifier for a rule
application is a number, which is incremented each time a rule is
applied.</p>

<p>(define rule-counter 0)</p><empty-line /><p>
(define (new-rule-application-id)</p><empty-line /><p>
  (set! rule-counter (+ 1 rule-counter))</p><empty-line /><p>
  rule-counter)</p><empty-line /><p>
(define (make-new-variable var rule-application-id)</p><empty-line /><p>
  (cons '? (cons rule-application-id (cdr var))))</p><empty-line /><empty-line /><p>

When query-driver-loop instantiates the query to print the
answer, it converts any unbound pattern variables back to the right
form for printing, using</p>

<p>(define (contract-question-mark variable)</p><empty-line /><p>
  (string-&gt;symbol</p><empty-line /><p>
   (string-append "?"</p><empty-line /><p>
     (if (number? (cadr variable))</p><empty-line /><p>
         (string-append (symbol-&gt;string (caddr variable))</p><empty-line /><p>
                        "-"</p><empty-line /><p>
                        (number-&gt;string (cadr variable)))</p><empty-line /><p>
         (symbol-&gt;string (cadr variable))))))</p><empty-line /><empty-line /><p><strong>4.4.4.8  Frames and Bindings</strong></p>

<p>

Frames are represented as lists of bindings, which are
variable-value pairs:</p>

<p>(define (make-binding variable value)</p><empty-line /><p>
  (cons variable value))</p><empty-line /><p>
(define (binding-variable binding)</p><empty-line /><p>
  (car binding))</p><empty-line /><p>
(define (binding-value binding)</p><empty-line /><p>
  (cdr binding))</p><empty-line /><p>
(define (binding-in-frame variable frame)</p><empty-line /><p>
  (assoc variable frame))</p><empty-line /><p>
(define (extend variable value frame)</p><empty-line /><p>
  (cons (make-binding variable value) frame))</p><empty-line /><empty-line /><p>
<strong>Exercise 4.71.</strong>  Louis Reasoner wonders why the simple-query and disjoin
procedures (section 4.4.4.2) are implemented using
explicit delay operations, rather than being defined as follows:</p>

<p>(define (simple-query query-pattern frame-stream)</p><empty-line /><p>
  (stream-flatmap</p><empty-line /><p>
   (lambda (frame)</p><empty-line /><p>
     (stream-append (find-assertions query-pattern frame)</p><empty-line /><p>
                    (apply-rules query-pattern frame)))</p><empty-line /><p>
   frame-stream))</p><empty-line /><p>
(define (disjoin disjuncts frame-stream)</p><empty-line /><p>
  (if (empty-disjunction? disjuncts)</p><empty-line /><p>
      the-empty-stream</p><empty-line /><p>
      (interleave</p><empty-line /><p>
       (qeval (first-disjunct disjuncts) frame-stream)</p><empty-line /><p>
       (disjoin (rest-disjuncts disjuncts) frame-stream))))</p><empty-line /><p>
Can you give examples of queries where these simpler definitions would
lead to undesirable behavior?</p>

<p>
<strong>Exercise 4.72.</strong>  Why do disjoin and stream-flatmap interleave the
streams rather than simply append them?  Give examples that illustrate
why interleaving works better.  (Hint: Why did we use interleave in
section 3.5.3?)</p>

<p>
<strong>Exercise 4.73.</strong>  Why does flatten-stream use delay explicitly?
What would be wrong with defining it as follows:</p>

<p>(define (flatten-stream stream)</p><empty-line /><p>
  (if (stream-null? stream)</p><empty-line /><p>
      the-empty-stream</p><empty-line /><p>
      (interleave</p><empty-line /><p>
       (stream-car stream)</p><empty-line /><p>
       (flatten-stream (stream-cdr stream)))))</p><empty-line /><empty-line /><p>
<strong>Exercise 4.74.</strong>  Alyssa P. Hacker proposes to use a simpler version of stream-flatmap
in negate, lisp-value, and find-assertions.
She observes that the procedure that is mapped over the frame stream
in these cases always produces either the empty stream or a singleton
stream, so no interleaving is needed when combining these streams.</p>

<p>a. Fill in the missing expressions in Alyssa's program.</p>

<p>(define (simple-stream-flatmap proc s)</p><empty-line /><p>
  (simple-flatten (stream-map proc s)))</p><empty-line /><empty-line /><p>
(define (simple-flatten stream)</p><empty-line /><p>
  (stream-map &lt;<emphasis>??</emphasis>&gt;</p><empty-line /><p>
              (stream-filter &lt;<emphasis>??</emphasis>&gt; stream)))</p><empty-line /><empty-line /><p>b. Does the query system's behavior change if we change it in this way?</p>

<p>
<strong>Exercise 4.75.</strong>  Implement for the query language a new special form called unique.  Unique should succeed if there is precisely one item
in the data base satisfying a specified query.  For example,</p>

<p>(unique (job ?x (computer wizard)))</p><empty-line /><p>
should print the one-item stream</p>

<p>(unique (job (Bitdiddle Ben) (computer wizard)))</p><empty-line /><p>
since Ben is the only computer wizard, and</p>

<p>(unique (job ?x (computer programmer)))</p><empty-line /><p>
should print the empty stream, since there is more than one computer
programmer.  Moreover,</p>

<p>(and (job ?x ?j) (unique (job ?anyone ?j)))</p><empty-line /><p>
should list all the jobs that are filled by only one person, and the
people who fill them.</p>

<p>

There are two parts to implementing unique.  The first is to
write a procedure that handles this special form, and the second is to make
qeval dispatch to that procedure.  The second part is trivial,
since qeval does its dispatching in a data-directed way.  If
your procedure is called uniquely-asserted, all you need to do
is</p>

<p>(put 'unique 'qeval uniquely-asserted)</p><empty-line /><p>
and qeval will dispatch to this procedure for every query whose
type (car) is the symbol unique.</p>

<p>

The real problem is to write the procedure uniquely-asserted.
This should take as input the contents (cdr) of the unique query, together with a stream of frames.  For each frame in
the stream, it should use qeval to find the stream of all
extensions to the frame that satisfy the given query.  Any stream that
does not have exactly one item in it should be eliminated.  The
remaining streams should be passed back to be accumulated into one big
stream that is the result of the unique query.  This is similar
to the implementation of the not special form.</p>

<p>

Test your implementation by forming a query that lists all people who
supervise precisely one person.</p>

<p>
<strong>Exercise 4.76.</strong>  Our implementation of and as a series combination of queries
(figure 4.5) is elegant, but it is inefficient because in
processing the second query of the and we must scan the data
base for each frame produced by the first query.  If the data base has
<emphasis>N</emphasis> elements, and a typical query produces a number of output frames
proportional to <emphasis>N</emphasis> (say <emphasis>N</emphasis>/<emphasis>k</emphasis>), then scanning the data base for each
frame produced by the first query will require <emphasis>N</emphasis><sup>2</sup>/<emphasis>k</emphasis> calls to the
pattern matcher.  Another approach would be to process the two clauses
of the and separately, then look for all pairs of output frames
that are compatible.  If each query produces <emphasis>N</emphasis>/<emphasis>k</emphasis> output frames, then
this means that we must perform <emphasis>N</emphasis><sup>2</sup>/<emphasis>k</emphasis><sup>2</sup> compatibility checks -- a
factor of <emphasis>k</emphasis> fewer than the number of matches required in our current
method.</p>

<p>

Devise an implementation of and that uses this strategy.  You
must implement a procedure that takes two frames as inputs, checks
whether the bindings in the frames are compatible, and, if so,
produces a frame that merges the two sets of bindings.  This operation
is similar to unification.</p>

<p>
<strong>Exercise 4.77.</strong>  In section 4.4.3 we saw that not and lisp-value can cause the query language to give "wrong" answers if
these filtering operations are applied to frames in which variables
are unbound.  Devise a way to fix this shortcoming.  One idea is to
perform the filtering in a "delayed" manner by appending to the
frame a "promise" to filter that is fulfilled only when enough
variables have been bound to make the operation possible.  We could
wait to perform filtering until all other operations have been
performed.  However, for efficiency's sake, we would like to perform
filtering as soon as possible so as to cut down on the number of
intermediate frames generated.</p>

<p>
<strong>Exercise 4.78.</strong>  Redesign the query language as a nondeterministic program to be
implemented using the evaluator of
section 4.3, rather than as a stream
process.  In this approach, each query will produce a single answer
(rather than the stream of all answers) and the user can type try-again to see more answers.  You should find that much of the
mechanism we built in this section is subsumed by nondeterministic
search and backtracking.  You will probably also find, however, that
your new query language has subtle differences in behavior from the
one implemented here.  Can you find examples that illustrate this
difference?</p>

<p>
<strong>Exercise 4.79.</strong>  When we implemented the Lisp evaluator in section 4.1,
we saw how to use local environments to avoid name conflicts between
the parameters of procedures.  For example, in evaluating</p>

<p>(define (square x)</p><empty-line /><p>
  (* x x))</p><empty-line /><p>
(define (sum-of-squares x y)</p><empty-line /><p>
  (+ (square x) (square y)))</p><empty-line /><p>
(sum-of-squares 3 4)</p><empty-line /><p>
there is no confusion between the x in square and the x
in sum-of-squares, because we evaluate the body of each
procedure in an environment that is specially constructed to contain
bindings for the local variables.  In the query system, we used a
different strategy to avoid name conflicts in applying rules.  Each
time we apply a rule we rename the variables with new names that are
guaranteed to be unique.  The analogous strategy for the Lisp
evaluator would be to do away with local environments and simply
rename the variables in the body of a procedure each time we apply the
procedure.</p>

<p>

Implement for the query language a rule-application method that uses
environments rather than renaming.  See if you can build on your
environment structure to create constructs in the query language for
dealing with large systems, such as the rule analog of
block-structured procedures.  Can you relate any of this to the
problem of making deductions in a context (e.g., "If I supposed that
<emphasis>P</emphasis> were true, then I would be able to deduce <emphasis>A</emphasis> and <emphasis>B</emphasis>.") as a
method of problem solving?  (This problem is open-ended.  A good
answer is probably worth a Ph.D.)</p><empty-line /><empty-line /><empty-line /><p><sup>58</sup> Logic programming has grown out of a long
history of research in automatic theorem proving.  Early
theorem-proving programs could accomplish very little, because they
exhaustively searched the space of possible proofs.  The major
breakthrough that made such a search plausible was the discovery in
the early 1960s of the <emphasis>unification algorithm</emphasis> and the <emphasis>resolution principle</emphasis> (Robinson 1965).  Resolution was used, for
example, by Green and Raphael (1968) (see also Green 1969) as the
basis for a deductive question-answering system.  During most of this
period, researchers concentrated on algorithms that are guaranteed to
find a proof if one exists.  Such algorithms were difficult to control
and to direct toward a proof.  Hewitt (1969) recognized the
possibility of merging the control structure of a programming language
with the operations of a logic-manipulation system, leading to the
work in automatic search mentioned in section 4.3.1
(footnote 47).  At the same time that this was being done,
Colmerauer, in Marseille, was developing rule-based systems for
manipulating natural language (see Colmerauer et al. 1973).  He
invented a programming language called Prolog for representing those
rules.  Kowalski (1973; 1979), in Edinburgh, recognized that execution
of a Prolog program could be interpreted as proving theorems (using a
proof technique called linear Horn-clause resolution).  The merging of
the last two strands led to the logic-programming movement.  Thus, in
assigning credit for the development of logic programming, the French
can point to Prolog's genesis at the University of Marseille, while
the British can highlight the work at the University of Edinburgh.
According to people at MIT, logic programming was developed by these
groups in an attempt to figure out what Hewitt was talking about in
his brilliant but impenetrable Ph.D. thesis.  For a history of logic
programming, see Robinson 1983.</p>

<p><sup>59</sup> To
see the correspondence between the rules and the procedure, let x in the procedure (where x is nonempty) correspond to (cons u v) in the rule.  Then z in the rule corresponds to the
append of (cdr x) and y.</p>

<p><sup>60</sup> This certainly does not
relieve the user of the entire problem of how to compute the answer.
There are many different mathematically equivalent sets of rules for
formulating the append relation, only some of which can be
turned into effective devices for computing in any direction.  In
addition, sometimes "what is" information gives no clue "how to"
compute an answer.  For example, consider the problem of computing the
<emphasis>y</emphasis> such that <emphasis>y</emphasis><sup>2</sup>  =  <emphasis>x</emphasis>.</p>

<p><sup>61</sup> Interest in logic programming peaked
during the early 80s when the Japanese government began an ambitious
project aimed at building superfast computers optimized to run logic
programming languages.  The speed of such computers was to be measured
in LIPS (Logical Inferences Per Second) rather than the usual FLOPS
(FLoating-point Operations Per Second).  Although the project
succeeded in developing hardware and software as originally planned,
the international computer industry moved in a different direction.
See Feigenbaum and Shrobe 1993 for an overview evaluation of the
Japanese project.  The logic programming community has also moved on
to consider relational programming based on techniques other than
simple pattern matching, such as the ability to deal with numerical
constraints such as the ones illustrated in the constraint-propagation
system of section 3.3.5.</p>

<p><sup>62</sup> This uses the dotted-tail notation introduced in
exercise 2.20.</p>

<p><sup>63</sup> Actually, this description of not is valid only for simple cases.  The real behavior of not
is more complex.  We will examine not's peculiarities in
sections 4.4.2 and 4.4.3.</p>

<p><sup>64</sup> Lisp-value should be used only to perform an operation not
provided in the query language.  In particular, it should not
be used to test equality (since that is what the matching in the
query language is designed to do) or inequality (since that can
be done with the same rule shown below).</p>

<p><sup>65</sup> Notice that we do not need same in order to make two things be
the same: We just use the same pattern variable for each -- in effect,
we have one thing instead of two things in the first place.  For
example, see ?town in the lives-near rule and ?middle-manager in the wheel rule below.
Same is useful when we want to force two things to be
different, such as ?person-1 and ?person-2 in the lives-near rule.  Although using the same pattern variable in two
parts of a query forces the same value to appear in both places, using
different pattern variables does not force different values to appear.
(The values assigned to different pattern variables may be the same or
different.)</p>

<p><sup>66</sup> We will also allow rules without bodies, as in same, and we will interpret such a rule to mean that the rule
conclusion is satisfied by any values of the variables.</p>

<p><sup>67</sup> Because matching is generally very expensive, we would
like to avoid applying the full matcher to every element of the data
base.  This is usually arranged by breaking up the process into a
fast, coarse match and the final match.  The coarse match filters the
data base to produce a small set of candidates for the final match.
With care, we can arrange our data base so that some of the work of
coarse matching can be done when the data base is constructed rather
then when we want to select the candidates.  This is called <emphasis>indexing</emphasis> the data base.  There is a vast technology built around
data-base-indexing schemes.  Our implementation, described in
section 4.4.4, contains a
simple-minded form of such an optimization.</p>

<p><sup>68</sup> But this kind of exponential explosion is not common in and
queries because the added conditions tend to reduce rather than expand
the number of frames produced.</p>

<p><sup>69</sup> There is a large literature on data-base-management
systems that is concerned with how to handle complex queries
efficiently.</p>

<p><sup>70</sup> There is a subtle difference between this filter
implementation of not and the usual meaning of not in
mathematical logic.  See section 4.4.3.</p>

<p><sup>71</sup> In one-sided pattern matching, all the equations that
contain pattern variables are explicit and already solved for the
unknown (the pattern variable).</p>

<p><sup>72</sup> Another way to think of unification is that it generates the most
general pattern that is a specialization of the two input patterns.
That is, the unification of (?x a) and ((b ?y) ?z) is ((b ?y) a), and the unification of (?x a ?y) and (?y ?z
a), discussed above, is (a a a).
For our implementation, it is more convenient to think of the result
of unification as a frame rather than a pattern.</p>

<p><sup>73</sup> Since unification is a
generalization of matching, we could simplify the system by using the
unifier to produce both streams.  Treating the easy case with the
simple matcher, however, illustrates how matching (as opposed to
full-blown unification) can be useful in its own right.</p>

<p><sup>74</sup> The reason we use streams (rather than lists) of frames is that the
recursive application of rules can generate
infinite numbers of values that satisfy a query.  The delayed
evaluation embodied in streams is crucial here: The system will print
responses one by one as they are generated, regardless of whether
there are a finite or infinite number of responses.</p>

<p><sup>75</sup> That a particular method of inference is
legitimate is not a trivial assertion.  One must prove that if one
starts with true premises, only true conclusions can be derived.  The
method of inference represented by rule applications is <emphasis>modus
ponens</emphasis>, the familiar method of inference that says that if <emphasis>A</emphasis> is
true and <emphasis>A implies B</emphasis> is true, then we may conclude that <emphasis>B</emphasis>
is true.</p>

<p><sup>76</sup> We must qualify this statement by
agreeing that, in speaking of the "inference" accomplished by a
logic program, we assume that the computation terminates.
Unfortunately, even this qualified statement is false for our
implementation of the query language (and also false for programs in
Prolog and most other current logic programming languages) because of
our use of not and lisp-value.  As we will describe below,
the not implemented in the query language is not always
consistent with the not of mathematical logic, and lisp-value introduces additional complications.  We could implement a
language consistent with mathematical logic by simply removing not and lisp-value from the language and agreeing to write
programs using only simple queries, and, and or.  However,
this would greatly restrict the expressive power of the language.  One
of the major concerns of research in logic programming is to find ways
to achieve more consistency with mathematical logic without unduly
sacrificing expressive power.</p>

<p><sup>77</sup> This is not a problem of the logic but one of the
procedural interpretation of the logic provided by our interpreter.
We could write an interpreter that would not fall into a loop here.
For example, we could enumerate all the proofs derivable from our
assertions and our rules in a breadth-first rather than a depth-first
order.  However, such a system makes it more difficult to take
advantage of the order of deductions in our programs.  One attempt to
build sophisticated control into such a program is described in
deKleer et al. 1977.  Another technique, which does not lead to such
serious control problems, is to put in special knowledge, such as
detectors for particular kinds of loops
(exercise 4.67).  However, there can be no
general scheme for reliably preventing a system from going down
infinite paths in performing deductions.  Imagine a diabolical rule of
the form "To show <emphasis>P</emphasis>(<emphasis>x</emphasis>) is true, show that <emphasis>P</emphasis>(<emphasis>f</emphasis>(<emphasis>x</emphasis>)) is true", for
some suitably chosen function <emphasis>f</emphasis>.</p>

<p><sup>78</sup> Consider the query (not (baseball-fan (Bitdiddle Ben))).  The system finds that (baseball-fan (Bitdiddle Ben)) is not in the data base, so the empty
frame does not satisfy the pattern and is not filtered out of the
initial stream of frames.  The result of the query is thus the empty
frame, which is used to instantiate the input query to produce (not (baseball-fan (Bitdiddle Ben))).</p>

<p><sup>79</sup> A discussion and justification of this
treatment of not can be found in the article by Clark (1978).</p>

<p><sup>80</sup> In general, unifying ?y with an expression involving
?y would require our being able to find a fixed point of the
equation ?y  =  &lt;<emphasis>expression involving ?y</emphasis>&gt;.  It is
sometimes possible to syntactically form an expression that appears to
be the solution.  For example, ?y  =  (f ?y) seems to have
the fixed point (f (f (f ... ))), which we can produce by
beginning with the expression (f ?y) and repeatedly substituting
(f ?y) for ?y.  Unfortunately, not every such equation has
a meaningful fixed point.  The issues that arise here are similar to
the issues of manipulating infinite series in mathematics.  For
example, we know that 2 is the solution to the equation <emphasis>y</emphasis>  =  1  +  <emphasis>y</emphasis>/2.
Beginning with the expression 1  +  <emphasis>y</emphasis>/2 and repeatedly substituting 1
 +  <emphasis>y</emphasis>/2 for <emphasis>y</emphasis> gives</p>

<p><image xlink:href="#_200.jpg" /></p>

<p>
which leads to</p>

<p><image xlink:href="#_201.jpg" /></p>

<p>
However, if we try the same manipulation beginning with the
observation that  - 1 is the solution to the equation <emphasis>y</emphasis>  =  1  +  2<emphasis>y</emphasis>, we
obtain</p>

<p><image xlink:href="#_202.jpg" /></p>

<p>
which leads to</p>

<p><image xlink:href="#_203.jpg" /></p>

<p>
Although the formal manipulations used in deriving these two equations
are identical, the first result is a valid assertion about infinite
series but the second is not.  Similarly, for our unification results,
reasoning with an arbitrary syntactically constructed expression may
lead to errors.</p>

<p><sup>81</sup> Most Lisp systems give the user the ability to
modify the ordinary read procedure to perform such
transformations by defining <emphasis>reader macro characters</emphasis>.  Quoted
expressions are already handled in this way: The reader automatically
translates 'expression into (quote expression) before the
evaluator sees it.  We could arrange for ?expression to be
transformed into (? expression) in the same way; however, for
the sake of clarity we have included the transformation procedure here
explicitly.</p>

<p>

Expand-question-mark and contract-question-mark use
several procedures with string in their names.
These are Scheme primitives.</p>


</section>

<section>


<p><strong>
</strong></p>

<p><strong>Chapter 5</strong></p>

<p>
Computing with Register Machines</p><empty-line /><p>

My aim is to show that the heavenly machine is not a kind of divine,
live being, but a kind of clockwork (and he who believes that a clock
has soul attributes the maker's glory to the work), insofar as nearly
all the manifold motions are caused by a most simple and material
force, just as all motions of the clock are caused by a single weight.</p>

<p>

Johannes Kepler (letter to Herwart von Hohenburg, 1605)</p><empty-line /><p>


We began this book by studying processes and by describing processes
in terms of procedures written in Lisp.  To explain the meanings of
these procedures, we used a succession of models of evaluation: the
substitution model of chapter 1, the environment model of chapter 3,
and the metacircular evaluator of chapter 4.  Our examination of the
metacircular evaluator, in particular, dispelled much of the mystery
of how Lisp-like languages are interpreted.
But even the metacircular evaluator leaves important questions
unanswered, because it fails to elucidate the mechanisms of control in
a Lisp system.  For instance, the evaluator does not explain how the
evaluation of a subexpression manages to return a value to the
expression that uses this value, nor does the evaluator explain how
some recursive procedures generate iterative processes (that is, are evaluated
using constant space) whereas other recursive procedures generate recursive
processes.  These questions remain unanswered because the metacircular
evaluator is itself a Lisp program and hence inherits the control
structure of the underlying Lisp system.  In order to provide a more
complete description of the control structure of the Lisp evaluator,
we must work at a more primitive level than Lisp itself.</p>

<p>

In this chapter we will describe processes in terms of the step-by-step
operation of a traditional computer.  Such a computer, or <emphasis>register
machine</emphasis>, sequentially executes <emphasis>instructions</emphasis> that
manipulate the contents of a fixed set of storage elements called <emphasis>registers</emphasis>.  A typical register-machine instruction applies a
primitive operation to the contents of some registers and assigns the
result to another register.  Our descriptions of processes executed by
register machines will look very much like "machine-language"
programs for traditional computers.  However, instead of focusing on
the machine language of any particular computer, we will examine
several Lisp procedures and design a specific register machine to
execute each procedure.  Thus, we will approach our task from the
perspective of a hardware architect rather than that of a
machine-language computer programmer.  In designing register machines,
we will develop mechanisms for implementing important programming
constructs such as recursion.  We will also present a language for
describing designs for register machines.  In
section 5.2 we will
implement a Lisp program that
uses these descriptions to simulate the machines we design.</p>

<p>

Most of the primitive operations of our register machines are very
simple.  For example, an operation might add the numbers fetched from
two registers, producing a result to be stored into a third register.
Such an operation can be performed by easily described hardware.  In
order to deal with list structure, however, we will also use the
memory operations car, cdr, and cons, which require
an elaborate storage-allocation mechanism.  In
section 5.3 we study their implementation in
terms of more elementary operations.</p>

<p>

In section 5.4, after we have accumulated experience
formulating simple procedures as register machines, we will design a
machine that carries out the algorithm described by the metacircular
evaluator of section 4.1.  This will fill in the gap in
our understanding of how Scheme expressions are interpreted, by
providing an explicit model for the mechanisms of control in the
evaluator.
In section 5.5 we will study a simple compiler that
translates Scheme programs into sequences of instructions that can be
executed directly with the registers and operations of the evaluator
register machine.</p>


</section>

<section>


<p><strong>5.1  Designing Register Machines</strong></p>

<p>




To design a register machine, we must design its <emphasis>data paths</emphasis>
(registers and operations) and the <emphasis>controller</emphasis> that sequences
these operations.  To illustrate the design of a simple register
machine, let us examine Euclid's Algorithm, which is used to compute
the greatest common divisor (GCD) of two integers.  As we saw in
section 1.2.5, Euclid's Algorithm can be carried out by an iterative
process, as specified by the following procedure:</p>

<p>(define (gcd a b)</p><empty-line /><p>
  (if (= b 0)</p><empty-line /><p>
      a</p><empty-line /><p>
      (gcd b (remainder a b))))</p><empty-line /><empty-line /><p>

A machine to carry out this algorithm must keep track of two numbers,
<emphasis>a</emphasis> and <emphasis>b</emphasis>, so let us assume that these numbers are stored in two
registers with those names.  The basic operations required are testing
whether the contents of register b is zero and computing the
remainder of the contents of register a divided by the contents
of register b.  The remainder operation is a complex process,
but assume for the moment that we have a primitive device that
computes remainders.  On each cycle of the GCD algorithm, the contents
of register a must be replaced by the contents of register b, and the contents of b must be replaced by the remainder of
the old contents of a divided by the old contents of b.
It would be convenient if these replacements could be done
simultaneously, but in our model of register machines we will assume
that only one register can be assigned a new value at each step.  To
accomplish the replacements, our machine will use a third
"temporary" register, which we call t.  (First the remainder
will be placed in t, then the contents of b will be placed
in a, and finally the remainder stored in t will be placed
in b.)</p>

<p>

We can illustrate the registers and operations required for this
machine by using the data-path diagram shown in
figure 5.1.  In this
diagram, the registers (a, b, and t) are represented
by rectangles.  Each way to assign a value to a register is
indicated by an arrow with an X behind the head, pointing from
the source of data to the register.  We can think of the X as a
button that, when pushed, allows the value at the source to "flow"
into the designated register.  The label next to each button is the
name we will use to refer to the button.  The names are arbitrary, and
can be chosen to have mnemonic value (for example, a&lt;-b denotes
pushing the button that assigns the contents of register b to
register a).  The source of data for a register can be another
register (as in the a&lt;-b assignment), an operation result (as in
the t&lt;-r assignment), or a constant (a built-in value that
cannot be changed, represented in a data-path diagram by a triangle
containing the constant).</p>

<p>

An operation that computes a value from constants and the contents
of registers is represented in a data-path diagram by a trapezoid
containing a name for the operation.  For example, the box marked rem in figure 5.1 represents an
operation that computes the remainder of the contents of the
registers a and b to which it is attached.  Arrows
(without buttons) point from the input registers and constants to the
box, and arrows connect the operation's output value to registers.
A test is represented by a circle containing a name for the test.  For
example, our GCD machine has an operation that
tests whether the contents of register
b is zero.  A test also has arrows from its input
registers and constants, but it has no output
arrows; its value is used by the controller rather than by the data
paths.  Overall, the data-path diagram shows the registers and
operations that are required for the machine and how they must be
connected.  If we view the arrows as wires and the X buttons as
switches, the data-path diagram is very like the wiring diagram for a
machine that could be constructed from electrical components.</p><empty-line /><p><image xlink:href="#_204.jpg" /></p>

<p><strong>Figure 5.1:</strong>  Data paths for a GCD machine.</p>

<p>

In order for the data paths to actually compute GCDs, the buttons must
be pushed in the correct sequence.  We will describe this sequence in
terms of a controller diagram, as illustrated in
figure 5.2.  The elements of the controller
diagram indicate how the
data-path components should be operated.  The rectangular boxes in the
controller diagram identify data-path buttons to be pushed, and the
arrows describe the sequencing from one step to the next.  The diamond
in the diagram represents a decision.  One of the two sequencing
arrows will be followed, depending on the value of the data-path test
identified in the diamond.  We can interpret the controller in terms
of a physical analogy: Think of the diagram as a maze in which a
marble is rolling.  When the marble rolls into a box, it pushes the
data-path button that is named by the box.  When the marble rolls into
a decision node (such as the test for b   = 0), it leaves the
node on the path determined by the result of the indicated test.
Taken together, the data paths and the controller completely describe
a machine for computing GCDs.  We start the controller (the rolling
marble) at the place marked start, after placing numbers in
registers a and b.  When the controller reaches done, we will find the value of the GCD in register a.</p>

<p>
<image xlink:href="#_205.jpg" /></p>

<p><strong>Figure 5.2:</strong>  Controller for a GCD machine.</p>

<p>
<strong>Exercise 5.1.</strong>  Design a register machine to compute factorials using the iterative
algorithm specified by the following procedure.  Draw data-path and
controller diagrams for this machine.</p>

<p>(define (factorial n)</p><empty-line /><p>
  (define (iter product counter)</p><empty-line /><p>
    (if (&gt; counter n)</p><empty-line /><p>
        product</p><empty-line /><p>
        (iter (* counter product)</p><empty-line /><p>
              (+ counter 1))))</p><empty-line /><p>
  (iter 1 1))</p><empty-line /><empty-line /><p><strong>5.1.1  A Language for Describing Register Machines</strong></p>

<p>



Data-path and controller diagrams are adequate for representing simple
machines such as GCD, but they are unwieldy for describing large
machines such as a Lisp interpreter.  To make it possible to deal with
complex machines, we will create a language that presents, in textual
form, all the information given by the data-path and controller
diagrams.  We will start with a notation that directly mirrors the diagrams.</p>

<p>

We define the data paths of a machine by describing the registers and
the operations.  To describe a register, we give it a name
and specify the buttons that control assignment to it.  We give each
of these buttons a name and specify the source of the data that enters
the register under the button's control.  (The source is a register, a
constant, or an operation.)
To describe an operation, we give
it a name and specify its inputs (registers or constants).</p>

<p>

We define the controller of a machine as a sequence of <emphasis>instructions</emphasis> together with <emphasis>labels</emphasis> that identify <emphasis>entry
points</emphasis> in the sequence. An instruction is one of the following:</p>

<p>The name of a data-path button to push to assign a value to
a register.  (This corresponds to a box in the controller diagram.)</p>

<p>A test instruction, that performs a specified test.</p>

<p>A conditional branch (branch instruction) to a
location indicated by a controller label, based on the result of the
previous test.  (The test and branch together correspond to a diamond
in the controller diagram.)  If the test is false, the controller
should continue with the next instruction in the sequence.  Otherwise,
the controller should continue with the instruction after the label.</p>

<p>An unconditional branch (goto instruction) naming a
controller label at which to continue execution.</p>

<p>
The machine starts at the beginning of the controller instruction
sequence and stops when execution reaches the end of the sequence.
Except when a branch changes the flow of control, instructions are
executed in the order in which they are listed.</p><empty-line /><p>(data-paths</p><empty-line /><p>
 (registers</p><empty-line /><p>
  ((name a)</p><empty-line /><p>
   (buttons ((name a&lt;-b) (source (register b)))))</p><empty-line /><p>
  ((name b)</p><empty-line /><p>
   (buttons ((name b&lt;-t) (source (register t)))))</p><empty-line /><p>
  ((name t)</p><empty-line /><p>
   (buttons ((name t&lt;-r) (source (operation rem))))))</p><empty-line /><empty-line /><p>
 (operations</p><empty-line /><p>
  ((name rem)</p><empty-line /><p>
   (inputs (register a) (register b)))</p><empty-line /><p>
  ((name =)</p><empty-line /><p>
   (inputs (register b) (constant 0)))))</p><empty-line /><empty-line /><p>
(controller</p><empty-line /><p>
 test-b                           <emphasis>; label</emphasis></p><empty-line /><p>
   (test =)                       <emphasis>; test</emphasis></p><empty-line /><p>
   (branch (label gcd-done))      <emphasis>; conditional branch</emphasis></p><empty-line /><p>
   (t&lt;-r)                         <emphasis>; button push</emphasis></p><empty-line /><p>
   (a&lt;-b)                         <emphasis>; button push</emphasis></p><empty-line /><p>
   (b&lt;-t)                         <emphasis>; button push</emphasis></p><empty-line /><p>
   (goto (label test-b))          <emphasis>; unconditional branch</emphasis></p><empty-line /><p>
 gcd-done)                        <emphasis>; label</emphasis></p><empty-line /><empty-line /><p><strong>Figure 5.3:</strong>  A specification of the GCD machine.</p>

<p>

Figure 5.3 shows the GCD machine described in
this way.  This example only hints at the generality of these
descriptions, since the GCD machine is a very simple case: Each
register has only one button, and each button and test is used only
once in the controller.</p>

<p>

Unfortunately, it is difficult to read such a description.  In order
to understand the controller instructions we must constantly refer
back to the definitions of the button names and the operation names,
and to understand what the buttons do we may have to refer to the
definitions of the operation names.  We will thus transform our
notation to combine the information from the data-path and controller
descriptions so that we see it all together.</p>

<p>

To obtain this form of description, we will replace the arbitrary
button and operation names by the definitions of their behavior.  That
is, instead of saying (in the controller) "Push button t&lt;-r"
and separately saying (in the data paths) "Button t&lt;-r assigns
the value of the rem operation to register t" and "The
rem operation's inputs are the contents of registers
a and b", we will say (in the controller) "Push the
button that assigns to register t the value of the rem
operation on the contents of registers a and b."
Similarly, instead of saying (in the controller) "Perform the = test" and separately saying (in the data paths) "The = test operates on the contents of register b and the
constant 0", we will say "Perform the = test on the
contents of register b and the constant 0."  We will omit the
data-path description, leaving only the controller sequence.  Thus,
the GCD machine is described as follows:</p>

<p>(controller</p><empty-line /><p>
 test-b</p><empty-line /><p>
   (test (op =) (reg b) (const 0))</p><empty-line /><p>
   (branch (label gcd-done))</p><empty-line /><p>
   (assign t (op rem) (reg a) (reg b))</p><empty-line /><p>
   (assign a (reg b))</p><empty-line /><p>
   (assign b (reg t))</p><empty-line /><p>
   (goto (label test-b))</p><empty-line /><p>
 gcd-done)</p><empty-line /><empty-line /><p>

This form of description is easier to read than the kind illustrated
in figure 5.3, but it also has disadvantages:</p>

<p>It is more verbose for large machines,
because complete descriptions of the data-path elements are repeated
whenever the elements are mentioned in the controller instruction
sequence.  (This is not a problem in the GCD example, because each
operation and button is used only once.)  Moreover, repeating the
data-path descriptions obscures the actual data-path structure of the
machine; it is not obvious for a large machine how many registers,
operations, and buttons there are and how they are interconnected.</p>

<p>Because the controller instructions in a machine definition
look like Lisp expressions, it is easy to forget that they are
not arbitrary Lisp expressions.  They can notate only legal machine
operations.  For example, operations can operate directly only on
constants and the contents of registers, not on the results of other
operations.</p>

<p>
In spite of these disadvantages, we will use this register-machine
language throughout this chapter, because we will be more concerned with
understanding controllers than with understanding the elements and
connections in data paths.  We should keep in mind,
however, that data-path design is crucial in designing real machines.</p>

<p>
<strong>Exercise 5.2.</strong>  Use the register-machine language to describe
the iterative factorial machine of exercise 5.1.</p>

<p><strong>Actions</strong></p>

<p>


Let us modify the GCD machine so that we can type in the numbers
whose GCD we want and get the answer printed at our terminal.  We will
not discuss how to make a machine that can read and print, but will
assume (as we do when we use read and display in Scheme) that
they are available as primitive operations.<sup>1</sup></p>

<p>

Read is like the operations we have been using in that it
produces a value that can be stored in a register.  But read
does not take inputs from any registers; its value depends on
something that happens outside the parts of the machine we are
designing.  We will allow our machine's operations to have such
behavior, and thus will draw and notate the use of read just as
we do any other operation that computes a value.</p>

<p>

Print, on the other hand, differs from the operations we have
been using in a fundamental way: It does not produce an output value
to be stored in a register.  Though it has an effect, this effect is
not on a part of the machine we are designing.  We will refer to this
kind of operation as an <emphasis>action</emphasis>.  We will represent an action in
a data-path diagram just as we represent an operation that computes a
value -- as a trapezoid that contains the name of the action.
Arrows point to the action box from any inputs (registers or
constants).  We also associate a button with the action.  Pushing the
button makes the action happen.  To make a controller push an action
button we use a new kind of instruction called perform.  Thus,
the action of printing the contents of register a is represented
in a controller sequence by the instruction</p>

<p>(perform (op print) (reg a))</p><empty-line /><empty-line /><p>

Figure 5.4 shows the data paths and controller for
the new GCD machine.  Instead of having the machine stop after
printing the answer, we have made it start over, so that it repeatedly
reads a pair of numbers, computes their GCD, and prints the result.
This structure is like the driver loops we used in the interpreters of
chapter 4.</p>

<p><image xlink:href="#_206.jpg" /></p>

<p> (controller</p><empty-line /><p>
  gcd-loop</p><empty-line /><p>
    (assign a (op read))</p><empty-line /><p>
    (assign b (op read))</p><empty-line /><p>
  test-b</p><empty-line /><p>
    (test (op =) (reg b) (const 0))</p><empty-line /><p>
    (branch (label gcd-done))</p><empty-line /><p>
    (assign t (op rem) (reg a) (reg b))</p><empty-line /><p>
    (assign a (reg b))</p><empty-line /><p>
    (assign b (reg t))</p><empty-line /><p>
    (goto (label test-b))</p><empty-line /><p>
  gcd-done</p><empty-line /><p>
    (perform (op print) (reg a))</p><empty-line /><p>
    (goto (label gcd-loop)))</p><empty-line /><empty-line /><p><strong>Figure 5.4:</strong>  A GCD machine that reads inputs and prints results.</p>

<p><strong>5.1.2  Abstraction in Machine Design</strong></p>

<p>


We will often define a machine to include "primitive" operations that are
actually very complex.  For example, in sections 5.4 and
5.5 we will treat Scheme's environment
manipulations as primitive.  Such abstraction is valuable because it
allows us to ignore the details of parts of a machine so that we can
concentrate on other aspects of the design.  The fact that we have
swept a lot of complexity under the rug, however, does not mean that a
machine design is unrealistic.  We can always replace the complex
"primitives" by simpler primitive operations.</p>

<p>

Consider the GCD machine. The machine has an instruction that computes
the remainder of the contents of registers a and b and
assigns the result to register t.  If we want to construct the
GCD machine without using a primitive remainder operation,
we must specify how to compute remainders in terms of simpler
operations, such as subtraction.  Indeed, we can write a Scheme
procedure that finds remainders in this way:</p>

<p>(define (remainder n d)</p><empty-line /><p>
  (if (&lt; n d)</p><empty-line /><p>
      n</p><empty-line /><p>
      (remainder (- n d) d)))</p><empty-line /><p>
We can thus replace the remainder operation in the GCD machine's
data paths with a subtraction operation and a comparison test.
Figure 5.5 shows the data paths and controller
for the elaborated machine.
The instruction</p>

<p><image xlink:href="#_207.jpg" /></p>

<p><strong>Figure 5.5:</strong>  Data paths and controller for the elaborated GCD  machine.</p><empty-line /><p>(assign t (op rem) (reg a) (reg b))</p><empty-line /><p>
in the GCD controller definition is replaced by a sequence of
instructions that contains a loop, as shown in
figure 5.6.</p><empty-line /><p>(controller</p><empty-line /><p>
 test-b</p><empty-line /><p>
   (test (op =) (reg b) (const 0))</p><empty-line /><p>
   (branch (label gcd-done))</p><empty-line /><p>
   (assign t (reg a))</p><empty-line /><p>
 rem-loop</p><empty-line /><p>
   (test (op &lt;) (reg t) (reg b))</p><empty-line /><p>
   (branch (label rem-done))</p><empty-line /><p>
   (assign t (op -) (reg t) (reg b))</p><empty-line /><p>
   (goto (label rem-loop))</p><empty-line /><p>
 rem-done</p><empty-line /><p>
   (assign a (reg b))</p><empty-line /><p>
   (assign b (reg t))</p><empty-line /><p>
   (goto (label test-b))</p><empty-line /><p>
 gcd-done)</p><empty-line /><empty-line /><p><strong>Figure 5.6:</strong>  Controller instruction sequence for the GCD machine in
figure 5.5.</p>

<p>
<strong>Exercise 5.3.</strong>  Design a machine to compute square roots using Newton's method, as
described in section 1.1.7:</p>

<p>(define (sqrt x)</p><empty-line /><p>
  (define (good-enough? guess)</p><empty-line /><p>
    (&lt; (abs (- (square guess) x)) 0.001))</p><empty-line /><p>
  (define (improve guess)</p><empty-line /><p>
    (average guess (/ x guess)))</p><empty-line /><p>
  (define (sqrt-iter guess)</p><empty-line /><p>
    (if (good-enough? guess)</p><empty-line /><p>
        guess</p><empty-line /><p>
        (sqrt-iter (improve guess))))</p><empty-line /><p>
  (sqrt-iter 1.0))</p><empty-line /><p>
Begin by assuming that good-enough? and improve operations
are available as primitives.  Then show how to expand these in terms
of arithmetic operations.  Describe each version of the sqrt
machine design by drawing a data-path diagram and writing a controller
definition in the register-machine language.</p>

<p><strong>5.1.3  Subroutines</strong></p>

<p>



When designing a machine to perform a computation, we would often
prefer to arrange for components to be shared by different parts of
the computation rather than duplicate the components.  Consider a
machine that includes two GCD computations -- one that finds the GCD of
the contents of registers a and b and one that finds the
GCD of the contents of registers c and d.  We might start
by assuming we have a primitive gcd operation, then expand the
two instances of gcd in terms of more primitive operations.
Figure 5.7 shows just the GCD portions of the
resulting machine's data paths, without showing how they connect to
the rest of the machine.  The figure also shows the corresponding
portions of the machine's controller sequence.</p>

<p><image xlink:href="#_208.jpg" /></p>

<p>gcd-1</p><empty-line /><p>
 (test (op =) (reg b) (const 0))</p><empty-line /><p>
 (branch (label after-gcd-1))</p><empty-line /><p>
 (assign t (op rem) (reg a) (reg b))</p><empty-line /><p>
 (assign a (reg b))</p><empty-line /><p>
 (assign b (reg t))</p><empty-line /><p>
 (goto (label gcd-1))</p><empty-line /><p>
after-gcd-1</p><empty-line /><p>
   <image xlink:href="#_5.jpg" /></p><empty-line /><p>
gcd-2</p><empty-line /><p>
 (test (op =) (reg d) (const 0))</p><empty-line /><p>
 (branch (label after-gcd-2))</p><empty-line /><p>
 (assign s (op rem) (reg c) (reg d))</p><empty-line /><p>
 (assign c (reg d))</p><empty-line /><p>
 (assign d (reg s))</p><empty-line /><p>
 (goto (label gcd-2))</p><empty-line /><p>
after-gcd-2</p><empty-line /><empty-line /><p><strong>Figure 5.7:</strong>  Portions of the data paths and controller sequence for
a machine with two GCD computations.</p>

<p>

This machine has two remainder operation boxes and two boxes for
testing equality.  If the duplicated components are complicated, as is the
remainder box, this will not be an economical way to build the
machine.  We can avoid duplicating the data-path components by using
the same components for both GCD computations, provided that doing so
will not affect the rest of the larger machine's computation.  If the
values in registers a and b are not needed by the time the
controller gets to gcd-2 (or if these values can be moved to
other registers for safekeeping), we can change the machine so that
it uses registers a and b, rather than registers c
and d, in computing the second GCD as well as the first.  If we
do this, we obtain the controller sequence shown in
figure 5.8.</p>

<p>

We have removed the duplicate data-path components
(so that the data paths are again as in figure 5.1),
but the controller
now has two GCD sequences that differ only in their entry-point
labels.  It would be better to replace these two sequences by branches
to a single sequence -- a gcd <emphasis>subroutine</emphasis> -- at the end of
which we branch back to the correct place in the main instruction
sequence.  We can accomplish this as follows: Before branching to gcd, we place a distinguishing value (such as 0 or 1) into a special
register, continue.  At the end of the gcd subroutine we
return either to after-gcd-1 or to after-gcd-2, depending
on the value of the continue register.
Figure 5.9 shows the relevant portion of the
resulting controller sequence, which includes only a single copy of the
gcd instructions.</p><empty-line /><p>gcd-1</p><empty-line /><p>
 (test (op =) (reg b) (const 0))</p><empty-line /><p>
 (branch (label after-gcd-1))</p><empty-line /><p>
 (assign t (op rem) (reg a) (reg b))</p><empty-line /><p>
 (assign a (reg b))</p><empty-line /><p>
 (assign b (reg t))</p><empty-line /><p>
 (goto (label gcd-1))</p><empty-line /><p>
after-gcd-1</p><empty-line /><p>
  <image xlink:href="#_5.jpg" /></p><empty-line /><p>
gcd-2</p><empty-line /><p>
 (test (op =) (reg b) (const 0))</p><empty-line /><p>
 (branch (label after-gcd-2))</p><empty-line /><p>
 (assign t (op rem) (reg a) (reg b))</p><empty-line /><p>
 (assign a (reg b))</p><empty-line /><p>
 (assign b (reg t))</p><empty-line /><p>
 (goto (label gcd-2))</p><empty-line /><p>
after-gcd-2</p><empty-line /><empty-line /><p><strong>Figure 5.8:</strong>  Portions of the controller sequence for a machine that
uses the same data-path components for two different GCD
computations.</p><empty-line /><p>gcd</p><empty-line /><p>
 (test (op =) (reg b) (const 0))</p><empty-line /><p>
 (branch (label gcd-done))</p><empty-line /><p>
 (assign t (op rem) (reg a) (reg b))</p><empty-line /><p>
 (assign a (reg b))</p><empty-line /><p>
 (assign b (reg t))</p><empty-line /><p>
 (goto (label gcd))</p><empty-line /><p>
gcd-done</p><empty-line /><p>
 (test (op =) (reg continue) (const 0))</p><empty-line /><p>
 (branch (label after-gcd-1))</p><empty-line /><p>
 (goto (label after-gcd-2))</p><empty-line /><p>
  <image xlink:href="#_5.jpg" /></p><empty-line /><p><emphasis>;; Before branching to gcd from the first place where</emphasis></p><empty-line /><p><emphasis>;; it is needed, we place 0 in the continue register</emphasis></p><empty-line /><p>
 (assign continue (const 0))</p><empty-line /><p>
 (goto (label gcd))</p><empty-line /><p>
after-gcd-1</p><empty-line /><p>
  <image xlink:href="#_5.jpg" /></p><empty-line /><p><emphasis>;; Before the second use of gcd, we place 1 in the continue register</emphasis></p><empty-line /><p>
 (assign continue (const 1))</p><empty-line /><p>
 (goto (label gcd))</p><empty-line /><p>
after-gcd-2</p><empty-line /><empty-line /><p><strong>Figure 5.9:</strong>  Using a continue register to avoid
the duplicate controller sequence in figure 5.8.</p><empty-line /><p>gcd</p><empty-line /><p>
 (test (op =) (reg b) (const 0))</p><empty-line /><p>
 (branch (label gcd-done))</p><empty-line /><p>
 (assign t (op rem) (reg a) (reg b))</p><empty-line /><p>
 (assign a (reg b))</p><empty-line /><p>
 (assign b (reg t))</p><empty-line /><p>
 (goto (label gcd))</p><empty-line /><p>
gcd-done</p><empty-line /><p>
 (goto (reg continue))</p><empty-line /><p>
   <image xlink:href="#_5.jpg" /></p><empty-line /><p><emphasis>;; Before calling gcd, we assign to continue</emphasis></p><empty-line /><p><emphasis>;; the label to which gcd should return.</emphasis></p><empty-line /><p>
 (assign continue (label after-gcd-1))</p><empty-line /><p>
 (goto (label gcd))</p><empty-line /><p>
after-gcd-1</p><empty-line /><p>
   <image xlink:href="#_5.jpg" /></p><empty-line /><p><emphasis>;; Here is the second call to gcd, with a different continuation.</emphasis></p><empty-line /><p>
 (assign continue (label after-gcd-2))</p><empty-line /><p>
 (goto (label gcd))</p><empty-line /><p>
after-gcd-2</p><empty-line /><empty-line /><p><strong>Figure 5.10:</strong>  Assigning labels to the continue register simplifies
and generalizes the strategy shown in figure 5.9.</p>

<p>

This is a reasonable approach for handling small problems, but it
would be awkward if there were many instances of GCD computations in
the controller sequence.  To decide where to continue executing after
the gcd subroutine, we would need tests in the data paths and
branch instructions in the controller for all the places that use gcd.  A more powerful method for implementing subroutines is to have
the continue register hold the label of the entry point in the
controller sequence at which execution should continue when the
subroutine is finished.  Implementing this strategy requires a new
kind of connection between the data paths and the controller of a
register machine: There must be a way to assign to a register a label
in the controller sequence in such a way that this value can be fetched
from the register and used to continue execution at the designated
entry point.</p>

<p>

To reflect this ability, we will extend the assign
instruction of the register-machine language to allow a register to be
assigned as value a label from the controller sequence (as a special
kind of constant).  We will also extend the goto instruction to
allow execution to continue at the entry point described by the
contents of a register rather than only at an entry point described by
a constant label.  Using these new constructs we can terminate the
gcd subroutine with a branch to the location stored in the continue register.  This leads to the controller sequence shown in
figure 5.10.</p>

<p>

A machine with more than one subroutine could use multiple
continuation registers (e.g., gcd-continue, factorial-continue) or we could have all subroutines share a single
continue register.  Sharing is more economical, but we must be
careful if we have a subroutine (sub1) that calls another
subroutine (sub2).  Unless sub1 saves the contents of continue in some other register before setting up continue for
the call to sub2, sub1 will not know where to go when it
is finished.  The mechanism developed in the next section to handle
recursion also provides a better solution to this problem of nested
subroutine calls.</p>

<p><strong>5.1.4  Using a Stack to Implement Recursion</strong></p>

<p>



With the ideas illustrated so far, we can implement any iterative
process by specifying a register machine that has a register
corresponding to each state variable of the process.  The machine
repeatedly executes a controller loop, changing the contents
of the registers, until some termination condition is satisfied.  At
each point in the controller sequence, the state of the machine
(representing the state of the iterative process) is completely
determined by the contents of the registers (the values of the state
variables).</p>

<p>


Implementing recursive processes, however, requires an additional
mechanism.  Consider the following recursive method for computing
factorials, which we first examined in
section 1.2.1:</p>

<p>(define (factorial n)</p><empty-line /><p>
  (if (= n 1)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* (factorial (- n 1)) n)))</p><empty-line /><p>
As we see from the procedure, computing <emphasis>n</emphasis>! requires computing
(<emphasis>n</emphasis> - 1)!.  Our GCD machine, modeled on the procedure</p>

<p>(define (gcd a b)</p><empty-line /><p>
  (if (= b 0)</p><empty-line /><p>
      a</p><empty-line /><p>
      (gcd b (remainder a b))))</p><empty-line /><p>
similarly had to compute another GCD.  But there is an important
difference between the gcd procedure, which reduces the original
computation to a new GCD computation, and factorial, which
requires computing another factorial as a subproblem.  In GCD, the
answer to the new GCD computation is the answer to the original
problem.  To compute the next GCD, we simply place the new arguments
in the input registers of the GCD machine and reuse the
machine's data paths by executing the same controller sequence.  When
the machine is finished solving the final GCD problem, it has
completed the entire computation.</p>

<p>

In the case of factorial (or any recursive process) the answer to the
new factorial subproblem is not the answer to the original problem.
The value obtained for (<emphasis>n</emphasis> - 1)! must be multiplied by <emphasis>n</emphasis> to get the
final answer.  If we try to imitate the GCD design, and solve
the factorial subproblem by decrementing the n register and
rerunning the factorial machine, we will no longer have available the
old value of n by which to multiply the result.  We thus need a
second factorial machine to work on the subproblem.  This second
factorial computation itself has a factorial subproblem, which
requires a third factorial machine, and so on.  Since each factorial
machine contains another factorial machine within it, the total
machine contains an infinite nest of similar machines and hence cannot
be constructed from a fixed, finite number of parts.</p>

<p>

Nevertheless, we can implement the factorial process as a register
machine if we can arrange to use the same components for each nested
instance of the machine.  Specifically, the machine that computes <emphasis>n</emphasis>!
should use the same components to work on the subproblem of computing
(<emphasis>n</emphasis> - 1)!, on the subproblem for (<emphasis>n</emphasis> - 2)!, and so on.  This is
plausible because, although the factorial process dictates that an
unbounded number of copies of the same machine are needed to perform a
computation, only one of these copies needs to be active at any given
time.  When the machine encounters a recursive subproblem, it can
suspend work on the main problem, reuse the same physical parts to
work on the subproblem, then continue the suspended computation.</p>

<p>

In the subproblem, the contents of the registers will be different
than they were in the main problem. (In this case the n register
is decremented.)  In order to be able to continue the suspended
computation, the machine must save the contents of any registers that
will be needed after the subproblem is solved so that these can be
restored to continue the suspended computation.  In the case of
factorial, we will save the old value of n, to be restored when
we are finished computing the factorial of the decremented n
register.<sup>2</sup></p>

<p>

Since there is no <emphasis>a priori</emphasis> limit on the depth of nested
recursive calls, we may need to save an arbitrary number of register
values.  These values must be restored in the reverse of the order in
which they were saved, since in a nest of recursions the last
subproblem to be entered is the first to be finished.  This dictates
the use of a <emphasis>stack</emphasis>, or "last in, first out" data structure, to
save register values.  We can extend the register-machine language to
include a stack by adding two kinds of instructions: Values are placed
on the stack using a save instruction and restored from the
stack using a restore instruction.  After a sequence of values
has been saved on the stack, a sequence of restores will
retrieve these values in reverse order.<sup>3</sup></p>

<p>


With the aid of the stack, we can reuse a single copy of the factorial
machine's data paths for each factorial subproblem.  There is a
similar design issue in reusing the controller sequence that operates
the data paths.  To reexecute the factorial computation, the
controller cannot simply loop back to the beginning, as with
an iterative process, because after solving the (<emphasis>n</emphasis> - 1)! subproblem
the machine must still multiply the result by <emphasis>n</emphasis>.  The controller
must suspend its computation of <emphasis>n</emphasis>!, solve the (<emphasis>n</emphasis> - 1)! subproblem,
then continue its computation of <emphasis>n</emphasis>!.  This view of the factorial
computation suggests the use of the subroutine mechanism described in
section 5.1.3, which has the controller use a
continue register to transfer to the part of the sequence that
solves a subproblem and then continue where it left off on the main
problem.  We can thus make a factorial subroutine that returns to the
entry point stored in the continue register.  Around each subroutine
call, we save and restore continue just as we do the n
register, since each "level" of the factorial computation will use
the same continue register.  That is, the factorial subroutine
must put a new value in continue when it calls itself for a
subproblem, but it will need the old value in order to return to the
place that called it to solve a subproblem.</p>

<p>


Figure 5.11 shows the data paths and controller for
a machine that implements the recursive factorial procedure.
The machine has a stack and three registers, called n, val, and continue.  To simplify the data-path diagram, we have
not named the register-assignment buttons, only the stack-operation
buttons (sc and sn to save registers, rc and rn to restore registers).  To operate the machine, we put in register
n the number whose factorial we wish to compute and start the
machine.  When the machine reaches fact-done, the computation is
finished and the answer will be found in the val register.  In
the controller sequence, n and continue are saved before
each recursive call and restored upon return from the call.  Returning
from a call is accomplished by branching to the location stored in
continue.  Continue is initialized when the machine starts
so that the last return will go to fact-done.  The val
register, which holds the result of the factorial computation, is not
saved before the recursive call, because the old contents of val
is not useful after the subroutine returns.  Only the new value, which
is the value produced by the subcomputation, is needed.

Although in principle the factorial computation requires an infinite
machine, the machine in figure 5.11 is actually
finite except for the stack, which is potentially unbounded.  Any
particular physical implementation of a stack, however, will be of
finite size, and this will limit the depth of recursive calls that can
be handled by the machine.  This implementation of factorial
illustrates the general strategy for realizing recursive algorithms as
ordinary register machines augmented by stacks.  When a recursive
subproblem is encountered, we save on the stack the registers whose
current values will be required after the subproblem is solved, solve
the recursive subproblem, then restore the saved registers and
continue execution on the main problem.  The continue register
must always be saved.  Whether there are other registers that need to
be saved depends on the particular machine, since not all recursive
computations need the original values of registers that are modified
during solution of the subproblem (see exercise 5.4).</p>

<p><strong>A double recursion</strong></p>

<p>

Let us examine a more complex recursive process, the tree-recursive
computation of the Fibonacci numbers, which we introduced in
section 1.2.2:</p>

<p>(define (fib n)</p><empty-line /><p>
  (if (&lt; n 2)</p><empty-line /><p>
      n</p><empty-line /><p>
      (+ (fib (- n 1)) (fib (- n 2)))))</p><empty-line /><p>
Just as with factorial, we can implement the recursive Fibonacci
computation as a register machine with registers n, val,
and continue.  The machine is more complex than the one for
factorial, because there are two places in the controller sequence
where we need to perform recursive calls -- once to compute Fib(<emphasis>n</emphasis> - 1)
and once to compute Fib(<emphasis>n</emphasis> - 2).  To set up for each of these calls, we
save the registers whose values will be needed later, set the n
register to the number whose Fib we need to compute recursively (<emphasis>n</emphasis> - 1
or <emphasis>n</emphasis> - 2), and assign to continue the entry point in the main sequence
to which to return (afterfib-n-1 or afterfib-n-2,
respectively).  We then go to fib-loop.  When we return from the
recursive call, the answer is in val.
Figure 5.12 shows the controller sequence for this
machine.</p>

<p><image xlink:href="#_209.jpg" /></p>

<p>(controller</p><empty-line /><p>
   (assign continue (label fact-done))     <emphasis>; set up final return address</emphasis></p><empty-line /><p>
 fact-loop</p><empty-line /><p>
   (test (op =) (reg n) (const 1))</p><empty-line /><p>
   (branch (label base-case))</p><empty-line /><p>
   <emphasis>;; Set up for the recursive call by saving n and continue.</emphasis></p><empty-line /><p>
   <emphasis>;; Set up continue so that the computation will continue</emphasis></p><empty-line /><p>
   <emphasis>;; at after-fact when the subroutine returns.</emphasis></p><empty-line /><p>
   (save continue)</p><empty-line /><p>
   (save n)</p><empty-line /><p>
   (assign n (op -) (reg n) (const 1))</p><empty-line /><p>
   (assign continue (label after-fact))</p><empty-line /><p>
   (goto (label fact-loop))</p><empty-line /><p>
 after-fact</p><empty-line /><p>
   (restore n)</p><empty-line /><p>
   (restore continue)</p><empty-line /><p>
   (assign val (op *) (reg n) (reg val))   <emphasis>; val now contains</emphasis> <emphasis>n</emphasis>(<emphasis>n</emphasis> - 1)!</p><empty-line /><p>
   (goto (reg continue))                   <emphasis>; return to caller</emphasis></p><empty-line /><p>
 base-case</p><empty-line /><p>
   (assign val (const 1))                  <emphasis>; base case: </emphasis>1! = 1</p><empty-line /><p>
   (goto (reg continue))                   <emphasis>; return to caller</emphasis></p><empty-line /><p>
 fact-done)</p><empty-line /><empty-line /><p><strong>Figure 5.11:</strong>  A recursive factorial machine.</p><empty-line /><p>(controller</p><empty-line /><p>
   (assign continue (label fib-done))</p><empty-line /><p>
 fib-loop</p><empty-line /><p>
   (test (op &lt;) (reg n) (const 2))</p><empty-line /><p>
   (branch (label immediate-answer))</p><empty-line /><p>
   <emphasis>;; set up to compute Fib(n - 1)</emphasis></p><empty-line /><p>
   (save continue)</p><empty-line /><p>
   (assign continue (label afterfib-n-1))</p><empty-line /><p>
   (save n)                           <emphasis>; save old value of n</emphasis></p><empty-line /><p>
   (assign n (op -) (reg n) (const 1))<emphasis>; clobber n to n - 1</emphasis></p><empty-line /><p>
   (goto (label fib-loop))            <emphasis>; perform recursive call</emphasis></p><empty-line /><p>
 afterfib-n-1                         <emphasis>; upon return, val contains Fib(n - 1)</emphasis></p><empty-line /><p>
   (restore n)</p><empty-line /><p>
   (restore continue)</p><empty-line /><p>
   <emphasis>;; set up to compute Fib(n - 2)</emphasis></p><empty-line /><p>
   (assign n (op -) (reg n) (const 2))</p><empty-line /><p>
   (save continue)</p><empty-line /><p>
   (assign continue (label afterfib-n-2))</p><empty-line /><p>
   (save val)                         <emphasis>; save Fib(n - 1)</emphasis></p><empty-line /><p>
   (goto (label fib-loop))</p><empty-line /><p>
 afterfib-n-2                         <emphasis>; upon return, val contains Fib(n - 2)</emphasis></p><empty-line /><p>
   (assign n (reg val))               <emphasis>; n now contains Fib(n - 2)</emphasis></p><empty-line /><p>
   (restore val)                      <emphasis>; val now contains Fib(n - 1)</emphasis></p><empty-line /><p>
   (restore continue)</p><empty-line /><p>
   (assign val                        <emphasis>;  Fib(n - 1) +  Fib(n - 2)</emphasis></p><empty-line /><p>
           (op +) (reg val) (reg n))</p><empty-line /><p>
   (goto (reg continue))              <emphasis>; return to caller, answer is in val</emphasis></p><empty-line /><p>
 immediate-answer</p><empty-line /><p>
   (assign val (reg n))               <emphasis>; base case:  Fib(n) = n</emphasis></p><empty-line /><p>
   (goto (reg continue))</p><empty-line /><p>
 fib-done)</p><empty-line /><empty-line /><p><strong>Figure 5.12:</strong>  Controller for a machine to compute Fibonacci
numbers.</p>

<p>
<strong>Exercise 5.4.</strong>  Specify register machines that implement each of the following
procedures.  For each machine, write a controller instruction sequence
and draw a diagram showing the data paths.</p>

<p>a. Recursive exponentiation:</p>

<p>(define (expt b n)</p><empty-line /><p>
  (if (= n 0)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* b (expt b (- n 1)))))</p><empty-line /><empty-line /><p>b. Iterative exponentiation:</p>

<p>(define (expt b n)</p><empty-line /><p>
  (define (expt-iter counter product)</p><empty-line /><p>
    (if (= counter 0)</p><empty-line /><p>
        product</p><empty-line /><p>
        (expt-iter (- counter 1) (* b product))))</p><empty-line /><p>
  (expt-iter n 1))</p><empty-line /><empty-line /><p>
<strong>Exercise 5.5.</strong>  Hand-simulate the factorial and Fibonacci machines, using some
nontrivial input (requiring execution of at least one recursive call).
Show the contents of the stack at each significant point in the
execution.</p>

<p>
<strong>Exercise 5.6.</strong>  Ben Bitdiddle observes that the Fibonacci machine's controller sequence
has an extra save and an extra restore, which can be
removed to make a faster machine.  Where are these instructions?</p>

<p><strong>5.1.5  Instruction Summary</strong></p>

<p>


A controller instruction in our register-machine language
has one of the following forms, where each
&lt;<emphasis>input<sub>i</sub></emphasis>&gt; is either (reg &lt;<emphasis>register-name</emphasis>&gt;)
or (const &lt;<emphasis>constant-value</emphasis>&gt;).</p>

<p>

These instructions were introduced in
section 5.1.1:</p>

<p>(assign &lt;<emphasis>register-name</emphasis>&gt; (reg &lt;<emphasis>register-name</emphasis>&gt;))</p><empty-line /><empty-line /><p>
(assign &lt;<emphasis>register-name</emphasis>&gt; (const &lt;<emphasis>constant-value</emphasis>&gt;))</p><empty-line /><empty-line /><p>(assign &lt;<emphasis>register-name</emphasis>&gt; (op &lt;<emphasis>operation-name</emphasis>&gt;) &lt;<emphasis>input<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>input<sub>n</sub></emphasis>&gt;)</p><empty-line /><empty-line /><p>(perform (op &lt;<emphasis>operation-name</emphasis>&gt;) &lt;<emphasis>input<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>input<sub>n</sub></emphasis>&gt;)</p><empty-line /><empty-line /><p>(test (op &lt;<emphasis>operation-name</emphasis>&gt;) &lt;<emphasis>input<sub>1</sub></emphasis>&gt; ... &lt;<emphasis>input<sub>n</sub></emphasis>&gt;)</p><empty-line /><empty-line /><p>(branch (label &lt;<emphasis>label-name</emphasis>&gt;))</p><empty-line /><empty-line /><p>(goto (label &lt;<emphasis>label-name</emphasis>&gt;))</p><empty-line /><empty-line /><p>

The use of registers to hold labels was introduced in
section 5.1.3:</p>

<p>(assign &lt;<emphasis>register-name</emphasis>&gt; (label &lt;<emphasis>label-name</emphasis>&gt;))</p><empty-line /><empty-line /><p>
(goto (reg &lt;<emphasis>register-name</emphasis>&gt;))</p><empty-line /><empty-line /><p>

Instructions to use the stack were introduced in
section 5.1.4:</p>

<p>(save &lt;<emphasis>register-name</emphasis>&gt;)</p><empty-line /><empty-line /><p>(restore &lt;<emphasis>register-name</emphasis>&gt;)</p><empty-line /><empty-line /><p>

The only kind of &lt;<emphasis>constant-value</emphasis>&gt; we have seen so far is a number,
but later we will use strings, symbols, and lists.
For example,
(const "abc") is the string "abc",
(const abc) is the symbol abc,
(const (a b c)) is the list (a b c),
and (const ()) is the empty list.</p><empty-line /><empty-line /><empty-line /><p><sup>1</sup> This assumption
glosses over a great deal of complexity.  Usually a large portion of
the implementation of a Lisp system is dedicated to making reading
and printing work.</p>

<p><sup>2</sup> One might argue that we don't need to save the old
n; after we decrement it and solve the subproblem, we could
simply increment it to recover the old value.  Although this strategy
works for factorial, it cannot work in general, since the old value of
a register cannot always be computed from the new one.</p>

<p><sup>3</sup> In
section 5.3 we will see how to implement a
stack in terms of more primitive operations.</p>


</section>

<section>


<p><strong>5.2  A Register-Machine Simulator</strong></p>

<p>



In order to gain a good understanding of the design of register
machines, we must test the machines we design to see if they perform
as expected.  One way to test a design is to hand-simulate the
operation of the controller, as in exercise 5.5.  But this is
extremely tedious for all but the simplest machines.  In this section
we construct a simulator for machines described in the
register-machine language.  The simulator is a Scheme program with
four interface procedures.  The first uses a description of a register
machine to construct a model of the machine (a data structure whose
parts correspond to the parts of the machine to be simulated), and the
other three allow us to simulate the machine by manipulating the
model:</p>

<p>(make-machine &lt;<emphasis>register-names</emphasis>&gt; &lt;<emphasis>operations</emphasis>&gt; &lt;<emphasis>controller</emphasis>&gt;)</p><empty-line /><p>
constructs and returns a model of the machine with the given
registers, operations, and controller.</p>

<p>(set-register-contents! &lt;<emphasis>machine-model</emphasis>&gt; &lt;<emphasis>register-name</emphasis>&gt; &lt;<emphasis>value</emphasis>&gt;)</p><empty-line /><p>
stores a value in a simulated register in the given
machine.</p>

<p>(get-register-contents &lt;<emphasis>machine-model</emphasis>&gt; &lt;<emphasis>register-name</emphasis>&gt;)</p><empty-line /><p>
returns the contents of a simulated register in the given machine.</p>

<p>(start &lt;<emphasis>machine-model</emphasis>&gt;)</p><empty-line /><p>
simulates the execution of the given
machine, starting from the beginning of the controller sequence and
stopping when it reaches the end of the sequence.</p>

<p>

As an example of how these procedures are used, we can define
gcd-machine to be a model of the GCD machine
of section 5.1.1 as follows:</p>

<p>(define gcd-machine</p><empty-line /><p>
  (make-machine</p><empty-line /><p>
   '(a b t)</p><empty-line /><p>
   (list (list 'rem remainder) (list '= =))</p><empty-line /><p>
   '(test-b</p><empty-line /><p>
       (test (op =) (reg b) (const 0))</p><empty-line /><p>
       (branch (label gcd-done))</p><empty-line /><p>
       (assign t (op rem) (reg a) (reg b))</p><empty-line /><p>
       (assign a (reg b))</p><empty-line /><p>
       (assign b (reg t))</p><empty-line /><p>
       (goto (label test-b))</p><empty-line /><p>
     gcd-done)))</p><empty-line /><p>
The first argument to make-machine is a list of register names.
The next argument is a table (a list of two-element lists) that pairs
each operation name with a Scheme procedure that implements the operation
(that is, produces the same output value given the same input values).
The last argument specifies the controller as a list of labels and
machine instructions, as in section 5.1.</p>

<p>


To compute GCDs with this machine, we set the
input registers, start the machine, and examine the result when the
simulation terminates:</p>

<p>(set-register-contents! gcd-machine 'a 206)</p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
(set-register-contents! gcd-machine 'b 40)</p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
(start gcd-machine)</p><empty-line /><p><emphasis>done</emphasis></p><empty-line /><p>
(get-register-contents gcd-machine 'a)</p><empty-line /><p><emphasis>2</emphasis></p><empty-line /><p>
This computation will run much more slowly than a gcd procedure
written in Scheme, because we will simulate low-level machine
instructions, such as assign, by much more complex operations.</p>

<p>
<strong>Exercise 5.7.</strong>  Use the simulator to test the machines you designed in
exercise 5.4.</p>

<p><strong>5.2.1  The Machine Model</strong></p>

<p>

The machine model generated by make-machine is represented as a
procedure with local state using the message-passing techniques
developed in chapter 3.  To build this model, make-machine
begins by calling the procedure make-new-machine to construct
the parts of the machine model that are common to all register
machines.  This basic machine model constructed by make-new-machine is essentially a container for some registers and a
stack, together with an execution mechanism that processes the controller
instructions one by one.</p>

<p>

Make-machine then extends this basic model (by sending it
messages) to include the registers, operations, and controller of the
particular machine being defined.  First it allocates a register in
the new machine for each of the supplied register names and installs
the designated operations in the machine.  Then it uses an <emphasis>assembler</emphasis> (described below in section 5.2.2) to
transform the controller list into instructions for the new machine
and installs these as the machine's instruction sequence.  Make-machine returns as its value the modified machine model.</p>

<p>(define (make-machine register-names ops controller-text)</p><empty-line /><p>
  (let ((machine (make-new-machine)))</p><empty-line /><p>
    (for-each (lambda (register-name)</p><empty-line /><p>
                ((machine 'allocate-register) register-name))</p><empty-line /><p>
              register-names)</p><empty-line /><p>
    ((machine 'install-operations) ops)</p><empty-line /><p>
    ((machine 'install-instruction-sequence)</p><empty-line /><p>
     (assemble controller-text machine))</p><empty-line /><p>
    machine))</p><empty-line /><empty-line /><p><strong>Registers</strong></p>

<p>


We will represent a register as a procedure with local state, as in
chapter 3.  The procedure make-register creates a register that
holds a value that can be accessed or changed:</p>

<p>(define (make-register name)</p><empty-line /><p>
  (let ((contents '*unassigned*))</p><empty-line /><p>
    (define (dispatch message)</p><empty-line /><p>
      (cond ((eq? message 'get) contents)</p><empty-line /><p>
            ((eq? message 'set)</p><empty-line /><p>
             (lambda (value) (set! contents value)))</p><empty-line /><p>
            (else</p><empty-line /><p>
             (error "Unknown request -- REGISTER" message))))</p><empty-line /><p>
    dispatch))</p><empty-line /><p>
The following procedures are used to access registers:</p>

<p>(define (get-contents register)</p><empty-line /><p>
  (register 'get))</p><empty-line /><empty-line /><p>(define (set-contents! register value)</p><empty-line /><p>
  ((register 'set) value))</p><empty-line /><empty-line /><p><strong>The stack</strong></p>

<p>


We can also represent a stack as a procedure with local state.  The
procedure make-stack creates a stack whose local state consists
of a list of the items on the stack.  A stack accepts requests to push an item onto the stack, to pop the top item off the stack
and return it, and to initialize the stack to empty.</p>

<p>(define (make-stack)</p><empty-line /><p>
  (let ((s '()))</p><empty-line /><p>
    (define (push x)</p><empty-line /><p>
      (set! s (cons x s)))</p><empty-line /><p>
    (define (pop)</p><empty-line /><p>
      (if (null? s)</p><empty-line /><p>
          (error "Empty stack -- POP")</p><empty-line /><p>
          (let ((top (car s)))</p><empty-line /><p>
            (set! s (cdr s))</p><empty-line /><p>
            top)))</p><empty-line /><p>
    (define (initialize)</p><empty-line /><p>
      (set! s '())</p><empty-line /><p>
      'done)</p><empty-line /><p>
    (define (dispatch message)</p><empty-line /><p>
      (cond ((eq? message 'push) push)</p><empty-line /><p>
            ((eq? message 'pop) (pop))</p><empty-line /><p>
            ((eq? message 'initialize) (initialize))</p><empty-line /><p>
            (else (error "Unknown request -- STACK"</p><empty-line /><p>
                         message))))</p><empty-line /><p>
    dispatch))</p><empty-line /><p>
The following procedures are used to access stacks:</p>

<p>(define (pop stack)</p><empty-line /><p>
  (stack 'pop))</p><empty-line /><empty-line /><p>(define (push stack value)</p><empty-line /><p>
  ((stack 'push) value))</p><empty-line /><empty-line /><p><strong>The basic machine</strong></p>

<p>

The make-new-machine procedure, shown in
figure 5.13, constructs an object whose local
state consists of a stack, an initially empty instruction sequence, a
list of operations that initially contains an operation to initialize
the stack, and a <emphasis>register table</emphasis> that initially contains two
registers, named flag and pc (for "program counter").
The internal procedure allocate-register adds new entries to the
register table, and the internal procedure lookup-register looks
up registers in the table.</p>

<p>


The flag register is used to control branching in the simulated
machine.  Test instructions set the contents of flag to
the result of the test (true or false).  Branch instructions
decide whether or not to branch by examining the contents of flag.</p>

<p>

The pc register determines the sequencing of instructions as
the machine runs.  This sequencing is implemented by the internal
procedure execute.
In the simulation model, each machine instruction is a data structure
that includes a procedure of no arguments, called the <emphasis>instruction
execution procedure</emphasis>, such that calling this procedure simulates
executing the instruction.  As the simulation runs, pc points to
the place in the instruction sequence beginning with the next
instruction to be executed.  Execute gets that instruction,
executes it by calling the instruction execution procedure, and
repeats this cycle until there are no more instructions to execute
(i.e., until pc points to the end of the instruction sequence).</p><empty-line /><p>(define (make-new-machine)</p><empty-line /><p>
  (let ((pc (make-register 'pc))</p><empty-line /><p>
        (flag (make-register 'flag))</p><empty-line /><p>
        (stack (make-stack))</p><empty-line /><p>
        (the-instruction-sequence '()))</p><empty-line /><p>
    (let ((the-ops</p><empty-line /><p>
           (list (list 'initialize-stack</p><empty-line /><p>
                       (lambda () (stack 'initialize)))))</p><empty-line /><p>
          (register-table</p><empty-line /><p>
           (list (list 'pc pc) (list 'flag flag))))</p><empty-line /><p>
      (define (allocate-register name)</p><empty-line /><p>
        (if (assoc name register-table)</p><empty-line /><p>
            (error "Multiply defined register: " name)</p><empty-line /><p>
            (set! register-table</p><empty-line /><p>
                  (cons (list name (make-register name))</p><empty-line /><p>
                        register-table)))</p><empty-line /><p>
        'register-allocated)</p><empty-line /><p>
      (define (lookup-register name)</p><empty-line /><p>
        (let ((val (assoc name register-table)))</p><empty-line /><p>
          (if val</p><empty-line /><p>
              (cadr val)</p><empty-line /><p>
              (error "Unknown register:" name))))</p><empty-line /><p>
      (define (execute)</p><empty-line /><p>
        (let ((insts (get-contents pc)))</p><empty-line /><p>
          (if (null? insts)</p><empty-line /><p>
              'done</p><empty-line /><p>
              (begin</p><empty-line /><p>
                ((instruction-execution-proc (car insts)))</p><empty-line /><p>
                (execute)))))</p><empty-line /><p>
      (define (dispatch message)</p><empty-line /><p>
        (cond ((eq? message 'start)</p><empty-line /><p>
               (set-contents! pc the-instruction-sequence)</p><empty-line /><p>
               (execute))</p><empty-line /><p>
              ((eq? message 'install-instruction-sequence)</p><empty-line /><p>
               (lambda (seq) (set! the-instruction-sequence seq)))</p><empty-line /><p>
              ((eq? message 'allocate-register) allocate-register)</p><empty-line /><p>
              ((eq? message 'get-register) lookup-register)</p><empty-line /><p>
              ((eq? message 'install-operations)</p><empty-line /><p>
               (lambda (ops) (set! the-ops (append the-ops ops))))</p><empty-line /><p>
              ((eq? message 'stack) stack)</p><empty-line /><p>
              ((eq? message 'operations) the-ops)</p><empty-line /><p>
              (else (error "Unknown request -- MACHINE" message))))</p><empty-line /><p>
      dispatch)))</p><empty-line /><empty-line /><p><strong>Figure 5.13:</strong>  The make-new-machine procedure, which implements
the basic machine model.</p>

<p>

As part of its operation, each instruction execution procedure
modifies pc to indicate the next instruction to be executed.
Branch and goto instructions change pc to point to
the new destination.  All other instructions simply advance pc,
making it point to the next instruction in the sequence.  Observe that
each call to execute calls execute again, but this does
not produce an infinite loop because running the instruction execution
procedure changes the contents of pc.</p>

<p>

Make-new-machine returns a
dispatch procedure that implements message-passing
access to the internal state.  Notice that starting the machine is
accomplished by setting pc to the beginning of the instruction
sequence and calling execute.</p>

<p>

For convenience, we provide an alternate procedural interface to a
machine's start operation,
as well as procedures to set and examine register contents,
as specified at the beginning of section 5.2:</p>

<p>(define (start machine)</p><empty-line /><p>
  (machine 'start))</p><empty-line /><p>(define (get-register-contents machine register-name)</p><empty-line /><p>
  (get-contents (get-register machine register-name)))</p><empty-line /><p>(define (set-register-contents! machine register-name value)</p><empty-line /><p>
  (set-contents! (get-register machine register-name) value)</p><empty-line /><p>
  'done)</p><empty-line /><p>
These procedures (and many procedures in sections 5.2.2
and 5.2.3) use the following to look up the register with a
given name in a given machine:</p>

<p>(define (get-register machine reg-name)</p><empty-line /><p>
  ((machine 'get-register) reg-name))</p><empty-line /><empty-line /><p><strong>5.2.2  The Assembler</strong></p>

<p>



The assembler transforms the sequence of controller expressions for a
machine into a corresponding list of machine instructions, each with
its execution procedure.  Overall, the assembler is much like the
evaluators we studied in chapter 4 -- there is an input language (in
this case, the register-machine language) and we must perform an
appropriate action for each type of expression in the language.</p>

<p>

The technique of producing an execution procedure for each instruction
is just what we used in section 4.1.7 to speed
up the evaluator by separating analysis from runtime execution.  As we
saw in chapter 4, much useful analysis of Scheme expressions could be
performed without knowing the actual values of variables.  Here,
analogously, much useful analysis of register-machine-language
expressions can be performed without knowing the actual contents of
machine registers.  For example, we can replace references to
registers by pointers to the register objects, and we can
replace references to labels by pointers to the place in the
instruction sequence that the label designates.</p>

<p>

Before it can generate the instruction execution procedures, the
assembler must know what all the labels refer to, so it begins by
scanning the controller text to separate the labels from the
instructions.  As it scans the text, it constructs both a list of
instructions and a table that associates each label with a pointer
into that list.  Then the assembler augments the instruction list by
inserting the execution procedure for each instruction.</p>

<p>

The assemble procedure is the main entry to the assembler.
It takes the controller text and the machine model as arguments and
returns the instruction sequence to be stored in the model.
Assemble calls extract-labels to build the initial instruction list
and label table from the supplied controller text.  The second argument
to extract-labels is a procedure to be called to process these results:
This procedure uses update-insts! to generate the instruction execution
procedures and insert them into the instruction list,
and returns the modified list.</p>

<p>(define (assemble controller-text machine)</p><empty-line /><p>
  (extract-labels controller-text</p><empty-line /><p>
    (lambda (insts labels)</p><empty-line /><p>
      (update-insts! insts labels machine)</p><empty-line /><p>
      insts)))</p><empty-line /><empty-line /><p>

Extract-labels
takes as arguments a list text (the sequence of controller
instruction expressions) and a receive procedure.  Receive
will be called with two values: (1) a list insts of instruction
data structures, each containing an instruction from text; and
(2) a table called labels, which associates each label from text
with the position in the list insts that the label designates.</p>

<p>(define (extract-labels text receive)</p><empty-line /><p>
  (if (null? text)</p><empty-line /><p>
      (receive '() '())</p><empty-line /><p>
      (extract-labels (cdr text)</p><empty-line /><p>
       (lambda (insts labels)</p><empty-line /><p>
         (let ((next-inst (car text)))</p><empty-line /><p>
           (if (symbol? next-inst)</p><empty-line /><p>
               (receive insts</p><empty-line /><p>
                        (cons (make-label-entry next-inst</p><empty-line /><p>
                                                insts)</p><empty-line /><p>
                              labels))</p><empty-line /><p>
               (receive (cons (make-instruction next-inst)</p><empty-line /><p>
                              insts)</p><empty-line /><p>
                        labels)))))))</p><empty-line /><p>
Extract-labels works by sequentially scanning the elements of
the text and accumulating the insts and the labels.
If an element is a symbol (and thus a label) an appropriate entry is
added to the labels table.  Otherwise the element is accumulated
onto the insts list.<sup>4</sup></p>

<p>

Update-insts! modifies the instruction list, which initially
contains only the text of the instructions, to include the
corresponding execution procedures:</p>

<p>(define (update-insts! insts labels machine)</p><empty-line /><p>
  (let ((pc (get-register machine 'pc))</p><empty-line /><p>
        (flag (get-register machine 'flag))</p><empty-line /><p>
        (stack (machine 'stack))</p><empty-line /><p>
        (ops (machine 'operations)))</p><empty-line /><p>
    (for-each</p><empty-line /><p>
     (lambda (inst)</p><empty-line /><p>
       (set-instruction-execution-proc!</p><empty-line /><p>
        inst</p><empty-line /><p>
        (make-execution-procedure</p><empty-line /><p>
         (instruction-text inst) labels machine</p><empty-line /><p>
         pc flag stack ops)))</p><empty-line /><p>
     insts)))</p><empty-line /><empty-line /><p>


The machine instruction data structure simply pairs the
instruction text with the corresponding execution procedure.
The execution procedure is not yet available when extract-labels
constructs the instruction, and is inserted later by update-insts!.</p>

<p>(define (make-instruction text)</p><empty-line /><p>
  (cons text '()))</p><empty-line /><p>(define (instruction-text inst)</p><empty-line /><p>
  (car inst))</p><empty-line /><p>(define (instruction-execution-proc inst)</p><empty-line /><p>
  (cdr inst))</p><empty-line /><p>(define (set-instruction-execution-proc! inst proc)</p><empty-line /><p>
  (set-cdr! inst proc))</p><empty-line /><p>
The instruction text is not used by our simulator, but it is handy to keep
around for debugging (see exercise 5.16).</p>

<p>

Elements of the label table are pairs:</p>

<p>(define (make-label-entry label-name insts)</p><empty-line /><p>
  (cons label-name insts))</p><empty-line /><p>
Entries will be looked up in the table with</p>

<p>(define (lookup-label labels label-name)</p><empty-line /><p>
  (let ((val (assoc label-name labels)))</p><empty-line /><p>
    (if val</p><empty-line /><p>
        (cdr val)</p><empty-line /><p>
        (error "Undefined label -- ASSEMBLE" label-name))))</p><empty-line /><empty-line /><p>
<strong>Exercise 5.8.</strong>  The following register-machine code is ambiguous, because the label
here is defined more than once:</p>

<p>start</p><empty-line /><p>
  (goto (label here))</p><empty-line /><p>
here</p><empty-line /><p>
  (assign a (const 3))</p><empty-line /><p>
  (goto (label there))</p><empty-line /><p>
here</p><empty-line /><p>
  (assign a (const 4))</p><empty-line /><p>
  (goto (label there))</p><empty-line /><p>
there</p><empty-line /><p>
With the simulator as written, what will the contents of register a
be when control reaches there?  Modify the extract-labels
procedure so that the assembler will signal an error if the same label
name is used to indicate two different locations.</p>

<p><strong>5.2.3  Generating Execution Procedures for Instructions</strong></p>

<p>



The assembler calls make-execution-procedure to
generate the execution procedure for an instruction.
Like the analyze procedure in the evaluator of
section 4.1.7, this dispatches on the type of
instruction to generate the appropriate execution procedure.</p>

<p>(define (make-execution-procedure inst labels machine</p><empty-line /><p>
                                  pc flag stack ops)</p><empty-line /><p>
  (cond ((eq? (car inst) 'assign)</p><empty-line /><p>
         (make-assign inst machine labels ops pc))</p><empty-line /><p>
        ((eq? (car inst) 'test)</p><empty-line /><p>
         (make-test inst machine labels ops flag pc))</p><empty-line /><p>
        ((eq? (car inst) 'branch)</p><empty-line /><p>
         (make-branch inst machine labels flag pc))</p><empty-line /><p>
        ((eq? (car inst) 'goto)</p><empty-line /><p>
         (make-goto inst machine labels pc))</p><empty-line /><p>
        ((eq? (car inst) 'save)</p><empty-line /><p>
         (make-save inst machine stack pc))</p><empty-line /><p>
        ((eq? (car inst) 'restore)</p><empty-line /><p>
         (make-restore inst machine stack pc))</p><empty-line /><p>
        ((eq? (car inst) 'perform)</p><empty-line /><p>
         (make-perform inst machine labels ops pc))</p><empty-line /><p>
        (else (error "Unknown instruction type -- ASSEMBLE"</p><empty-line /><p>
                     inst))))</p><empty-line /><empty-line /><p>

For each type of instruction in the register-machine language, there
is a generator that builds an appropriate execution procedure.  The
details of these procedures determine both the syntax and meaning of
the individual instructions in the register-machine language.
We use data abstraction to isolate the detailed syntax of
register-machine expressions from the general execution mechanism, as
we did for evaluators in section 4.1.2,
by using syntax procedures to extract and classify the parts of an instruction.</p>

<p><strong>Assign instructions</strong></p>

<p>


The make-assign procedure handles assign instructions:</p>

<p>(define (make-assign inst machine labels operations pc)</p><empty-line /><p>
  (let ((target</p><empty-line /><p>
         (get-register machine (assign-reg-name inst)))</p><empty-line /><p>
        (value-exp (assign-value-exp inst)))</p><empty-line /><p>
    (let ((value-proc</p><empty-line /><p>
           (if (operation-exp? value-exp)</p><empty-line /><p>
               (make-operation-exp</p><empty-line /><p>
                value-exp machine labels operations)</p><empty-line /><p>
               (make-primitive-exp</p><empty-line /><p>
                (car value-exp) machine labels))))</p><empty-line /><p>
      (lambda ()                <emphasis>; execution procedure for assign</emphasis></p><empty-line /><p>
        (set-contents! target (value-proc))</p><empty-line /><p>
        (advance-pc pc)))))</p><empty-line /><p>
Make-assign extracts the target register name (the
second element of the instruction) and the value expression
(the rest of the list that forms the instruction)
from the assign instruction using the selectors</p>

<p>(define (assign-reg-name assign-instruction)</p><empty-line /><p>
  (cadr assign-instruction))</p><empty-line /><p>(define (assign-value-exp assign-instruction)</p><empty-line /><p>
  (cddr assign-instruction))</p><empty-line /><p>
The register name is looked up with get-register to produce the
target register object.  The value expression is passed to make-operation-exp if the value is the result of an operation, and to
make-primitive-exp otherwise.  These procedures (shown below)
parse the value expression and produce an execution procedure for the
value.  This is a procedure of no arguments, called value-proc,
which will be evaluated during the simulation to produce the actual
value to be assigned to the register.  Notice that the work of looking
up the register name and parsing the value expression is performed
just once, at assembly time, not every time the instruction is
simulated.  This saving of work is the reason we use execution
procedures, and corresponds directly to the saving in work we obtained
by separating program analysis from execution in the evaluator of
section 4.1.7.</p>

<p>

The result returned by make-assign is the execution
procedure for the assign instruction.  When this procedure is
called (by the machine model's execute procedure),
it sets the contents of the target register to the result
obtained by executing value-proc.  Then it advances
the pc to the next instruction by running the procedure</p>

<p>(define (advance-pc pc)</p><empty-line /><p>
  (set-contents! pc (cdr (get-contents pc))))</p><empty-line /><p>
Advance-pc is the normal termination for all instructions except
branch and goto.</p>

<p><strong>Test, branch, and goto instructions</strong></p>

<p>

Make-test handles test instructions in a similar way.  It
extracts the expression that specifies the condition to be tested and
generates an execution procedure for it.  At simulation time, the
procedure for the condition is called, the result is assigned to the
flag register, and the pc is advanced:</p>

<p>(define (make-test inst machine labels operations flag pc)</p><empty-line /><p>
  (let ((condition (test-condition inst)))</p><empty-line /><p>
    (if (operation-exp? condition)</p><empty-line /><p>
        (let ((condition-proc</p><empty-line /><p>
               (make-operation-exp</p><empty-line /><p>
                condition machine labels operations)))</p><empty-line /><p>
          (lambda ()</p><empty-line /><p>
            (set-contents! flag (condition-proc))</p><empty-line /><p>
            (advance-pc pc)))</p><empty-line /><p>
        (error "Bad TEST instruction -- ASSEMBLE" inst))))</p><empty-line /><p>(define (test-condition test-instruction)</p><empty-line /><p>
  (cdr test-instruction))</p><empty-line /><empty-line /><p>

The execution procedure for a branch instruction checks the
contents of the flag register and either sets the contents of
the pc to the branch destination (if the branch is taken) or
else just advances the pc (if the branch is not taken).  Notice
that the indicated destination in a branch instruction must be a
label, and the make-branch procedure enforces this.  Notice
also that the label is looked up at assembly time, not each time the
branch instruction is simulated.</p>

<p>(define (make-branch inst machine labels flag pc)</p><empty-line /><p>
  (let ((dest (branch-dest inst)))</p><empty-line /><p>
    (if (label-exp? dest)</p><empty-line /><p>
        (let ((insts</p><empty-line /><p>
               (lookup-label labels (label-exp-label dest))))</p><empty-line /><p>
          (lambda ()</p><empty-line /><p>
            (if (get-contents flag)</p><empty-line /><p>
                (set-contents! pc insts)</p><empty-line /><p>
                (advance-pc pc))))</p><empty-line /><p>
        (error "Bad BRANCH instruction -- ASSEMBLE" inst))))</p><empty-line /><p>(define (branch-dest branch-instruction)</p><empty-line /><p>
  (cadr branch-instruction))</p><empty-line /><empty-line /><p>

A goto instruction is similar to a branch, except that the
destination may be specified either as a label or as a register, and
there is no condition to check -- the pc is always set to the
new destination.</p>

<p>(define (make-goto inst machine labels pc)</p><empty-line /><p>
  (let ((dest (goto-dest inst)))</p><empty-line /><p>
    (cond ((label-exp? dest)</p><empty-line /><p>
           (let ((insts</p><empty-line /><p>
                  (lookup-label labels</p><empty-line /><p>
                                (label-exp-label dest))))</p><empty-line /><p>
             (lambda () (set-contents! pc insts))))</p><empty-line /><p>
          ((register-exp? dest)</p><empty-line /><p>
           (let ((reg</p><empty-line /><p>
                  (get-register machine</p><empty-line /><p>
                                (register-exp-reg dest))))</p><empty-line /><p>
             (lambda ()</p><empty-line /><p>
               (set-contents! pc (get-contents reg)))))</p><empty-line /><p>
          (else (error "Bad GOTO instruction -- ASSEMBLE"</p><empty-line /><p>
                       inst)))))</p><empty-line /><p>(define (goto-dest goto-instruction)</p><empty-line /><p>
  (cadr goto-instruction))</p><empty-line /><empty-line /><p><strong>Other instructions</strong></p>

<p>

The stack instructions save and restore simply use the
stack with the designated register and advance the pc:</p>

<p>(define (make-save inst machine stack pc)</p><empty-line /><p>
  (let ((reg (get-register machine</p><empty-line /><p>
                           (stack-inst-reg-name inst))))</p><empty-line /><p>
    (lambda ()</p><empty-line /><p>
      (push stack (get-contents reg))</p><empty-line /><p>
      (advance-pc pc))))</p><empty-line /><p>(define (make-restore inst machine stack pc)</p><empty-line /><p>
  (let ((reg (get-register machine</p><empty-line /><p>
                           (stack-inst-reg-name inst))))</p><empty-line /><p>
    (lambda ()</p><empty-line /><p>
      (set-contents! reg (pop stack))</p><empty-line /><p>
      (advance-pc pc))))</p><empty-line /><p>(define (stack-inst-reg-name stack-instruction)</p><empty-line /><p>
  (cadr stack-instruction))</p><empty-line /><empty-line /><p>

The final instruction type, handled by make-perform, generates
an execution procedure for the action to be performed.  At simulation
time, the action procedure is executed and the pc advanced.</p>

<p>(define (make-perform inst machine labels operations pc)</p><empty-line /><p>
  (let ((action (perform-action inst)))</p><empty-line /><p>
    (if (operation-exp? action)</p><empty-line /><p>
        (let ((action-proc</p><empty-line /><p>
               (make-operation-exp</p><empty-line /><p>
                action machine labels operations)))</p><empty-line /><p>
          (lambda ()</p><empty-line /><p>
            (action-proc)</p><empty-line /><p>
            (advance-pc pc)))</p><empty-line /><p>
        (error "Bad PERFORM instruction -- ASSEMBLE" inst))))</p><empty-line /><p>(define (perform-action inst) (cdr inst))</p><empty-line /><empty-line /><p><strong>Execution procedures for subexpressions</strong></p>

<p>

The value of a reg, label, or const expression
may be needed for assignment to a register (make-assign) or for input to
an operation (make-operation-exp, below).  The following procedure
generates execution procedures to produce values for these expressions
during the simulation:</p>

<p>(define (make-primitive-exp exp machine labels)</p><empty-line /><p>
  (cond ((constant-exp? exp)</p><empty-line /><p>
         (let ((c (constant-exp-value exp)))</p><empty-line /><p>
           (lambda () c)))</p><empty-line /><p>
        ((label-exp? exp)</p><empty-line /><p>
         (let ((insts</p><empty-line /><p>
                (lookup-label labels</p><empty-line /><p>
                              (label-exp-label exp))))</p><empty-line /><p>
           (lambda () insts)))</p><empty-line /><p>
        ((register-exp? exp)</p><empty-line /><p>
         (let ((r (get-register machine</p><empty-line /><p>
                                (register-exp-reg exp))))</p><empty-line /><p>
           (lambda () (get-contents r))))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (error "Unknown expression type -- ASSEMBLE" exp))))</p><empty-line /><p>
The syntax of reg, label, and const expressions
is determined by</p>

<p>(define (register-exp? exp) (tagged-list? exp 'reg))</p><empty-line /><p>(define (register-exp-reg exp) (cadr exp))</p><empty-line /><p>(define (constant-exp? exp) (tagged-list? exp 'const))</p><empty-line /><p>(define (constant-exp-value exp) (cadr exp))</p><empty-line /><p>(define (label-exp? exp) (tagged-list? exp 'label))</p><empty-line /><p>(define (label-exp-label exp) (cadr exp))</p><empty-line /><empty-line /><p>


Assign, perform, and test instructions
may include the application of a machine operation (specified by
an op expression) to some operands (specified by reg
and const expressions).
The following procedure produces an execution procedure
for an "operation expression" -- a list containing the operation and
operand expressions from the instruction:</p>

<p>(define (make-operation-exp exp machine labels operations)</p><empty-line /><p>
  (let ((op (lookup-prim (operation-exp-op exp) operations))</p><empty-line /><p>
        (aprocs</p><empty-line /><p>
         (map (lambda (e)</p><empty-line /><p>
                (make-primitive-exp e machine labels))</p><empty-line /><p>
              (operation-exp-operands exp))))</p><empty-line /><p>
    (lambda ()</p><empty-line /><p>
      (apply op (map (lambda (p) (p)) aprocs)))))</p><empty-line /><p>
The syntax of operation expressions is determined by</p>

<p>(define (operation-exp? exp)</p><empty-line /><p>
  (and (pair? exp) (tagged-list? (car exp) 'op)))</p><empty-line /><p>(define (operation-exp-op operation-exp)</p><empty-line /><p>
  (cadr (car operation-exp)))</p><empty-line /><p>(define (operation-exp-operands operation-exp)</p><empty-line /><p>
  (cdr operation-exp))</p><empty-line /><p>
Observe that the treatment of operation expressions is very much like
the treatment of procedure applications by the analyze-application procedure in the evaluator of
section 4.1.7 in that we generate an execution
procedure for each operand.  At simulation time, we call the
operand procedures and apply the Scheme procedure that simulates
the operation to the resulting values.
The simulation procedure is found by looking up the operation name in
the operation table for the machine:</p>

<p>(define (lookup-prim symbol operations)</p><empty-line /><p>
  (let ((val (assoc symbol operations)))</p><empty-line /><p>
    (if val</p><empty-line /><p>
        (cadr val)</p><empty-line /><p>
        (error "Unknown operation -- ASSEMBLE" symbol))))</p><empty-line /><empty-line /><p>
<strong>Exercise 5.9.</strong>  The treatment of machine operations above permits them to operate
on labels as well as on constants and the contents of registers.
Modify the expression-processing procedures to enforce the condition
that operations can be used only with registers and constants.</p>

<p>
<strong>Exercise 5.10.</strong>  Design a new syntax for register-machine instructions and modify the
simulator to use your new syntax.  Can you implement your new
syntax without changing any part of the simulator except the
syntax procedures in this section?</p>

<p>
<strong>Exercise 5.11.</strong>  When we introduced save and restore in
section 5.1.4, we didn't specify what would happen
if you tried to restore a register that was not the last one saved, as
in the sequence</p>

<p>(save y)</p><empty-line /><p>
(save x)</p><empty-line /><p>
(restore y)</p><empty-line /><p>
There are several reasonable possibilities for the meaning of restore:</p>

<p>

a.  (restore y) puts into y the last value saved on the
stack, regardless of what register that value came from.  This is the
way our simulator behaves.  Show how to take advantage of this
behavior to eliminate one instruction from the Fibonacci machine of
section 5.1.4 (figure 5.12).</p>

<p>

b.  (restore y) puts into y the last value saved on the
stack, but only if that value was saved from y; otherwise, it
signals an error.  Modify the simulator to behave this way.  You will
have to change save to put the register name on the stack along
with the value.</p>

<p>

c.  (restore y) puts into y the last value saved from y regardless of what other registers were saved after y and not
restored.  Modify the simulator to behave this way.  You will have to
associate a separate stack with each register.  You should make the
initialize-stack operation initialize all the register stacks.</p>

<p>
<strong>Exercise 5.12.</strong>  The simulator can be used to help determine the data paths required
for implementing a machine with a given controller.  Extend
the assembler to store the following information in the machine model:</p>

<p>a list of all instructions, with duplicates removed, sorted by
instruction type (assign, goto, and so on);</p>

<p>a list (without duplicates) of the registers used to hold entry
points (these are the registers referenced by goto
instructions);</p>

<p>a list (without duplicates) of the registers that are saved
or restored;</p>

<p>for each register, a list (without duplicates) of the sources from
which it is assigned (for example, the sources for register val
in the factorial machine of figure 5.11 are
(const 1) and ((op *) (reg n) (reg val))).</p>

<p>
Extend the
message-passing interface to the machine to provide access to this new
information.  To test your analyzer, define the Fibonacci machine from
figure 5.12 and examine the lists you constructed.</p>

<p>
<strong>Exercise 5.13.</strong>  Modify the simulator so that it uses the controller sequence to
determine what registers the machine has rather than requiring a list
of registers as an argument to make-machine.  Instead of
pre-allocating the registers in make-machine, you can allocate
them one at a time when they are first seen during assembly of the
instructions.</p>

<p><strong>5.2.4  Monitoring Machine Performance</strong></p>

<p>



Simulation is useful not only for verifying the correctness of a
proposed machine design but also for measuring the machine's
performance.  For example, we can install in our simulation program a
"meter" that measures the number of stack operations used in a
computation.  To do this, we modify our simulated stack to keep track
of the number of times registers are saved on the stack and the
maximum depth reached by the stack, and add a message to the stack's
interface that prints the statistics, as shown below.
We also add an operation to the basic machine model to print the
stack statistics, by initializing the-ops in make-new-machine to</p>

<p>(list (list 'initialize-stack</p><empty-line /><p>
            (lambda () (stack 'initialize)))</p><empty-line /><p>
      (list 'print-stack-statistics</p><empty-line /><p>
            (lambda () (stack 'print-statistics))))</p><empty-line /><p>
Here is the new version of make-stack:</p>

<p>(define (make-stack)</p><empty-line /><p>
  (let ((s '())</p><empty-line /><p>
        (number-pushes 0)</p><empty-line /><p>
        (max-depth 0)</p><empty-line /><p>
        (current-depth 0))</p><empty-line /><p>
    (define (push x)</p><empty-line /><p>
      (set! s (cons x s))</p><empty-line /><p>
      (set! number-pushes (+ 1 number-pushes))</p><empty-line /><p>
      (set! current-depth (+ 1 current-depth))</p><empty-line /><p>
      (set! max-depth (max current-depth max-depth)))</p><empty-line /><p>
    (define (pop)</p><empty-line /><p>
      (if (null? s)</p><empty-line /><p>
          (error "Empty stack -- POP")</p><empty-line /><p>
          (let ((top (car s)))</p><empty-line /><p>
            (set! s (cdr s))</p><empty-line /><p>
            (set! current-depth (- current-depth 1))</p><empty-line /><p>
            top)))</p><empty-line /><p>
    (define (initialize)</p><empty-line /><p>
      (set! s '())</p><empty-line /><p>
      (set! number-pushes 0)</p><empty-line /><p>
      (set! max-depth 0)</p><empty-line /><p>
      (set! current-depth 0)</p><empty-line /><p>
      'done)</p><empty-line /><p>
    (define (print-statistics)</p><empty-line /><p>
      (newline)</p><empty-line /><p>
      (display (list 'total-pushes  '= number-pushes</p><empty-line /><p>
                     'maximum-depth '= max-depth)))</p><empty-line /><p>
    (define (dispatch message)</p><empty-line /><p>
      (cond ((eq? message 'push) push)</p><empty-line /><p>
            ((eq? message 'pop) (pop))</p><empty-line /><p>
            ((eq? message 'initialize) (initialize))</p><empty-line /><p>
            ((eq? message 'print-statistics)</p><empty-line /><p>
             (print-statistics))</p><empty-line /><p>
            (else</p><empty-line /><p>
             (error "Unknown request -- STACK" message))))</p><empty-line /><p>
    dispatch))</p><empty-line /><empty-line /><p>

Exercises 5.15 through 5.19
describe other useful monitoring and debugging features that can be
added to the register-machine simulator.</p>

<p>
<strong>Exercise 5.14.</strong>  Measure the number of pushes and the maximum stack depth required to
compute <emphasis>n</emphasis>! for various small values of <emphasis>n</emphasis> using the factorial
machine shown in figure 5.11.  From your data
determine formulas in terms of <emphasis>n</emphasis> for the total number of push
operations and the maximum stack depth used in computing <emphasis>n</emphasis>! for any
<emphasis>n</emphasis> &gt; 1. Note that each of these is a linear function of <emphasis>n</emphasis> and is
thus determined by two constants.  In order to get the statistics
printed, you will have to augment the factorial machine with instructions to
initialize the stack and print the statistics.
You may want to also modify the
machine so that it repeatedly reads a value for <emphasis>n</emphasis>, computes the
factorial, and prints the result (as we did for the GCD machine in
figure 5.4), so that you will not have to repeatedly
invoke get-register-contents, set-register-contents!, and
start.</p>

<p>
<strong>Exercise 5.15.</strong>  Add <emphasis>instruction counting</emphasis> to the register machine simulation.
That is, have the machine model keep track of the number of
instructions executed.  Extend the machine model's interface to accept
a new message that prints the value of the instruction count and
resets the count to zero.</p>

<p>
<strong>Exercise 5.16.</strong>  Augment the simulator to provide for <emphasis>instruction tracing</emphasis>.
That is, before each instruction is executed, the simulator should print
the text of the instruction.  Make the machine model accept trace-on and
trace-off messages to turn tracing on and off.</p>

<p>
<strong>Exercise 5.17.</strong>  Extend the instruction tracing of
exercise 5.16 so that before
printing an instruction, the simulator prints any labels that
immediately precede that instruction in the controller sequence.  Be
careful to do this in a way that does not interfere with instruction
counting (exercise 5.15).
You will have to make the simulator retain the necessary label information.</p>

<p>
<strong>Exercise 5.18.</strong>  Modify the make-register procedure of
section 5.2.1 so that registers can be traced.
Registers should accept messages that turn tracing on and off.  When a
register is traced, assigning a value to the register should print the
name of the register, the old contents of the register, and the new
contents being assigned.  Extend the interface to the machine model
to permit you to turn tracing on and off for designated machine registers.</p>

<p>
<strong>Exercise 5.19.</strong>  Alyssa P. Hacker wants a <emphasis>breakpoint</emphasis> feature in the simulator to
help her debug her machine designs.  You have been hired to install
this feature for her.  She wants to be able to specify a place in the
controller sequence where the simulator will stop and allow her to
examine the state of the machine.  You are to implement a procedure</p><empty-line /><p>(set-breakpoint &lt;<emphasis>machine</emphasis>&gt; &lt;<emphasis>label</emphasis>&gt; &lt;<emphasis>n</emphasis>&gt;)</p><empty-line /><p>
that sets a breakpoint just before the <emphasis>n</emphasis>th instruction after the
given label.  For example,</p>

<p>(set-breakpoint gcd-machine 'test-b 4)</p><empty-line /><p>
installs a breakpoint in gcd-machine just before the
assignment to register a.  When the simulator reaches the
breakpoint it should print the label and the offset of the breakpoint
and stop executing instructions.  Alyssa can then use get-register-contents and set-register-contents! to manipulate
the state of the simulated machine.  She should then be able to
continue execution by saying</p>

<p>(proceed-machine &lt;<emphasis>machine</emphasis>&gt;)</p><empty-line /><p>
She should also be able to remove a specific breakpoint by means of</p>

<p>(cancel-breakpoint &lt;<emphasis>machine</emphasis>&gt; &lt;<emphasis>label</emphasis>&gt; &lt;<emphasis>n</emphasis>&gt;)</p><empty-line /><p>
or to remove all breakpoints by means of</p>

<p>(cancel-all-breakpoints &lt;<emphasis>machine</emphasis>&gt;)</p><empty-line /><empty-line /><empty-line /><empty-line /><p><sup>4</sup> Using the receive procedure here is a way to get extract-labels to effectively return two values -- labels and
insts -- without explicitly making a compound data structure to
hold them.  An alternative implementation, which returns an explicit
pair of values, is</p>

<p>(define (extract-labels text)</p><empty-line /><p>
  (if (null? text)</p><empty-line /><p>
      (cons '() '())</p><empty-line /><p>
      (let ((result (extract-labels (cdr text))))</p><empty-line /><p>
        (let ((insts (car result)) (labels (cdr result)))</p><empty-line /><p>
          (let ((next-inst (car text)))</p><empty-line /><p>
            (if (symbol? next-inst)</p><empty-line /><p>
                (cons insts</p><empty-line /><p>
                      (cons (make-label-entry next-inst insts) labels))</p><empty-line /><p>
                (cons (cons (make-instruction next-inst) insts)</p><empty-line /><p>
                      labels)))))))</p><empty-line /><p>
which would be called by assemble as follows:</p>

<p>(define (assemble controller-text machine)</p><empty-line /><p>
  (let ((result (extract-labels controller-text)))</p><empty-line /><p>
    (let ((insts (car result)) (labels (cdr result)))</p><empty-line /><p>
      (update-insts! insts labels machine)</p><empty-line /><p>
      insts)))</p><empty-line /><p>
You can consider our use of receive as demonstrating an elegant
way to return multiple values, or simply an excuse to show off a
programming trick.  An argument like receive that is the next
procedure to be invoked is called a "continuation."  Recall that we
also used continuations to implement the backtracking control
structure in the amb evaluator in section 4.3.3.</p>


</section>

<section>


<p><strong>5.3  Storage Allocation and Garbage Collection</strong></p>

<p>



In section 5.4, we will show how to implement a Scheme
evaluator as a register machine.  In order to simplify the discussion,
we will assume that our register machines can be equipped with a <emphasis>list-structured memory</emphasis>, in which the basic operations for
manipulating list-structured data are primitive.  Postulating the
existence of such a memory is a useful abstraction when one is
focusing on the mechanisms of control in a Scheme interpreter, but
this does not reflect a realistic view of the actual primitive data
operations of contemporary computers.  To obtain a more complete
picture of how a Lisp system operates, we must investigate how list
structure can be represented in a way that is compatible with
conventional computer memories.</p>

<p>

There are two considerations in implementing list structure.  The
first is purely an issue of representation: how to represent the
"box-and-pointer" structure of Lisp pairs, using only the storage
and addressing capabilities of typical computer memories.  The second
issue concerns the management of memory as a computation proceeds.
The operation of a Lisp system depends crucially on the ability to
continually create new data objects.  These include objects that are
explicitly created by the Lisp procedures being interpreted as well
as structures created by the interpreter itself, such as environments
and argument lists.  Although the constant creation of new data
objects would pose no problem on a computer with an infinite amount of
rapidly addressable memory, computer memories are available only in
finite sizes (more's the pity).  Lisp systems
thus provide an <emphasis>automatic storage allocation</emphasis> facility to
support the illusion of an infinite memory.  When a data object is no
longer needed, the memory allocated to it is automatically recycled
and used to construct new data objects.  There are various
techniques for providing such automatic storage allocation.  The
method we shall discuss in this section is called <emphasis>garbage
collection</emphasis>.</p>

<p><strong>5.3.1  Memory as Vectors</strong></p>

<p>

A conventional computer memory can be thought of as an array of
cubbyholes, each of which can contain a piece of information.  Each
cubbyhole has a unique name, called its <emphasis>address</emphasis> or <emphasis>location</emphasis>.  Typical memory systems provide two primitive operations:
one that fetches the data stored in a specified location and one that
assigns new data to a specified location.  Memory addresses can be
incremented to support sequential access to some set of the
cubbyholes.  More generally, many important data operations require
that memory addresses be treated as data, which can be stored in
memory locations and manipulated in machine registers.  The
representation of list structure is one application of such <emphasis>address arithmetic</emphasis>.</p>

<p>

To model computer memory, we use a new kind of data
structure called a <emphasis>vector</emphasis>.  Abstractly, a vector is a compound
data object whose individual elements can be accessed by means of an
integer index in an amount of time that is independent of the
index.<sup>5</sup> In order to describe memory operations, we use two
primitive Scheme procedures for manipulating vectors:</p>

<p>(vector-ref &lt;<emphasis>vector</emphasis>&gt; &lt;<emphasis>n</emphasis>&gt;) returns the <emphasis>n</emphasis>th
element of the vector.</p>

<p>(vector-set! &lt;<emphasis>vector</emphasis>&gt; &lt;<emphasis>n</emphasis>&gt; &lt;<emphasis>value</emphasis>&gt;) sets
the <emphasis>n</emphasis>th element of the vector to the designated value.</p>

<p>
For example, if v is a vector, then (vector-ref v 5) gets
the fifth entry in the vector v and (vector-set! v 5 7)
changes the value of the fifth entry of the vector v to 7.<sup>6</sup>
For computer memory, this access can be implemented
through the use of address arithmetic to combine a <emphasis>base address</emphasis>
that specifies the beginning location of a vector in memory with an
<emphasis>index</emphasis> that specifies the offset of a particular element of the vector.</p>

<p><strong>Representing Lisp data</strong></p>

<p>


We can use vectors to implement the basic pair structures required for
a list-structured memory.  Let us imagine that computer memory is
divided into two vectors: the-cars and the-cdrs.  We will
represent list structure as follows: A pointer to a pair is an index
into the two vectors.  The car of the pair is the entry in the-cars with the designated index, and the cdr of the pair is
the entry in the-cdrs with the designated index.  We also need a
representation for objects other than pairs (such as numbers and
symbols) and a way to distinguish one kind of data from another.
There are many methods of accomplishing this, but they all reduce to
using <emphasis>typed pointers</emphasis>, that is, to extending the notion of
"pointer" to include information on data type.<sup>7</sup> The data type enables the system to
distinguish a pointer to a pair (which consists of the "pair" data
type and an index into the memory vectors) from pointers to other
kinds of data (which consist of some other data type and whatever is
being used to represent data of that type).  Two data objects are
considered to be the same (eq?) if their pointers are
identical.<sup>8</sup> Figure 5.14
illustrates the use of this method to represent the list ((1 2) 3
4), whose box-and-pointer diagram is also shown.  We use letter
prefixes to denote the data-type information.  Thus, a pointer to the
pair with index 5 is denoted p5, the empty list is denoted by
the pointer e0, and a pointer to the number 4 is denoted n4.  In the box-and-pointer diagram, we have indicated at the lower
left of each pair the vector index that specifies where the car
and cdr of the pair are stored.  The blank locations in the-cars and the-cdrs may contain parts of other list
structures (not of interest here).</p>

<p><image xlink:href="#_210.jpg" /></p>

<p><strong>Figure 5.14:</strong>  Box-and-pointer and memory-vector representations 
of the list ((1 2) 3 4).</p>

<p>

A pointer to a number, such as n4,
might consist of a type indicating numeric data together with the
actual representation of the number 4.<sup>9</sup>
To deal with numbers that are too large to
be represented in the fixed amount of space allocated for a single
pointer, we could use a distinct <emphasis>bignum</emphasis> data type, for which the
pointer designates a list in which the parts of the number are
stored.<sup>10</sup></p>

<p>


A symbol might be represented as a typed pointer that designates a
sequence of the characters that form the symbol's printed representation.
This sequence is constructed by the Lisp reader when the character string
is initially encountered in input.  Since we want two instances of a
symbol to be recognized as the "same" symbol by eq? and we
want eq? to be a simple test for equality of pointers, we must
ensure that if the reader sees the same character string twice, it
will use the same pointer (to the same sequence of characters) to
represent both occurrences.  To accomplish this, the reader maintains
a table, traditionally called the <emphasis>obarray</emphasis>, of all the symbols it
has ever encountered.  When the reader encounters a character string
and is about to construct a symbol, it checks the obarray to see if it
has ever before seen the same character string.  If it has not, it
uses the characters to construct a new symbol (a typed pointer to a
new character sequence) and enters this pointer in the obarray.  If the
reader has seen the string before, it returns the symbol pointer
stored in the obarray.  This process of replacing character strings by
unique pointers is called <emphasis>interning</emphasis> symbols.</p>

<p><strong>Implementing the primitive list operations</strong></p>

<p>

Given the above representation scheme, we can replace each
"primitive" list operation of a register machine with one or more
primitive vector operations.  We will use two registers, the-cars and the-cdrs, to identify the memory vectors, and will
assume that vector-ref and vector-set! are available as
primitive operations.  We also assume that numeric operations on
pointers (such as incrementing a pointer, using a pair pointer to
index a vector, or adding two numbers) use only the index portion of
the typed pointer.</p>

<p>

For example, we can make a register machine support the instructions</p>

<p>(assign &lt;<emphasis>reg<sub>1</sub></emphasis>&gt; (op car) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;))</p><empty-line /><empty-line /><p>
(assign &lt;<emphasis>reg<sub>1</sub></emphasis>&gt; (op cdr) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;))</p><empty-line /><p>
if we implement these, respectively, as</p>

<p>(assign &lt;<emphasis>reg<sub>1</sub></emphasis>&gt; (op vector-ref) (reg the-cars) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;))</p><empty-line /><empty-line /><p>
(assign &lt;<emphasis>reg<sub>1</sub></emphasis>&gt; (op vector-ref) (reg the-cdrs) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;))</p><empty-line /><p>
The instructions</p>

<p>(perform (op set-car!) (reg &lt;<emphasis>reg<sub>1</sub></emphasis>&gt;) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;))</p><empty-line /><empty-line /><p>
(perform (op set-cdr!) (reg &lt;<emphasis>reg<sub>1</sub></emphasis>&gt;) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;))</p><empty-line /><p>
are implemented as</p>

<p>(perform</p><empty-line /><p>
 (op vector-set!) (reg the-cars) (reg &lt;<emphasis>reg<sub>1</sub></emphasis>&gt;) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;))</p><empty-line /><empty-line /><p>
(perform</p><empty-line /><p>
 (op vector-set!) (reg the-cdrs) (reg &lt;<emphasis>reg<sub>1</sub></emphasis>&gt;) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;))</p><empty-line /><empty-line /><p>

Cons is performed by allocating an unused index and storing the
arguments to cons in the-cars and the-cdrs at that
indexed vector position.  We presume that there is a special register,
free, that always holds a pair pointer containing the next
available index, and that we can increment the index part of that
pointer to find the next free location.<sup>11</sup>
For example, the instruction</p>

<p>(assign &lt;<emphasis>reg<sub>1</sub></emphasis>&gt; (op cons) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;) (reg &lt;<emphasis>reg<sub>3</sub></emphasis>&gt;))</p><empty-line /><p>
is implemented as the following sequence of vector
operations:<sup>12</sup></p>

<p>(perform</p><empty-line /><p>
 (op vector-set!) (reg the-cars) (reg free) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;))</p><empty-line /><p>
(perform</p><empty-line /><p>
 (op vector-set!) (reg the-cdrs) (reg free) (reg &lt;<emphasis>reg<sub>3</sub></emphasis>&gt;))</p><empty-line /><p>
(assign &lt;<emphasis>reg<sub>1</sub></emphasis>&gt; (reg free))</p><empty-line /><p>
(assign free (op +) (reg free) (const 1))</p><empty-line /><p>
The eq? operation</p>

<p>(op eq?) (reg &lt;<emphasis>reg<sub>1</sub></emphasis>&gt;) (reg &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;)</p><empty-line /><p>
simply tests the equality of all fields in the registers, and
predicates such as pair?, null?, symbol?, and number? need only check the type field.</p>

<p><strong>Implementing stacks</strong></p>

<p>


Although our register machines use stacks, we need do nothing special
here, since stacks can be modeled in terms of lists.  The stack can be
a list of the saved values, pointed to by a special register the-stack.  Thus, (save &lt;<emphasis>reg</emphasis>&gt;) can be implemented as</p>

<p>(assign the-stack (op cons) (reg &lt;<emphasis>reg</emphasis>&gt;) (reg the-stack))</p><empty-line /><p>
Similarly, (restore &lt;<emphasis>reg</emphasis>&gt;) can be implemented as</p>

<p>(assign &lt;<emphasis>reg</emphasis>&gt; (op car) (reg the-stack))</p><empty-line /><p>
(assign the-stack (op cdr) (reg the-stack))</p><empty-line /><p>
and (perform (op initialize-stack)) can be implemented as</p>

<p>(assign the-stack (const ()))</p><empty-line /><p>
These operations can be further expanded in terms of the vector
operations given above.  In conventional computer architectures,
however, it is usually advantageous to allocate the stack as a
separate vector.  Then pushing and popping the stack can be
accomplished by incrementing or decrementing an index into that
vector.</p>

<p>
<strong>Exercise 5.20.</strong>  Draw the box-and-pointer representation and the memory-vector
representation (as in figure 5.14) of the
list structure produced by</p>

<p>(define x (cons 1 2))</p><empty-line /><p>
(define y (list x x))</p><empty-line /><p>
with the free pointer initially p1.  What is the final
value of free ?  What pointers represent the values of x and y ?</p>

<p>
<strong>Exercise 5.21.</strong>  Implement register machines for the following procedures.
Assume that the list-structure memory operations are available as
machine primitives.</p>

<p>a. Recursive count-leaves:</p>

<p>(define (count-leaves tree)</p><empty-line /><p>
  (cond ((null? tree) 0)</p><empty-line /><p>
        ((not (pair? tree)) 1)</p><empty-line /><p>
        (else (+ (count-leaves (car tree))</p><empty-line /><p>
                 (count-leaves (cdr tree))))))</p><empty-line /><empty-line /><p>b. Recursive count-leaves with explicit counter:</p>

<p>(define (count-leaves tree)</p><empty-line /><p>
  (define (count-iter tree n)</p><empty-line /><p>
    (cond ((null? tree) n)</p><empty-line /><p>
          ((not (pair? tree)) (+ n 1))</p><empty-line /><p>
          (else (count-iter (cdr tree)</p><empty-line /><p>
                            (count-iter (car tree) n)))))</p><empty-line /><p>
  (count-iter tree 0))</p><empty-line /><empty-line /><p>
<strong>Exercise 5.22.</strong>  Exercise 3.12 of section 3.3.1
presented an append procedure that appends two lists to form a
new list and an append! procedure that splices two lists
together.  Design a register machine to implement each of these
procedures.  Assume that the list-structure memory operations are
available as primitive operations.</p>

<p><strong>5.3.2  Maintaining the Illusion of Infinite Memory</strong></p>

<p>

The representation method outlined in
section 5.3.1 solves the problem of implementing
list structure, provided that we have an infinite amount of memory.
With a real computer we will eventually run out of free space in which
to construct new pairs.<sup>13</sup>
However, most of the pairs generated in a typical
computation are used only to hold intermediate results.  After these
results are accessed, the pairs are no longer needed -- they are <emphasis>garbage</emphasis>.  For instance, the computation</p>

<p>(accumulate + 0 (filter odd? (enumerate-interval 0 n)))</p><empty-line /><p>
constructs two lists: the enumeration and the result of filtering
the enumeration.  When the accumulation is complete, these lists are
no longer needed, and the allocated memory can be reclaimed.  If we
can arrange to collect all the garbage periodically, and if this turns
out to recycle memory at about the same rate at which we construct new
pairs, we will have preserved the illusion that there is an infinite
amount of memory.</p>

<p>

In order to recycle pairs, we must have a way to determine which
allocated pairs are not needed (in the sense that their contents can
no longer influence the future of the computation).  The method we
shall examine for accomplishing this is known as <emphasis>garbage
collection</emphasis>.  Garbage collection is based on the observation that, at
any moment in a Lisp interpretation, the only objects that can
affect the future of the computation are those that can be reached by
some succession of car and cdr operations starting from
the pointers that are currently in the machine registers.<sup>14</sup>  Any memory cell
that is not so accessible may be recycled.</p>

<p>

There are many ways to perform garbage collection.  The method we
shall examine here is called <emphasis>stop-and-copy</emphasis>.  The basic idea is
to divide memory into two halves: "working memory" and "free
memory."  When cons constructs pairs, it allocates these in
working memory.  When working memory is full, we perform garbage
collection by locating all the useful pairs in working memory and
copying these into consecutive locations in free memory.  (The useful
pairs are located by tracing all the car and cdr pointers,
starting with the machine registers.)  Since we do not copy the
garbage, there will presumably be additional free memory that we can
use to allocate new pairs.  In addition, nothing in the working memory
is needed, since all the useful pairs in it have been copied.  Thus,
if we interchange the roles of working memory and free memory, we can
continue processing; new pairs will be allocated in the new working
memory (which was the old free memory).  When this is full, we can
copy the useful pairs into the new free memory (which was the old
working memory).<sup>15</sup></p>

<p><strong>Implementation of a stop-and-copy garbage collector</strong></p>

<p>

We now use our register-machine language to describe the stop-and-copy
algorithm in more detail.  We will assume that there is a register
called root that contains a pointer to a structure that
eventually points at all accessible data.  This can be arranged by
storing the contents of all the machine registers in a
pre-allocated list pointed at by root just before starting
garbage collection.<sup>16</sup> We also assume that, in addition to the
current working memory, there is free memory available into which we
can copy the useful data.  The current working memory consists of
vectors whose base addresses are in registers called the-cars
and the-cdrs, and the free memory is in registers called new-cars and new-cdrs.</p>

<p>

Garbage collection is triggered when we exhaust the free cells in the
current working memory, that is, when a cons operation attempts
to increment the free pointer beyond the end of the memory
vector.  When the garbage-collection process is complete, the root pointer will point into the new memory, all objects accessible
from the root will have been moved to the new memory, and the
free pointer will indicate the next place in the new memory
where a new pair can be allocated.  In addition, the roles of working
memory and new memory will have been interchanged -- new pairs will be
constructed in the new memory, beginning at the place indicated by
free, and the (previous) working memory will be available as the
new memory for the next garbage collection.
Figure 5.15 shows the arrangement of memory just
before and just after garbage collection.</p>

<p><image xlink:href="#_211.jpg" /></p>

<p><strong>Figure 5.15:</strong>  Reconfiguration of memory by the garbage-collection 
process.</p>

<p>

The state of the garbage-collection process is controlled by
maintaining two pointers: free and scan.  These are
initialized to point to the beginning of the new memory.  The
algorithm begins by relocating the pair pointed at by root to
the beginning of the new memory.  The pair is copied, the root
pointer is adjusted to point to the new location, and the free
pointer is incremented.  In addition, the old location of the pair is
marked to show that its contents have been moved.  This marking is
done as follows: In the car position, we place a special tag
that signals that this is an already-moved object.  (Such an object is
traditionally called a <emphasis>broken heart</emphasis>.)<sup>17</sup>  In the cdr position we place a <emphasis>forwarding
address</emphasis> that points at the location to which the object has been
moved.</p>

<p>


After relocating the root, the garbage collector enters its basic
cycle.  At each step in the algorithm, the scan pointer
(initially pointing at the relocated root) points at a pair that has
been moved to the new memory but whose car and cdr
pointers still refer to objects in the old memory.  These objects are
each relocated, and the scan pointer is incremented.  To
relocate an object (for example, the object indicated by the car
pointer of the pair we are scanning) we check to see if the object has
already been moved (as indicated by the presence of a broken-heart tag
in the car position of the object).  If the object has not
already been moved, we copy it to the place indicated by free,
update free, set up a broken heart at the object's old location,
and update the pointer to the object (in this
example, the car pointer of the pair we are scanning) to point
to the new location.  If the object has already been moved, its
forwarding address (found in the cdr position of the broken
heart) is substituted for the pointer in the pair being scanned.
Eventually, all accessible objects will have been moved and scanned,
at which point the scan pointer will overtake the free
pointer and the process will terminate.</p>

<p>

We can specify the stop-and-copy algorithm as a sequence of
instructions for a register
machine.  The basic step of relocating an object is accomplished by a
subroutine called relocate-old-result-in-new.  This
subroutine gets its argument, a pointer to the object to be relocated,
from a register named old.  It relocates the designated object
(incrementing free in the process),
puts a pointer to the relocated object into a register called new, and returns by branching to the entry point stored in the register
relocate-continue.  To begin garbage collection, we invoke this
subroutine to relocate the root pointer, after initializing free and scan.  When the relocation of root has been
accomplished, we install the new pointer as the new root and
enter the main loop of the garbage collector.</p>

<p>begin-garbage-collection</p><empty-line /><p>
  (assign free (const 0))</p><empty-line /><p>
  (assign scan (const 0))</p><empty-line /><p>
  (assign old (reg root))</p><empty-line /><p>
  (assign relocate-continue (label reassign-root))</p><empty-line /><p>
  (goto (label relocate-old-result-in-new))</p><empty-line /><p>
reassign-root</p><empty-line /><p>
  (assign root (reg new))</p><empty-line /><p>
  (goto (label gc-loop))</p><empty-line /><empty-line /><p>

In the main loop of the garbage collector we must determine whether
there are any more objects to be scanned.  We do this by testing
whether the scan pointer is coincident with the free
pointer.  If the pointers are equal, then all accessible objects have
been relocated, and we branch to gc-flip, which cleans things up
so that we can continue the interrupted computation.  If there are
still pairs to be scanned, we call the relocate subroutine to relocate
the car of the next pair (by placing the car pointer in old).  The relocate-continue register is set up so that the
subroutine will return to update the car pointer.</p>

<p>gc-loop</p><empty-line /><p>
  (test (op =) (reg scan) (reg free))</p><empty-line /><p>
  (branch (label gc-flip))</p><empty-line /><p>
  (assign old (op vector-ref) (reg new-cars) (reg scan))</p><empty-line /><p>
  (assign relocate-continue (label update-car))</p><empty-line /><p>
  (goto (label relocate-old-result-in-new))</p><empty-line /><empty-line /><p>

At update-car, we modify the car pointer of the pair being
scanned, then proceed to relocate the cdr of the pair.  We
return to update-cdr when that relocation has been accomplished.
After relocating and updating the cdr, we are finished scanning
that pair, so we continue with the main loop.</p>

<p>update-car</p><empty-line /><p>
  (perform</p><empty-line /><p>
   (op vector-set!) (reg new-cars) (reg scan) (reg new))</p><empty-line /><p>
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))</p><empty-line /><p>
  (assign relocate-continue (label update-cdr))</p><empty-line /><p>
  (goto (label relocate-old-result-in-new))</p><empty-line /><empty-line /><p>
update-cdr</p><empty-line /><p>
  (perform</p><empty-line /><p>
   (op vector-set!) (reg new-cdrs) (reg scan) (reg new))</p><empty-line /><p>
  (assign scan (op +) (reg scan) (const 1))</p><empty-line /><p>
  (goto (label gc-loop))</p><empty-line /><empty-line /><p>

The subroutine relocate-old-result-in-new relocates objects as
follows: If the object to be relocated (pointed at by old) is
not a pair, then we return the same pointer to the object unchanged
(in new).  (For example, we may be scanning a pair whose car is the number 4.  If we represent the car by n4, as
described in section 5.3.1, then we want the
"relocated" car pointer to still be n4.)  Otherwise, we
must perform the relocation.  If the car position of the pair to
be relocated contains a broken-heart tag, then the pair has in fact
already been moved, so we retrieve the forwarding address (from the
cdr position of the broken heart) and return this in new.
If the pointer in old points at a yet-unmoved pair, then we move
the pair to the first free cell in new memory (pointed at by free) and set up the broken heart by storing a broken-heart tag and
forwarding address at the old location.
Relocate-old-result-in-new uses a register oldcr
to hold the car or the cdr of the object pointed at by
old.<sup>18</sup></p>

<p>relocate-old-result-in-new</p><empty-line /><p>
  (test (op pointer-to-pair?) (reg old))</p><empty-line /><p>
  (branch (label pair))</p><empty-line /><p>
  (assign new (reg old))</p><empty-line /><p>
  (goto (reg relocate-continue))</p><empty-line /><p>
pair</p><empty-line /><p>
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))</p><empty-line /><p>
  (test (op broken-heart?) (reg oldcr))</p><empty-line /><p>
  (branch (label already-moved))</p><empty-line /><p>
  (assign new (reg free)) <emphasis>; new location for pair</emphasis></p><empty-line /><p>
  <emphasis>;; Update free pointer.</emphasis></p><empty-line /><p>
  (assign free (op +) (reg free) (const 1))</p><empty-line /><p>
  <emphasis>;; Copy the car and cdr to new memory.</emphasis></p><empty-line /><p>
  (perform (op vector-set!)</p><empty-line /><p>
           (reg new-cars) (reg new) (reg oldcr))</p><empty-line /><p>
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))</p><empty-line /><p>
  (perform (op vector-set!)</p><empty-line /><p>
           (reg new-cdrs) (reg new) (reg oldcr))</p><empty-line /><p>
  <emphasis>;; Construct the broken heart.</emphasis></p><empty-line /><p>
  (perform (op vector-set!)</p><empty-line /><p>
           (reg the-cars) (reg old) (const broken-heart))</p><empty-line /><p>
  (perform</p><empty-line /><p>
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))</p><empty-line /><p>
  (goto (reg relocate-continue))</p><empty-line /><p>
already-moved</p><empty-line /><p>
  (assign new (op vector-ref) (reg the-cdrs) (reg old))</p><empty-line /><p>
  (goto (reg relocate-continue))</p><empty-line /><empty-line /><p>

At the very end of the garbage-collection process, we interchange the
role of old and new memories by interchanging pointers: interchanging
the-cars with new-cars, and the-cdrs with new-cdrs.  We will then be ready to perform another garbage
collection the next time memory runs out.</p>

<p>gc-flip</p><empty-line /><p>
  (assign temp (reg the-cdrs))</p><empty-line /><p>
  (assign the-cdrs (reg new-cdrs))</p><empty-line /><p>
  (assign new-cdrs (reg temp))</p><empty-line /><p>
  (assign temp (reg the-cars))</p><empty-line /><p>
  (assign the-cars (reg new-cars))</p><empty-line /><p>
  (assign new-cars (reg temp))</p><empty-line /><empty-line /><empty-line /><empty-line /><p><sup>5</sup> We could represent memory as lists of items.
However, the access time would then not be independent of the index,
since accessing the <emphasis>n</emphasis>th element of a list requires <emphasis>n</emphasis> - 1 cdr
operations.</p>

<p><sup>6</sup> For completeness, we should specify a make-vector
operation that constructs vectors.  However, in the present
application we will use vectors only to model fixed divisions of the
computer memory.</p>

<p><sup>7</sup> This is
precisely the same "tagged data" idea we introduced in chapter 2 for
dealing with generic operations.  Here, however, the data types are
included at the primitive machine level rather than constructed
through the use of lists.</p>

<p><sup>8</sup> Type information may be encoded in a variety of
ways, depending on the details of the machine on which the Lisp
system is to be implemented.  The execution efficiency of Lisp
programs will be strongly dependent on how cleverly this choice is
made, but it is difficult to formulate general design rules for good
choices.  The most straightforward way to implement typed pointers is
to allocate a fixed set of bits in each pointer to be a <emphasis>type
field</emphasis> that encodes the data type.  Important questions to be
addressed in designing such a representation include the following:
How many type bits are required?  How large must the vector indices
be?  How efficiently can the primitive machine instructions be used to
manipulate the type fields of pointers?  Machines that include special
hardware for the efficient handling of type fields are said to have
<emphasis>tagged architectures</emphasis>.</p>

<p><sup>9</sup> This decision on the
representation of numbers determines whether eq?, which tests
equality of pointers, can be used to test for equality of numbers.  If
the pointer contains the number itself, then equal numbers will have
the same pointer.  But if the pointer contains the index of a location
where the number is stored, equal numbers will be guaranteed to have
equal pointers only if we are careful never to store the same number
in more than one location.</p>

<p><sup>10</sup> This is just like writing a number as a sequence of
digits, except that each "digit" is a number between 0 and the
largest number that can be stored in a single pointer.</p>

<p><sup>11</sup> There are other ways
of finding free storage.  For example, we could link together all the
unused pairs into a <emphasis>free list</emphasis>.  Our free locations are
consecutive (and hence can be accessed by incrementing a pointer)
because we are using a compacting garbage collector, as we will see in
section 5.3.2.</p>

<p><sup>12</sup> This is essentially the implementation of cons in terms of set-car! and set-cdr!, as described in
section 3.3.1.  The operation get-new-pair used in that implementation is realized here by the free pointer.</p>

<p><sup>13</sup> This may not be true eventually,
because memories may get large enough so that it would be impossible
to run out of free memory in the lifetime of the computer.  For
example, there are about 3× 10<sup>13</sup>, microseconds in a year, so
if we were to cons once per microsecond we would need about
10<sup>15</sup> cells of memory to build a machine that could operate for 30
years without running out of memory.  That much memory seems absurdly
large by today's standards, but it is not physically impossible.  On
the other hand, processors are getting faster and a future computer
may have large numbers of processors operating in parallel on a single
memory, so it may be possible to use up memory much faster than we
have postulated.</p>

<p><sup>14</sup> We
assume here that the stack is represented as a list as described in
section 5.3.1, so that items on the stack are
accessible via the pointer in the stack register.</p>

<p><sup>15</sup> This idea was invented and first implemented
by Minsky, as part of the implementation of Lisp for the PDP-1 at the
MIT Research Laboratory of Electronics.  It was further developed by
Fenichel and Yochelson (1969) for use in the Lisp implementation for
the Multics time-sharing system.  Later, Baker (1978) developed a
"real-time" version of the method, which does not require the
computation to stop during garbage collection.  Baker's idea was
extended by Hewitt, Lieberman, and Moon (see Lieberman and Hewitt
1983) to take advantage of the fact that some structure is more volatile
and other structure is more permanent.</p>

<p>

An alternative commonly used garbage-collection technique is the <emphasis>mark-sweep</emphasis> method.  This consists of tracing all the structure
accessible from the machine registers and marking each pair we reach.
We then scan all of memory, and any location that is unmarked is
"swept up" as garbage and made available for reuse.  A full
discussion of the mark-sweep method can be found in Allen 1978.</p>

<p>

The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in
use for large-memory systems because it examines only the useful part
of memory.  This is in contrast to mark-sweep, in which the sweep
phase must check all of memory.  A second advantage of stop-and-copy
is that it is a <emphasis>compacting</emphasis> garbage collector.  That is, at the
end of the garbage-collection phase the useful data will have been
moved to consecutive memory locations, with all garbage pairs
compressed out.  This can be an extremely important performance
consideration in machines with virtual memory, in which accesses to
widely separated memory addresses may require extra paging
operations.</p>

<p><sup>16</sup> This list of registers does not include
the registers used by the storage-allocation system -- root, the-cars, the-cdrs, and the other registers that will be
introduced in this section.</p>

<p><sup>17</sup> The term <emphasis>broken heart</emphasis> was coined by David Cressey, who wrote a garbage
collector for MDL, a dialect of Lisp developed at MIT during the early
1970s.</p>

<p><sup>18</sup> The garbage collector uses the low-level predicate
pointer-to-pair? instead of the list-structure pair?
operation because in a real system there might be various things
that are treated as pairs for garbage-collection purposes.
For example, in a Scheme system that conforms to the IEEE standard
a procedure object may be implemented as a special kind of "pair"
that doesn't satisfy the pair? predicate.
For simulation purposes, pointer-to-pair? can be implemented as
pair?.</p>


</section>

<section>


<p><strong>5.4  The Explicit-Control Evaluator</strong></p>

<p>



In section 5.1 we saw how to
transform simple Scheme programs into descriptions of register
machines.  We will now perform this transformation on a more complex
program, the metacircular evaluator of
sections 4.1.1-4.1.4,
which shows how
the behavior of a Scheme interpreter can be described in terms of the
procedures eval and apply.
The <emphasis>explicit-control
evaluator</emphasis> that we develop in this section shows how the underlying
procedure-calling and argument-passing mechanisms used in the
evaluation process can be described in terms of operations on
registers and stacks.  In addition, the explicit-control evaluator can
serve as an implementation of a Scheme interpreter, written in a
language that is very similar to the native machine language of
conventional computers.  The evaluator can be executed by the
register-machine simulator of section 5.2.
Alternatively, it can be used as a starting point for building a
machine-language implementation of a Scheme evaluator, or even a
special-purpose machine for evaluating Scheme expressions.
Figure 5.16 shows such a hardware implementation: a
silicon chip that acts as an evaluator for Scheme.  The chip designers
started with the data-path and controller specifications for a
register machine similar to the evaluator described in this section
and used design automation programs to construct the
integrated-circuit layout.<sup>19</sup></p>

<p><strong>Registers and operations</strong></p>

<p>


In designing the explicit-control evaluator, we must specify the
operations to be used in our register machine.  We described the
metacircular evaluator in terms of abstract syntax, using procedures
such as quoted? and make-procedure.  In implementing the
register machine, we could expand these procedures into sequences of
elementary list-structure memory operations, and implement these
operations on our register machine.  However, this would make our
evaluator very long, obscuring the basic structure with
details.  To clarify the presentation, we will include as primitive
operations of the register machine the syntax procedures given in
section 4.1.2 and the procedures for
representing environments and other run-time data given in
sections 4.1.3 and 4.1.4.
In order to completely specify an evaluator that could be programmed
in a low-level machine language or implemented in hardware, we would
replace these operations by more elementary operations, using the
list-structure implementation we described in
section 5.3.</p>

<p><image xlink:href="#_212.jpg" /></p>

<p><strong>Figure 5.16:</strong>  A silicon-chip implementation of an evaluator for
Scheme.</p>

<p>

Our Scheme evaluator register machine includes a stack and seven
registers: exp, env, val, continue, proc,
argl, and unev.  Exp is used to hold the expression
to be evaluated, and env contains the environment in which the
evaluation is to be performed.  At the end of an evaluation, val
contains the value obtained by evaluating the expression in the
designated environment.  The continue register is used to
implement recursion, as explained in
section 5.1.4.  (The evaluator needs to call
itself recursively, since evaluating an expression requires evaluating
its subexpressions.)  The registers proc, argl, and unev are used in evaluating combinations.</p>

<p>


We will not provide a data-path diagram to show how the registers and
operations of the evaluator are connected, nor will we give the
complete list of machine operations.  These are implicit in the
evaluator's controller, which will be presented in detail.</p>

<p><strong>5.4.1  The Core of the Explicit-Control Evaluator</strong></p>

<p>



The central element in the evaluator is the sequence of instructions
beginning at eval-dispatch.  This corresponds to the eval
procedure of the metacircular evaluator described in
section 4.1.1.  When the controller starts at eval-dispatch, it evaluates the expression specified by exp in
the environment specified by env.  When evaluation is complete,
the controller will go to the entry point stored in continue, and the
val register will hold the value of the expression.  As with the
metacircular eval, the structure of eval-dispatch is a
case analysis on the syntactic type of the expression to be
evaluated.<sup>20</sup></p>

<p>eval-dispatch</p><empty-line /><p>
  (test (op self-evaluating?) (reg exp))</p><empty-line /><p>
  (branch (label ev-self-eval))</p><empty-line /><p>
  (test (op variable?) (reg exp))</p><empty-line /><p>
  (branch (label ev-variable))</p><empty-line /><p>
  (test (op quoted?) (reg exp))</p><empty-line /><p>
  (branch (label ev-quoted))</p><empty-line /><p>
  (test (op assignment?) (reg exp))</p><empty-line /><p>
  (branch (label ev-assignment))</p><empty-line /><p>
  (test (op definition?) (reg exp))</p><empty-line /><p>
  (branch (label ev-definition))</p><empty-line /><p>
  (test (op if?) (reg exp))</p><empty-line /><p>
  (branch (label ev-if))</p><empty-line /><p>
  (test (op lambda?) (reg exp))</p><empty-line /><p>
  (branch (label ev-lambda))</p><empty-line /><p>
  (test (op begin?) (reg exp))</p><empty-line /><p>
  (branch (label ev-begin))</p><empty-line /><p>
  (test (op application?) (reg exp))</p><empty-line /><p>
  (branch (label ev-application))</p><empty-line /><p>
  (goto (label unknown-expression-type))</p><empty-line /><empty-line /><p><strong>Evaluating simple expressions</strong></p>

<p>


Numbers and strings (which are self-evaluating),
variables, quotations, and lambda expressions have no
subexpressions to be evaluated.  For these, the evaluator simply
places the correct value in the val register and continues
execution at the entry point specified by continue.  Evaluation
of simple expressions is performed by the following controller code:</p>

<p>ev-self-eval</p><empty-line /><p>
  (assign val (reg exp))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><p>ev-variable</p><empty-line /><p>
  (assign val (op lookup-variable-value) (reg exp) (reg env))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><p>ev-quoted</p><empty-line /><p>
  (assign val (op text-of-quotation) (reg exp))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><p>ev-lambda</p><empty-line /><p>
  (assign unev (op lambda-parameters) (reg exp))</p><empty-line /><p>
  (assign exp (op lambda-body) (reg exp))</p><empty-line /><p>
  (assign val (op make-procedure)</p><empty-line /><p>
              (reg unev) (reg exp) (reg env))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><p>
Observe how ev-lambda uses the unev and exp
registers to hold the parameters and body of the lambda expression so
that they can be passed to the make-procedure operation, along
with the environment in env.</p>

<p><strong>Evaluating procedure applications</strong></p>

<p>


A procedure application is specified by a combination containing an
operator and operands.  The operator is a subexpression whose value is
a procedure, and the operands are subexpressions whose values are the
arguments to which the procedure should be applied.  The metacircular
eval handles applications by calling itself recursively to
evaluate each element of the combination, and then passing the results
to apply, which performs the actual procedure application.  The
explicit-control evaluator does the same thing; these recursive calls
are implemented by goto instructions, together with use of the
stack to save registers that will be restored after the recursive call
returns.  Before each call we will be careful to identify which
registers must be saved (because their values will be needed
later).<sup>21</sup></p>

<p>

We begin the evaluation of an application by evaluating the operator
to produce a procedure, which will later be applied to the evaluated
operands.  To evaluate the operator, we move it to the exp
register and go to eval-dispatch.  The environment in the env register is already the correct one in which to evaluate the
operator.  However, we save env because we will need it later to
evaluate the operands.  We also extract the operands into unev
and save this on the stack.  We set up continue so that eval-dispatch will resume at ev-appl-did-operator after the
operator has been evaluated.  First, however, we save the old value of
continue, which tells the controller where to continue after the
application.</p>

<p>ev-application</p><empty-line /><p>
  (save continue)</p><empty-line /><p>
  (save env)</p><empty-line /><p>
  (assign unev (op operands) (reg exp))</p><empty-line /><p>
  (save unev)</p><empty-line /><p>
  (assign exp (op operator) (reg exp))</p><empty-line /><p>
  (assign continue (label ev-appl-did-operator))</p><empty-line /><p>
  (goto (label eval-dispatch))</p><empty-line /><empty-line /><p>

Upon returning from evaluating the operator subexpression, we proceed
to evaluate the operands of the combination and to accumulate the
resulting arguments in a list, held in argl.  First we restore
the unevaluated operands and the environment.  We initialize argl to an empty list.  Then we assign to the proc register the
procedure that was produced by evaluating the operator.  If there are
no operands, we go directly to apply-dispatch.  Otherwise we
save proc on the stack and start the argument-evaluation
loop:<sup>22</sup></p>

<p>ev-appl-did-operator</p><empty-line /><p>
  (restore unev)                  <emphasis>; the operands</emphasis></p><empty-line /><p>
  (restore env)</p><empty-line /><p>
  (assign argl (op empty-arglist))</p><empty-line /><p>
  (assign proc (reg val))         <emphasis>; the operator</emphasis></p><empty-line /><p>
  (test (op no-operands?) (reg unev))</p><empty-line /><p>
  (branch (label apply-dispatch))</p><empty-line /><p>
  (save proc)</p><empty-line /><empty-line /><p>

Each cycle of the argument-evaluation loop evaluates an operand
from the list in unev and accumulates the result into argl.
To evaluate an operand, we place it in the exp register
and go to eval-dispatch, after setting continue so that
execution will resume with the argument-accumulation phase.  But first
we save the arguments accumulated so far (held in argl), the
environment (held in env), and the remaining operands to be evaluated
(held in unev).  A special case is made for the evaluation of the
last operand, which is handled at ev-appl-last-arg.</p>

<p>ev-appl-operand-loop</p><empty-line /><p>
  (save argl)</p><empty-line /><p>
  (assign exp (op first-operand) (reg unev))</p><empty-line /><p>
  (test (op last-operand?) (reg unev))</p><empty-line /><p>
  (branch (label ev-appl-last-arg))</p><empty-line /><p>
  (save env)</p><empty-line /><p>
  (save unev)</p><empty-line /><p>
  (assign continue (label ev-appl-accumulate-arg))</p><empty-line /><p>
  (goto (label eval-dispatch))</p><empty-line /><empty-line /><p>

When an operand has been evaluated, the value is accumulated into the
list held in argl.  The operand is then removed from the list of
unevaluated operands in unev, and the argument-evaluation continues.</p>

<p>ev-appl-accumulate-arg</p><empty-line /><p>
  (restore unev)</p><empty-line /><p>
  (restore env)</p><empty-line /><p>
  (restore argl)</p><empty-line /><p>
  (assign argl (op adjoin-arg) (reg val) (reg argl))</p><empty-line /><p>
  (assign unev (op rest-operands) (reg unev))</p><empty-line /><p>
  (goto (label ev-appl-operand-loop))</p><empty-line /><empty-line /><p>

Evaluation of the last argument is handled differently.  There is no
need to save the environment or the list of unevaluated operands
before going to eval-dispatch,
since they will not be required after the last operand is evaluated.
Thus, we return from the evaluation to a special entry point ev-appl-accum-last-arg, which restores the argument list, accumulates
the new argument, restores the saved procedure, and goes off to
perform the application.<sup>23</sup></p>

<p>ev-appl-last-arg</p><empty-line /><p>
  (assign continue (label ev-appl-accum-last-arg))</p><empty-line /><p>
  (goto (label eval-dispatch))</p><empty-line /><p>
ev-appl-accum-last-arg</p><empty-line /><p>
  (restore argl)</p><empty-line /><p>
  (assign argl (op adjoin-arg) (reg val) (reg argl))</p><empty-line /><p>
  (restore proc)</p><empty-line /><p>
  (goto (label apply-dispatch))</p><empty-line /><empty-line /><p>

The details of the argument-evaluation loop determine the order in
which the interpreter evaluates the operands of a combination (e.g.,
left to right or right to left -- see
exercise 3.8).  This order is not determined
by the metacircular evaluator, which inherits its control structure
from the underlying Scheme in which it is implemented.<sup>24</sup> Because the first-operand
selector (used in ev-appl-operand-loop to extract successive operands
from unev) is implemented as car and the rest-operands selector is implemented as cdr, the
explicit-control evaluator will evaluate the operands of a combination
in left-to-right order.</p>

<p><strong>Procedure application</strong></p>

<p>

The entry point apply-dispatch corresponds to the apply
procedure of the metacircular evaluator.  By the time we get to apply-dispatch, the proc register contains the procedure to
apply and argl contains the list of evaluated arguments to which
it must be applied.  The saved value of continue (originally
passed to eval-dispatch and saved at ev-application),
which tells where to return with the result of the procedure
application, is on the stack.  When the application is complete, the
controller transfers to the entry point specified by the saved continue, with the result of the application in val.  As with
the metacircular apply, there are two cases to consider.  Either
the procedure to be applied is a primitive or it is a compound
procedure.</p>

<p>apply-dispatch</p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-apply))</p><empty-line /><p>
  (test (op compound-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label compound-apply))</p><empty-line /><p>
  (goto (label unknown-procedure-type))</p><empty-line /><empty-line /><p>

We assume that each primitive is implemented so as to obtain its
arguments from argl and place its result in val.  To
specify how the machine handles primitives, we would have to provide a
sequence of controller instructions to implement each primitive and
arrange for primitive-apply to dispatch to the
instructions for the primitive identified by the
contents of proc.  Since we are interested in the structure of
the evaluation process rather than the details of the primitives, we
will instead just use an apply-primitive-procedure operation
that applies the procedure in proc to the arguments in argl.  For the purpose of simulating the evaluator with the simulator
of section 5.2 we use the procedure apply-primitive-procedure, which calls on the underlying Scheme
system to perform the application, just as we did for the metacircular
evaluator in section 4.1.4.  After computing the
value of the primitive application, we restore continue and go
to the designated entry point.</p>

<p>primitive-apply</p><empty-line /><p>
  (assign val (op apply-primitive-procedure)</p><empty-line /><p>
              (reg proc)</p><empty-line /><p>
              (reg argl))</p><empty-line /><p>
  (restore continue)</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><empty-line /><p>

To apply a compound procedure, we proceed just as with the
metacircular evaluator.  We construct a frame that binds the
procedure's parameters to the arguments, use this frame to
extend the environment carried by the procedure, and evaluate in this
extended environment the sequence of expressions that forms the body
of the procedure.  Ev-sequence, described below in
section 5.4.2, handles the evaluation
of the sequence.</p>

<p>compound-apply</p><empty-line /><p>
  (assign unev (op procedure-parameters) (reg proc))</p><empty-line /><p>
  (assign env (op procedure-environment) (reg proc))</p><empty-line /><p>
  (assign env (op extend-environment)</p><empty-line /><p>
              (reg unev) (reg argl) (reg env))</p><empty-line /><p>
  (assign unev (op procedure-body) (reg proc))</p><empty-line /><p>
  (goto (label ev-sequence))</p><empty-line /><empty-line /><p>

Compound-apply is the only place in the interpreter where the
env register is ever assigned a new value.  Just as in the
metacircular evaluator, the new environment is constructed from the
environment carried by the procedure, together with the argument list
and the corresponding list of variables to be bound.</p>

<p><strong>5.4.2  Sequence Evaluation and Tail Recursion</strong></p>

<p>



The portion of the explicit-control evaluator at ev-sequence is
analogous to the metacircular evaluator's eval-sequence procedure.  It
handles sequences of expressions in procedure bodies or in explicit
begin expressions.</p>

<p>

Explicit begin expressions are evaluated by placing the sequence
of expressions to be evaluated in unev, saving continue on the
stack, and jumping to ev-sequence.</p>

<p>ev-begin</p><empty-line /><p>
  (assign unev (op begin-actions) (reg exp))</p><empty-line /><p>
  (save continue)</p><empty-line /><p>
  (goto (label ev-sequence))</p><empty-line /><p>
The implicit sequences in procedure bodies are handled by jumping to
ev-sequence from compound-apply, at which point continue is already on the stack, having been saved at
ev-application.</p>

<p>

The entries at ev-sequence
and ev-sequence-continue form a loop that
successively evaluates each expression in a sequence.  The list of
unevaluated expressions is kept in unev.  Before evaluating each
expression, we check to see if there are additional expressions to be
evaluated in the sequence.  If so, we save the rest of the unevaluated
expressions (held in unev) and the environment in which these
must be evaluated (held in env) and call eval-dispatch to
evaluate the expression.  The two saved registers are restored upon
the return from this evaluation, at ev-sequence-continue.</p>

<p>

The final expression in the sequence is handled differently, at the
entry point ev-sequence-last-exp.  Since there are no more
expressions to be evaluated after this one, we need not save unev or env before going to eval-dispatch.  The value of
the whole sequence is the value of the last expression, so after the
evaluation of the last expression there is nothing left to do except
continue at the entry point currently held on the stack (which was saved
by ev-application or ev-begin.)
Rather than setting up continue to arrange for eval-dispatch to return here and then restoring continue from
the stack and continuing at that entry point, we restore continue from
the stack before going to eval-dispatch, so that eval-dispatch will continue at that entry point after evaluating the
expression.</p>

<p>ev-sequence</p><empty-line /><p>
  (assign exp (op first-exp) (reg unev))</p><empty-line /><p>
  (test (op last-exp?) (reg unev))</p><empty-line /><p>
  (branch (label ev-sequence-last-exp))</p><empty-line /><p>
  (save unev)</p><empty-line /><p>
  (save env)</p><empty-line /><p>
  (assign continue (label ev-sequence-continue))</p><empty-line /><p>
  (goto (label eval-dispatch))</p><empty-line /><p>
ev-sequence-continue</p><empty-line /><p>
  (restore env)</p><empty-line /><p>
  (restore unev)</p><empty-line /><p>
  (assign unev (op rest-exps) (reg unev))</p><empty-line /><p>
  (goto (label ev-sequence))</p><empty-line /><p>
ev-sequence-last-exp</p><empty-line /><p>
  (restore continue)</p><empty-line /><p>
  (goto (label eval-dispatch))</p><empty-line /><empty-line /><p><strong>Tail recursion</strong></p>

<p>


In chapter 1 we said that the process described by a procedure such as</p>

<p>(define (sqrt-iter guess x)</p><empty-line /><p>
  (if (good-enough? guess x)</p><empty-line /><p>
      guess</p><empty-line /><p>
      (sqrt-iter (improve guess x)</p><empty-line /><p>
                 x)))</p><empty-line /><p>
is an iterative process.  Even though the procedure is syntactically
recursive (defined in terms of itself), it is not logically necessary
for an evaluator to save information in passing from one call to sqrt-iter to the next.<sup>25</sup> An evaluator that can
execute a procedure such as sqrt-iter without requiring
increasing storage as the procedure continues to call itself is called
a <emphasis>tail-recursive</emphasis> evaluator.  The metacircular implementation of
the evaluator in chapter 4 does not specify whether the evaluator is
tail-recursive, because that evaluator inherits its mechanism for
saving state from the underlying Scheme.  With the explicit-control
evaluator, however, we can trace through the evaluation process to see
when procedure calls cause a net accumulation of information on the
stack.</p>

<p>


Our evaluator is tail-recursive, because in order to evaluate the final
expression of a sequence we transfer directly to eval-dispatch without
saving any information on the stack.  Hence, evaluating the final expression
in a sequence -- even if it is a procedure call (as in sqrt-iter, where
the if expression, which is the last expression in the procedure body,
reduces to a call to sqrt-iter) -- will not cause any information to be
accumulated on the stack.<sup>26</sup></p>

<p>

If we did not think to take advantage of the fact that it was
unnecessary to save information in this case, we might have
implemented eval-sequence by treating all the expressions in a
sequence in the same way -- saving the registers, evaluating the expression,
returning to restore the registers, and repeating this until all the
expressions have been evaluated:<sup>27</sup></p>

<p>ev-sequence</p><empty-line /><p>
  (test (op no-more-exps?) (reg unev))</p><empty-line /><p>
  (branch (label ev-sequence-end))</p><empty-line /><p>
  (assign exp (op first-exp) (reg unev))</p><empty-line /><p>
  (save unev)</p><empty-line /><p>
  (save env)</p><empty-line /><p>
  (assign continue (label ev-sequence-continue))</p><empty-line /><p>
  (goto (label eval-dispatch))</p><empty-line /><p>
ev-sequence-continue</p><empty-line /><p>
  (restore env)</p><empty-line /><p>
  (restore unev)</p><empty-line /><p>
  (assign unev (op rest-exps) (reg unev))</p><empty-line /><p>
  (goto (label ev-sequence))</p><empty-line /><p>
ev-sequence-end</p><empty-line /><p>
  (restore continue)</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><empty-line /><p>


This may seem like a minor change to our previous code for evaluation
of a sequence:  The only difference is that we go through the
save-restore cycle for the last expression in a sequence as well as
for the
others.  The interpreter will still give the same value for
any expression.  But this change is fatal to the tail-recursive
implementation, because we must now return after evaluating the final
expression in a sequence in order to undo the (useless) register
saves.  These extra saves will accumulate during a nest of procedure
calls.  Consequently, processes such as sqrt-iter will require
space proportional to the number of iterations rather than requiring
constant space.  This difference can be significant.  For example,
with tail recursion, an infinite loop can be expressed using only the
procedure-call mechanism:</p>

<p>(define (count n)</p><empty-line /><p>
  (newline)</p><empty-line /><p>
  (display n)</p><empty-line /><p>
  (count (+ n 1)))</p><empty-line /><p>
Without tail recursion, such a procedure would eventually run out of
stack space, and expressing a true iteration would require some
control mechanism other than procedure call.</p>

<p><strong>5.4.3  Conditionals, Assignments, and Definitions</strong></p>

<p>

As with the metacircular evaluator, special forms are handled by
selectively evaluating fragments of the expression.  For an if
expression, we must evaluate the predicate and decide, based on the
value of predicate, whether to evaluate the consequent or the
alternative.</p>

<p>

Before evaluating the predicate, we save the if expression
itself so that we can later extract the consequent or alternative.  We
also save the environment, which we will need later in order to
evaluate the consequent or the alternative, and we save continue, which we will need later in order to return to the
evaluation of the expression that is waiting for the value of the if.</p>

<p>ev-if</p><empty-line /><p>
  (save exp)                    <emphasis>; save expression for later</emphasis></p><empty-line /><p>
  (save env)</p><empty-line /><p>
  (save continue)</p><empty-line /><p>
  (assign continue (label ev-if-decide))</p><empty-line /><p>
  (assign exp (op if-predicate) (reg exp))</p><empty-line /><p>
  (goto (label eval-dispatch))  <emphasis>; evaluate the predicate</emphasis></p><empty-line /><empty-line /><p>


When we return from evaluating the predicate, we test whether it was
true or false and, depending on the result, place either the
consequent or the alternative in exp before going to eval-dispatch.  Notice that restoring env and continue
here sets up eval-dispatch to have the correct environment and
to continue at the right place to receive the value of the if
expression.</p>

<p>ev-if-decide</p><empty-line /><p>
  (restore continue)</p><empty-line /><p>
  (restore env)</p><empty-line /><p>
  (restore exp)</p><empty-line /><p>
  (test (op true?) (reg val))</p><empty-line /><p>
  (branch (label ev-if-consequent))</p><empty-line /><empty-line /><p>
ev-if-alternative</p><empty-line /><p>
  (assign exp (op if-alternative) (reg exp))</p><empty-line /><p>
  (goto (label eval-dispatch))</p><empty-line /><p>
ev-if-consequent</p><empty-line /><p>
  (assign exp (op if-consequent) (reg exp))</p><empty-line /><p>
  (goto (label eval-dispatch))</p><empty-line /><empty-line /><p><strong>Assignments and definitions</strong></p>

<p>

Assignments are handled by ev-assignment, which is reached from
eval-dispatch with the assignment expression in exp.  The code at ev-assignment first evaluates the value part of the expression and
then installs the new value in the environment.  Set-variable-value! is assumed to be available as a machine
operation.</p>

<p>ev-assignment</p><empty-line /><p>
  (assign unev (op assignment-variable) (reg exp))</p><empty-line /><p>
  (save unev)                   <emphasis>; save variable for later</emphasis></p><empty-line /><p>
  (assign exp (op assignment-value) (reg exp))</p><empty-line /><p>
  (save env)</p><empty-line /><p>
  (save continue)</p><empty-line /><p>
  (assign continue (label ev-assignment-1))</p><empty-line /><p>
  (goto (label eval-dispatch))  <emphasis>; evaluate the assignment value</emphasis></p><empty-line /><p>
ev-assignment-1</p><empty-line /><p>
  (restore continue)</p><empty-line /><p>
  (restore env)</p><empty-line /><p>
  (restore unev)</p><empty-line /><p>
  (perform</p><empty-line /><p>
   (op set-variable-value!) (reg unev) (reg val) (reg env))</p><empty-line /><p>
  (assign val (const ok))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><empty-line /><p>


Definitions are handled in a similar way:</p>

<p>ev-definition</p><empty-line /><p>
  (assign unev (op definition-variable) (reg exp))</p><empty-line /><p>
  (save unev)                   <emphasis>; save variable for later</emphasis></p><empty-line /><p>
  (assign exp (op definition-value) (reg exp))</p><empty-line /><p>
  (save env)</p><empty-line /><p>
  (save continue)</p><empty-line /><p>
  (assign continue (label ev-definition-1))</p><empty-line /><p>
  (goto (label eval-dispatch))  <emphasis>; evaluate the definition value</emphasis></p><empty-line /><p>
ev-definition-1</p><empty-line /><p>
  (restore continue)</p><empty-line /><p>
  (restore env)</p><empty-line /><p>
  (restore unev)</p><empty-line /><p>
  (perform</p><empty-line /><p>
   (op define-variable!) (reg unev) (reg val) (reg env))</p><empty-line /><p>
  (assign val (const ok))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><empty-line /><p>
<strong>Exercise 5.23.</strong>  Extend the evaluator to handle derived expressions such as cond,
let, and so on (section 4.1.2).
You may "cheat" and assume that the syntax
transformers such as cond-&gt;if are available as machine
operations.<sup>28</sup></p>

<p>
<strong>Exercise 5.24.</strong>  Implement cond as a new basic special form without
reducing it to if.  You will have to construct a loop that tests
the predicates of successive cond clauses until you find one
that is true, and then use ev-sequence to evaluate the actions
of the clause.</p>

<p>
<strong>Exercise 5.25.</strong>  Modify the evaluator so that it uses normal-order evaluation,
based on the lazy evaluator of section 4.2.</p>

<p><strong>5.4.4  Running the Evaluator</strong></p>

<p>



With the implementation of the explicit-control evaluator we come to
the end of a development, begun in chapter 1, in which we have
explored successively more precise models of the evaluation process.
We started with the relatively informal substitution model, then
extended this in chapter 3 to the environment model, which enabled us
to deal with state and change.  In the metacircular evaluator of
chapter 4, we used Scheme itself as a language for making more explicit
the environment structure constructed during evaluation of an
expression.  Now, with register machines, we have taken a close look
at the evaluator's mechanisms for storage management,
argument passing, and control.  At
each new level of description, we have had to raise issues and resolve
ambiguities that were not apparent at the previous, less precise
treatment of evaluation.  To understand the behavior of the
explicit-control evaluator, we can simulate it and monitor its
performance.</p>

<p>


We will install a driver loop in our evaluator machine.  This plays
the role of the driver-loop procedure of
section 4.1.4.  The evaluator will repeatedly print a
prompt, read an expression, evaluate the expression by going to eval-dispatch, and print the result.  The following instructions form
the beginning of the explicit-control evaluator's controller
sequence:<sup>29</sup></p>

<p>read-eval-print-loop</p><empty-line /><p>
  (perform (op initialize-stack))</p><empty-line /><p>
  (perform</p><empty-line /><p>
   (op prompt-for-input) (const ";;; EC-Eval input:"))</p><empty-line /><p>
  (assign exp (op read))</p><empty-line /><p>
  (assign env (op get-global-environment))</p><empty-line /><p>
  (assign continue (label print-result))</p><empty-line /><p>
  (goto (label eval-dispatch))</p><empty-line /><p>print-result</p><empty-line /><p>
  (perform</p><empty-line /><p>
   (op announce-output) (const ";;; EC-Eval value:"))</p><empty-line /><p>
  (perform (op user-print) (reg val))</p><empty-line /><p>
  (goto (label read-eval-print-loop))</p><empty-line /><empty-line /><p>

When we encounter an error in a procedure (such as the "unknown
procedure type error" indicated at apply-dispatch), we print an
error message and return to the driver loop.<sup>30</sup></p>

<p>unknown-expression-type</p><empty-line /><p>
  (assign val (const unknown-expression-type-error))</p><empty-line /><p>
  (goto (label signal-error))</p><empty-line /><p>unknown-procedure-type</p><empty-line /><p>
  (restore continue)    <emphasis>; clean up stack (from apply-dispatch)</emphasis></p><empty-line /><p>
  (assign val (const unknown-procedure-type-error))</p><empty-line /><p>
  (goto (label signal-error))</p><empty-line /><p>signal-error</p><empty-line /><p>
  (perform (op user-print) (reg val))</p><empty-line /><p>
  (goto (label read-eval-print-loop))</p><empty-line /><empty-line /><p>

For the purposes of the simulation, we initialize the stack each time
through the driver loop, since it might not be empty after an error
(such as an undefined variable) interrupts an evaluation.<sup>31</sup></p>

<p>

If we combine all the code fragments presented in sections
5.4.1-5.4.4, we can create an
evaluator machine model that we can run using the register-machine simulator
of section 5.2.</p>

<p>(define eceval</p><empty-line /><p>
  (make-machine</p><empty-line /><p>
   '(exp env val proc argl continue unev)</p><empty-line /><p>
   eceval-operations</p><empty-line /><p>
  '(</p><empty-line /><p>
    read-eval-print-loop</p><empty-line /><p>
      &lt;<emphasis>entire machine controller as given above</emphasis>&gt;</p><empty-line /><p>
   )))</p><empty-line /><p>
We must define Scheme procedures to simulate the
operations used as primitives by the evaluator.  These are
the same procedures we used for the metacircular evaluator in
section 4.1, together with the few additional ones
defined in footnotes throughout section 5.4.</p>

<p>(define eceval-operations</p><empty-line /><p>
  (list (list 'self-evaluating? self-evaluating)</p><empty-line /><p>
        <emphasis>&lt;complete list of operations for eceval machine&gt;</emphasis>))</p><empty-line /><empty-line /><p>


Finally, we can initialize the global environment and run the evaluator:</p>

<p>(define the-global-environment (setup-environment))</p><empty-line /><empty-line /><p>
(start eceval)</p><empty-line /><p><emphasis>;;; EC-Eval input:</emphasis></p><empty-line /><p>
(define (append x y)</p><empty-line /><p>
  (if (null? x)</p><empty-line /><p>
      y</p><empty-line /><p>
      (cons (car x)</p><empty-line /><p>
            (append (cdr x) y))))</p><empty-line /><p><emphasis>;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><p><emphasis>;;; EC-Eval input:</emphasis></p><empty-line /><p>
(append '(a b c) '(d e f))</p><empty-line /><p><emphasis>;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>(a b c d e f)</emphasis></p><empty-line /><empty-line /><p>

Of course, evaluating expressions in this way will take much longer
than if we had directly typed them into Scheme, because of the
multiple levels of simulation involved.  Our expressions are evaluated
by the explicit-control-evaluator machine, which is being simulated by
a Scheme program, which is itself being evaluated by the Scheme
interpreter.</p>

<p><strong>Monitoring the performance of the evaluator</strong></p>

<p>


Simulation can be a powerful tool to guide the implementation of
evaluators.  Simulations make it easy not only to explore variations
of the register-machine design but also to monitor the performance of
the simulated evaluator.  For example, one important factor in
performance is how efficiently the evaluator uses the stack.  We can
observe the number of stack operations required to evaluate various
expressions by defining the evaluator register machine with the
version of the simulator that collects statistics on stack use
(section 5.2.4), and adding an instruction at the
evaluator's print-result entry point to print the
statistics:</p>

<p>print-result</p><empty-line /><p>
  (perform (op print-stack-statistics))<emphasis>; added instruction</emphasis></p><empty-line /><p>
  (perform</p><empty-line /><p>
   (op announce-output) (const ";;; EC-Eval value:"))</p><empty-line /><p>
  ... <emphasis>; same as before</emphasis></p><empty-line /><p>
Interactions with the evaluator now look like this:</p>

<p><emphasis>;;; EC-Eval input:</emphasis></p><empty-line /><p>
(define (factorial n)</p><empty-line /><p>
  (if (= n 1)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* (factorial (- n 1)) n)))</p><empty-line /><p><emphasis>(total-pushes = 3 maximum-depth = 3)</emphasis></p><empty-line /><p><emphasis>;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><p><emphasis>;;; EC-Eval input:</emphasis></p><empty-line /><p>
(factorial 5)</p><empty-line /><p><emphasis>(total-pushes = 144 maximum-depth = 28)</emphasis></p><empty-line /><p><emphasis>;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>120</emphasis></p><empty-line /><p>
Note that the driver loop of the evaluator reinitializes the stack
at the start of
each interaction, so that the statistics printed will refer only to
stack operations used to evaluate the previous expression.</p>

<p>
<strong>Exercise 5.26.</strong>  Use the monitored stack to explore the tail-recursive property of the
evaluator (section 5.4.2).  Start the
evaluator and define the iterative factorial procedure from
section 1.2.1:</p>

<p>(define (factorial n)</p><empty-line /><p>
  (define (iter product counter)</p><empty-line /><p>
    (if (&gt; counter n)</p><empty-line /><p>
        product</p><empty-line /><p>
        (iter (* counter product)</p><empty-line /><p>
              (+ counter 1))))</p><empty-line /><p>
  (iter 1 1))</p><empty-line /><p>
Run the procedure with some small values of <emphasis>n</emphasis>.  Record the maximum
stack depth and the number of pushes required to compute <emphasis>n</emphasis>! for each of
these values.</p>

<p>a.  You will find that the maximum depth required to evaluate <emphasis>n</emphasis>! is
independent of <emphasis>n</emphasis>.  What is that depth?</p>

<p>b.  Determine from your data a formula in terms of <emphasis>n</emphasis> for the total
number of push operations used in evaluating <emphasis>n</emphasis>! for any <emphasis>n</emphasis> &gt; 1.
Note that the number of operations used is a linear function of <emphasis>n</emphasis>
and is thus determined by two constants.</p>

<p>
<strong>Exercise 5.27.</strong>  For comparison with exercise 5.26, explore the
behavior of the following procedure for computing factorials
recursively:</p>

<p>(define (factorial n)</p><empty-line /><p>
  (if (= n 1)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* (factorial (- n 1)) n)))</p><empty-line /><p>
By running this procedure with the monitored stack, determine, as a
function of <emphasis>n</emphasis>, the maximum depth of the stack and the total number
of pushes used in evaluating <emphasis>n</emphasis>! for <emphasis>n</emphasis> &gt; 1.  (Again, these functions
will be linear.)  Summarize your experiments by filling in the
following table with the appropriate expressions in terms of <emphasis>n</emphasis>:</p>

<p>Maximum depth</p>

<p>Number of pushes</p>

<p>Recursive</p>

<p>factorial</p>

<p>Iterative</p>

<p>factorial</p>

<p>

The maximum depth is a measure of the amount of space used by the
evaluator in carrying out the computation, and the number of pushes
correlates well with the time required.</p><empty-line /><p>
<strong>Exercise 5.28.</strong>  Modify the definition of the evaluator by changing
eval-sequence as described in
section 5.4.2 so that the evaluator is no
longer tail-recursive.  Rerun your experiments from
exercises 5.26 and 5.27 to demonstrate
that both versions of the factorial procedure now require space
that grows linearly with their input.</p>

<p>
<strong>Exercise 5.29.</strong>  Monitor the stack operations in the tree-recursive Fibonacci computation:</p>

<p>(define (fib n)</p><empty-line /><p>
  (if (&lt; n 2)</p><empty-line /><p>
      n</p><empty-line /><p>
      (+ (fib (- n 1)) (fib (- n 2)))))</p><empty-line /><p>
a.  Give a formula in terms of <emphasis>n</emphasis> for the maximum depth of the stack
required to compute  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>) for <emphasis>n</emphasis> &gt; 2.  Hint: In
section 1.2.2 we argued that the space used by this
process grows linearly with <emphasis>n</emphasis>.</p>

<p>b.  Give a formula for the total number of pushes used to compute
 <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>) for <emphasis>n</emphasis> &gt; 2.  You should find that the number of
pushes (which correlates well with the time used) grows exponentially
with <emphasis>n</emphasis>.  Hint: Let <emphasis>S</emphasis>(<emphasis>n</emphasis>) be the number of pushes used in computing
 <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis>).  You should be able to argue that there is a formula
that expresses <emphasis>S</emphasis>(<emphasis>n</emphasis>) in terms of <emphasis>S</emphasis>(<emphasis>n</emphasis> - 1), <emphasis>S</emphasis>(<emphasis>n</emphasis> - 2), and some fixed
"overhead" constant <emphasis>k</emphasis> that is independent of <emphasis>n</emphasis>.  Give the
formula, and say what <emphasis>k</emphasis> is.  Then show that <emphasis>S</emphasis>(<emphasis>n</emphasis>) can be expressed
as <emphasis>a</emphasis>  <emphasis>F</emphasis><emphasis>i</emphasis><emphasis>b</emphasis>(<emphasis>n</emphasis> + 1)  +  <emphasis>b</emphasis> and give the values of <emphasis>a</emphasis> and <emphasis>b</emphasis>.</p>

<p>
<strong>Exercise 5.30.</strong>  Our evaluator currently catches and signals only two kinds of
errors -- unknown expression types and unknown procedure types.  Other
errors will take us out of the evaluator read-eval-print loop.  When
we run the evaluator using the register-machine simulator, these
errors are caught by the underlying Scheme system.  This is analogous
to the computer crashing when a user program makes an
error.<sup>32</sup>  It is a large project to make a real
error system work, but it is well worth the effort to understand what
is involved here.</p>

<p>a. Errors that occur in the evaluation process, such as an attempt to
access an unbound variable, could be caught by changing the lookup
operation to make it return a distinguished condition code, which cannot
be a possible value of any user variable.  The evaluator can test
for this condition code and then do what is necessary to go to signal-error.  Find all of the places in the evaluator where such a
change is necessary and fix them.  This is lots of work.</p>

<p>b. Much worse is the problem of handling errors that are signaled by
applying primitive procedures, such as an attempt to divide by zero or
an attempt to extract the car of a symbol.  In a professionally
written high-quality system, each primitive application is checked for
safety as part of the primitive.  For example, every call to car
could first check that the argument is a pair.  If the argument is not
a pair, the application would return a distinguished condition code to
the evaluator, which would then report the failure.  We could arrange
for this in our register-machine simulator by making each primitive
procedure
check for applicability and returning an appropriate distinguished
condition code on failure. Then the primitive-apply code in the
evaluator can check for the condition code and go to signal-error if necessary.  Build this structure and make it work.
This is a major project.</p><empty-line /><empty-line /><empty-line /><p><sup>19</sup> See Batali et al. 1982 for more
information on the chip and the method by which it was designed.</p>

<p><sup>20</sup> In our controller, the dispatch is written as a
sequence of test and branch instructions.  Alternatively,
it could have been written in a data-directed style (and in a real
system it probably would have been) to avoid the need to perform
sequential tests and to facilitate the definition of new expression
types.  A machine designed to run Lisp would probably include a dispatch-on-type instruction that would efficiently execute such
data-directed dispatches.</p>

<p><sup>21</sup> This is an important but subtle point in translating
algorithms from a procedural language, such as Lisp, to a
register-machine language.  As an alternative to saving only what is
needed, we could save all the registers (except val) before each
recursive call. This is called a <emphasis>framed-stack</emphasis> discipline.  This
would work but might save more registers than necessary; this could be
an important consideration in a system where stack operations are
expensive.  Saving registers whose contents will not be needed later
may also hold onto useless data that could otherwise be
garbage-collected, freeing space to be reused.</p>

<p><sup>22</sup> We add to the evaluator data-structure procedures in
section 4.1.3 the following two procedures
for manipulating argument lists:</p>

<p>(define (empty-arglist) '())</p><empty-line /><empty-line /><p>(define (adjoin-arg arg arglist)</p><empty-line /><p>
  (append arglist (list arg)))</p><empty-line /><p>
We also use an additional syntax procedure to test for the
last operand in a combination:</p>

<p>(define (last-operand? ops)</p><empty-line /><p>
  (null? (cdr ops)))</p><empty-line /><empty-line /><p><sup>23</sup> The optimization of treating the last operand
specially is known as <emphasis>evlis tail recursion</emphasis> (see Wand 1980).
We could be somewhat more efficient
in the argument evaluation loop if we made evaluation of the first
operand a special case too.  This would permit us to postpone
initializing argl until after evaluating the first operand, so
as to avoid saving argl in this case.  The compiler in
section 5.5 performs this optimization.  (Compare
the construct-arglist procedure of
section 5.5.3.)</p>

<p><sup>24</sup> The
order of operand evaluation in the metacircular evaluator is
determined by the order of evaluation of the arguments to cons
in the procedure list-of-values of section 4.1.1
(see exercise 4.1).</p>

<p><sup>25</sup> We saw in
section 5.1 how to implement such a
process with a register machine that had no stack; the state of the
process was stored in a fixed set of registers.</p>

<p><sup>26</sup> This implementation of tail recursion in
ev-sequence is one variety of a well-known optimization technique used
by many compilers.  In compiling a procedure that ends with a procedure call,
one can replace the call by a jump to the called procedure's entry point.
Building this strategy into the interpreter, as we have done in this section,
provides the optimization uniformly throughout the language.</p>

<p><sup>27</sup> We can define no-more-exps? as follows:</p>

<p>(define (no-more-exps? seq) (null? seq))</p><empty-line /><empty-line /><p><sup>28</sup> This isn't really cheating.  In an actual
implementation built from scratch, we would use our explicit-control
evaluator to interpret a Scheme program that performs source-level
transformations like cond-&gt;if in a syntax phase that runs before
execution.</p>

<p><sup>29</sup> We assume here that read and the
various printing operations are
available as primitive machine operations, which is useful for our
simulation, but completely unrealistic in practice.  These
are actually extremely complex operations.  In practice, they would be
implemented using low-level input-output operations
such as transferring single characters to and from a device.</p>

<p>

To support the get-global-environment operation we define</p>

<p>(define the-global-environment (setup-environment))</p><empty-line /><empty-line /><p>(define (get-global-environment)</p><empty-line /><p>
  the-global-environment)</p><empty-line /><empty-line /><p><sup>30</sup> There are other
errors that we would like the interpreter to handle, but these are not
so simple.  See exercise 5.30.</p>

<p><sup>31</sup> We
could perform the stack initialization only after errors, but doing it in
the driver loop will be convenient for monitoring the evaluator's
performance, as described below.</p>

<p><sup>32</sup> Regrettably, this is the normal state of affairs in
conventional compiler-based language systems such as C.  
In UNIX<sup><emphasis>T</emphasis><emphasis>M</emphasis></sup> the system "dumps core", and in 
DOS/Windows<sup><emphasis>T</emphasis><emphasis>M</emphasis></sup> it becomes catatonic.
The Macintosh<sup><emphasis>T</emphasis><emphasis>M</emphasis></sup> displays a
picture of an exploding bomb and offers you the opportunity to reboot
the computer -- if you're lucky.</p>


</section>

<section>


<p><strong>5.5  Compilation</strong></p>

<p>



The explicit-control evaluator of section 5.4 is a
register machine whose controller interprets Scheme programs.  In this
section we will see how to run Scheme programs on a register machine
whose controller is not a Scheme interpreter.</p>

<p>

The explicit-control evaluator machine is universal -- it can carry out
any computational process that can be described in Scheme.  The
evaluator's controller orchestrates the use of its data paths to
perform the desired computation.  Thus, the evaluator's data paths are
universal: They are sufficient to perform any computation we desire,
given an appropriate controller.<sup>33</sup></p>

<p>

Commercial general-purpose computers are register machines organized
around a collection of registers and operations that constitute
an efficient and convenient universal set of data paths.
The controller for a general-purpose machine is an interpreter for
a register-machine language like the one we have been using.  This
language is called the <emphasis>native language</emphasis> of the machine, or simply
<emphasis>machine language</emphasis>.  Programs written in machine language are
sequences of instructions that use the machine's data paths.
For example, the explicit-control evaluator's instruction sequence
can be thought of as a machine-language program for a general-purpose
computer rather than as the controller for a specialized interpreter
machine.</p>

<p>

There are two common strategies for bridging the gap between
higher-level languages and register-machine languages.  The
explicit-control evaluator illustrates the
strategy of interpretation.  An interpreter written in the native
language of a machine configures the machine to execute programs
written in a language (called the <emphasis>source language</emphasis>) that may
differ from the native language of the machine performing the
evaluation.  The primitive procedures of the source language are
implemented as a library of subroutines written in the native language
of the given machine.  A program to be interpreted (called the <emphasis>source program</emphasis>) is represented as a data structure.  The interpreter
traverses this data structure, analyzing the source program.  As it
does so, it simulates the intended behavior of the source program by
calling appropriate primitive subroutines from the library.</p>

<p>


In this section, we explore the alternative strategy of <emphasis>compilation</emphasis>.  A compiler for a given source language and machine
translates a source program into an equivalent program (called the
<emphasis>object program</emphasis>) written in the machine's native language.  The
compiler that we implement in this section translates programs written
in Scheme into sequences of instructions to be executed using
the explicit-control evaluator machine's data paths.<sup>34</sup></p>

<p>

Compared with interpretation, compilation can provide a great increase
in the efficiency of program execution, as we will explain below in
the overview of the compiler.  On the other hand, an interpreter
provides a more powerful environment for interactive program
development and debugging, because the source program being executed
is available at run time to be examined and modified.  In addition,
because the entire library of primitives is present, new programs can
be constructed and added to the system during debugging.</p>

<p>

In view of the complementary advantages of compilation and
interpretation, modern program-development environments pursue a mixed
strategy.  Lisp interpreters are generally organized so that
interpreted procedures and compiled procedures can call each other.
This enables a programmer to compile those parts of a program that are
assumed to be debugged, thus gaining the efficiency advantage of
compilation, while retaining the interpretive mode of execution for
those parts of the program that are in the flux of interactive
development and debugging.  In
section 5.5.7, after we have implemented
the compiler, we will show how to interface it with our interpreter to
produce an integrated interpreter-compiler development system.</p>

<p><strong>An overview of the compiler</strong></p>

<p>


Our compiler is much like our interpreter, both in its structure and in
the function it performs.  Accordingly, the mechanisms used by the
compiler for analyzing expressions will be similar to those used by
the interpreter.  Moreover, to make it easy to interface compiled and
interpreted code, we will design the compiler to generate code that
obeys the same conventions of register usage as the interpreter: The
environment will be kept in the env register, argument lists
will be accumulated in argl, a procedure to be applied will be
in proc, procedures will return their answers in val,
and the location to which a procedure should return will be kept in
continue.
In general, the compiler translates a source program into an object
program that performs essentially the same register operations as
would the interpreter in evaluating the same source program.</p>

<p>

This description suggests a strategy for implementing a rudimentary
compiler: We traverse the expression in the same way the
interpreter does.  When we encounter a register instruction that the
interpreter would perform in evaluating the expression, we do not
execute the instruction but instead accumulate it into a sequence.  The
resulting sequence of instructions will be the object code.  Observe
the efficiency advantage of compilation over interpretation.  Each
time the interpreter evaluates an expression -- for example,
(f 84 96) -- it performs the work of
classifying the expression (discovering that this
is a procedure application) and testing for the end of the operand list
(discovering that there are two operands).  With a
compiler, the expression is analyzed only once, when the
instruction sequence is generated at compile time.  The object code
produced by the compiler contains only the instructions that evaluate
the operator and the two operands, assemble the argument list,
and apply the procedure (in proc) to the arguments (in argl).</p>

<p>


This is the same kind of optimization we implemented in the
analyzing evaluator of section 4.1.7.
But there are further opportunities to gain efficiency in compiled code.
As the interpreter runs, it follows a process that must be applicable
to any expression in the language.  In contrast, a given segment of
compiled code is meant to execute some particular expression.  This
can make a big difference, for example in the use of the stack to
save registers.  When the interpreter evaluates an expression, it must
be prepared for any contingency.  Before evaluating a subexpression,
the interpreter saves all
registers that will be needed later, because
the subexpression might require an arbitrary evaluation.
A compiler, on the other hand, can exploit the structure of the
particular expression it is processing to generate code that avoids
unnecessary stack operations.</p>

<p>

As a case in point, consider the combination (f 84 96).  Before
the interpreter evaluates the operator of the combination, it prepares
for this evaluation by saving the registers containing the operands
and the environment, whose values will be needed later.  The
interpreter then evaluates the operator to obtain the result in val, restores the saved registers, and finally moves the result from
val to proc.  However, in the particular expression we are
dealing with, the operator is the symbol f, whose evaluation is
accomplished by the machine operation lookup-variable-value,
which does not alter any registers.  The compiler that we implement in
this section will take advantage of this fact and generate code that
evaluates the operator using the instruction</p>

<p>(assign proc (op lookup-variable-value) (const f) (reg env))</p><empty-line /><p>
This code not only avoids the unnecessary saves and
restores but also assigns the value of the lookup directly to
proc, whereas the interpreter would obtain the result in val
and then move this to proc.</p>

<p>


A compiler can also optimize access to the environment.  Having
analyzed the code, the compiler can in many cases know in which frame
a particular variable will be located and access that frame directly,
rather than performing the lookup-variable-value search.  We
will discuss how to implement such variable access in
section 5.5.6.  Until then, however, we will
focus on the kind of register and stack optimizations described above.
There are many other optimizations that can be performed by a
compiler, such as coding primitive operations "in line" instead of
using a general apply mechanism (see
exercise 5.38); but we will not emphasize these here.
Our main goal in this section is to illustrate the compilation process
in a simplified (but still interesting) context.</p>

<p><strong>5.5.1  Structure of the Compiler</strong></p>

<p>



In section 4.1.7 we modified our original
metacircular interpreter to separate analysis from execution.  We
analyzed each expression to produce an execution procedure that took
an environment as argument and performed the required operations.  In
our compiler, we will do essentially the same analysis.  Instead of
producing execution procedures, however, we will generate sequences of
instructions to be run by our register machine.</p>

<p>


The procedure compile is the top-level dispatch in the compiler.
It corresponds to the eval procedure of
section 4.1.1, the analyze procedure of
section 4.1.7, and the eval-dispatch
entry point of the explicit-control-evaluator in
section 5.4.1.
The compiler, like the interpreters, uses the expression-syntax
procedures defined in section 4.1.2.<sup>35</sup>
Compile performs a case
analysis on the syntactic type of the expression to be compiled.  For
each type of expression, it dispatches to a specialized <emphasis>code
generator</emphasis>:</p>

<p>(define (compile exp target linkage)</p><empty-line /><p>
  (cond ((self-evaluating? exp)</p><empty-line /><p>
         (compile-self-evaluating exp target linkage))</p><empty-line /><p>
        ((quoted? exp) (compile-quoted exp target linkage))</p><empty-line /><p>
        ((variable? exp)</p><empty-line /><p>
         (compile-variable exp target linkage))</p><empty-line /><p>
        ((assignment? exp)</p><empty-line /><p>
         (compile-assignment exp target linkage))</p><empty-line /><p>
        ((definition? exp)</p><empty-line /><p>
         (compile-definition exp target linkage))</p><empty-line /><p>
        ((if? exp) (compile-if exp target linkage))</p><empty-line /><p>
        ((lambda? exp) (compile-lambda exp target linkage))</p><empty-line /><p>
        ((begin? exp)</p><empty-line /><p>
         (compile-sequence (begin-actions exp)</p><empty-line /><p>
                           target</p><empty-line /><p>
                           linkage))</p><empty-line /><p>
        ((cond? exp) (compile (cond-&gt;if exp) target linkage))</p><empty-line /><p>
        ((application? exp)</p><empty-line /><p>
         (compile-application exp target linkage))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (error "Unknown expression type -- COMPILE" exp))))</p><empty-line /><empty-line /><p><strong>Targets and linkages</strong></p>

<p>

Compile and the code generators that it calls take two arguments
in addition to the expression to compile.  There is a <emphasis>target</emphasis>,
which specifies the register in which the compiled code is to return
the value of the expression.  There is also a <emphasis>linkage
descriptor</emphasis>, which describes how the code resulting from the
compilation of the expression should proceed when it has finished its
execution.  The linkage descriptor can require that the code do one of
the following three things:</p>

<p>continue at the next instruction in sequence (this is
specified by the linkage descriptor next),</p>

<p>return from the procedure being compiled (this is specified
by the linkage descriptor return), or</p>

<p>jump to a named entry point (this is specified by using the
designated label as the linkage descriptor).</p>

<p>

For example, compiling the expression 5 (which is
self-evaluating) with a target of the val register and a
linkage of next should produce the instruction</p>

<p>(assign val (const 5))</p><empty-line /><p>
Compiling the same expression with a linkage of return should
produce the instructions</p>

<p>(assign val (const 5))</p><empty-line /><p>
(goto (reg continue))</p><empty-line /><p>
In the first case, execution will continue with the next instruction
in the sequence. In the second case, we will return from a procedure
call.  In both cases, the value of the expression will be placed into
the target val register.</p>

<p><strong>Instruction sequences and stack usage</strong></p>

<p>

Each code generator returns an <emphasis>instruction sequence</emphasis> containing
the object code it has generated for the expression.  Code generation
for a compound expression is accomplished by combining the output from
simpler code generators for component expressions, just as
evaluation of a compound expression is accomplished by evaluating the
component expressions.</p>

<p>


The simplest method for combining instruction sequences is a procedure
called append-instruction-sequences.  It takes as arguments any
number of instruction sequences that are to be executed sequentially;
it appends them and returns the combined sequence.  That is, if
&lt;<emphasis>seq<sub>1</sub></emphasis>&gt; and &lt;<emphasis>seq<sub>2</sub></emphasis>&gt; are sequences of instructions, then
evaluating</p>

<p>(append-instruction-sequences &lt;<emphasis>seq<sub>1</sub></emphasis>&gt; &lt;<emphasis>seq<sub>2</sub></emphasis>&gt;)</p><empty-line /><p>
produces the sequence</p>

<p>&lt;<emphasis>seq<sub>1</sub></emphasis>&gt;</p><empty-line /><p>
&lt;<emphasis>seq<sub>2</sub></emphasis>&gt;</p><empty-line /><empty-line /><p>

Whenever registers might need to be saved, the compiler's code generators use
preserving, which is a more subtle method for combining
instruction sequences.  Preserving takes three arguments: a set
of registers and two instruction sequences that are to be executed
sequentially.  It appends the sequences in such a way that the
contents of each register in the set is preserved over the execution
of the first sequence, if this is needed for the execution of the
second sequence.  That is, if the first sequence modifies the register
and the second sequence actually needs the register's original
contents, then preserving wraps a save and a restore
of the register around the first sequence before appending the
sequences.  Otherwise, preserving simply returns the appended
instruction sequences.  Thus, for example,</p>

<p>(preserving (list &lt;<emphasis>reg<sub>1</sub></emphasis>&gt; &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;) &lt;<emphasis>seq<sub>1</sub></emphasis>&gt; &lt;<emphasis>seq<sub>2</sub></emphasis>&gt;)</p><empty-line /><p>
produces one of the following four sequences of instructions, depending on how
&lt;<emphasis>seq<sub>1</sub></emphasis>&gt; and &lt;<emphasis>seq<sub>2</sub></emphasis>&gt; use &lt;<emphasis>reg<sub>1</sub></emphasis>&gt; and &lt;<emphasis>reg<sub>2</sub></emphasis>&gt;:</p><empty-line /><p><image xlink:href="#_213.jpg" /></p>

<p>

By using preserving to combine instruction sequences the
compiler avoids unnecessary stack operations.  This also isolates the
details of whether or not to generate save and restore
instructions within the preserving procedure, separating them
from the concerns that arise in writing each of the individual code
generators.
In fact no save or restore instructions are explicitly
produced by the code generators.</p>

<p>

In principle, we could represent an instruction sequence simply as a
list of instructions.  Append-instruction-sequences could then
combine instruction sequences by performing an ordinary list append.  However, preserving would then be a complex operation,
because it would have to analyze each instruction sequence to
determine how the sequence uses its registers.  Preserving
would be inefficient as well as complex, because it would have to
analyze each of its instruction sequence arguments, even though these
sequences might themselves have been constructed by calls to preserving, in which case their parts would have already been
analyzed.  To avoid such repetitious analysis we will associate with each
instruction sequence some information about its register use.
When we construct a basic instruction sequence we
will provide this information explicitly,
and the procedures that combine instruction sequences will derive
register-use information for the combined sequence from the
information associated with the component sequences.</p>

<p>

An instruction sequence will contain three pieces of information:</p>

<p>the set of registers that must be initialized before the
instructions in the sequence are executed (these registers are said to
be <emphasis>needed</emphasis> by the sequence),</p>

<p>the set of registers whose values are modified by the
instructions in the sequence, and</p>

<p>the actual instructions (also called <emphasis>statements</emphasis>) in
the sequence.</p>

<p>

We will represent an instruction sequence as a list of its three
parts.  The constructor for instruction sequences is thus</p>

<p>(define (make-instruction-sequence needs modifies statements)</p><empty-line /><p>
  (list needs modifies statements))</p><empty-line /><empty-line /><p>

For example, the two-instruction sequence that looks up the value of
the variable x in the current environment, assigns the result
to val, and then returns, requires registers env and continue to have been initialized, and modifies register val.
This sequence would therefore be constructed as</p>

<p>(make-instruction-sequence '(env continue) '(val)</p><empty-line /><p>
 '((assign val</p><empty-line /><p>
           (op lookup-variable-value) (const x) (reg env))</p><empty-line /><p>
   (goto (reg continue))))</p><empty-line /><empty-line /><p>

We sometimes need to construct an instruction sequence with no statements:</p>

<p>(define (empty-instruction-sequence)</p><empty-line /><p>
  (make-instruction-sequence '() '() '()))</p><empty-line /><empty-line /><p>

The procedures for combining instruction sequences are shown in
section 5.5.4.</p>

<p>
<strong>Exercise 5.31.</strong>  In evaluating a procedure application, the explicit-control evaluator
always saves and restores
the env register around the evaluation of the operator, saves and
restores env around the evaluation of each operand (except the
final one), saves and restores argl around the evaluation of each
operand, and saves and restores proc around the evaluation of the
operand sequence.  For each of the following combinations, say which
of these save and restore operations are superfluous and
thus could be eliminated by the compiler's preserving mechanism:</p>

<p>(f 'x 'y)</p><empty-line /><empty-line /><p>
((f) 'x 'y)</p><empty-line /><empty-line /><p>
(f (g 'x) y)</p><empty-line /><empty-line /><p>
(f (g 'x) 'y)</p><empty-line /><empty-line /><p>
<strong>Exercise 5.32.</strong>  Using the preserving mechanism, the compiler will avoid saving
and restoring env around the evaluation of the operator of a
combination in the case where the operator is a symbol.  We could also
build such optimizations into the evaluator.  Indeed, the
explicit-control evaluator of section 5.4 already
performs a similar optimization, by treating combinations with no
operands as a special case.</p>

<p>a. Extend the explicit-control evaluator to recognize as a separate class
of expressions combinations whose operator is a symbol, and to take
advantage of this fact in evaluating such expressions.</p>

<p>b. Alyssa P. Hacker suggests that by extending the evaluator to recognize
more and more special cases we could incorporate all the compiler's
optimizations, and that this would eliminate the advantage of compilation
altogether.  What do you think of this idea?</p>

<p><strong>5.5.2  Compiling Expressions</strong></p>

<p>

In this section and the next we implement the code generators to which the compile procedure dispatches.</p>

<p><strong>Compiling linkage code</strong></p>

<p>

In general, the output of each code generator will end with
instructions -- generated by the procedure compile-linkage -- that
implement the required linkage.  If the linkage is return then
we must generate the instruction (goto (reg continue)).  This
needs the continue register and does not modify any registers.
If the linkage is next, then we needn't include any additional
instructions.  Otherwise, the linkage is a label, and we generate a
goto to that label, an instruction that does not need or modify
any registers.<sup>36</sup></p>

<p>(define (compile-linkage linkage)</p><empty-line /><p>
  (cond ((eq? linkage 'return)</p><empty-line /><p>
         (make-instruction-sequence '(continue) '()</p><empty-line /><p>
          '((goto (reg continue)))))</p><empty-line /><p>
        ((eq? linkage 'next)</p><empty-line /><p>
         (empty-instruction-sequence))</p><empty-line /><p>
        (else</p><empty-line /><p>
         (make-instruction-sequence '() '()</p><empty-line /><p>
          `((goto (label ,linkage)))))))</p><empty-line /><p>
The linkage code is appended to an instruction sequence by preserving
the continue register, since a return linkage will
require the continue register:
If the given instruction sequence modifies continue and the
linkage code needs it, continue will be saved and restored.</p>

<p>(define (end-with-linkage linkage instruction-sequence)</p><empty-line /><p>
  (preserving '(continue)</p><empty-line /><p>
   instruction-sequence</p><empty-line /><p>
   (compile-linkage linkage)))</p><empty-line /><empty-line /><p><strong>Compiling simple expressions</strong></p>

<p>

The code generators for self-evaluating expressions,
quotations, and variables construct instruction
sequences that assign the required value to the target register
and then proceed as specified by the linkage descriptor.</p>

<p>(define (compile-self-evaluating exp target linkage)</p><empty-line /><p>
  (end-with-linkage linkage</p><empty-line /><p>
   (make-instruction-sequence '() (list target)</p><empty-line /><p>
    `((assign ,target (const ,exp))))))</p><empty-line /><p>(define (compile-quoted exp target linkage)</p><empty-line /><p>
  (end-with-linkage linkage</p><empty-line /><p>
   (make-instruction-sequence '() (list target)</p><empty-line /><p>
    `((assign ,target (const ,(text-of-quotation exp)))))))</p><empty-line /><p>(define (compile-variable exp target linkage)</p><empty-line /><p>
  (end-with-linkage linkage</p><empty-line /><p>
   (make-instruction-sequence '(env) (list target)</p><empty-line /><p>
    `((assign ,target</p><empty-line /><p>
              (op lookup-variable-value)</p><empty-line /><p>
              (const ,exp)</p><empty-line /><p>
              (reg env))))))</p><empty-line /><p>
All these assignment instructions modify the target register,
and the one that looks up a variable needs the env register.</p>

<p>

Assignments and definitions are handled much as they are in the
interpreter.  We recursively generate code that computes the value to
be assigned to the variable, and append to it a two-instruction
sequence that actually sets or defines the variable and assigns the
value of the whole expression (the symbol ok) to the target
register.  The recursive compilation has target val and linkage
next so that the code will put its result into val and
continue with the code that is appended after it.  The appending is
done preserving env, since the environment is needed for setting
or defining the variable and the code for the variable value could be
the compilation of a complex expression that might modify the
registers in arbitrary ways.</p>

<p>(define (compile-assignment exp target linkage)</p><empty-line /><p>
  (let ((var (assignment-variable exp))</p><empty-line /><p>
        (get-value-code</p><empty-line /><p>
         (compile (assignment-value exp) 'val 'next)))</p><empty-line /><p>
    (end-with-linkage linkage</p><empty-line /><p>
     (preserving '(env)</p><empty-line /><p>
      get-value-code</p><empty-line /><p>
      (make-instruction-sequence '(env val) (list target)</p><empty-line /><p>
       `((perform (op set-variable-value!)</p><empty-line /><p>
                  (const ,var)</p><empty-line /><p>
                  (reg val)</p><empty-line /><p>
                  (reg env))</p><empty-line /><p>
         (assign ,target (const ok))))))))</p><empty-line /><p>(define (compile-definition exp target linkage)</p><empty-line /><p>
  (let ((var (definition-variable exp))</p><empty-line /><p>
        (get-value-code</p><empty-line /><p>
         (compile (definition-value exp) 'val 'next)))</p><empty-line /><p>
    (end-with-linkage linkage</p><empty-line /><p>
     (preserving '(env)</p><empty-line /><p>
      get-value-code</p><empty-line /><p>
      (make-instruction-sequence '(env val) (list target)</p><empty-line /><p>
       `((perform (op define-variable!)</p><empty-line /><p>
                  (const ,var)</p><empty-line /><p>
                  (reg val)</p><empty-line /><p>
                  (reg env))</p><empty-line /><p>
         (assign ,target (const ok))))))))</p><empty-line /><p>
The appended two-instruction sequence requires env and val
and modifies the target.  Note that although we preserve env for
this sequence, we do not preserve val, because the get-value-code is designed to explicitly place its result in val for use by this sequence.
(In fact, if we did preserve val, we would
have a bug, because this would cause the previous contents of val to be restored right after the get-value-code is run.)</p>

<p><strong>Compiling conditional expressions</strong></p>

<p>

The code for an if expression
compiled with a given target and linkage has the form</p>

<p> &lt;<emphasis>compilation of predicate, target val, linkage next</emphasis>&gt;</p><empty-line /><p>
 (test (op false?) (reg val))</p><empty-line /><p>
 (branch (label false-branch))</p><empty-line /><p>
true-branch</p><empty-line /><p>
 &lt;<emphasis>compilation of consequent with given target and given linkage or after-if</emphasis>&gt;</p><empty-line /><p>
false-branch</p><empty-line /><p>
 &lt;<emphasis>compilation of alternative with given target and linkage</emphasis>&gt;</p><empty-line /><p>
after-if</p><empty-line /><empty-line /><p>

To generate this code, we compile the predicate, consequent,
and alternative, and combine the resulting code with instructions
to test the predicate result and with newly generated labels
to mark the true and false branches and the end of the conditional.<sup>37</sup>
In this arrangement of code, we must branch around the true branch
if the test is false.  The only slight complication is in how the
linkage for the true branch should be handled.  If the linkage for the
conditional is return or a label, then the true and false
branches will both use this same linkage.  If the linkage is next, the true branch ends with a jump around the code for the false
branch to the label at the end of the conditional.</p>

<p>(define (compile-if exp target linkage)</p><empty-line /><p>
  (let ((t-branch (make-label 'true-branch))</p><empty-line /><p>
        (f-branch (make-label 'false-branch))</p><empty-line /><p>
        (after-if (make-label 'after-if)))</p><empty-line /><p>
    (let ((consequent-linkage</p><empty-line /><p>
           (if (eq? linkage 'next) after-if linkage)))</p><empty-line /><p>
      (let ((p-code (compile (if-predicate exp) 'val 'next))</p><empty-line /><p>
            (c-code</p><empty-line /><p>
             (compile</p><empty-line /><p>
              (if-consequent exp) target consequent-linkage))</p><empty-line /><p>
            (a-code</p><empty-line /><p>
             (compile (if-alternative exp) target linkage)))</p><empty-line /><p>
        (preserving '(env continue)</p><empty-line /><p>
         p-code</p><empty-line /><p>
         (append-instruction-sequences</p><empty-line /><p>
          (make-instruction-sequence '(val) '()</p><empty-line /><p>
           `((test (op false?) (reg val))</p><empty-line /><p>
             (branch (label ,f-branch))))</p><empty-line /><p>
          (parallel-instruction-sequences</p><empty-line /><p>
           (append-instruction-sequences t-branch c-code)</p><empty-line /><p>
           (append-instruction-sequences f-branch a-code))</p><empty-line /><p>
          after-if))))))</p><empty-line /><p>
Env is preserved around the predicate code because it could be needed by
the true and false branches, and continue is preserved because it could
be needed by the linkage code in those branches.  The code for the true and
false branches (which are not executed sequentially) is appended using a
special combiner parallel-instruction-sequences described in
section 5.5.4.</p>

<p>


Note that cond is a derived expression, so all that the
compiler needs to do handle it is to apply the cond-&gt;if
transformer (from section 4.1.2) and
compile the resulting if expression.</p>

<p><strong>Compiling sequences</strong></p>

<p>

The compilation of sequences (from procedure bodies or explicit begin expressions) parallels their evaluation.  Each expression of the
sequence is compiled -- the last expression with the linkage specified
for the sequence, and the other expressions with linkage next
(to execute the rest of the sequence).
The instruction sequences for the individual expressions are appended
to form a single instruction sequence, such that env (needed for
the rest of the sequence) and continue (possibly needed for the
linkage at the end of the sequence) are preserved.</p>

<p>(define (compile-sequence seq target linkage)</p><empty-line /><p>
  (if (last-exp? seq)</p><empty-line /><p>
      (compile (first-exp seq) target linkage)</p><empty-line /><p>
      (preserving '(env continue)</p><empty-line /><p>
       (compile (first-exp seq) target 'next)</p><empty-line /><p>
       (compile-sequence (rest-exps seq) target linkage))))</p><empty-line /><empty-line /><p><strong>Compiling lambda expressions</strong></p>

<p>

Lambda expressions construct procedures.
The object code for a lambda expression must have the form</p>

<p>&lt;<emphasis>construct procedure object and assign it to target register</emphasis>&gt;</p><empty-line /><p>
&lt;<emphasis>linkage</emphasis>&gt;</p><empty-line /><p>
When we compile the lambda expression, we also generate the code for the
procedure body.  Although the body won't be executed at the time of procedure
construction, it is convenient to insert it into the object code right after
the code for the lambda.  If the linkage for the lambda expression
is a label or return, this is fine.  But if the linkage is next,
we will need to skip around the code for the procedure body by using a linkage
that jumps to a label that is inserted after the body.  The object code thus
has the form</p>

<p> &lt;<emphasis>construct procedure object and assign it to target register</emphasis>&gt;</p><empty-line /><p>
 &lt;<emphasis>code for given linkage</emphasis>&gt;<emphasis>or</emphasis> (goto (label after-lambda))</p><empty-line /><p>
 &lt;<emphasis>compilation of procedure body</emphasis>&gt;</p><empty-line /><p>
after-lambda</p><empty-line /><empty-line /><p>

Compile-lambda generates the code for constructing the procedure
object followed by the code for the procedure body.
The procedure object will be constructed at run time by combining
the current environment (the environment at the point of definition)
with the entry point to the compiled procedure body (a newly generated
label).<sup>38</sup></p>

<p>(define (compile-lambda exp target linkage)</p><empty-line /><p>
  (let ((proc-entry (make-label 'entry))</p><empty-line /><p>
        (after-lambda (make-label 'after-lambda)))</p><empty-line /><p>
    (let ((lambda-linkage</p><empty-line /><p>
           (if (eq? linkage 'next) after-lambda linkage)))</p><empty-line /><p>
      (append-instruction-sequences</p><empty-line /><p>
       (tack-on-instruction-sequence</p><empty-line /><p>
        (end-with-linkage lambda-linkage</p><empty-line /><p>
         (make-instruction-sequence '(env) (list target)</p><empty-line /><p>
          `((assign ,target</p><empty-line /><p>
                    (op make-compiled-procedure)</p><empty-line /><p>
                    (label ,proc-entry)</p><empty-line /><p>
                    (reg env)))))</p><empty-line /><p>
        (compile-lambda-body exp proc-entry))</p><empty-line /><p>
       after-lambda))))</p><empty-line /><p>
Compile-lambda uses the special combiner tack-on-instruction-sequence
(section 5.5.4) rather than append-instruction-sequences to append the procedure body to the lambda
expression code, because the body is not part of the sequence of instructions
that will be executed when the combined sequence is entered; rather, it is in
the sequence only because that was a convenient place to put it.</p>

<p>


Compile-lambda-body constructs the code for the body of the
procedure.  This code begins with a label for the entry point.  Next
come instructions that will cause the run-time evaluation environment
to switch to the correct environment for evaluating the procedure
body -- namely, the definition environment of the procedure, extended
to include the bindings of the formal parameters to the arguments with
which the procedure is called.  After this comes the code for the
sequence of expressions that makes up the procedure body.
The sequence is compiled with linkage return and target val
so that it will end by returning from the procedure with the
procedure result in val.</p>

<p>(define (compile-lambda-body exp proc-entry)</p><empty-line /><p>
  (let ((formals (lambda-parameters exp)))</p><empty-line /><p>
    (append-instruction-sequences</p><empty-line /><p>
     (make-instruction-sequence '(env proc argl) '(env)</p><empty-line /><p>
      `(,proc-entry</p><empty-line /><p>
        (assign env (op compiled-procedure-env) (reg proc))</p><empty-line /><p>
        (assign env</p><empty-line /><p>
                (op extend-environment)</p><empty-line /><p>
                (const ,formals)</p><empty-line /><p>
                (reg argl)</p><empty-line /><p>
                (reg env))))</p><empty-line /><p>
     (compile-sequence (lambda-body exp) 'val 'return))))</p><empty-line /><empty-line /><p><strong>5.5.3  Compiling Combinations</strong></p>

<p>



The essence of the compilation process is the compilation of procedure
applications.
The code for a combination compiled with a given target and linkage
has the form</p>

<p>&lt;<emphasis>compilation of operator, target proc, linkage next</emphasis>&gt;</p><empty-line /><p>
&lt;<emphasis>evaluate operands and construct argument list in argl</emphasis>&gt;</p><empty-line /><p>
&lt;<emphasis>compilation of procedure call with given target and linkage</emphasis>&gt;</p><empty-line /><p>
The registers env, proc, and argl may have to be
saved and restored during evaluation of the operator and operands.
Note that this is the only place in the compiler where a target other
than val is specified.</p>

<p>

The required code is generated by compile-application.  This
recursively compiles the operator, to produce code that puts the
procedure to be applied into proc, and compiles the operands, to
produce code that evaluates the individual operands of the
application.  The instruction sequences for the operands are combined
(by construct-arglist) with code that constructs the list of
arguments in argl, and the resulting argument-list code is
combined with the procedure code and the code that performs the
procedure call (produced by compile-procedure-call).  In
appending the code sequences, the env register must be preserved
around the evaluation of the operator (since evaluating the operator
might modify env, which will be needed to evaluate the
operands), and the proc register must be preserved around the
construction of the argument list (since evaluating the operands might
modify proc, which will be needed for the actual procedure
application).  Continue must also be preserved throughout, since
it is needed for the linkage in the procedure call.</p>

<p>(define (compile-application exp target linkage)</p><empty-line /><p>
  (let ((proc-code (compile (operator exp) 'proc 'next))</p><empty-line /><p>
        (operand-codes</p><empty-line /><p>
         (map (lambda (operand) (compile operand 'val 'next))</p><empty-line /><p>
              (operands exp))))</p><empty-line /><p>
    (preserving '(env continue)</p><empty-line /><p>
     proc-code</p><empty-line /><p>
     (preserving '(proc continue)</p><empty-line /><p>
      (construct-arglist operand-codes)</p><empty-line /><p>
      (compile-procedure-call target linkage)))))</p><empty-line /><empty-line /><p>

The code to construct the argument list will evaluate each operand into
val and then cons that value onto the argument list being
accumulated in argl.
Since we cons the arguments onto argl in sequence, we must
start with the last argument and end with the first, so that the
arguments will appear in order from first to last in the resulting list.
Rather than waste an instruction by initializing argl to the empty list
to set up for this sequence of evaluations,
we make the first code sequence construct the initial argl.
The general form of the argument-list construction is thus as follows:</p>

<p>&lt;<emphasis>compilation of last operand, targeted to val</emphasis>&gt;</p><empty-line /><p>
(assign argl (op list) (reg val))</p><empty-line /><p>
&lt;<emphasis>compilation of next operand, targeted to val</emphasis>&gt;</p><empty-line /><p>
(assign argl (op cons) (reg val) (reg argl))</p><empty-line /><p>...&lt;<emphasis>compilation of first operand, targeted to val</emphasis>&gt;</p><empty-line /><p>
(assign argl (op cons) (reg val) (reg argl))</p><empty-line /><p>
Argl must be preserved around each operand evaluation except
the first (so that arguments accumulated so far won't be lost), and
env must be preserved around each operand evaluation
except the last (for use by subsequent operand evaluations).</p>

<p>

Compiling this argument code is a bit tricky, because of
the special treatment of the first operand to be evaluated and the
need to preserve argl and env in different places.
The construct-arglist procedure takes as arguments the code that
evaluates the individual operands.  If there are no operands at all, it simply
emits the instruction</p>

<p>(assign argl (const ()))</p><empty-line /><p>
Otherwise, construct-arglist creates code that initializes argl with the last argument, and appends code that evaluates
the rest of the arguments and adjoins them to argl in
succession.  In order to process the arguments from last to
first, we must reverse the list of operand code sequences from the order
supplied by compile-application.</p>

<p>(define (construct-arglist operand-codes)</p><empty-line /><p>
  (let ((operand-codes (reverse operand-codes)))</p><empty-line /><p>
    (if (null? operand-codes)</p><empty-line /><p>
        (make-instruction-sequence '() '(argl)</p><empty-line /><p>
         '((assign argl (const ()))))</p><empty-line /><p>
        (let ((code-to-get-last-arg</p><empty-line /><p>
               (append-instruction-sequences</p><empty-line /><p>
                (car operand-codes)</p><empty-line /><p>
                (make-instruction-sequence '(val) '(argl)</p><empty-line /><p>
                 '((assign argl (op list) (reg val)))))))</p><empty-line /><p>
          (if (null? (cdr operand-codes))</p><empty-line /><p>
              code-to-get-last-arg</p><empty-line /><p>
              (preserving '(env)</p><empty-line /><p>
               code-to-get-last-arg</p><empty-line /><p>
               (code-to-get-rest-args</p><empty-line /><p>
                (cdr operand-codes))))))))</p><empty-line /><p>
(define (code-to-get-rest-args operand-codes)</p><empty-line /><p>
  (let ((code-for-next-arg</p><empty-line /><p>
         (preserving '(argl)</p><empty-line /><p>
          (car operand-codes)</p><empty-line /><p>
          (make-instruction-sequence '(val argl) '(argl)</p><empty-line /><p>
           '((assign argl</p><empty-line /><p>
              (op cons) (reg val) (reg argl)))))))</p><empty-line /><p>
    (if (null? (cdr operand-codes))</p><empty-line /><p>
        code-for-next-arg</p><empty-line /><p>
        (preserving '(env)</p><empty-line /><p>
         code-for-next-arg</p><empty-line /><p>
         (code-to-get-rest-args (cdr operand-codes))))))</p><empty-line /><empty-line /><p><strong>Applying procedures</strong></p>

<p>

After evaluating the elements of a combination, the compiled code must
apply the procedure in proc to the arguments in argl.  The
code performs essentially the same dispatch as the apply procedure in the
metacircular evaluator of section 4.1.1 or the
apply-dispatch entry point in the explicit-control evaluator of
section 5.4.1.  It checks whether the
procedure to be applied is a primitive procedure or a compiled
procedure.  For a primitive procedure, it uses apply-primitive-procedure; we will see shortly how it handles
compiled procedures.  The procedure-application code has the following
form:</p>

<p> (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
 (branch (label primitive-branch))</p><empty-line /><p>
compiled-branch</p><empty-line /><p>
 &lt;<emphasis>code to apply compiled procedure with given target and appropriate linkage</emphasis>&gt;</p><empty-line /><p>
primitive-branch</p><empty-line /><p>
 (assign &lt;<emphasis>target</emphasis>&gt;</p><empty-line /><p>
         (op apply-primitive-procedure)</p><empty-line /><p>
         (reg proc)</p><empty-line /><p>
         (reg argl))</p><empty-line /><p>
 &lt;<emphasis>linkage</emphasis>&gt;</p><empty-line /><p>
after-call</p><empty-line /><p>
Observe that the compiled branch must skip around the primitive
branch.  Therefore, if the linkage for the original procedure call was
next, the compound branch must use a linkage that jumps to a
label that is inserted after the primitive branch.  (This is similar
to the linkage used for the true branch in compile-if.)</p>

<p>(define (compile-procedure-call target linkage)</p><empty-line /><p>
  (let ((primitive-branch (make-label 'primitive-branch))</p><empty-line /><p>
        (compiled-branch (make-label 'compiled-branch))</p><empty-line /><p>
        (after-call (make-label 'after-call)))</p><empty-line /><p>
    (let ((compiled-linkage</p><empty-line /><p>
           (if (eq? linkage 'next) after-call linkage)))</p><empty-line /><p>
      (append-instruction-sequences</p><empty-line /><p>
       (make-instruction-sequence '(proc) '()</p><empty-line /><p>
        `((test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
          (branch (label ,primitive-branch))))</p><empty-line /><p>
       (parallel-instruction-sequences</p><empty-line /><p>
        (append-instruction-sequences</p><empty-line /><p>
         compiled-branch</p><empty-line /><p>
         (compile-proc-appl target compiled-linkage))</p><empty-line /><p>
        (append-instruction-sequences</p><empty-line /><p>
         primitive-branch</p><empty-line /><p>
         (end-with-linkage linkage</p><empty-line /><p>
          (make-instruction-sequence '(proc argl)</p><empty-line /><p>
                                     (list target)</p><empty-line /><p>
           `((assign ,target</p><empty-line /><p>
                     (op apply-primitive-procedure)</p><empty-line /><p>
                     (reg proc)</p><empty-line /><p>
                     (reg argl)))))))</p><empty-line /><p>
       after-call))))</p><empty-line /><p>
The primitive and compound branches, like the true
and false branches in compile-if, are appended using
parallel-instruction-sequences rather than the ordinary append-instruction-sequences, because they will
not be executed sequentially.</p>

<p><strong>Applying compiled procedures</strong></p>

<p>

The code that handles procedure application is the most subtle part of
the compiler, even though the instruction sequences it generates are
very short.  A compiled procedure (as constructed by compile-lambda) has an entry point, which is a label that designates
where the code for the procedure starts.  The code at this entry point
computes a result in val and returns by executing the
instruction (goto (reg continue)).  Thus, we might expect the
code for a compiled-procedure application (to be generated by compile-proc-appl) with a given target and linkage to look like this
if the linkage is a label</p>

<p> (assign continue (label proc-return))</p><empty-line /><p>
 (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
 (goto (reg val))</p><empty-line /><p>
proc-return</p><empty-line /><p>
 (assign &lt;<emphasis>target</emphasis>&gt; (reg val))   <emphasis>; included if target is not val</emphasis></p><empty-line /><p>
 (goto (label &lt;<emphasis>linkage</emphasis>&gt;))   <emphasis>; linkage code</emphasis></p><empty-line /><p>
or like this if the linkage is return.</p>

<p> (save continue)</p><empty-line /><p>
 (assign continue (label proc-return))</p><empty-line /><p>
 (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
 (goto (reg val))</p><empty-line /><p>
proc-return</p><empty-line /><p>
 (assign &lt;<emphasis>target</emphasis>&gt; (reg val))   <emphasis>; included if target is not val</emphasis></p><empty-line /><p>
 (restore continue)</p><empty-line /><p>
 (goto (reg continue))   <emphasis>; linkage code</emphasis></p><empty-line /><p>
This code sets up continue so that the procedure will return to a
label proc-return and jumps to the procedure's entry point.  The code
at proc-return transfers the procedure's result from val
to the target register (if necessary) and then jumps to
the location specified by the linkage.
(The linkage is always return or a label, because compile-procedure-call replaces a next linkage for the
compound-procedure branch by an after-call label.)</p>

<p>


In fact, if the target is not val, that is exactly the code our
compiler will generate.<sup>39</sup>
Usually, however, the target is val (the only time the compiler
specifies a different register is when targeting the evaluation of an
operator to proc), so the procedure result is put directly into
the target register and there is no need to return to a special
location that copies it.  Instead, we simplify the code by
setting up continue so that the procedure will "return"
directly to the place specified by the caller's linkage:</p>

<p>&lt;<emphasis>set up continue for linkage</emphasis>&gt;</p><empty-line /><p>
(assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
(goto (reg val))</p><empty-line /><p>
If the linkage is a label, we set up continue so that the procedure will return to
that label.  (That is, the (goto (reg continue)) the procedure
ends with becomes equivalent to the (goto (label &lt;<emphasis>linkage</emphasis>&gt;)) at
proc-return above.)</p>

<p>(assign continue (label &lt;<emphasis>linkage</emphasis>&gt;))</p><empty-line /><p>
(assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
(goto (reg val))</p><empty-line /><p>
If the linkage is return, we don't need to set up continue
at all: It already holds the desired location.  (That is, the (goto (reg continue)) the procedure ends with goes directly to the
place where the (goto (reg continue)) at proc-return would
have gone.)</p>

<p>(assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
(goto (reg val))</p><empty-line /><p>
With this implementation of the return linkage, the compiler
generates tail-recursive code.  Calling a procedure as the final step
in a procedure body does a direct transfer, without saving any
information on the stack.</p>

<p>


Suppose instead that we had handled the case of a procedure call with
a linkage of return and a target of val as shown above for
a non-val target.  This would destroy tail recursion.  Our
system would still give the same value for any expression.  But each
time we called a procedure, we would save continue and return
after the call to undo the (useless) save.  These extra saves would
accumulate during a nest of procedure calls.<sup>40</sup></p>

<p>

Compile-proc-appl generates the above procedure-application code by
considering four cases, depending on whether the target for the call
is val and whether the linkage is return.
Observe that the instruction sequences are
declared to modify all the registers, since executing the procedure
body can change the registers in arbitrary ways.<sup>41</sup>
Also note that the code sequence for the case with target val
and linkage return is declared to need continue:  Even
though continue is not explicitly used in the two-instruction
sequence, we must be sure that continue will have the correct
value when we enter the compiled procedure.</p>

<p>(define (compile-proc-appl target linkage)</p><empty-line /><p>
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))</p><empty-line /><p>
         (make-instruction-sequence '(proc) all-regs</p><empty-line /><p>
           `((assign continue (label ,linkage))</p><empty-line /><p>
             (assign val (op compiled-procedure-entry)</p><empty-line /><p>
                         (reg proc))</p><empty-line /><p>
             (goto (reg val)))))</p><empty-line /><p>
        ((and (not (eq? target 'val))</p><empty-line /><p>
              (not (eq? linkage 'return)))</p><empty-line /><p>
         (let ((proc-return (make-label 'proc-return)))</p><empty-line /><p>
           (make-instruction-sequence '(proc) all-regs</p><empty-line /><p>
            `((assign continue (label ,proc-return))</p><empty-line /><p>
              (assign val (op compiled-procedure-entry)</p><empty-line /><p>
                          (reg proc))</p><empty-line /><p>
              (goto (reg val))</p><empty-line /><p>
              ,proc-return</p><empty-line /><p>
              (assign ,target (reg val))</p><empty-line /><p>
              (goto (label ,linkage))))))</p><empty-line /><p>
        ((and (eq? target 'val) (eq? linkage 'return))</p><empty-line /><p>
         (make-instruction-sequence '(proc continue) all-regs</p><empty-line /><p>
          '((assign val (op compiled-procedure-entry)</p><empty-line /><p>
                        (reg proc))</p><empty-line /><p>
            (goto (reg val)))))</p><empty-line /><p>
        ((and (not (eq? target 'val)) (eq? linkage 'return))</p><empty-line /><p>
         (error "return linkage, target not val -- COMPILE"</p><empty-line /><p>
                target))))</p><empty-line /><empty-line /><p><strong>5.5.4  Combining Instruction Sequences</strong></p>

<p>



This section describes the details on how instruction sequences are
represented and combined.  Recall from
section 5.5.1 that an instruction sequence
is represented as a list of the registers needed, the registers
modified, and the actual instructions.  We will also consider a label
(symbol) to be a degenerate case of an instruction sequence, which doesn't
need or modify any registers.
So to determine the registers needed
and modified by instruction sequences we use the selectors</p>

<p>(define (registers-needed s)</p><empty-line /><p>
  (if (symbol? s) '() (car s)))</p><empty-line /><p>(define (registers-modified s)</p><empty-line /><p>
  (if (symbol? s) '() (cadr s)))</p><empty-line /><p>(define (statements s)</p><empty-line /><p>
  (if (symbol? s) (list s) (caddr s)))</p><empty-line /><p>
and to determine whether a given
sequence needs or modifies a given register we use the predicates</p>

<p>(define (needs-register? seq reg)</p><empty-line /><p>
  (memq reg (registers-needed seq)))</p><empty-line /><p>(define (modifies-register? seq reg)</p><empty-line /><p>
  (memq reg (registers-modified seq)))</p><empty-line /><p>
In terms of these predicates and selectors, we can implement the
various instruction sequence combiners used throughout the compiler.</p>

<p>

The basic combiner is append-instruction-sequences.  This takes as
arguments an arbitrary number of instruction sequences that are to be executed
sequentially and returns an instruction sequence whose statements are the
statements of all the sequences appended together.  The subtle point is to
determine the registers that are needed and modified by the resulting
sequence.  It modifies those registers that are modified by any of the
sequences; it needs those registers that must be initialized before the first
sequence can be run (the registers needed by the first sequence), together
with those registers needed by any of the other sequences that are not
initialized (modified) by sequences preceding it.</p>

<p>

The sequences are appended two at a time by append-2-sequences.  This
takes two instruction sequences seq1 and seq2 and returns the
instruction sequence whose statements are the statements of seq1
followed by the statements of seq2, whose modified registers are those
registers that are modified by either seq1 or seq2, and whose
needed registers are the registers needed by seq1 together with those
registers needed by seq2 that are not modified by seq1.  (In terms
of set operations, the new set of needed registers is the union of the set of
registers needed by seq1 with the set difference of the registers needed
by seq2 and the registers modified by seq1.)  Thus, append-instruction-sequences is implemented as follows:</p>

<p>(define (append-instruction-sequences . seqs)</p><empty-line /><p>
  (define (append-2-sequences seq1 seq2)</p><empty-line /><p>
    (make-instruction-sequence</p><empty-line /><p>
     (list-union (registers-needed seq1)</p><empty-line /><p>
                 (list-difference (registers-needed seq2)</p><empty-line /><p>
                                  (registers-modified seq1)))</p><empty-line /><p>
     (list-union (registers-modified seq1)</p><empty-line /><p>
                 (registers-modified seq2))</p><empty-line /><p>
     (append (statements seq1) (statements seq2))))</p><empty-line /><p>
  (define (append-seq-list seqs)</p><empty-line /><p>
    (if (null? seqs)</p><empty-line /><p>
        (empty-instruction-sequence)</p><empty-line /><p>
        (append-2-sequences (car seqs)</p><empty-line /><p>
                            (append-seq-list (cdr seqs)))))</p><empty-line /><p>
  (append-seq-list seqs))</p><empty-line /><empty-line /><p>

This procedure uses some simple operations for manipulating sets
represented as lists, similar to the (unordered) set representation
described in section 2.3.3:</p>

<p>(define (list-union s1 s2)</p><empty-line /><p>
  (cond ((null? s1) s2)</p><empty-line /><p>
        ((memq (car s1) s2) (list-union (cdr s1) s2))</p><empty-line /><p>
        (else (cons (car s1) (list-union (cdr s1) s2)))))</p><empty-line /><p>(define (list-difference s1 s2)</p><empty-line /><p>
  (cond ((null? s1) '())</p><empty-line /><p>
        ((memq (car s1) s2) (list-difference (cdr s1) s2))</p><empty-line /><p>
        (else (cons (car s1)</p><empty-line /><p>
                    (list-difference (cdr s1) s2)))))</p><empty-line /><empty-line /><p>


Preserving, the second major instruction sequence combiner, takes a list
of registers regs and two instruction sequences seq1 and seq2 that are to be executed sequentially.  It returns an instruction
sequence whose statements are the statements of seq1 followed by the
statements of seq2, with appropriate save and restore
instructions around seq1 to protect the registers in regs that are
modified by seq1 but needed by seq2.  To accomplish this, preserving first creates a sequence that has the required saves
followed by the statements of seq1 followed by the required restores.  This sequence needs the registers being saved and restored in
addition to the registers needed by seq1, and modifies the registers
modified by seq1 except for the ones being saved and restored.  This
augmented sequence and seq2 are then appended in the usual way.  The
following procedure implements this strategy recursively, walking down the
list of registers to be preserved:<sup>42</sup></p>

<p>(define (preserving regs seq1 seq2)</p><empty-line /><p>
  (if (null? regs)</p><empty-line /><p>
      (append-instruction-sequences seq1 seq2)</p><empty-line /><p>
      (let ((first-reg (car regs)))</p><empty-line /><p>
        (if (and (needs-register? seq2 first-reg)</p><empty-line /><p>
                 (modifies-register? seq1 first-reg))</p><empty-line /><p>
            (preserving (cdr regs)</p><empty-line /><p>
             (make-instruction-sequence</p><empty-line /><p>
              (list-union (list first-reg)</p><empty-line /><p>
                          (registers-needed seq1))</p><empty-line /><p>
              (list-difference (registers-modified seq1)</p><empty-line /><p>
                               (list first-reg))</p><empty-line /><p>
              (append `((save ,first-reg))</p><empty-line /><p>
                      (statements seq1)</p><empty-line /><p>
                      `((restore ,first-reg))))</p><empty-line /><p>
             seq2)</p><empty-line /><p>
            (preserving (cdr regs) seq1 seq2)))))</p><empty-line /><empty-line /><p>

Another sequence combiner, tack-on-instruction-sequence,
is used by compile-lambda to append a procedure body to another
sequence.  Because the procedure body is not "in line" to be
executed as part of the combined sequence, its register use has no
impact on the register use of the sequence in which it is embedded.
We thus ignore the procedure body's sets of needed and modified
registers when we tack it onto the other sequence.</p>

<p>(define (tack-on-instruction-sequence seq body-seq)</p><empty-line /><p>
  (make-instruction-sequence</p><empty-line /><p>
   (registers-needed seq)</p><empty-line /><p>
   (registers-modified seq)</p><empty-line /><p>
   (append (statements seq) (statements body-seq))))</p><empty-line /><empty-line /><p>

Compile-if and compile-procedure-call use a special
combiner called parallel-instruction-sequences to append the two
alternative branches that follow a test.  The two branches will never be
executed sequentially; for any particular evaluation of the test, one
branch or the other will be entered.  Because of this, the registers
needed by the second branch are still needed by the combined sequence,
even if these are modified by the first branch.</p>

<p>(define (parallel-instruction-sequences seq1 seq2)</p><empty-line /><p>
  (make-instruction-sequence</p><empty-line /><p>
   (list-union (registers-needed seq1)</p><empty-line /><p>
               (registers-needed seq2))</p><empty-line /><p>
   (list-union (registers-modified seq1)</p><empty-line /><p>
               (registers-modified seq2))</p><empty-line /><p>
   (append (statements seq1) (statements seq2))))</p><empty-line /><empty-line /><p><strong>5.5.5  An Example of Compiled Code</strong></p>

<p>


Now that we have seen all the elements of the compiler, let us examine
an example of compiled code to see how things fit together.  We will
compile the definition of a recursive factorial procedure by
calling compile:</p>

<p>(compile</p><empty-line /><p>
 '(define (factorial n)</p><empty-line /><p>
    (if (= n 1)</p><empty-line /><p>
        1</p><empty-line /><p>
        (* (factorial (- n 1)) n)))</p><empty-line /><p>
 'val</p><empty-line /><p>
 'next)</p><empty-line /><p>
We have specified that the value of the define expression should
be placed in the val register.  We don't care what the compiled
code does after executing the define, so our choice of next as the linkage descriptor is arbitrary.</p>

<p>

Compile determines that the expression is a definition, so it calls compile-definition to compile code to compute the value to be assigned
(targeted to val), followed by code to install the definition, followed
by code to put the value of the define (which is the symbol ok)
into the target register, followed finally by the linkage code.  Env is
preserved around the computation of the value, because it is needed in order
to install the definition.  Because the linkage is next, there is no
linkage code in this case.  The skeleton of the compiled code is thus</p>

<p>  &lt;<emphasis>save env if modified by code to compute value</emphasis>&gt;</p><empty-line /><p>
  &lt;<emphasis>compilation of definition value, target val, linkage next</emphasis>&gt;</p><empty-line /><p>
  &lt;<emphasis>restore env if saved above</emphasis>&gt;</p><empty-line /><p>
  (perform (op define-variable!)</p><empty-line /><p>
           (const factorial)</p><empty-line /><p>
           (reg val)</p><empty-line /><p>
           (reg env))</p><empty-line /><p>
  (assign val (const ok))</p><empty-line /><empty-line /><p>

The expression that is to be compiled to produce the value for the
variable factorial is a lambda expression whose value is
the procedure that computes factorials.  Compile handles this by
calling compile-lambda, which compiles the procedure body,
labels it as a new entry point, and generates the instruction that
will combine the procedure body at the new entry point with the
run-time environment and assign the result to val.  The sequence
then skips around the compiled procedure code, which is inserted at
this point.  The procedure code itself begins by extending the
procedure's definition environment by a frame that binds
the formal parameter n to the procedure argument.  Then comes the actual
procedure body.  Since this code for the value of the variable
doesn't modify the env register, the optional save
and restore shown above aren't generated.  (The procedure code at
entry2 isn't executed at this point, so its use of env
is irrelevant.)
Therefore, the skeleton for the compiled code becomes</p>

<p>  (assign val (op make-compiled-procedure)</p><empty-line /><p>
              (label entry2)</p><empty-line /><p>
              (reg env))</p><empty-line /><p>
  (goto (label after-lambda1))</p><empty-line /><p>
entry2</p><empty-line /><p>
  (assign env (op compiled-procedure-env) (reg proc))</p><empty-line /><p>
  (assign env (op extend-environment)</p><empty-line /><p>
              (const (n))</p><empty-line /><p>
              (reg argl)</p><empty-line /><p>
              (reg env))</p><empty-line /><p>
  &lt;<emphasis>compilation of procedure body</emphasis>&gt;</p><empty-line /><p>
after-lambda1</p><empty-line /><p>
  (perform (op define-variable!)</p><empty-line /><p>
           (const factorial)</p><empty-line /><p>
           (reg val)</p><empty-line /><p>
           (reg env))</p><empty-line /><p>
  (assign val (const ok))</p><empty-line /><empty-line /><p>

A procedure body is always compiled (by compile-lambda-body) as
a sequence with target val and linkage return.  The
sequence in this case consists of a single if expression:</p>

<p>(if (= n 1)</p><empty-line /><p>
    1</p><empty-line /><p>
    (* (factorial (- n 1)) n))</p><empty-line /><p>
Compile-if generates code that first computes the predicate (targeted to
val), then checks the result and branches around the true branch if the
predicate is false.  Env and continue are preserved around the
predicate code, since they may be needed for the rest of the if
expression.  Since the if expression is the final expression (and only
expression) in the sequence making up the procedure body, its target is val and its linkage is return, so the true and false branches are both
compiled with target val and linkage return.
(That is, the value of the conditional, which is the value computed by
either of its branches, is the value of the procedure.)</p>

<p>  &lt;<emphasis>save continue, env if modified by predicate and needed by branches</emphasis>&gt;</p><empty-line /><p>
  &lt;<emphasis>compilation of predicate, target val, linkage next</emphasis>&gt;</p><empty-line /><p>
  &lt;<emphasis>restore continue, env if saved above</emphasis>&gt;</p><empty-line /><p>
  (test (op false?) (reg val))</p><empty-line /><p>
  (branch (label false-branch4))</p><empty-line /><p>
true-branch5</p><empty-line /><p>
  &lt;<emphasis>compilation of true branch, target val, linkage return</emphasis>&gt;</p><empty-line /><p>
false-branch4</p><empty-line /><p>
  &lt;<emphasis>compilation of false branch, target val, linkage return</emphasis>&gt;</p><empty-line /><p>
after-if3</p><empty-line /><empty-line /><p>

The predicate (= n 1) is a procedure call.  This
looks up the operator (the symbol =) and places this value in
proc.  It then assembles the arguments 1 and the value of
n into argl.  Then it tests whether proc contains a
primitive or a compound procedure, and dispatches to a primitive branch
or a compound branch accordingly.  Both branches resume at the after-call label.  The requirements to preserve registers
around the evaluation of the operator and operands don't result in
any saving of registers, because in this case those evaluations don't
modify the registers in question.</p>

<p>  (assign proc</p><empty-line /><p>
          (op lookup-variable-value) (const =) (reg env))</p><empty-line /><p>
  (assign val (const 1))</p><empty-line /><p>
  (assign argl (op list) (reg val))</p><empty-line /><p>
  (assign val (op lookup-variable-value) (const n) (reg env))</p><empty-line /><p>
  (assign argl (op cons) (reg val) (reg argl))</p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-branch17))</p><empty-line /><p>
compiled-branch16</p><empty-line /><p>
  (assign continue (label after-call15))</p><empty-line /><p>
  (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>
primitive-branch17</p><empty-line /><p>
  (assign val (op apply-primitive-procedure)</p><empty-line /><p>
              (reg proc)</p><empty-line /><p>
              (reg argl))</p><empty-line /><p>
after-call15</p><empty-line /><empty-line /><p>

The true branch, which is the constant 1, compiles (with target
val and linkage return) to</p>

<p>  (assign val (const 1))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><p>
The code for the false branch is another a procedure call, where the
procedure is the value of the symbol *, and the arguments are
n and the result of another procedure call (a call to factorial).
Each of these calls sets up proc and argl and its own primitive
and compound branches.  Figure 5.17
shows the complete compilation of the
definition of the factorial procedure.
Notice that the possible save and restore of
continue and env around the predicate, shown above,
are in fact generated, because these registers are modified by the procedure
call in the predicate and needed for the procedure call and the
return linkage in the branches.</p>

<p>
<strong>Exercise 5.33.</strong>  Consider the following definition of a factorial procedure, which is
slightly different from the one given above:</p>

<p>(define (factorial-alt n)</p><empty-line /><p>
  (if (= n 1)</p><empty-line /><p>
      1</p><empty-line /><p>
      (* n (factorial-alt (- n 1)))))</p><empty-line /><p>
Compile this procedure and compare the resulting code with that produced for
factorial.  Explain any differences you find.  Does either
program execute more efficiently than the other?</p>

<p>
<strong>Exercise 5.34.</strong>  Compile the iterative factorial procedure</p>

<p>(define (factorial n)</p><empty-line /><p>
  (define (iter product counter)</p><empty-line /><p>
    (if (&gt; counter n)</p><empty-line /><p>
        product</p><empty-line /><p>
        (iter (* counter product)</p><empty-line /><p>
              (+ counter 1))))</p><empty-line /><p>
  (iter 1 1))</p><empty-line /><p>
Annotate the resulting code, showing the essential difference between
the code for iterative and recursive versions of factorial that
makes one process build up stack space and the other run in constant
stack space.</p><empty-line /><p><emphasis>;; construct the procedure and skip over code for the procedure body</emphasis></p><empty-line /><p>
  (assign val</p><empty-line /><p>
          (op make-compiled-procedure) (label entry2) (reg env))</p><empty-line /><p>
  (goto (label after-lambda1))</p><empty-line /><empty-line /><p>
entry2     <emphasis>; calls to factorial will enter here</emphasis></p><empty-line /><p>
  (assign env (op compiled-procedure-env) (reg proc))</p><empty-line /><p>
  (assign env</p><empty-line /><p>
          (op extend-environment) (const (n)) (reg argl) (reg env))</p><empty-line /><p><emphasis>;; begin actual procedure body</emphasis></p><empty-line /><p>
  (save continue)</p><empty-line /><p>
  (save env)</p><empty-line /><empty-line /><p><emphasis>;; compute (= n 1)</emphasis></p><empty-line /><p>
  (assign proc (op lookup-variable-value) (const =) (reg env))</p><empty-line /><p>
  (assign val (const 1))</p><empty-line /><p>
  (assign argl (op list) (reg val))</p><empty-line /><p>
  (assign val (op lookup-variable-value) (const n) (reg env))</p><empty-line /><p>
  (assign argl (op cons) (reg val) (reg argl))</p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-branch17))</p><empty-line /><p>
compiled-branch16</p><empty-line /><p>
  (assign continue (label after-call15))</p><empty-line /><p>
  (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>
primitive-branch17</p><empty-line /><p>
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))</p><empty-line /><empty-line /><p>
after-call15   <emphasis>; val now contains result of (= n 1)</emphasis></p><empty-line /><p>
  (restore env)</p><empty-line /><p>
  (restore continue)</p><empty-line /><p>
  (test (op false?) (reg val))</p><empty-line /><p>
  (branch (label false-branch4))</p><empty-line /><p>
true-branch5  <emphasis>; return 1</emphasis></p><empty-line /><p>
  (assign val (const 1))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><empty-line /><p>
false-branch4</p><empty-line /><p><emphasis>;; compute and return (* (factorial (- n 1)) n)</emphasis></p><empty-line /><p>
  (assign proc (op lookup-variable-value) (const *) (reg env))</p><empty-line /><p>
  (save continue)</p><empty-line /><p>
  (save proc)   <emphasis>; save *</emphasis> procedure</p><empty-line /><p>
  (assign val (op lookup-variable-value) (const n) (reg env))</p><empty-line /><p>
  (assign argl (op list) (reg val))</p><empty-line /><p>
  (save argl)   <emphasis>; save partial argument list for *</emphasis></p><empty-line /><empty-line /><p><emphasis>;; compute (factorial (- n 1)), which is the other argument for *</emphasis></p><empty-line /><p>
  (assign proc</p><empty-line /><p>
          (op lookup-variable-value) (const factorial) (reg env))</p><empty-line /><p>
  (save proc)  <emphasis>; save factorial procedure</emphasis></p><empty-line /><empty-line /><p><strong>Figure 5.17:</strong>  Compilation of the definition of the factorial
procedure (continued on next page).</p><empty-line /><p><emphasis>;; compute (- n 1), which is the argument for factorial</emphasis></p><empty-line /><p>
  (assign proc (op lookup-variable-value) (const -) (reg env))</p><empty-line /><p>
  (assign val (const 1))</p><empty-line /><p>
  (assign argl (op list) (reg val))</p><empty-line /><p>
  (assign val (op lookup-variable-value) (const n) (reg env))</p><empty-line /><p>
  (assign argl (op cons) (reg val) (reg argl))</p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-branch8))</p><empty-line /><p>
compiled-branch7</p><empty-line /><p>
  (assign continue (label after-call6))</p><empty-line /><p>
  (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>
primitive-branch8</p><empty-line /><p>
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))</p><empty-line /><empty-line /><p>
after-call6   <emphasis>; val now contains result of (- n 1)</emphasis></p><empty-line /><p>
  (assign argl (op list) (reg val))</p><empty-line /><p>
  (restore proc) <emphasis>; restore factorial</emphasis></p><empty-line /><p><emphasis>;; apply factorial</emphasis></p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-branch11))</p><empty-line /><p>
compiled-branch10</p><empty-line /><p>
  (assign continue (label after-call9))</p><empty-line /><p>
  (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>
primitive-branch11</p><empty-line /><p>
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))</p><empty-line /><empty-line /><p>
after-call9      <emphasis>; val now contains result of (factorial (- n 1))</emphasis></p><empty-line /><p>
  (restore argl) <emphasis>; restore partial argument list for *</emphasis></p><empty-line /><p>
  (assign argl (op cons) (reg val) (reg argl))</p><empty-line /><p>
  (restore proc) <emphasis>; restore *</emphasis></p><empty-line /><p>
  (restore continue)</p><empty-line /><p><emphasis>;; apply *</emphasis> and return its value</p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-branch14))</p><empty-line /><p>
compiled-branch13</p><empty-line /><p><emphasis>;; note that a compound procedure here is called tail-recursively</emphasis></p><empty-line /><p>
  (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>
primitive-branch14</p><empty-line /><p>
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><p>
after-call12</p><empty-line /><p>
after-if3</p><empty-line /><p>
after-lambda1</p><empty-line /><p><emphasis>;; assign the procedure to the variable factorial</emphasis></p><empty-line /><p>
  (perform</p><empty-line /><p>
   (op define-variable!) (const factorial) (reg val) (reg env))</p><empty-line /><p>
  (assign val (const ok))</p><empty-line /><empty-line /><p><strong>Figure 5.17:</strong>  (continued)</p>

<p>
<strong>Exercise 5.35.</strong>  What expression was compiled to produce the code shown in
figure 5.18?</p><empty-line /><p>  (assign val (op make-compiled-procedure) (label entry16)</p><empty-line /><p>
                                           (reg env))</p><empty-line /><p>
  (goto (label after-lambda15))</p><empty-line /><p>
entry16</p><empty-line /><p>
  (assign env (op compiled-procedure-env) (reg proc))</p><empty-line /><p>
  (assign env</p><empty-line /><p>
          (op extend-environment) (const (x)) (reg argl) (reg env))</p><empty-line /><p>
  (assign proc (op lookup-variable-value) (const +) (reg env))</p><empty-line /><p>
  (save continue)</p><empty-line /><p>
  (save proc)</p><empty-line /><p>
  (save env)</p><empty-line /><p>
  (assign proc (op lookup-variable-value) (const g) (reg env))</p><empty-line /><p>
  (save proc)</p><empty-line /><p>
  (assign proc (op lookup-variable-value) (const +) (reg env))</p><empty-line /><p>
  (assign val (const 2))</p><empty-line /><p>
  (assign argl (op list) (reg val))</p><empty-line /><p>
  (assign val (op lookup-variable-value) (const x) (reg env))</p><empty-line /><p>
  (assign argl (op cons) (reg val) (reg argl))</p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-branch19))</p><empty-line /><p>
compiled-branch18</p><empty-line /><p>
  (assign continue (label after-call17))</p><empty-line /><p>
  (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>
primitive-branch19</p><empty-line /><p>
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))</p><empty-line /><p>
after-call17</p><empty-line /><p>
  (assign argl (op list) (reg val))</p><empty-line /><p>
  (restore proc)</p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-branch22))</p><empty-line /><p>
compiled-branch21</p><empty-line /><p>
  (assign continue (label after-call20))</p><empty-line /><p>
  (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>
primitive-branch22</p><empty-line /><p>
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))</p><empty-line /><empty-line /><p><strong>Figure 5.18:</strong>  An example of compiler output (continued on next page).
See exercise 5.35.</p><empty-line /><p>after-call20</p><empty-line /><p>
  (assign argl (op list) (reg val))</p><empty-line /><p>
  (restore env)</p><empty-line /><p>
  (assign val (op lookup-variable-value) (const x) (reg env))</p><empty-line /><p>
  (assign argl (op cons) (reg val) (reg argl))</p><empty-line /><p>
  (restore proc)</p><empty-line /><p>
  (restore continue)</p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-branch25))</p><empty-line /><p>
compiled-branch24</p><empty-line /><p>
  (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>
primitive-branch25</p><empty-line /><p>
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))</p><empty-line /><p>
  (goto (reg continue))</p><empty-line /><p>
after-call23</p><empty-line /><p>
after-lambda15</p><empty-line /><p>
  (perform (op define-variable!) (const f) (reg val) (reg env))</p><empty-line /><p>
  (assign val (const ok))</p><empty-line /><empty-line /><p><strong>Figure 5.18:</strong>  (continued)</p><empty-line /><p>
<strong>Exercise 5.36.</strong>  What order of evaluation does our compiler produce for operands of a
combination?  Is it left-to-right, right-to-left, or some other order?
Where in the compiler is this order determined?  Modify the compiler
so that it produces some other order of evaluation.  (See the
discussion of order of evaluation for the explicit-control evaluator
in section 5.4.1.)  How does changing the order of
operand evaluation affect the efficiency of the code that constructs
the argument list?</p>

<p>
<strong>Exercise 5.37.</strong>  One way to understand the compiler's preserving mechanism for
optimizing stack usage is to see what extra operations would
be generated if we did not use this idea.  Modify preserving so
that it always generates the save and restore operations.
Compile some simple expressions and identify the unnecessary stack
operations that are generated.
Compare the code to that generated with the preserving mechanism intact.</p>

<p>
<strong>Exercise 5.38.</strong>  Our compiler is clever about avoiding unnecessary stack operations,
but it is not clever at all when it comes to compiling calls to the primitive
procedures of the language in terms of the primitive operations
supplied by the machine.  For example, consider how much code is
compiled to compute (+ a 1): The code sets up an argument list
in argl, puts the primitive addition procedure (which it finds
by looking up the symbol + in the environment) into proc,
and tests whether the procedure is primitive or compound.  The
compiler always generates code to perform the test, as well as code
for primitive and compound branches (only one of which will be executed).
We have not shown the part of the controller that implements
primitives, but we presume that these instructions make use of
primitive arithmetic operations in the machine's data paths.  Consider
how much less code would be generated if the compiler could <emphasis>open-code</emphasis> primitives -- that is, if it could generate code to directly
use these primitive machine operations.  The expression (+ a 1)
might be compiled into something as simple as <sup>43</sup></p>

<p>(assign val (op lookup-variable-value) (const a) (reg env))</p><empty-line /><p>
(assign val (op +) (reg val) (const 1))</p><empty-line /><p>
In this exercise we will extend our compiler to support open coding of
selected primitives.  Special-purpose code will be generated
for calls to these primitive procedures instead of the general
procedure-application code.  In order to support this, we will augment
our machine with special argument registers arg1 and arg2.
The primitive arithmetic operations of the machine will take their
inputs from arg1 and arg2. The results may be put into
val, arg1, or arg2.</p>

<p>

The compiler must be able to recognize the application of an
open-coded primitive in the source program.  We will augment the
dispatch in the compile procedure to recognize the names of
these primitives in addition to the reserved words (the special forms)
it currently recognizes.<sup>44</sup> For each special form our compiler has a code generator.  In
this exercise we will construct a family of code generators for the
open-coded primitives.</p>

<p>


a.  The open-coded primitives, unlike the special forms, all need their
operands evaluated.  Write a code generator spread-arguments for use by
all the open-coding code generators.  Spread-arguments should take an
operand list and compile the given operands targeted to successive argument
registers.  Note that an operand may contain a call to an open-coded
primitive, so argument registers will have to be preserved during operand
evaluation.</p>

<p>

b.  For each of the primitive procedures =, *, -, and
+, write a code generator that takes a combination with that
operator, together with a target and a linkage descriptor, and
produces code to spread the arguments into the registers and then
perform the operation targeted to the given target with the given
linkage.  You need only handle expressions with two operands.  Make
compile dispatch to these code generators.</p>

<p>

c.  Try your new compiler on the factorial example.  Compare the
resulting code with the result produced without open coding.</p>

<p>

d.  Extend your code generators for + and * so that they
can handle expressions with arbitrary numbers of operands.  An
expression with more than two operands will have to be compiled into a
sequence of operations, each with only two inputs.</p>

<p><strong>5.5.6  Lexical Addressing</strong></p>

<p>




One of the most common optimizations performed by compilers is the
optimization of variable lookup.  Our compiler, as we have implemented
it so far, generates code that uses the lookup-variable-value
operation of the evaluator machine.  This searches for a variable by
comparing it with each variable that is currently bound, working frame
by frame outward through the run-time environment.  This search can be
expensive if the frames are deeply nested or if there are many
variables.  For example, consider the problem of looking up the value
of x while evaluating the expression (* x y z) in an
application of the procedure that is returned by</p>

<p>(let ((x 3) (y 4))</p><empty-line /><p>
  (lambda (a b c d e)</p><empty-line /><p>
    (let ((y (* a b x))</p><empty-line /><p>
          (z (+ c d x)))</p><empty-line /><p>
      (* x y z))))</p><empty-line /><p>
Since a let expression is just syntactic sugar for a lambda combination, this expression is equivalent to</p>

<p>((lambda (x y)</p><empty-line /><p>
   (lambda (a b c d e)</p><empty-line /><p>
     ((lambda (y z) (* x y z))</p><empty-line /><p>
      (* a b x)</p><empty-line /><p>
      (+ c d x))))</p><empty-line /><p>
 3</p><empty-line /><p>
 4)</p><empty-line /><p>
Each time lookup-variable-value searches for x, it must
determine that the symbol x is not eq? to y or z (in the first frame), nor to a, b, c, d, or
e (in the second frame).  We will assume, for the moment, that
our programs do not use define -- that variables are
bound only with lambda.  Because our language is lexically
scoped, the run-time environment for any expression will have a
structure that parallels the lexical structure of the program in which
the expression appears.<sup>45</sup>
Thus, the compiler can know, when it analyzes the
above expression, that each time the procedure is applied the variable
x in (* x y z) will be found two frames out from the
current frame and will be the first variable in that frame.</p>

<p>

We can exploit this fact by inventing a new kind of variable-lookup
operation, lexical-address-lookup, that takes as arguments an
environment and a <emphasis>lexical address</emphasis> that consists of two numbers:
a <emphasis>frame number</emphasis>, which specifies how many frames to pass over,
and a <emphasis>displacement number</emphasis>, which specifies how many variables to
pass over in that frame.  Lexical-address-lookup will produce
the value of the variable stored at that lexical address relative to
the current environment.  If we add the lexical-address-lookup
operation to our machine, we can make the compiler generate code that
references variables using this operation, rather than lookup-variable-value.  Similarly, our compiled code can use a new
lexical-address-set!  operation instead of set-variable-value!.</p>

<p>

In order to generate such code, the compiler must be able to determine
the lexical address of a variable it is about to compile a reference
to.  The lexical address of a variable in a program depends on where
one is in the code.  For example, in the following program, the
address of x in expression &lt;<emphasis>e1</emphasis>&gt; is (2,0) -- two frames back
and the first variable in the frame.  At that point y is at
address (0,0) and c is at address (1,2).  In expression
&lt;<emphasis>e2</emphasis>&gt;,  x is at (1,0),   y is at (1,1), and c is at (0,2).</p>

<p>((lambda (x y)</p><empty-line /><p>
   (lambda (a b c d e)</p><empty-line /><p>
     ((lambda (y z) &lt;<emphasis>e1</emphasis>&gt;)</p><empty-line /><p>
      &lt;<emphasis>e2</emphasis>&gt;</p><empty-line /><p>
      (+ c d x))))</p><empty-line /><p>
 3</p><empty-line /><p>
 4)</p><empty-line /><empty-line /><p>

One way for the compiler to produce code that uses lexical addressing
is to maintain a data structure called a <emphasis>compile-time
environment</emphasis>.  This keeps track of which variables will be at which
positions in which frames in the run-time environment when a
particular variable-access operation is executed.  The compile-time
environment is a list of frames, each containing a list of variables.
(There will of course be no values bound to the variables, since
values are not computed at compile time.)  The compile-time
environment becomes an additional argument to compile and is
passed along to each code generator.  The top-level call to compile uses an empty compile-time environment.
When a lambda body is compiled, compile-lambda-body
extends the compile-time environment by a frame containing the
procedure's parameters, so that the sequence making up the body
is compiled with that extended environment.
At each point in the compilation, compile-variable and compile-assignment use the compile-time
environment in order to generate the appropriate lexical addresses.</p>

<p>

Exercises 5.39
through 5.43 describe how to complete this sketch of
the lexical-addressing strategy in order to incorporate lexical lookup
into the compiler.
Exercise 5.44 describes another use for the
compile-time environment.</p>

<p>
<strong>Exercise 5.39.</strong>  Write a procedure lexical-address-lookup that implements the new
lookup operation.  It should take two arguments -- a lexical address
and a run-time environment -- and return the value of the variable
stored at the specified lexical address.  Lexical-address-lookup
should signal an error if the value of the variable is the symbol *unassigned*.<sup>46</sup> Also write a procedure lexical-address-set! that
implements the operation that changes the value of the variable at a
specified lexical address.</p>

<p>
<strong>Exercise 5.40.</strong>  Modify the compiler to maintain the compile-time environment as
described above.  That is, add a compile-time-environment argument to
compile and the various code generators, and extend it in
compile-lambda-body.</p>

<p>
<strong>Exercise 5.41.</strong>  Write a procedure find-variable that takes as arguments a
variable and a compile-time environment and returns the lexical
address of the variable with respect to that environment.  For
example, in the program fragment that is shown above, the compile-time
environment during the compilation of expression &lt;<emphasis>e1</emphasis>&gt; is ((y
z) (a b c d e) (x y)).  Find-variable should produce</p>

<p>(find-variable 'c '((y z) (a b c d e) (x y)))</p><empty-line /><p><emphasis>(1 2)</emphasis></p><empty-line /><empty-line /><p>
(find-variable 'x '((y z) (a b c d e) (x y)))</p><empty-line /><p><emphasis>(2 0)</emphasis></p><empty-line /><empty-line /><p>
(find-variable 'w '((y z) (a b c d e) (x y)))</p><empty-line /><p><emphasis>not-found</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 5.42.</strong>  Using find-variable from exercise 5.41,
rewrite compile-variable and compile-assignment to output
lexical-address instructions.  In cases where find-variable
returns not-found (that is, where the variable is not in the
compile-time environment), you should have the code generators use the
evaluator operations, as before, to search for the binding.
(The only place a variable that is not found at compile time can be is in
the global environment, which is part of the run-time environment but
is not part of the compile-time environment.<sup>47</sup>
Thus, if you wish, you may have the evaluator operations look directly in
the global environment, which can be obtained with the operation (op get-global-environment), instead of having them search the whole run-time
environment found in env.)
Test the modified compiler on a few simple cases, such as the nested
lambda combination at the beginning of this section.</p>

<p>
<strong>Exercise 5.43.</strong>  We argued in section 4.1.6 that internal definitions
for block structure should not be considered "real" defines.  Rather,
a procedure body should be interpreted as if the internal variables being
defined were installed as ordinary lambda variables initialized to their
correct values using set!.  Section 4.1.6 and
exercise 4.16 showed how to modify the metacircular
interpreter to accomplish this by scanning out internal definitions.  Modify
the compiler to perform the same transformation before it compiles a procedure
body.</p>

<p>
<strong>Exercise 5.44.</strong>  In this section we have focused on the use of the compile-time
environment to produce lexical addresses.  But there are other uses
for compile-time environments.  For instance, in
exercise 5.38 we increased the efficiency of compiled
code by open-coding primitive procedures.  Our implementation treated
the names of open-coded procedures as reserved words.  If a program
were to rebind such a name, the mechanism described in
exercise 5.38 would still open-code it as a primitive,
ignoring the new binding.  For example, consider the procedure</p>

<p>(lambda (+ * a b x y)</p><empty-line /><p>
  (+ (* a x) (* b y)))</p><empty-line /><p>
which computes a linear combination of x and y.  We might
call it with arguments +matrix, *matrix, and four
matrices, but the open-coding compiler would still open-code the + and the * in (+ (* a x) (* b y)) as primitive +
and *.  Modify the open-coding compiler to consult the
compile-time environment in order to compile the correct code for
expressions involving the names of primitive procedures.
(The code will work correctly as long as the program does not define or set! these names.)</p>

<p><strong>5.5.7  Interfacing Compiled Code to the Evaluator</strong></p>

<p>



We have not yet explained how to load compiled code into the evaluator machine
or how to run it.  We will assume that the explicit-control-evaluator machine
has been defined as in section 5.4.4, with the
additional operations specified in footnote 38.
We will implement
a procedure compile-and-go that compiles a Scheme expression, loads the
resulting object code into the evaluator machine,
and causes the machine to run the code in the
evaluator global environment, print the result, and
enter the evaluator's driver loop.  We will also modify the evaluator so that
interpreted expressions can call compiled procedures as well as interpreted
ones.  We can then put a compiled procedure into the machine and use the
evaluator to call it:</p>

<p>(compile-and-go</p><empty-line /><p>
 '(define (factorial n)</p><empty-line /><p>
    (if (= n 1)</p><empty-line /><p>
        1</p><empty-line /><p>
        (* (factorial (- n 1)) n))))</p><empty-line /><p><emphasis> ;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><p><emphasis> ;;; EC-Eval input:</emphasis></p><empty-line /><p>
(factorial 5)</p><empty-line /><p><emphasis>;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>120</emphasis></p><empty-line /><empty-line /><p>


To allow the evaluator to handle compiled procedures (for example,
to evaluate the call to factorial above),
we need to change the code at apply-dispatch
(section 5.4.1) so that it recognizes
compiled procedures (as distinct from compound or primitive
procedures) and transfers control directly to the entry point of the
compiled code:<sup>48</sup></p>

<p>apply-dispatch</p><empty-line /><p>
  (test (op primitive-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label primitive-apply))</p><empty-line /><p>
  (test (op compound-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label compound-apply))</p><empty-line /><p>
  (test (op compiled-procedure?) (reg proc))</p><empty-line /><p>
  (branch (label compiled-apply))</p><empty-line /><p>
  (goto (label unknown-procedure-type))</p><empty-line /><p>compiled-apply</p><empty-line /><p>
  (restore continue)</p><empty-line /><p>
  (assign val (op compiled-procedure-entry) (reg proc))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>
Note the restore of continue at compiled-apply.  Recall that the
evaluator was arranged so that at apply-dispatch, the continuation would
be at the top of the stack.  The compiled code entry point, on the other hand,
expects the continuation to be in continue, so continue must be
restored before the compiled code is executed.</p>

<p>


To enable us to run some compiled code when we start the evaluator
machine, we add a branch instruction at
the beginning of the evaluator machine, which causes the machine to
go to a new entry point if the flag register is set.<sup>49</sup></p>

<p>  (branch (label external-entry))      <emphasis>; branches if flag is set</emphasis></p><empty-line /><p>
read-eval-print-loop</p><empty-line /><p>
  (perform (op initialize-stack))</p><empty-line /><p>
  ...</p>

<p>
External-entry assumes that the machine is started with
val containing the location of an instruction sequence that
puts a result into val and ends with (goto (reg
continue)).  Starting at this entry point jumps to the location designated
by val, but first assigns continue so that execution will return
to print-result, which prints the value in val and then goes to
the beginning of the evaluator's read-eval-print loop.<sup>50</sup></p>

<p>external-entry</p><empty-line /><p>
  (perform (op initialize-stack))</p><empty-line /><p>
  (assign env (op get-global-environment))</p><empty-line /><p>
  (assign continue (label print-result))</p><empty-line /><p>
  (goto (reg val))</p><empty-line /><p>

Now we can use the following procedure to compile a procedure definition,
execute the compiled code, and run the read-eval-print loop so we can try the
procedure.  Because we want the compiled code to return to the location in
continue with its result in val, we compile the expression with a
target of val and a linkage of return.  In order to transform the
object code produced by the compiler into executable instructions for the
evaluator register machine, we use the procedure assemble from the
register-machine simulator (section 5.2.2).  We then initialize
the val register to point to the list of instructions, set the
flag so that the evaluator will go to external-entry, and start
the evaluator.</p>

<p>(define (compile-and-go expression)</p><empty-line /><p>
  (let ((instructions</p><empty-line /><p>
         (assemble (statements</p><empty-line /><p>
                    (compile expression 'val 'return))</p><empty-line /><p>
                   eceval)))</p><empty-line /><p>
    (set! the-global-environment (setup-environment))</p><empty-line /><p>
    (set-register-contents! eceval 'val instructions)</p><empty-line /><p>
    (set-register-contents! eceval 'flag true)</p><empty-line /><p>
    (start eceval)))</p><empty-line /><empty-line /><p>

If we have set up stack monitoring, as at the end of
section 5.4.4, we can examine the
stack usage of compiled code:</p>

<p>(compile-and-go</p><empty-line /><p>
 '(define (factorial n)</p><empty-line /><p>
    (if (= n 1)</p><empty-line /><p>
        1</p><empty-line /><p>
        (* (factorial (- n 1)) n))))</p><empty-line /><empty-line /><p><emphasis>(total-pushes = 0 maximum-depth = 0)</emphasis></p><empty-line /><p><emphasis> ;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><p><emphasis> ;;; EC-Eval input:</emphasis></p><empty-line /><p>
(factorial 5)</p><empty-line /><p><emphasis>(total-pushes = 31 maximum-depth = 14)</emphasis></p><empty-line /><p><emphasis>;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>120</emphasis></p><empty-line /><p>
Compare this example with the evaluation of (factorial 5) using
the interpreted version of the same procedure, shown at the end of
section 5.4.4.  The interpreted version required
144 pushes and a maximum stack depth of 28.  This illustrates the
optimization that results from our compilation strategy.</p>

<p><strong>Interpretation and compilation</strong></p>

<p>


With the programs in this section, we can now experiment with the
alternative execution strategies of interpretation and
compilation.<sup>51</sup>  An interpreter raises
the machine to the level of the user program; a compiler lowers the
user program to the level of the machine language.  We can regard the
Scheme language (or any programming language) as a coherent family of
abstractions erected on the machine language.  Interpreters are good
for interactive program development and debugging because the steps of
program execution are organized in terms of these abstractions, and
are therefore more intelligible to the programmer.  Compiled code can
execute faster, because the steps of program execution are organized
in terms of the machine language, and the compiler is free to make
optimizations that cut across the higher-level
abstractions.<sup>52</sup></p>

<p>


The alternatives of interpretation and compilation also lead to
different strategies for porting languages to new computers. Suppose
that we wish to implement Lisp for a new machine.  One strategy is
to begin with the explicit-control evaluator of section 5.4
and translate its instructions to instructions for the
new machine.  A different strategy is to begin with the compiler and
change the code generators so that they generate code for the new
machine.  The second strategy allows us to run any Lisp program on
the new machine by first compiling it with the compiler running on our
original Lisp system, and linking it with a compiled version of the
run-time library.<sup>53</sup>  Better yet, we can compile the compiler itself, and run
this on the new machine to compile other Lisp programs.<sup>54</sup>  Or we can
compile one of the interpreters of section 4.1 to
produce an interpreter that runs on the new machine.</p>

<p>
<strong>Exercise 5.45.</strong>  By comparing the stack operations used by compiled code to the stack
operations used by the evaluator for the same computation, we can
determine the extent to which the compiler optimizes use of the stack,
both in speed (reducing the total number of stack operations) and in
space (reducing the maximum stack depth).  Comparing this optimized
stack use to the performance of a special-purpose machine for the same
computation gives some indication of the quality of the compiler.</p>

<p>a. Exercise 5.27 asked you to determine, as a function of
<emphasis>n</emphasis>, the number of pushes and the maximum stack depth needed by the
evaluator to compute <emphasis>n</emphasis>! using the recursive factorial procedure
given above.  Exercise 5.14 asked you to do the same
measurements for the special-purpose factorial machine shown in
figure 5.11. Now perform the same analysis using the
compiled factorial procedure.</p>

<p>

Take the ratio of the number of pushes in the compiled version to the
number of pushes in the interpreted version, and do the same for the
maximum stack depth.  Since the number of operations and the stack
depth used to compute <emphasis>n</emphasis>! are linear in <emphasis>n</emphasis>, these ratios should
approach constants as <emphasis>n</emphasis> becomes large.  What are these constants?
Similarly, find the ratios of the stack usage in the special-purpose
machine to the usage in the interpreted version.</p>

<p>

Compare the ratios for special-purpose versus interpreted code to the ratios
for compiled versus interpreted code.  You should find that the
special-purpose machine does much better than the compiled code, since
the hand-tailored controller code should be much better than what is
produced by our rudimentary general-purpose compiler.</p>

<p>b. Can you suggest improvements to the compiler that would help it
generate code that would come closer in performance to the
hand-tailored version?</p>

<p>
<strong>Exercise 5.46.</strong>  Carry out an analysis like the one in
exercise 5.45 to determine the effectiveness of
compiling the tree-recursive Fibonacci procedure</p>

<p>(define (fib n)</p><empty-line /><p>
  (if (&lt; n 2)</p><empty-line /><p>
      n</p><empty-line /><p>
      (+ (fib (- n 1)) (fib (- n 2)))))</p><empty-line /><p>
compared to the effectiveness of using the special-purpose Fibonacci machine of
figure 5.12.  (For measurement of the interpreted
performance, see exercise 5.29.)
For Fibonacci, the time resource used is not linear in <emphasis>n</emphasis>; hence the
ratios of stack operations will not approach a limiting value that is
independent of <emphasis>n</emphasis>.</p>

<p>
<strong>Exercise 5.47.</strong>  This section described how to modify the explicit-control evaluator so
that interpreted code can call compiled procedures.  Show how to
modify the compiler so that compiled procedures can call not only
primitive procedures and compiled procedures, but interpreted
procedures as well.  This requires modifying compile-procedure-call
to handle the case of compound (interpreted) procedures.
Be sure to handle all the same target and linkage combinations
as in compile-proc-appl.  To do the actual procedure application,
the code needs to jump to the evaluator's compound-apply entry point.
This label cannot be directly referenced in object code
(since the assembler requires that all labels referenced by the
code it is assembling be defined there), so we will add a register
called compapp to the evaluator machine to hold this
entry point, and add an instruction to initialize it:</p>

<p>  (assign compapp (label compound-apply))</p><empty-line /><p>
  (branch (label external-entry))      <emphasis>; branches if flag is set</emphasis></p><empty-line /><p>
read-eval-print-loop</p><empty-line /><p>
  ...</p>

<p>
To test your code, start by defining a procedure f that calls a
procedure g.  Use compile-and-go to compile the definition
of f and start the evaluator.  Now, typing at the evaluator,
define g and try to call f.</p>

<p>
<strong>Exercise 5.48.</strong>  The compile-and-go interface implemented in this section is
awkward, since the compiler can be called only once (when the
evaluator machine is started).  Augment the compiler-interpreter
interface by providing a compile-and-run primitive that can be
called from within the explicit-control evaluator as follows:</p>

<p><emphasis>;;; EC-Eval input:</emphasis></p><empty-line /><p>
(compile-and-run</p><empty-line /><p>
 '(define (factorial n)</p><empty-line /><p>
    (if (= n 1)</p><empty-line /><p>
        1</p><empty-line /><p>
        (* (factorial (- n 1)) n))))</p><empty-line /><p><emphasis>;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>ok</emphasis></p><empty-line /><p><emphasis>;;; EC-Eval input:</emphasis></p><empty-line /><p>
(factorial 5)</p><empty-line /><p><emphasis>;;; EC-Eval value:</emphasis></p><empty-line /><p><emphasis>120</emphasis></p><empty-line /><empty-line /><p>
<strong>Exercise 5.49.</strong>  As an alternative to using the explicit-control evaluator's
read-eval-print loop, design a register machine that performs a
read-compile-execute-print loop.  That is, the machine should run a
loop that reads an expression, compiles it, assembles and
executes the resulting code, and prints the result.  This is easy to
run in our simulated setup, since we can arrange to call the
procedures compile and assemble as "register-machine
operations."</p>

<p>
<strong>Exercise 5.50.</strong>  Use the compiler to compile the metacircular evaluator of
section 4.1 and run this program using the register-machine
simulator.  (To compile more than one definition at a time, you can
package the definitions in a begin.)  The resulting interpreter
will run very slowly because of the multiple levels of interpretation,
but getting all the details to work is an instructive exercise.</p>

<p>
<strong>Exercise 5.51.</strong>  Develop a rudimentary implementation of Scheme in C (or some other
low-level language of your choice) by translating the explicit-control
evaluator of section 5.4 into C.  In order to run this code
you will need to also
provide appropriate storage-allocation routines and other run-time
support.</p>

<p>
<strong>Exercise 5.52.</strong>  As a counterpoint to exercise 5.51, modify the compiler
so that it compiles Scheme procedures into sequences of C
instructions.  Compile the metacircular evaluator of
section 4.1 to produce a Scheme interpreter written in C.</p><empty-line /><empty-line /><empty-line /><p><sup>33</sup> This is a theoretical statement.  We are not claiming
that the evaluator's data paths are a particularly convenient or
efficient set of data paths for a general-purpose computer.  For example,
they are not very good for implementing high-performance floating-point
calculations or calculations that intensively manipulate bit vectors.</p>

<p><sup>34</sup> Actually, the machine that runs
compiled code can be simpler than the interpreter machine, because we
won't use the exp and unev registers.  The interpreter
used these to hold pieces of unevaluated expressions.  With the
compiler, however, these expressions get built into the
compiled code that the register machine will run.  For the same
reason, we don't need the machine operations that deal with expression
syntax.  But compiled code will use a few additional machine
operations (to represent compiled procedure objects) that didn't
appear in the explicit-control evaluator machine.</p>

<p><sup>35</sup> Notice, however, that our
compiler is a Scheme program, and the syntax procedures that it uses
to manipulate expressions are the actual Scheme procedures used with
the metacircular evaluator.  For the explicit-control evaluator, in
contrast, we assumed that equivalent syntax operations were available
as operations for the register machine.  (Of course, when we simulated
the register machine in Scheme, we used the actual Scheme procedures
in our register machine simulation.)</p>

<p><sup>36</sup> This procedure uses a feature of Lisp called <emphasis>backquote</emphasis> (or <emphasis>quasiquote</emphasis>) that is handy for constructing lists.
Preceding a list with a backquote symbol is much like quoting it,
except that anything in the list that is flagged with a comma is evaluated.</p>

<p>

For example, if the value of linkage is the symbol
branch25, then the expression
`((goto (label ,linkage)))
evaluates to the list
((goto (label branch25))).
Similarly, if the value of x is the list (a b c), then
`(1 2 ,(car x))
evaluates to the list
(1 2 a).</p>

<p><sup>37</sup> We can't just
use the labels true-branch, false-branch, and
after-if as shown above,
because there might be more than one if in the program.
The compiler uses the procedure make-label to generate labels.
Make-label takes a symbol as argument and returns a new symbol
that begins with the given symbol.  For example, successive calls to
(make-label 'a) would return a1, a2, and so on.
Make-label can be implemented similarly to the generation of
unique variable names in the query language, as follows:</p>

<p>(define label-counter 0)</p><empty-line /><empty-line /><p>
(define (new-label-number)</p><empty-line /><p>
  (set! label-counter (+ 1 label-counter))</p><empty-line /><p>
  label-counter)</p><empty-line /><empty-line /><p>(define (make-label name)</p><empty-line /><p>
  (string-&gt;symbol</p><empty-line /><p>
    (string-append (symbol-&gt;string name)</p><empty-line /><p>
                   (number-&gt;string (new-label-number)))))</p><empty-line /><empty-line /><p><sup>38</sup> We need machine operations to implement a data
structure for representing compiled procedures, analogous to the structure for
compound procedures described in section 4.1.3:</p>

<p>(define (make-compiled-procedure entry env)</p><empty-line /><p>
  (list 'compiled-procedure entry env))</p><empty-line /><empty-line /><p>(define (compiled-procedure? proc)</p><empty-line /><p>
  (tagged-list? proc 'compiled-procedure))</p><empty-line /><empty-line /><p>(define (compiled-procedure-entry c-proc) (cadr c-proc))</p><empty-line /><empty-line /><p>(define (compiled-procedure-env c-proc) (caddr c-proc))</p><empty-line /><empty-line /><p><sup>39</sup> Actually, we signal an error when the target is not val
and the linkage is return, since
the only place we request return linkages is in compiling
procedures, and our convention is that procedures return their
values in val.</p>

<p><sup>40</sup> Making a
compiler generate tail-recursive code might seem like a
straightforward idea.  But most compilers for common languages,
including C and Pascal, do not do this, and therefore these languages
cannot represent iterative processes in terms of procedure call alone.
The difficulty with tail recursion in these languages is that their
implementations use the stack to store procedure arguments and local
variables as well as return addresses.  The Scheme implementations
described in this book store arguments and variables in memory to be
garbage-collected.  The reason for using the stack for variables and
arguments is that it avoids the need for garbage collection in
languages that would not otherwise require it, and is generally
believed to be more efficient.  Sophisticated Lisp compilers can, in
fact, use the stack for arguments without destroying tail recursion.
(See Hanson 1990 for a description.)  There is also some debate about
whether stack allocation is actually more efficient than garbage
collection in the first place, but the details seem to hinge on fine
points of computer architecture.  (See Appel 1987 and Miller and Rozas
1994 for opposing views on this issue.)</p>

<p><sup>41</sup> The variable
all-regs is bound to the list of names of all the registers:</p>

<p>(define all-regs '(env proc val argl continue))</p><empty-line /><empty-line /><p><sup>42</sup> Note that preserving calls append with three
arguments.  Though the definition of append shown in this book
accepts only two arguments, Scheme standardly provides an append
procedure that takes an arbitrary number of arguments.</p>

<p><sup>43</sup> We have used
the same symbol + here to denote both the source-language
procedure and the machine operation.  In general there will not be a
one-to-one correspondence between primitives of the source language
and primitives of the machine.</p>

<p><sup>44</sup> Making the primitives into reserved
words is in general a bad idea, since a user cannot then rebind these
names to different procedures.  Moreover, if we add reserved words to
a compiler that is in use, existing programs that define procedures
with these names will stop working.  See
exercise 5.44 for ideas on how to avoid this
problem.</p>

<p><sup>45</sup> This is not true if we allow
internal definitions, unless we scan them out.
See exercise 5.43.</p>

<p><sup>46</sup> This is the modification to variable lookup
required if we implement the scanning method to eliminate internal
definitions (exercise 5.43).  We will need
to eliminate these definitions in order for lexical addressing to
work.</p>

<p><sup>47</sup> Lexical addresses cannot be used to access variables in the global
environment, because these names can be defined and redefined
interactively at any time.  With internal definitions scanned out, as
in exercise 5.43, the only definitions the
compiler sees are those at top level, which act on the global
environment.  Compilation of a definition does not cause the defined
name to be entered in the compile-time environment.</p>

<p><sup>48</sup> Of course, compiled procedures as well as interpreted
procedures are compound (nonprimitive).  For compatibility with
the terminology used in the explicit-control evaluator, in this
section we will use "compound" to mean interpreted (as opposed
to compiled).</p>

<p><sup>49</sup> Now that the evaluator machine starts
with a branch, we must always initialize the flag register
before starting the evaluator machine.  To start the machine at
its ordinary read-eval-print loop, we could use</p>

<p>(define (start-eceval)</p><empty-line /><p>
  (set! the-global-environment (setup-environment))</p><empty-line /><p>
  (set-register-contents! eceval 'flag false)</p><empty-line /><p>
  (start eceval))</p><empty-line /><empty-line /><p><sup>50</sup> Since a compiled procedure is an
object that the system may try to print, we also modify the system
print operation user-print (from section 4.1.4)
so that it will not attempt to print the
components of a compiled procedure:</p>

<p>(define (user-print object)</p><empty-line /><p>
  (cond ((compound-procedure? object)</p><empty-line /><p>
         (display (list 'compound-procedure</p><empty-line /><p>
                        (procedure-parameters object)</p><empty-line /><p>
                        (procedure-body object)</p><empty-line /><p>
                        '&lt;procedure-env&gt;)))</p><empty-line /><p>
        ((compiled-procedure? object)</p><empty-line /><p>
         (display '&lt;compiled-procedure&gt;))</p><empty-line /><p>
        (else (display object))))</p><empty-line /><empty-line /><p><sup>51</sup> We can do even better by extending the compiler
to allow compiled code to call interpreted procedures.  See
exercise 5.47.</p>

<p><sup>52</sup> Independent of the strategy of execution, we
incur significant overhead if we insist that errors encountered in
execution of a user program be detected and signaled, rather than being
allowed to kill the system or produce wrong answers.  For example, an
out-of-bounds array reference can be detected by checking the validity
of the reference before performing it.  The overhead of checking,
however, can be many times the cost of the array reference itself, and
a programmer should weigh speed against safety in determining whether
such a check is desirable.  A good compiler should be able to produce
code with such checks, should avoid redundant checks, and should allow
programmers to control the extent and type of error checking in the
compiled code.</p>

<p>

Compilers for popular languages, such as C and C++,
put hardly any error-checking operations into
running code, so as to make things run as fast as possible.  As a
result, it falls to programmers to explicitly provide error checking.
Unfortunately, people often neglect to do this, even in
critical applications where speed is not a constraint.  Their programs
lead fast and dangerous lives.  For example, the notorious "Worm"
that paralyzed the Internet in 1988 exploited the UNIX<sup><emphasis>T</emphasis><emphasis>M</emphasis></sup>
operating system's failure to check whether the input buffer has
overflowed in the finger daemon. (See Spafford 1989.)</p>

<p><sup>53</sup> Of course, with either the
interpretation or the compilation strategy we must also implement for
the new machine storage allocation, input and output, and all the
various operations that we took as "primitive" in our discussion of
the evaluator and compiler.  One strategy for minimizing work here is
to write as many of these operations as possible in Lisp and then
compile them for the new machine.  Ultimately, everything reduces to a
small kernel (such as garbage collection and the mechanism for
applying actual machine primitives) that is hand-coded for the new
machine.</p>

<p><sup>54</sup> 
This strategy leads to amusing tests of correctness of
the compiler, such as checking
whether the compilation of a program on the new machine, using the
compiled compiler, is identical with the
compilation of the program on the original Lisp system.  Tracking
down the source of differences is fun but often frustrating, because
the results are extremely sensitive to minuscule details.</p>


</section>

<section>


<p><strong>
</strong></p>

<p><strong> </strong></p>

<p>
References</p>

<p>

Abelson, Harold, Andrew Berlin, Jacob Katzenelson,
William McAllister,
Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992.  The
Supercomputer Toolkit: A general framework for special-purpose
computing.  <emphasis>International Journal of High-Speed Electronics</emphasis>
3(3):337-361.</p>

<p>

Allen, John.  1978.  <emphasis>Anatomy of Lisp.</emphasis> New York: McGraw-Hill.</p>

<p>

ANSI X3.226-1994. <emphasis>American National Standard for Information
Systems -- Programming Language -- Common Lisp.</emphasis></p>

<p>

Appel, Andrew W.  1987.  Garbage collection can be faster than stack
allocation.  <emphasis>Information Processing Letters</emphasis> 25(4):275-279.</p>

<p>

Backus, John.  1978.  Can programming be liberated from the von
Neumann style?  <emphasis>Communications of the ACM</emphasis> 21(8):613-641.</p>

<p>

Baker, Henry G., Jr.  1978.  List processing in real time on a serial
computer.  <emphasis>Communications of the ACM</emphasis> 21(4):280-293.</p>

<p>

Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and
Daniel Weise.  1982.  The Scheme-81 architecture -- System and chip.
In <emphasis>Proceedings of the MIT Conference on Advanced Research in
VLSI,</emphasis> edited by Paul Penfield, Jr. Dedham, MA: Artech House.</p>

<p>

Borning, Alan.  1977.  ThingLab -- An object-oriented system for
building simulations using constraints. In <emphasis>Proceedings of the 5th
International Joint Conference on Artificial Intelligence.</emphasis></p>

<p>

Borodin, Alan, and Ian Munro.  1975.  <emphasis>The Computational
Complexity of Algebraic and Numeric Problems.</emphasis> New York: American
Elsevier.</p>

<p>

Chaitin, Gregory J.  1975.  Randomness and mathematical proof.  <emphasis>Scientific American</emphasis> 232(5):47-52.</p>

<p>

Church, Alonzo.  1941.  <emphasis>The Calculi of Lambda-Conversion.</emphasis>
Princeton, N.J.: Princeton University Press.</p>

<p>

Clark, Keith L.  1978.  Negation as failure.  In <emphasis>Logic and Data
Bases.</emphasis> New York: Plenum Press, pp. 293-322.</p>

<p>

Clinger, William.  1982.  Nondeterministic call by need is neither
lazy nor by name. In <emphasis>Proceedings of the ACM Symposium on Lisp and
Functional Programming,</emphasis> pp. 226-234.</p>

<p>

Clinger, William, and Jonathan Rees.  1991.  Macros that work.  In
<emphasis>Proceedings of the 1991 ACM Conference on Principles of
Programming Languages,</emphasis> pp. 155-162.</p>

<p>

Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un système
de communication homme-machine en français.  Technical report,
Groupe Intelligence Artificielle, Université d'Aix Marseille,
Luminy.</p>

<p>

Cormen, Thomas, Charles Leiserson, and Ronald Rivest.  1990. <emphasis>Introduction to Algorithms.</emphasis> Cambridge, MA: MIT Press.</p>

<p>

Darlington, John, Peter Henderson, and David Turner.  1982.  <emphasis>Functional Programming and Its Applications.</emphasis> New York: Cambridge
University Press.</p>

<p>

Dijkstra, Edsger W. 1968a.  The structure of the "THE"
multiprogramming system.  <emphasis>Communications of the ACM</emphasis>
11(5):341-346.</p>

<p>

Dijkstra, Edsger W. 1968b.  Cooperating sequential processes.  In <emphasis>Programming Languages</emphasis>, edited by F. Genuys. New York: Academic Press, pp.
43-112.</p>

<p>

Dinesman, Howard P.  1968.  <emphasis>Superior Mathematical Puzzles</emphasis>.  New
York: Simon and Schuster.</p>

<p>

deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.
AMORD: Explicit control of reasoning.  In <emphasis>Proceedings of the ACM
Symposium on Artificial Intelligence and Programming Languages,</emphasis> pp.
116-125.</p>

<p>

Doyle, Jon. 1979. A truth maintenance system. <emphasis>Artificial
Intelligence</emphasis> 12:231-272.</p>

<p>

Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National
Fifth Generation Project: Introduction, survey, and evaluation.  In <emphasis>Future Generation Computer Systems,</emphasis> vol. 9, pp. 105-117.</p>

<p>

Feeley, Marc.  1986.  Deux approches à l'implantation du
language Scheme.  Masters thesis, Université de Montréal.</p>

<p>

Feeley, Marc and Guy Lapalme.  1987.  Using closures for code
generation.  <emphasis>Journal of Computer Languages</emphasis> 12(1):47-66.</p>

<p>

Feller, William.  1957.  <emphasis>An Introduction to Probability Theory
and Its Applications,</emphasis> volume 1. New York: John Wiley &amp; Sons.</p>

<p>

Fenichel, R., and J. Yochelson.  1969.  A Lisp garbage collector for
virtual memory computer systems.  <emphasis>Communications of the ACM</emphasis>
12(11):611-612.</p>

<p>

Floyd, Robert. 1967. Nondeterministic algorithms. <emphasis>JACM,</emphasis> 14(4):636-644.</p>

<p>

Forbus, Kenneth D., and Johan deKleer.  1993. <emphasis>Building Problem
Solvers.</emphasis> Cambridge, MA: MIT Press.</p>

<p>

Friedman, Daniel P., and David S. Wise.  1976.  CONS should not
evaluate its arguments. In <emphasis>Automata, Languages, and Programming:
Third International Colloquium,</emphasis> edited by S. Michaelson and R.
Milner, pp. 257-284.</p>

<p>

Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.
<emphasis>Essentials of Programming Languages.</emphasis>  Cambridge, MA: MIT
Press/McGraw-Hill.</p>

<p>

Gabriel, Richard P. 1988.  The Why of <emphasis>Y</emphasis>.  <emphasis>Lisp Pointers</emphasis>
2(2):15-25.</p>

<p>

Goldberg, Adele, and David Robson.  1983.  <emphasis>Smalltalk-80: The
Language and Its Implementation.</emphasis> Reading, MA: Addison-Wesley.</p>

<p>

Gordon, Michael, Robin Milner, and Christopher Wadsworth.  1979.  <emphasis>Edinburgh LCF.</emphasis> Lecture Notes in Computer Science, volume 78. New
York: Springer-Verlag.</p>

<p>

Gray, Jim, and Andreas Reuter. 1993. <emphasis>Transaction Processing:
Concepts and Models.</emphasis> San Mateo, CA: Morgan-Kaufman.</p>

<p>

Green, Cordell.  1969.  Application of theorem proving to problem
solving.  In <emphasis>Proceedings of the International Joint Conference on
Artificial Intelligence,</emphasis> pp. 219-240.</p>

<p>

Green, Cordell, and Bertram Raphael.  1968.  The use of
theorem-proving techniques in question-answering systems.  In <emphasis>Proceedings of the ACM National Conference,</emphasis> pp. 169-181.</p>

<p>

Griss, Martin L.  1981.  Portable Standard Lisp, a brief overview.
Utah Symbolic Computation Group Operating Note 58, University of Utah.</p>

<p>

Guttag, John V.  1977.  Abstract data types and the development of
data structures.  <emphasis>Communications of the ACM</emphasis> 20(6):397-404.</p>

<p>

Hamming, Richard W.  1980.  <emphasis>Coding and Information Theory.</emphasis>
Englewood Cliffs, N.J.: Prentice-Hall.</p>

<p>

Hanson, Christopher P.  1990.  Efficient stack allocation for
tail-recursive languages.  In <emphasis>Proceedings of ACM Conference on
Lisp and Functional Programming,</emphasis> pp. 106-118.</p>

<p>

Hanson, Christopher P.  1991.  A syntactic closures macro facility.
<emphasis>Lisp Pointers,</emphasis> 4(3).</p>

<p>

Hardy, Godfrey H.  1921.  Srinivasa Ramanujan.  <emphasis>Proceedings of
the London Mathematical Society</emphasis> XIX(2).</p>

<p>

Hardy, Godfrey H., and E. M. Wright.  1960.  <emphasis>An Introduction to
the Theory of Numbers.</emphasis>  4th edition.  New York: Oxford University
Press.</p>

<p>

Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. <emphasis>IBM Systems Journal</emphasis> 7(2):74-84.</p>

<p>

Hearn, Anthony C.  1969.  Standard Lisp.  Technical report AIM-90,
Artificial Intelligence Project, Stanford University.</p>

<p>

Henderson, Peter. 1980.  <emphasis>Functional Programming: Application and
Implementation.</emphasis> Englewood Cliffs, N.J.: Prentice-Hall.</p>

<p>

Henderson. Peter. 1982. Functional Geometry. In <emphasis>Conference Record
of the 1982 ACM Symposium on Lisp and Functional Programming,</emphasis>
pp. 179-187.</p>

<p>

Hewitt, Carl E.  1969.  PLANNER: A language for proving theorems in
robots.  In <emphasis>Proceedings of the International Joint Conference on
Artificial Intelligence,</emphasis> pp. 295-301.</p>

<p>

Hewitt, Carl E.  1977.  Viewing control structures as patterns of
passing messages.  <emphasis>Journal of Artificial Intelligence</emphasis>
8(3):323-364.</p>

<p>

Hoare, C. A. R. 1972.  Proof of correctness of data representations.
<emphasis>Acta Informatica</emphasis> 1(1).</p>

<p>

Hodges, Andrew. 1983.  <emphasis>Alan Turing: The Enigma.</emphasis> New York: Simon
and Schuster.</p>

<p>

Hofstadter, Douglas R.  1979.  <emphasis>Gödel, Escher, Bach: An Eternal
Golden Braid.</emphasis> New York: Basic Books.</p>

<p>

Hughes, R. J. M.  1990.  Why functional programming matters.  In <emphasis>Research Topics in Functional Programming</emphasis>, edited by David Turner.
Reading, MA: Addison-Wesley, pp. 17-42.</p>

<p>

IEEE Std 1178-1990.  1990.  <emphasis>IEEE Standard for the Scheme
Programming Language.</emphasis></p>

<p>

Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig;
assisted by M. Lind, Herbert Kanner, and Robert Floyd.  1960.  THUNKS:
A way of compiling procedure statements, with some comments on
procedure declarations.  Unpublished manuscript.  (Also, private
communication from Wallace Feurzeig.)</p>

<p>

Kaldewaij, Anne. 1990.  <emphasis>Programming: The Derivation of
Algorithms.</emphasis> New York: Prentice-Hall.</p>

<p>

Kohlbecker, Eugene Edmund, Jr. 1986.  Syntactic extensions in the
programming language Lisp.  Ph.D. thesis, Indiana University.</p>

<p>

Konopasek, Milos, and Sundaresan Jayaraman.  1984.  <emphasis>The TK!Solver
Book: A Guide to Problem-Solving in Science, Engineering, Business,
and Education.</emphasis> Berkeley, CA: Osborne/McGraw-Hill.</p>

<p>

Knuth, Donald E.  1973.  <emphasis>Fundamental Algorithms.</emphasis> Volume 1 of
<emphasis>The Art of Computer Programming.</emphasis>  2nd edition. Reading, MA:
Addison-Wesley.</p>

<p>

Knuth, Donald E.  1981.  <emphasis>Seminumerical Algorithms.</emphasis> Volume 2 of
<emphasis>The Art of Computer Programming.</emphasis>  2nd edition. Reading, MA:
Addison-Wesley.</p>

<p>

Kowalski, Robert.  1973.  Predicate logic as a programming language.
Technical report 70, Department of Computational Logic, School of
Artificial Intelligence, University of Edinburgh.</p>

<p>

Kowalski, Robert.  1979.  <emphasis>Logic for Problem Solving.</emphasis> New York:
North-Holland.</p>

<p>

Lamport, Leslie. 1978.  Time, clocks, and the ordering of events in a
distributed system.  <emphasis>Communications of the ACM</emphasis> 21(7):558-565.</p>

<p>

Lampson, Butler, J. J. Horning, R.  London, J. G. Mitchell, and G. K.
Popek.  1981.  Report on the programming language Euclid.  Technical
report, Computer Systems Research Group, University of Toronto.</p>

<p>

Landin, Peter.  1965.  A correspondence between Algol 60 and Church's
lambda notation: Part I.  <emphasis>Communications of the ACM</emphasis>
8(2):89-101.</p>

<p>

Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage
collector based on the lifetimes of objects. <emphasis>Communications of
the ACM</emphasis> 26(6):419-429.</p>

<p>

Liskov, Barbara H., and Stephen N. Zilles.  1975.  Specification
techniques for data abstractions.  <emphasis>IEEE Transactions on Software
Engineering</emphasis> 1(1):7-19.</p>

<p>

McAllester, David Allen.  1978.  A three-valued truth-maintenance
system.  Memo 473, MIT Artificial Intelligence Laboratory.</p>

<p>

McAllester, David Allen.  1980.  An outlook on truth maintenance.
Memo 551, MIT Artificial Intelligence Laboratory.</p>

<p>

McCarthy, John.  1960.  Recursive functions of symbolic expressions
and their computation by machine.  <emphasis>Communications of the ACM</emphasis>
3(4):184-195.</p>

<p>

McCarthy, John.  1967.  A basis for a mathematical theory of
computation.  In <emphasis>Computer Programing and Formal Systems</emphasis>, edited
by P. Braffort and D. Hirschberg.  North-Holland.</p>

<p>

McCarthy, John.  1978.  The history of Lisp.  In <emphasis>Proceedings of
the ACM SIGPLAN Conference on the History of Programming Languages.</emphasis></p>

<p>

McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I.
Levin.  1965.  <emphasis>Lisp 1.5 Programmer's Manual.</emphasis>  2nd edition.
Cambridge, MA: MIT Press.</p>

<p>

McDermott, Drew, and Gerald Jay Sussman.  1972. Conniver reference
manual.  Memo 259, MIT Artificial Intelligence Laboratory.</p>

<p>

Miller, Gary L.  1976.  Riemann's Hypothesis and tests for primality.
<emphasis>Journal of Computer and System Sciences</emphasis> 13(3):300-317.</p>

<p>

Miller, James S., and Guillermo J. Rozas. 1994.  Garbage collection is
fast, but a stack is faster.  Memo 1462, MIT Artificial Intelligence
Laboratory.</p>

<p>

Moon, David.  1978.  MacLisp reference manual, Version 0.  Technical
report, MIT Laboratory for Computer Science.</p>

<p>

Moon, David, and Daniel Weinreb.  1981.  Lisp machine manual.
Technical report, MIT Artificial Intelligence Laboratory.</p>

<p>

Morris, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience
with an applicative string processing language.  In <emphasis>Proceedings
of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of
Programming Languages.</emphasis></p>

<p>

Phillips, Hubert.  1934. <emphasis>The Sphinx Problem Book</emphasis>.  London: Faber
and Faber.</p>

<p>

Pitman, Kent.  1983.  The revised MacLisp Manual (Saturday evening
edition).  Technical report 295, MIT Laboratory for Computer Science.</p>

<p>

Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.
<emphasis>Journal of Number Theory</emphasis> 12:128-138.</p>

<p>

Raymond, Eric.  1993. <emphasis>The New Hacker's Dictionary.</emphasis> 2nd edition.
Cambridge, MA: MIT Press.</p>

<p>

Raynal, Michel. 1986. <emphasis>Algorithms for Mutual Exclusion.</emphasis>
Cambridge, MA: MIT Press.</p>

<p>

Rees, Jonathan A., and Norman I. Adams IV. 1982.  T: A dialect of Lisp
or, lambda: The ultimate software tool.  In <emphasis>Conference Record of
the 1982 ACM Symposium on Lisp and Functional Programming,</emphasis> pp.
114-122.</p>

<p>

Rees, Jonathan, and William Clinger (eds). 1991.  The revised<sup>4</sup>
report on the algorithmic language Scheme.  <emphasis>Lisp Pointers,</emphasis> 4(3).</p>

<p>

Rivest, Ronald, Adi Shamir, and Leonard Adleman.  1977.  A method for
obtaining digital signatures and public-key cryptosystems. Technical
memo LCS/TM82, MIT Laboratory for Computer Science.</p>

<p>

Robinson, J. A. 1965.  A machine-oriented logic based on the
resolution principle.  <emphasis>Journal of the ACM</emphasis> 12(1):23.</p>

<p>

Robinson, J. A. 1983.  Logic programming -- Past, present, and future.
<emphasis>New Generation Computing</emphasis> 1:107-124.</p>

<p>

Spafford, Eugene H.  1989.  The Internet Worm: Crisis and aftermath.
<emphasis>Communications of the ACM</emphasis> 32(6):678-688.</p>

<p>

Steele, Guy Lewis, Jr.  1977.  Debunking the "expensive procedure
call" myth.  In <emphasis>Proceedings of the National Conference of the
ACM,</emphasis> pp. 153-62.</p>

<p>

Steele, Guy Lewis, Jr.  1982.  An overview of Common Lisp.  In <emphasis>Proceedings of the ACM Symposium on Lisp and Functional Programming,</emphasis>
pp. 98-107.</p>

<p>

Steele, Guy Lewis, Jr.  1990.  <emphasis>Common Lisp: The Language.</emphasis> 2nd
edition.  Digital Press.</p>

<p>

Steele, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An
interpreter for the extended lambda calculus.  Memo 349, MIT
Artificial Intelligence Laboratory.</p>

<p>

Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.
Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  <emphasis>The Hacker's Dictionary.</emphasis> New York: Harper &amp; Row.</p>

<p>

Stoy, Joseph E.  1977.  <emphasis>Denotational Semantics.</emphasis> Cambridge, MA:
MIT Press.</p>

<p>

Sussman, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic
techniques in computer-aided circuit analysis.  <emphasis>IEEE Transactions
on Circuits and Systems</emphasis> CAS-22(11):857-865.</p>

<p>

Sussman, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints -- A
language for expressing almost-hierachical descriptions.  <emphasis>AI
Journal</emphasis> 14:1-39.</p>

<p>

Sussman, Gerald Jay, and Jack Wisdom.  1992. Chaotic evolution of the
solar system.  <emphasis>Science</emphasis> 257:256-262.</p>

<p>

Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.
Microplanner reference manual.  Memo 203A, MIT Artificial Intelligence
Laboratory.</p>

<p>

Sutherland, Ivan E.  1963.  SKETCHPAD: A man-machine graphical
communication system.  Technical report 296, MIT Lincoln Laboratory.</p>

<p>

Teitelman, Warren.  1974.  Interlisp reference manual.  Technical
report, Xerox Palo Alto Research Center.</p>

<p>

Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978.
Data type specification: Parameterization and the power of
specification techniques. In <emphasis>Conference Record of the Tenth Annual ACM
Symposium on Theory of Computing</emphasis>, pp. 119-132.

Turner, David.  1981.  The future of applicative languages.  In <emphasis>Proceedings of the 3rd European Conference on Informatics,</emphasis> Lecture
Notes in Computer Science, volume 123. New York: Springer-Verlag, pp.
334-348.</p>

<p>

Wand, Mitchell.  1980.  Continuation-based program transformation
strategies.  <emphasis>Journal of the ACM</emphasis> 27(1):164-180.</p>

<p>

Waters, Richard C.  1979.  A method for analyzing loop programs.  <emphasis>IEEE Transactions on Software Engineering</emphasis> 5(3):237-247.</p>

<p>

Winograd, Terry.  1971.  Procedures as a representation for data in a
computer program for understanding natural language.  Technical report
AI TR-17, MIT Artificial Intelligence Laboratory.</p>

<p>

Winston, Patrick. 1992. <emphasis>Artificial Intelligence</emphasis>.  3rd edition.
Reading, MA: Addison-Wesley.</p>

<p>

Zabih, Ramin, David McAllester, and David Chapman.  1987.
Non-deterministic Lisp with dependency-directed backtracking.
<emphasis>AAAI-87</emphasis>, pp. 59-64.</p>

<p>

Zippel, Richard.  1979.  Probabilistic algorithms for sparse
polynomials.  Ph.D. dissertation, Department of Electrical Engineering
and Computer Science, MIT.</p>

<p>

Zippel, Richard.  1993.  <emphasis>Effective Polynomial Computation.</emphasis>
Boston, MA: Kluwer Academic Publishers.</p><empty-line />
</section>

<section>


<p><strong>
</strong></p>

<p><strong> </strong></p>

<p>
List of Exercises</p>

<p>

1.1</p><empty-line /><p>1.2</p><empty-line /><p>1.3</p><empty-line /><p>1.4</p><empty-line /><p>1.5</p><empty-line /><p>1.6</p><empty-line /><p>1.7</p><empty-line /><p>1.8</p><empty-line /><p>1.9</p><empty-line /><p>1.10</p><empty-line /><p>1.11</p><empty-line /><p>1.12</p><empty-line /><p>1.13</p><empty-line /><p>1.14</p><empty-line /><p>1.15</p><empty-line /><p>1.16</p><empty-line /><p>1.17</p><empty-line /><p>1.18</p><empty-line /><p>1.19</p><empty-line /><p>1.20</p><empty-line /><p>1.21</p><empty-line /><p>1.22</p><empty-line /><p>1.23</p><empty-line /><p>1.24</p><empty-line /><p>1.25</p><empty-line /><p>1.26</p><empty-line /><p>1.27</p><empty-line /><p>1.28</p><empty-line /><p>1.29</p><empty-line /><p>1.30</p><empty-line /><p>1.31</p><empty-line /><p>1.32</p><empty-line /><p>1.33</p><empty-line /><p>1.34</p><empty-line /><p>1.35</p><empty-line /><p>1.36</p><empty-line /><p>1.37</p><empty-line /><p>1.38</p><empty-line /><p>1.39</p><empty-line /><p>1.40</p><empty-line /><p>1.41</p><empty-line /><p>1.42</p><empty-line /><p>1.43</p><empty-line /><p>1.44</p><empty-line /><p>1.45</p><empty-line /><p>1.46</p><empty-line /><p>2.1</p><empty-line /><p>2.2</p><empty-line /><p>2.3</p><empty-line /><p>2.4</p><empty-line /><p>2.5</p><empty-line /><p>2.6</p><empty-line /><p>2.7</p><empty-line /><p>2.8</p><empty-line /><p>2.9</p><empty-line /><p>2.10</p><empty-line /><p>2.11</p><empty-line /><p>2.12</p><empty-line /><p>2.13</p><empty-line /><p>2.14</p><empty-line /><p>2.15</p><empty-line /><p>2.16</p><empty-line /><p>2.17</p><empty-line /><p>2.18</p><empty-line /><p>2.19</p><empty-line /><p>2.20</p><empty-line /><p>2.21</p><empty-line /><p>2.22</p><empty-line /><p>2.23</p><empty-line /><p>2.24</p><empty-line /><p>2.25</p><empty-line /><p>2.26</p><empty-line /><p>2.27</p><empty-line /><p>2.28</p><empty-line /><p>2.29</p><empty-line /><p>2.30</p><empty-line /><p>2.31</p><empty-line /><p>2.32</p><empty-line /><p>2.33</p><empty-line /><p>2.34</p><empty-line /><p>2.35</p><empty-line /><p>2.36</p><empty-line /><p>2.37</p><empty-line /><p>2.38</p><empty-line /><p>2.39</p><empty-line /><p>2.40</p><empty-line /><p>2.41</p><empty-line /><p>2.42</p><empty-line /><p>2.43</p><empty-line /><p>2.44</p><empty-line /><p>2.45</p><empty-line /><p>2.46</p><empty-line /><p>2.47</p><empty-line /><p>2.48</p><empty-line /><p>2.49</p><empty-line /><p>2.50</p><empty-line /><p>2.51</p><empty-line /><p>2.52</p><empty-line /><p>2.53</p><empty-line /><p>2.54</p><empty-line /><p>2.55</p><empty-line /><p>2.56</p><empty-line /><p>2.57</p><empty-line /><p>2.58</p><empty-line /><p>2.59</p><empty-line /><p>2.60</p><empty-line /><p>2.61</p><empty-line /><p>2.62</p><empty-line /><p>2.63</p><empty-line /><p>2.64</p><empty-line /><p>2.65</p><empty-line /><p>2.66</p><empty-line /><p>2.67</p><empty-line /><p>2.68</p><empty-line /><p>2.69</p><empty-line /><p>2.70</p><empty-line /><p>2.71</p><empty-line /><p>2.72</p><empty-line /><p>2.73</p><empty-line /><p>2.74</p><empty-line /><p>2.75</p><empty-line /><p>2.76</p><empty-line /><p>2.77</p><empty-line /><p>2.78</p><empty-line /><p>2.79</p><empty-line /><p>2.80</p><empty-line /><p>2.81</p><empty-line /><p>2.82</p><empty-line /><p>2.83</p><empty-line /><p>2.84</p><empty-line /><p>2.85</p><empty-line /><p>2.86</p><empty-line /><p>2.87</p><empty-line /><p>2.88</p><empty-line /><p>2.89</p><empty-line /><p>2.90</p><empty-line /><p>2.91</p><empty-line /><p>2.92</p><empty-line /><p>2.93</p><empty-line /><p>2.94</p><empty-line /><p>2.95</p><empty-line /><p>2.96</p><empty-line /><p>2.97</p><empty-line /><p>3.1</p><empty-line /><p>3.2</p><empty-line /><p>3.3</p><empty-line /><p>3.4</p><empty-line /><p>3.5</p><empty-line /><p>3.6</p><empty-line /><p>3.7</p><empty-line /><p>3.8</p><empty-line /><p>3.9</p><empty-line /><p>3.10</p><empty-line /><p>3.11</p><empty-line /><p>3.12</p><empty-line /><p>3.13</p><empty-line /><p>3.14</p><empty-line /><p>3.15</p><empty-line /><p>3.16</p><empty-line /><p>3.17</p><empty-line /><p>3.18</p><empty-line /><p>3.19</p><empty-line /><p>3.20</p><empty-line /><p>3.21</p><empty-line /><p>3.22</p><empty-line /><p>3.23</p><empty-line /><p>3.24</p><empty-line /><p>3.25</p><empty-line /><p>3.26</p><empty-line /><p>3.27</p><empty-line /><p>3.28</p><empty-line /><p>3.29</p><empty-line /><p>3.30</p><empty-line /><p>3.31</p><empty-line /><p>3.32</p><empty-line /><p>3.33</p><empty-line /><p>3.34</p><empty-line /><p>3.35</p><empty-line /><p>3.36</p><empty-line /><p>3.37</p><empty-line /><p>3.38</p><empty-line /><p>3.39</p><empty-line /><p>3.40</p><empty-line /><p>3.41</p><empty-line /><p>3.42</p><empty-line /><p>3.43</p><empty-line /><p>3.44</p><empty-line /><p>3.45</p><empty-line /><p>3.46</p><empty-line /><p>3.47</p><empty-line /><p>3.48</p><empty-line /><p>3.49</p><empty-line /><p>3.50</p><empty-line /><p>3.51</p><empty-line /><p>3.52</p><empty-line /><p>3.53</p><empty-line /><p>3.54</p><empty-line /><p>3.55</p><empty-line /><p>3.56</p><empty-line /><p>3.57</p><empty-line /><p>3.58</p><empty-line /><p>3.59</p><empty-line /><p>3.60</p><empty-line /><p>3.61</p><empty-line /><p>3.62</p><empty-line /><p>3.63</p><empty-line /><p>3.64</p><empty-line /><p>3.65</p><empty-line /><p>3.66</p><empty-line /><p>3.67</p><empty-line /><p>3.68</p><empty-line /><p>3.69</p><empty-line /><p>3.70</p><empty-line /><p>3.71</p><empty-line /><p>3.72</p><empty-line /><p>3.73</p><empty-line /><p>3.74</p><empty-line /><p>3.75</p><empty-line /><p>3.76</p><empty-line /><p>3.77</p><empty-line /><p>3.78</p><empty-line /><p>3.79</p><empty-line /><p>3.80</p><empty-line /><p>3.81</p><empty-line /><p>3.82</p><empty-line /><p>4.1</p><empty-line /><p>4.2</p><empty-line /><p>4.3</p><empty-line /><p>4.4</p><empty-line /><p>4.5</p><empty-line /><p>4.6</p><empty-line /><p>4.7</p><empty-line /><p>4.8</p><empty-line /><p>4.9</p><empty-line /><p>4.10</p><empty-line /><p>4.11</p><empty-line /><p>4.12</p><empty-line /><p>4.13</p><empty-line /><p>4.14</p><empty-line /><p>4.15</p><empty-line /><p>4.16</p><empty-line /><p>4.17</p><empty-line /><p>4.18</p><empty-line /><p>4.19</p><empty-line /><p>4.20</p><empty-line /><p>4.21</p><empty-line /><p>4.22</p><empty-line /><p>4.23</p><empty-line /><p>4.24</p><empty-line /><p>4.25</p><empty-line /><p>4.26</p><empty-line /><p>4.27</p><empty-line /><p>4.28</p><empty-line /><p>4.29</p><empty-line /><p>4.30</p><empty-line /><p>4.31</p><empty-line /><p>4.32</p><empty-line /><p>4.33</p><empty-line /><p>4.34</p><empty-line /><p>4.35</p><empty-line /><p>4.36</p><empty-line /><p>4.37</p><empty-line /><p>4.38</p><empty-line /><p>4.39</p><empty-line /><p>4.40</p><empty-line /><p>4.41</p><empty-line /><p>4.42</p><empty-line /><p>4.43</p><empty-line /><p>4.44</p><empty-line /><p>4.45</p><empty-line /><p>4.46</p><empty-line /><p>4.47</p><empty-line /><p>4.48</p><empty-line /><p>4.49</p><empty-line /><p>4.50</p><empty-line /><p>4.51</p><empty-line /><p>4.52</p><empty-line /><p>4.53</p><empty-line /><p>4.54</p><empty-line /><p>4.55</p><empty-line /><p>4.56</p><empty-line /><p>4.57</p><empty-line /><p>4.58</p><empty-line /><p>4.59</p><empty-line /><p>4.60</p><empty-line /><p>4.61</p><empty-line /><p>4.62</p><empty-line /><p>4.63</p><empty-line /><p>4.64</p><empty-line /><p>4.65</p><empty-line /><p>4.66</p><empty-line /><p>4.67</p><empty-line /><p>4.68</p><empty-line /><p>4.69</p><empty-line /><p>4.70</p><empty-line /><p>4.71</p><empty-line /><p>4.72</p><empty-line /><p>4.73</p><empty-line /><p>4.74</p><empty-line /><p>4.75</p><empty-line /><p>4.76</p><empty-line /><p>4.77</p><empty-line /><p>4.78</p><empty-line /><p>4.79</p><empty-line /><p>5.1</p><empty-line /><p>5.2</p><empty-line /><p>5.3</p><empty-line /><p>5.4</p><empty-line /><p>5.5</p><empty-line /><p>5.6</p><empty-line /><p>5.7</p><empty-line /><p>5.8</p><empty-line /><p>5.9</p><empty-line /><p>5.10</p><empty-line /><p>5.11</p><empty-line /><p>5.12</p><empty-line /><p>5.13</p><empty-line /><p>5.14</p><empty-line /><p>5.15</p><empty-line /><p>5.16</p><empty-line /><p>5.17</p><empty-line /><p>5.18</p><empty-line /><p>5.19</p><empty-line /><p>5.20</p><empty-line /><p>5.21</p><empty-line /><p>5.22</p><empty-line /><p>5.23</p><empty-line /><p>5.24</p><empty-line /><p>5.25</p><empty-line /><p>5.26</p><empty-line /><p>5.27</p><empty-line /><p>5.28</p><empty-line /><p>5.29</p><empty-line /><p>5.30</p><empty-line /><p>5.31</p><empty-line /><p>5.32</p><empty-line /><p>5.33</p><empty-line /><p>5.34</p><empty-line /><p>5.35</p><empty-line /><p>5.36</p><empty-line /><p>5.37</p><empty-line /><p>5.38</p><empty-line /><p>5.39</p><empty-line /><p>5.40</p><empty-line /><p>5.41</p><empty-line /><p>5.42</p><empty-line /><p>5.43</p><empty-line /><p>5.44</p><empty-line /><p>5.45</p><empty-line /><p>5.46</p><empty-line /><p>5.47</p><empty-line /><p>5.48</p><empty-line /><p>5.49</p><empty-line /><p>5.50</p><empty-line /><p>5.51</p><empty-line /><p>5.52</p><empty-line /><empty-line />
</section>

<section>


<p><strong>
</strong></p>

<p><strong> </strong></p>

<p>
Index</p>

<p> 



Any inaccuracies in this index may be explained by the fact that it
has been prepared with the help of a computer.</p>

<p>Donald E. Knuth,
<emphasis>Fundamental Algorithms</emphasis> (Volume 1 of
<emphasis>The Art of Computer Programming</emphasis>)</p><empty-line /><empty-line /><p>! in names</p><empty-line /><p>" (double quote)</p><empty-line /><p><image xlink:href="#_51.jpg" />  calculus, <emphasis>see</emphasis> lambda calculus</p><empty-line /><p> <image xlink:href="#_45.jpg" />   notation for mathematical function</p><empty-line /><p><image xlink:href="#_37.jpg" /> , <emphasis>see</emphasis> pi</p><empty-line /><p>sum  (sigma) notation</p><empty-line /><p><image xlink:href="#_214.jpg" /> , <emphasis>see</emphasis> theta</p><empty-line /><p>' (single quote)</p><empty-line /><p>
    read and, 
[2]</p><empty-line /><p>* (primitive multiplication procedure)</p><empty-line /><p>+ (primitive addition procedure)</p><empty-line /><p>, (comma, used with backquote)</p><empty-line /><p>- (primitive subtraction procedure)</p><empty-line /><p>
    as negation</p><empty-line /><p>/ (primitive division procedure)</p><empty-line /><p>&lt; (primitive numeric comparison predicate)</p><empty-line /><p>= (primitive numeric equality predicate)</p><empty-line /><p>=number?</p><empty-line /><p>=zero? (generic)</p><empty-line /><p>
    for polynomials</p><empty-line /><p>&gt; (primitive numeric comparison predicate)</p><empty-line /><p>&gt;=, [2]</p><empty-line /><p>? , in predicate names</p><empty-line /><p>#f</p><empty-line /><p>#t</p><empty-line /><p>` (backquote)</p><empty-line /><p>;, <emphasis>see</emphasis> semicolon</p><empty-line /><empty-line /><p>Abelson, Harold</p><empty-line /><p>abs, [2], 
[3]</p><empty-line /><p>absolute value</p><empty-line /><p>abstract data, 
<emphasis>see also</emphasis> data abstraction</p><empty-line /><p>abstract models for data</p><empty-line /><p>
abstract syntax</p><empty-line /><p>
    in metacircular evaluator</p><empty-line /><p>
    in query interpreter</p><empty-line /><p>
abstraction, <emphasis>see also</emphasis> means of abstraction; data abstraction; higher-order procedures</p><empty-line /><p>
    common pattern and</p><empty-line /><p>
    metalinguistic</p><empty-line /><p>
    procedural</p><empty-line /><p>
    in register-machine design</p><empty-line /><p>
    of search in nondeterministic programming</p><empty-line /><p>abstraction barriers, 
[2], [3]</p><empty-line /><p>
    in complex-number system</p><empty-line /><p>
    in generic arithmetic system</p><empty-line /><p>accelerated-sequence</p><empty-line /><p>accumulate, 
[2]</p><empty-line /><p>
    same as fold-right</p><empty-line /><p>accumulate-n</p><empty-line /><p>accumulator, [2]</p><empty-line /><p>Áchárya, Bháscara</p><empty-line /><p>Ackermann's function</p><empty-line /><p>acquire a mutex</p><empty-line /><p>actions, in register machine</p><empty-line /><p>actual-value</p><empty-line /><p>Ada</p><empty-line /><p>
    recursive procedures</p><empty-line /><p>Adams, Norman I., IV</p><empty-line /><p>add (generic)</p><empty-line /><p>
    used for polynomial coefficients, 
[2]</p><empty-line /><p>add-action!, 
[2]</p><empty-line /><p>add-binding-to-frame!</p><empty-line /><p>add-complex</p><empty-line /><p>add-complex-to-schemenum</p><empty-line /><p>add-interval</p><empty-line /><p>add-lists</p><empty-line /><p>add-poly</p><empty-line /><p>add-rat</p><empty-line /><p>add-rule-or-assertion!</p><empty-line /><p>add-streams</p><empty-line /><p>add-terms</p><empty-line /><p>add-to-agenda!, 
[2]</p><empty-line /><p>add-vect</p><empty-line /><p>addend</p><empty-line /><p>
adder</p><empty-line /><p>
    full</p><empty-line /><p>
    half</p><empty-line /><p>
    ripple-carry</p><empty-line /><p>adder (primitive constraint)</p><empty-line /><p>additivity, [2], 
[3], [4]</p><empty-line /><p>address</p><empty-line /><p>address arithmetic</p><empty-line /><p>Adelman, Leonard</p><empty-line /><p>adjoin-arg</p><empty-line /><p>adjoin-set</p><empty-line /><p>
    binary-tree representation</p><empty-line /><p>
    ordered-list representation</p><empty-line /><p>
    unordered-list representation</p><empty-line /><p>
    for weighted sets</p><empty-line /><p>adjoin-term, 
[2]</p><empty-line /><p>advance-pc</p><empty-line /><p>after-delay, 
[2]</p><empty-line /><p>
agenda, <emphasis>see</emphasis> digital-circuit simulation</p><empty-line /><p>A'h-mose</p><empty-line /><p>
algebra, symbolic, <emphasis>see</emphasis> symbolic algebra</p><empty-line /><p>algebraic expression</p><empty-line /><p>
    differentiating</p><empty-line /><p>
    representing</p><empty-line /><p>
    simplifying</p><empty-line /><p>algebraic specification for data</p><empty-line /><p>
Algol</p><empty-line /><p>
    block structure</p><empty-line /><p>
    call-by-name argument passing, 
[2]</p><empty-line /><p>
    thunks, [2]</p><empty-line /><p>
    weakness in handling compound objects</p><empty-line /><p>
algorithm</p><empty-line /><p>
    optimal</p><empty-line /><p>
    probabilistic, 
[2]</p><empty-line /><p>aliasing</p><empty-line /><p>all-regs (compiler)</p><empty-line /><p>Allen, John</p><empty-line /><p>alternative of if</p><empty-line /><p>always-true</p><empty-line /><p>amb</p><empty-line /><p>amb evaluator, <emphasis>see</emphasis> nondeterministic evaluator</p><empty-line /><p>ambeval</p><empty-line /><p>an-element-of</p><empty-line /><p>an-integer-starting-from</p><empty-line /><p>analog computer</p><empty-line /><p>analyze</p><empty-line /><p>
    metacircular</p><empty-line /><p>
    nondeterministic</p><empty-line /><p>analyze-...</p><empty-line /><p>
    metacircular, 
[2]</p><empty-line /><p>
    nondeterministic</p><empty-line /><p>analyze-amb</p><empty-line /><p>analyzing evaluator</p><empty-line /><p>
    as basis for nondeterministic evaluator</p><empty-line /><p>
    let</p><empty-line /><p>and (query language)</p><empty-line /><p>
    evaluation of, 
[2], [3]</p><empty-line /><p>and (special form)</p><empty-line /><p>
    evaluation of</p><empty-line /><p>
    why a special form</p><empty-line /><p>
    with no subexpressions</p><empty-line /><p>and-gate</p><empty-line /><p>
    and-gate</p><empty-line /><p>angle</p><empty-line /><p>
    data-directed</p><empty-line /><p>
    polar representation</p><empty-line /><p>
    rectangular representation</p><empty-line /><p>
    with tagged data</p><empty-line /><p>angle-polar</p><empty-line /><p>angle-rectangular</p><empty-line /><p>announce-output</p><empty-line /><p>APL</p><empty-line /><p>Appel, Andrew W.</p><empty-line /><p>append, [2], 
[3]</p><empty-line /><p>
    as accumulation</p><empty-line /><p>
    append! vs.</p><empty-line /><p>
    with arbitrary number of arguments</p><empty-line /><p>
    as register machine</p><empty-line /><p>
    "what is" (rules) vs. "how to" (procedure)</p><empty-line /><p>append!</p><empty-line /><p>
    as register machine</p><empty-line /><p>append-instruction-sequences, 
[2]</p><empty-line /><p>append-to-form (rules)</p><empty-line /><p>application?</p><empty-line /><p>applicative-order evaluation</p><empty-line /><p>
    in Lisp</p><empty-line /><p>
    normal order vs., 
[2], [3]</p><empty-line /><p>apply (lazy)</p><empty-line /><p>apply (metacircular)</p><empty-line /><p>
    primitive apply vs.</p><empty-line /><p>apply (primitive procedure)</p><empty-line /><p>apply-dispatch</p><empty-line /><p>
    modified for compiled code</p><empty-line /><p>apply-generic</p><empty-line /><p>
    with coercion, 
[2]</p><empty-line /><p>
    with coercion by raising</p><empty-line /><p>
    with coercion of multiple arguments</p><empty-line /><p>
    with coercion to simplify</p><empty-line /><p>
    with message passing</p><empty-line /><p>
    with tower of types</p><empty-line /><p>apply-primitive-procedure, 
[2], [3]</p><empty-line /><p>apply-rules</p><empty-line /><p>arbiter</p><empty-line /><p>arctangent</p><empty-line /><p>argl register</p><empty-line /><p>
argument passing, <emphasis>see</emphasis> call-by-name argument passing; call-by-need argument passing</p><empty-line /><p>argument(s)</p><empty-line /><p>
    arbitrary number of, 
[2]</p><empty-line /><p>
    delayed</p><empty-line /><p>Aristotle's <emphasis>De caelo</emphasis> (Buridan's commentary on)</p><empty-line /><p>
arithmetic</p><empty-line /><p>
    address arithmetic</p><empty-line /><p>
    generic, 
<emphasis>see also</emphasis> generic arithmetic operations</p><empty-line /><p>
    on complex numbers</p><empty-line /><p>
    on intervals</p><empty-line /><p>
    on polynomials, <emphasis>see</emphasis> polynomial arithmetic</p><empty-line /><p>
    on power series, 
[2]</p><empty-line /><p>
    on rational numbers</p><empty-line /><p>
    primitive procedures for</p><empty-line /><p>articles</p><empty-line /><p>ASCII code</p><empty-line /><p>assemble, [2]</p><empty-line /><p>assembler, [2]</p><empty-line /><p>assert! (query interpreter)</p><empty-line /><p>assertion</p><empty-line /><p>
    implicit</p><empty-line /><p>assign (in register machine)</p><empty-line /><p>
    simulating</p><empty-line /><p>
    storing label in register</p><empty-line /><p>assign-reg-name</p><empty-line /><p>assign-value-exp</p><empty-line /><p>assignment, <emphasis>see also</emphasis> set!</p><empty-line /><p>
    benefits of</p><empty-line /><p>
    bugs associated with, 
[2]</p><empty-line /><p>
    costs of</p><empty-line /><p>assignment operator, 
<emphasis>see also</emphasis> set!</p><empty-line /><p>assignment-value</p><empty-line /><p>assignment-variable</p><empty-line /><p>assignment?</p><empty-line /><p>assoc</p><empty-line /><p>atan (primitive procedure)</p><empty-line /><p>atomic operations supported in hardware</p><empty-line /><p>atomic requirement for test-and-set!</p><empty-line /><p>attach-tag</p><empty-line /><p>
    using Scheme data types</p><empty-line /><p>augend</p><empty-line /><p>automagically</p><empty-line /><p>automatic search, 
<emphasis>see also</emphasis> search</p><empty-line /><p>
    history of</p><empty-line /><p>automatic storage allocation</p><empty-line /><p>average</p><empty-line /><p>average damping</p><empty-line /><p>average-damp</p><empty-line /><p>averager (constraint)</p><empty-line /><empty-line /><p>B-tree</p><empty-line /><p>backquote</p><empty-line /><p>backtracking, 
<emphasis>see also</emphasis> nondeterministic computing</p><empty-line /><p>Backus, John</p><empty-line /><p>Baker, Henry G., Jr.</p><empty-line /><p>balanced binary tree, 
<emphasis>see also</emphasis> binary tree</p><empty-line /><p>balanced mobile</p><empty-line /><p>bank account, [2]</p><empty-line /><p>
    exchanging balances</p><empty-line /><p>
    joint, [2]</p><empty-line /><p>
    joint, modeled with streams</p><empty-line /><p>
    joint, with concurrent access</p><empty-line /><p>
    password-protected</p><empty-line /><p>
    serialized</p><empty-line /><p>
    stream model</p><empty-line /><p>
    transferring money</p><empty-line /><p>barrier synchronization</p><empty-line /><p>Barth, John</p><empty-line /><p>
Basic</p><empty-line /><p>
    restrictions on compound data</p><empty-line /><p>
    weakness in handling compound objects</p><empty-line /><p>Batali, John Dean</p><empty-line /><p>begin (special form)</p><empty-line /><p>
    implicit in consequent of cond and in procedure body</p><empty-line /><p>begin-actions</p><empty-line /><p>begin?</p><empty-line /><p>below, [2]</p><empty-line /><p>Bertrand's Hypothesis</p><empty-line /><p>beside, [2]</p><empty-line /><p>bignum</p><empty-line /><p>
binary numbers, addition of, <emphasis>see</emphasis> adder</p><empty-line /><p>binary search</p><empty-line /><p>binary tree</p><empty-line /><p>
    balanced</p><empty-line /><p>
    converting a list to a</p><empty-line /><p>
    converting to a list</p><empty-line /><p>
    for Huffman encoding</p><empty-line /><p>
    represented with lists</p><empty-line /><p>
    sets represented as</p><empty-line /><p>
    table structured as</p><empty-line /><p>bind</p><empty-line /><p>binding</p><empty-line /><p>
    deep</p><empty-line /><p>binomial coefficients</p><empty-line /><p>black box</p><empty-line /><p>block structure, [2]</p><empty-line /><p>
    in environment model</p><empty-line /><p>
    in query language</p><empty-line /><p>blocked process</p><empty-line /><p>body of a procedure</p><empty-line /><p>Bolt Beranek and Newman Inc.</p><empty-line /><p>Borning, Alan</p><empty-line /><p>Borodin, Alan</p><empty-line /><p>bound variable</p><empty-line /><p>box-and-pointer notation</p><empty-line /><p>
    end-of-list marker</p><empty-line /><p>branch (in register machine)</p><empty-line /><p>
    simulating</p><empty-line /><p>branch of a tree</p><empty-line /><p>branch-dest</p><empty-line /><p>breakpoint</p><empty-line /><p>broken heart</p><empty-line /><p>bug</p><empty-line /><p>
    capturing a free variable</p><empty-line /><p>
    order of assignments</p><empty-line /><p>
    side effect with aliasing</p><empty-line /><p>bureaucracy</p><empty-line /><p>Buridan, Jean</p><empty-line /><p>busy-waiting</p><empty-line /><empty-line /><p>
C</p><empty-line /><p>
    compiling Scheme into</p><empty-line /><p>
    error handling, 
[2]</p><empty-line /><p>
    recursive procedures</p><empty-line /><p>
    restrictions on compound data</p><empty-line /><p>
    Scheme interpreter written in, 
[2]</p><empty-line /><p>ca...r</p><empty-line /><p>cache-coherence protocols</p><empty-line /><p>cadr</p><empty-line /><p>calculator, fixed points with</p><empty-line /><p>call-by-name argument passing, 
[2]</p><empty-line /><p>call-by-need argument passing, 
[2]</p><empty-line /><p>
    memoization and</p><empty-line /><p>call-each</p><empty-line /><p>cancer of the semicolon</p><empty-line /><p>canonical form, for polynomials</p><empty-line /><p>capturing a free variable</p><empty-line /><p>car (primitive procedure)</p><empty-line /><p>
    axiom for</p><empty-line /><p>
    implemented with vectors</p><empty-line /><p>
    as list operation</p><empty-line /><p>
    origin of the name</p><empty-line /><p>
    procedural implementation of, 
[2], [3], 
[4], [5]</p><empty-line /><p>Carmichael numbers, 
[2]</p><empty-line /><p>
case analysis</p><empty-line /><p>
    data-directed programming vs.</p><empty-line /><p>
    general, <emphasis>see also</emphasis> cond</p><empty-line /><p>
    with two cases (if)</p><empty-line /><p>cd...r</p><empty-line /><p>cdr (primitive procedure)</p><empty-line /><p>
    axiom for</p><empty-line /><p>
    implemented with vectors</p><empty-line /><p>
    as list operation</p><empty-line /><p>
    origin of the name</p><empty-line /><p>
    procedural implementation of, 
[2], [3], 
[4], [5]</p><empty-line /><p>cdr down a list</p><empty-line /><p>cell, in serializer implementation</p><empty-line /><p>celsius-fahrenheit-converter</p><empty-line /><p>
    expression-oriented</p><empty-line /><p>center</p><empty-line /><p>Cesàro, Ernesto</p><empty-line /><p>cesaro-stream</p><empty-line /><p>cesaro-test</p><empty-line /><p>Chaitin, Gregory</p><empty-line /><p>Chandah-sutra</p><empty-line /><p>
change and sameness</p><empty-line /><p>
    meaning of</p><empty-line /><p>
    shared data and</p><empty-line /><p>
changing money, <emphasis>see</emphasis> counting change</p><empty-line /><p>chaos in the Solar System</p><empty-line /><p>Chapman, David</p><empty-line /><p>
character strings</p><empty-line /><p>
    primitive procedures for, 
[2]</p><empty-line /><p>
    quotation of</p><empty-line /><p>character, ASCII encoding</p><empty-line /><p>Charniak, Eugene</p><empty-line /><p>Chebyshev, Pafnutii L'vovich</p><empty-line /><p>chess, eight-queens puzzle, 
[2]</p><empty-line /><p>chip implementation of Scheme, 
[2]</p><empty-line /><p>chronological backtracking</p><empty-line /><p>Chu Shih-chieh</p><empty-line /><p>Church numerals</p><empty-line /><p>Church, Alonzo, [2]</p><empty-line /><p>Church-Turing thesis</p><empty-line /><p>
circuit</p><empty-line /><p>
    digital, <emphasis>see</emphasis> digital-circuit simulation</p><empty-line /><p>
    modeled with streams, 
[2]</p><empty-line /><p>Clark, Keith L.</p><empty-line /><p>clause, of a cond</p><empty-line /><p>
    additional syntax</p><empty-line /><p>Clinger, William, 
[2]</p><empty-line /><p>closed world assumption</p><empty-line /><p>closure</p><empty-line /><p>
    in abstract algebra</p><empty-line /><p>
    closure property of cons</p><empty-line /><p>
    closure property of picture-language operations, [2]</p><empty-line /><p>
    lack of in many languages</p><empty-line /><p>coal, bituminous</p><empty-line /><p>
code</p><empty-line /><p>
    ASCII</p><empty-line /><p>
    fixed-length</p><empty-line /><p>
    Huffman, <emphasis>see</emphasis> Huffman code</p><empty-line /><p>
    Morse</p><empty-line /><p>
    prefix</p><empty-line /><p>
    variable-length</p><empty-line /><p>code generator</p><empty-line /><p>
    arguments of</p><empty-line /><p>
    value of</p><empty-line /><p>coeff, [2]</p><empty-line /><p>coercion</p><empty-line /><p>
    in algebraic manipulation</p><empty-line /><p>
    in polynomial arithmetic</p><empty-line /><p>
    procedure</p><empty-line /><p>
    table</p><empty-line /><p>Colmerauer, Alain</p><empty-line /><p>combination</p><empty-line /><p>
    combination as operator of</p><empty-line /><p>
    compound expression as operator of</p><empty-line /><p>
    evaluation of</p><empty-line /><p>
    lambda expression as operator of</p><empty-line /><p>
    as operator of combination</p><empty-line /><p>
    as a tree</p><empty-line /><p>combination, means of, 
<emphasis>see also</emphasis> closure</p><empty-line /><p>comma, used with backquote</p><empty-line /><p>comments in programs</p><empty-line /><p>Common Lisp</p><empty-line /><p>
    treatment of nil</p><empty-line /><p>compacting garbage collector</p><empty-line /><p>
compilation, <emphasis>see</emphasis> compiler</p><empty-line /><p>compile</p><empty-line /><p>compile-and-go, 
[2]</p><empty-line /><p>compile-and-run</p><empty-line /><p>compile-application</p><empty-line /><p>compile-assignment</p><empty-line /><p>compile-definition</p><empty-line /><p>compile-if</p><empty-line /><p>compile-lambda</p><empty-line /><p>compile-linkage</p><empty-line /><p>compile-proc-appl</p><empty-line /><p>compile-procedure-call</p><empty-line /><p>compile-quoted</p><empty-line /><p>compile-self-evaluating</p><empty-line /><p>compile-sequence</p><empty-line /><p>compile-time environment, 
[2], [3]</p><empty-line /><p>
    open coding and</p><empty-line /><p>compile-variable</p><empty-line /><p>compiled-apply</p><empty-line /><p>compiled-procedure-entry</p><empty-line /><p>compiled-procedure-env</p><empty-line /><p>compiled-procedure?</p><empty-line /><p>compiler</p><empty-line /><p>
    interpreter vs., 
[2]</p><empty-line /><p>
    tail recursion, stack allocation, and garbage-collection</p><empty-line /><p>compiler for Scheme, 
<emphasis>see also</emphasis> code generator; compile-time environment; instruction sequence; linkage descriptor; target register</p><empty-line /><p>
    analyzing evaluator vs., 
[2]</p><empty-line /><p>
    assignments</p><empty-line /><p>
    code generators, <emphasis>see</emphasis> compile-...</p><empty-line /><p>
    combinations</p><empty-line /><p>
    conditionals</p><empty-line /><p>
    definitions</p><empty-line /><p>
    efficiency</p><empty-line /><p>
    example compilation</p><empty-line /><p>
    explicit-control evaluator vs., 
[2], [3]</p><empty-line /><p>
    expression-syntax procedures</p><empty-line /><p>
    interfacing to evaluator</p><empty-line /><p>
    label generation</p><empty-line /><p>
    lambda expressions</p><empty-line /><p>
    lexical addressing</p><empty-line /><p>
    linkage code</p><empty-line /><p>
    machine-operation use</p><empty-line /><p>
    monitoring performance (stack use) of compiled code, [2], 
[3]</p><empty-line /><p>
    open coding of primitives, 
[2]</p><empty-line /><p>
    order of operand evaluation</p><empty-line /><p>
    procedure applications</p><empty-line /><p>
    quotations</p><empty-line /><p>
    register use, 
[2], [3]</p><empty-line /><p>
    running compiled code</p><empty-line /><p>
    scanning out internal definitions, 
[2]</p><empty-line /><p>
    self-evaluating expressions</p><empty-line /><p>
    sequences of expressions</p><empty-line /><p>
    stack usage, 
[2], [3]</p><empty-line /><p>
    structure of</p><empty-line /><p>
    tail-recursive code generated by</p><empty-line /><p>
    variables</p><empty-line /><p>complex package</p><empty-line /><p>
complex numbers</p><empty-line /><p>
    polar representation</p><empty-line /><p>
    rectangular representation</p><empty-line /><p>
    rectangular vs. polar form</p><empty-line /><p>
    represented as tagged data</p><empty-line /><p>complex-&gt;complex</p><empty-line /><p>complex-number arithmetic</p><empty-line /><p>
    interfaced to generic arithmetic system</p><empty-line /><p>
    structure of system</p><empty-line /><p>composition of functions</p><empty-line /><p>compound data, need for</p><empty-line /><p>compound expression, 
<emphasis>see also</emphasis> combination; special form</p><empty-line /><p>
    as operator of combination</p><empty-line /><p>compound procedure, 
<emphasis>see also</emphasis> procedure</p><empty-line /><p>
    used like primitive procedure</p><empty-line /><p>compound query</p><empty-line /><p>
    processing, [2], 
[3], [4], 
[5]</p><empty-line /><p>compound-apply</p><empty-line /><p>compound-procedure?</p><empty-line /><p>computability, [2]</p><empty-line /><p>computational process, 
<emphasis>see also</emphasis> process</p><empty-line /><p>computer science, 
[2]</p><empty-line /><p>
    mathematics vs., 
[2]</p><empty-line /><p>concrete data representation</p><empty-line /><p>concurrency</p><empty-line /><p>
    correctness of concurrent programs</p><empty-line /><p>
    deadlock</p><empty-line /><p>
    functional programming and</p><empty-line /><p>
    mechanisms for controlling</p><empty-line /><p>cond (special form)</p><empty-line /><p>
    additional clause syntax</p><empty-line /><p>
    clause</p><empty-line /><p>
    evaluation of</p><empty-line /><p>
    if vs.</p><empty-line /><p>
    implicit begin in consequent</p><empty-line /><p>cond-&gt;if</p><empty-line /><p>cond-actions</p><empty-line /><p>cond-clauses</p><empty-line /><p>cond-else-clause?</p><empty-line /><p>cond-predicate</p><empty-line /><p>cond?</p><empty-line /><p>
conditional expression</p><empty-line /><p>
    cond</p><empty-line /><p>
    if</p><empty-line /><p>congruent modulo <emphasis>n</emphasis></p><empty-line /><p>conjoin</p><empty-line /><p>connect, [2]</p><empty-line /><p>connector(s), in constraint system</p><empty-line /><p>
    operations on</p><empty-line /><p>
    representing</p><empty-line /><p>Conniver</p><empty-line /><p>cons (primitive procedure)</p><empty-line /><p>
    axiom for</p><empty-line /><p>
    closure property of</p><empty-line /><p>
    implemented with mutators</p><empty-line /><p>
    implemented with vectors</p><empty-line /><p>
    as list operation</p><empty-line /><p>
    meaning of the name</p><empty-line /><p>
    procedural implementation of, 
[2], [3], 
[4], [5], 
[6]</p><empty-line /><p>cons up a list</p><empty-line /><p>cons-stream (special form), 
[2]</p><empty-line /><p>
    lazy evaluation and</p><empty-line /><p>
    why a special form</p><empty-line /><p>consciousness, expansion of</p><empty-line /><p>
consequent</p><empty-line /><p>
    of cond clause</p><empty-line /><p>
    of if</p><empty-line /><p>const (in register machine)</p><empty-line /><p>
    simulating</p><empty-line /><p>
    syntax of</p><empty-line /><p>constant (primitive constraint)</p><empty-line /><p>constant, specifying in register machine</p><empty-line /><p>constant-exp</p><empty-line /><p>constant-exp-value</p><empty-line /><p>constraint network</p><empty-line /><p>
constraint(s)</p><empty-line /><p>
    primitive</p><empty-line /><p>
    propagation of</p><empty-line /><p>construct-arglist</p><empty-line /><p>constructor</p><empty-line /><p>
    as abstraction barrier</p><empty-line /><p>contents</p><empty-line /><p>
    using Scheme data types</p><empty-line /><p>
continuation</p><empty-line /><p>
    in nondeterministic evaluator, 
[2], 
<emphasis>see also</emphasis> failure continuation; success continuation</p><empty-line /><p>
    in register-machine simulator</p><empty-line /><p>continue register</p><empty-line /><p>
    in explicit-control evaluator</p><empty-line /><p>
    recursion and</p><empty-line /><p>continued fraction</p><empty-line /><p>
    <emphasis>e</emphasis> as</p><empty-line /><p>
    golden ratio as</p><empty-line /><p>
    tangent as</p><empty-line /><p>control structure</p><empty-line /><p>controller for register machine</p><empty-line /><p>
    controller diagram</p><empty-line /><p>conventional interface</p><empty-line /><p>
    sequence as</p><empty-line /><p>Cormen, Thomas H.</p><empty-line /><p>corner-split</p><empty-line /><p>correctness of a program</p><empty-line /><p>cos (primitive procedure)</p><empty-line /><p>
cosine</p><empty-line /><p>
    fixed point of</p><empty-line /><p>
    power series for</p><empty-line /><p>cosmic radiation</p><empty-line /><p>count-change</p><empty-line /><p>count-leaves, 
[2]</p><empty-line /><p>
    as accumulation</p><empty-line /><p>
    as register machine</p><empty-line /><p>count-pairs</p><empty-line /><p>counting change, [2]</p><empty-line /><p>credit-card accounts, international</p><empty-line /><p>Cressey, David</p><empty-line /><p>cross-type operations</p><empty-line /><p>cryptography</p><empty-line /><p>cube, [2], 
[3]</p><empty-line /><p>
cube root</p><empty-line /><p>
    as fixed point</p><empty-line /><p>
    by Newton's method</p><empty-line /><p>cube-root</p><empty-line /><p>current time, for simulation agenda</p><empty-line /><p>current-time, 
[2]</p><empty-line /><p>cycle in list</p><empty-line /><p>
    detecting</p><empty-line /><empty-line /><p>Darlington, John</p><empty-line /><p>data, [2]</p><empty-line /><p>
    abstract, 
<emphasis>see also</emphasis> data abstraction</p><empty-line /><p>
    abstract models for</p><empty-line /><p>
    algebraic specification for</p><empty-line /><p>
    compound</p><empty-line /><p>
    concrete representation of</p><empty-line /><p>
    hierarchical, 
[2]</p><empty-line /><p>
    list-structured</p><empty-line /><p>
    meaning of</p><empty-line /><p>
    mutable, <emphasis>see</emphasis> mutable data objects</p><empty-line /><p>
    numerical</p><empty-line /><p>
    procedural representation of</p><empty-line /><p>
    as program</p><empty-line /><p>
    shared</p><empty-line /><p>
    symbolic</p><empty-line /><p>
    tagged, [2]</p><empty-line /><p>data abstraction, 
[2], [3], 
[4], [5], 
<emphasis>see also</emphasis> metacircular evaluator</p><empty-line /><p>
    for queue</p><empty-line /><p>
data base</p><empty-line /><p>
    data-directed programming and</p><empty-line /><p>
    indexing, [2]</p><empty-line /><p>
    Insatiable Enterprises personnel</p><empty-line /><p>
    logic programming and</p><empty-line /><p>
    Microshaft personnel</p><empty-line /><p>
    as set of records</p><empty-line /><p>data paths for register machine</p><empty-line /><p>
    data-path diagram</p><empty-line /><p>
data types</p><empty-line /><p>
    in Lisp</p><empty-line /><p>
    in strongly typed languages</p><empty-line /><p>data-directed programming, 
[2]</p><empty-line /><p>
    case analysis vs.</p><empty-line /><p>
    in metacircular evaluator</p><empty-line /><p>
    in query interpreter</p><empty-line /><p>data-directed recursion</p><empty-line /><p>deadlock</p><empty-line /><p>
    avoidance</p><empty-line /><p>
    recovery</p><empty-line /><p>debug</p><empty-line /><p>decimal point in numbers</p><empty-line /><p>declarative vs. imperative knowledge, 
[2]</p><empty-line /><p>
    logic programming and, 
[2]</p><empty-line /><p>
    nondeterministic computing and</p><empty-line /><p>decode</p><empty-line /><p>decomposition of program into parts</p><empty-line /><p>deep binding</p><empty-line /><p>deep-reverse</p><empty-line /><p>deferred operations</p><empty-line /><p>define (special form)</p><empty-line /><p>
    with dotted-tail notation</p><empty-line /><p>
    environment model of</p><empty-line /><p>
    lambda vs.</p><empty-line /><p>
    for procedures, 
[2]</p><empty-line /><p>
    syntactic sugar</p><empty-line /><p>
    value of</p><empty-line /><p>
    why a special form</p><empty-line /><p>define (special form)</p><empty-line /><p>
    internal, <emphasis>see</emphasis> internal definition</p><empty-line /><p>define-variable!, 
[2]</p><empty-line /><p>definite integral</p><empty-line /><p>
    estimated with Monte Carlo simulation, [2]</p><empty-line /><p>
definition, <emphasis>see</emphasis> define; internal definition</p><empty-line /><p>definition-value</p><empty-line /><p>definition-variable</p><empty-line /><p>definition?</p><empty-line /><p>deKleer, Johan, [2]</p><empty-line /><p>delay (special form)</p><empty-line /><p>
    explicit</p><empty-line /><p>
    explicit vs. automatic</p><empty-line /><p>
    implementation using lambda</p><empty-line /><p>
    lazy evaluation and</p><empty-line /><p>
    memoized, [2]</p><empty-line /><p>
    why a special form</p><empty-line /><p>delay, in digital circuit</p><empty-line /><p>delay-it</p><empty-line /><p>delayed argument</p><empty-line /><p>delayed evaluation, 
[2]</p><empty-line /><p>
    assignment and</p><empty-line /><p>
    explicit vs. automatic</p><empty-line /><p>
    in lazy evaluator</p><empty-line /><p>
    normal-order evaluation and</p><empty-line /><p>
    printing and</p><empty-line /><p>
    streams and</p><empty-line /><p>delayed object</p><empty-line /><p>delete-queue!, 
[2]</p><empty-line /><p>denom, [2]</p><empty-line /><p>
    axiom for</p><empty-line /><p>
    reducing to lowest terms</p><empty-line /><p>dense polynomial</p><empty-line /><p>dependency-directed backtracking</p><empty-line /><p>deposit , with external serializer</p><empty-line /><p>deposit message for bank account</p><empty-line /><p>depth-first search</p><empty-line /><p>deque</p><empty-line /><p>deriv (numerical)</p><empty-line /><p>deriv (symbolic)</p><empty-line /><p>
    data-directed</p><empty-line /><p>derivative of a function</p><empty-line /><p>derived expressions in evaluator</p><empty-line /><p>
    adding to explicit-control evaluator</p><empty-line /><p>design, stratified</p><empty-line /><p>differential equation, 
<emphasis>see also</emphasis> solve</p><empty-line /><p>
    second-order, 
[2]</p><empty-line /><p>
differentiation</p><empty-line /><p>
    numerical</p><empty-line /><p>
    rules for, [2]</p><empty-line /><p>
    symbolic, [2]</p><empty-line /><p>diffusion, simulation of</p><empty-line /><p>digital signal</p><empty-line /><p>digital-circuit simulation</p><empty-line /><p>
    agenda</p><empty-line /><p>
    agenda implementation</p><empty-line /><p>
    primitive function boxes</p><empty-line /><p>
    representing wires</p><empty-line /><p>
    sample simulation</p><empty-line /><p>Dijkstra, Edsger Wybe</p><empty-line /><p>Dinesman, Howard P.</p><empty-line /><p>Diophantus's <emphasis>Arithmetic</emphasis>, Fermat's copy of</p><empty-line /><p>disjoin</p><empty-line /><p>
dispatching</p><empty-line /><p>
    comparing different styles</p><empty-line /><p>
    on type, 
<emphasis>see also</emphasis> data-directed programming</p><empty-line /><p>display (primitive procedure), 
[2]</p><empty-line /><p>display-line</p><empty-line /><p>display-stream</p><empty-line /><p>distinct?</p><empty-line /><p>div (generic)</p><empty-line /><p>div-complex</p><empty-line /><p>div-interval</p><empty-line /><p>
    division by zero</p><empty-line /><p>div-poly</p><empty-line /><p>div-rat</p><empty-line /><p>div-series</p><empty-line /><p>div-terms</p><empty-line /><p>divides?</p><empty-line /><p>divisible?</p><empty-line /><p>division of integers</p><empty-line /><p>dog, perfectly rational, behavior of</p><empty-line /><p>DOS/Windows</p><empty-line /><p>dot-product</p><empty-line /><p>
dotted-tail notation</p><empty-line /><p>
    for procedure parameters, 
[2]</p><empty-line /><p>
    in query pattern, 
[2]</p><empty-line /><p>
    in query-language rule</p><empty-line /><p>
    read and</p><empty-line /><p>Doyle, Jon</p><empty-line /><p>draw-line</p><empty-line /><p>
driver loop</p><empty-line /><p>
    in explicit-control evaluator</p><empty-line /><p>
    in lazy evaluator</p><empty-line /><p>
    in metacircular evaluator</p><empty-line /><p>
    in nondeterministic evaluator, 
[2]</p><empty-line /><p>
    in query interpreter, 
[2]</p><empty-line /><p>driver-loop</p><empty-line /><p>
    for lazy evaluator</p><empty-line /><p>
    for metacircular evaluator</p><empty-line /><p>
    for nondeterministic evaluator</p><empty-line /><empty-line /><p><emphasis>e</emphasis></p><empty-line /><p>
    as continued fraction</p><empty-line /><p>
    as solution to differential equation</p><empty-line /><p><emphasis>e</emphasis><sup><emphasis>x</emphasis></sup>, power series for</p><empty-line /><p>Earth, measuring circumference of</p><empty-line /><p>edge1-frame</p><empty-line /><p>edge2-frame</p><empty-line /><p>
efficiency, <emphasis>see also</emphasis> order of growth, 
<emphasis>see also</emphasis> order of growth</p><empty-line /><p>
    of compilation</p><empty-line /><p>
    of data-base access</p><empty-line /><p>
    of evaluation</p><empty-line /><p>
    of Lisp</p><empty-line /><p>
    of query processing</p><empty-line /><p>
    of tree-recursive process</p><empty-line /><p>EIEIO</p><empty-line /><p>eight-queens puzzle, 
[2]</p><empty-line /><p>electrical circuits, modeled with streams, [2]</p><empty-line /><p>element-of-set?</p><empty-line /><p>
    binary-tree representation</p><empty-line /><p>
    ordered-list representation</p><empty-line /><p>
    unordered-list representation</p><empty-line /><p>else (special symbol in cond)</p><empty-line /><p>embedded language, language design using</p><empty-line /><p>empty list</p><empty-line /><p>
    denoted as '()</p><empty-line /><p>
    recognizing with null?</p><empty-line /><p>empty stream</p><empty-line /><p>empty-agenda?, 
[2]</p><empty-line /><p>empty-arglist</p><empty-line /><p>empty-instruction-sequence</p><empty-line /><p>empty-queue?, 
[2]</p><empty-line /><p>empty-termlist?, 
[2]</p><empty-line /><p>encapsulated name</p><empty-line /><p>enclosing environment</p><empty-line /><p>enclosing-environment</p><empty-line /><p>encode</p><empty-line /><p>end-of-list marker</p><empty-line /><p>end-segment, 
[2]</p><empty-line /><p>end-with-linkage</p><empty-line /><p>engineering vs. mathematics</p><empty-line /><p>entry</p><empty-line /><p>enumerate-interval</p><empty-line /><p>enumerate-tree</p><empty-line /><p>enumerator</p><empty-line /><p>env register</p><empty-line /><p>environment, [2]</p><empty-line /><p>
    compile-time, <emphasis>see</emphasis> compile-time environment</p><empty-line /><p>
    as context for evaluation</p><empty-line /><p>
    enclosing</p><empty-line /><p>
    global, <emphasis>see</emphasis> global environment</p><empty-line /><p>
    lexical scoping and</p><empty-line /><p>
    in query interpreter</p><empty-line /><p>
    renaming vs.</p><empty-line /><p>environment model of evaluation, 
[2]</p><empty-line /><p>
    environment structure</p><empty-line /><p>
    internal definitions</p><empty-line /><p>
    local state</p><empty-line /><p>
    message passing</p><empty-line /><p>
    metacircular evaluator and</p><empty-line /><p>
    procedure-application example</p><empty-line /><p>
    rules for evaluation</p><empty-line /><p>
    tail recursion and</p><empty-line /><p>eq? (primitive procedure)</p><empty-line /><p>
    for arbitrary objects</p><empty-line /><p>
    as equality of pointers, 
[2]</p><empty-line /><p>
    implementation for symbols</p><empty-line /><p>
    numerical equality and</p><empty-line /><p>equ? (generic predicate)</p><empty-line /><p>equal-rat?</p><empty-line /><p>equal?</p><empty-line /><p>
equality</p><empty-line /><p>
    in generic arithmetic system</p><empty-line /><p>
    of lists</p><empty-line /><p>
    of numbers, [2], 
[3]</p><empty-line /><p>
    referential transparency and</p><empty-line /><p>
    of symbols</p><empty-line /><p>
equation, solving, <emphasis>see</emphasis> half-interval method; Newton's method; solve</p><empty-line /><p>Eratosthenes</p><empty-line /><p>error (primitive procedure)</p><empty-line /><p>
error handling</p><empty-line /><p>
    in compiled code</p><empty-line /><p>
    in explicit-control evaluator, 
[2]</p><empty-line /><p>Escher, Maurits Cornelis</p><empty-line /><p>estimate-integral</p><empty-line /><p>estimate-pi, 
[2]</p><empty-line /><p>Euclid's Algorithm, 
[2], 
<emphasis>see also</emphasis> greatest common divisor</p><empty-line /><p>
    order of growth</p><empty-line /><p>
    for polynomials</p><empty-line /><p>Euclid's <emphasis>Elements</emphasis></p><empty-line /><p>Euclid's proof of infinite number of primes</p><empty-line /><p>Euclidean ring</p><empty-line /><p>Euler, Leonhard</p><empty-line /><p>
    proof of Fermat's Little Theorem</p><empty-line /><p>
    series accelerator</p><empty-line /><p>euler-transform</p><empty-line /><p>ev-application</p><empty-line /><p>ev-assignment</p><empty-line /><p>ev-begin</p><empty-line /><p>ev-definition</p><empty-line /><p>ev-if</p><empty-line /><p>ev-lambda</p><empty-line /><p>ev-quoted</p><empty-line /><p>ev-self-eval</p><empty-line /><p>ev-sequence</p><empty-line /><p>
    with tail recursion</p><empty-line /><p>
    without tail recursion</p><empty-line /><p>ev-variable</p><empty-line /><p>eval (lazy)</p><empty-line /><p>eval (metacircular), 
[2]</p><empty-line /><p>
    analyzing version</p><empty-line /><p>
    data-directed</p><empty-line /><p>
    primitive eval vs.</p><empty-line /><p>eval (primitive procedure)</p><empty-line /><p>
    MIT Scheme</p><empty-line /><p>
    used in query interpreter</p><empty-line /><p>eval-assignment</p><empty-line /><p>eval-definition</p><empty-line /><p>eval-dispatch</p><empty-line /><p>eval-if (lazy)</p><empty-line /><p>eval-if (metacircular)</p><empty-line /><p>eval-sequence</p><empty-line /><p>
evaluation</p><empty-line /><p>
    applicative-order, <emphasis>see</emphasis> applicative-order evaluation</p><empty-line /><p>
    delayed, <emphasis>see</emphasis> delayed evaluation</p><empty-line /><p>
    environment model of, <emphasis>see</emphasis> environment model of evaluation</p><empty-line /><p>
    models of</p><empty-line /><p>
    normal-order, <emphasis>see</emphasis> normal-order evaluation</p><empty-line /><p>
    of a combination</p><empty-line /><p>
    of and</p><empty-line /><p>
    of cond</p><empty-line /><p>
    of if</p><empty-line /><p>
    of or</p><empty-line /><p>
    of primitive expressions</p><empty-line /><p>
    of special forms</p><empty-line /><p>
    order of subexpression evaluation, <emphasis>see</emphasis> order of evaluation</p><empty-line /><p>
    substitution model of, <emphasis>see</emphasis> substitution model of procedure application</p><empty-line /><p>evaluator, <emphasis>see also</emphasis> interpreter</p><empty-line /><p>
    as abstract machine</p><empty-line /><p>
    metacircular</p><empty-line /><p>
    as universal machine</p><empty-line /><p>
evaluators, <emphasis>see</emphasis> metacircular evaluator; analyzing evaluator; lazy evaluator; nondeterministic evaluator; query interpreter; explicit-control evaluator</p><empty-line /><p>even-fibs, [2]</p><empty-line /><p>even?</p><empty-line /><p>
evening star, <emphasis>see</emphasis> Venus</p><empty-line /><p>event-driven simulation</p><empty-line /><p>evlis tail recursion</p><empty-line /><p>exact integer</p><empty-line /><p>exchange</p><empty-line /><p>exclamation point in names</p><empty-line /><p>execute</p><empty-line /><p>execute-application</p><empty-line /><p>
    metacircular</p><empty-line /><p>
    nondeterministic</p><empty-line /><p>
execution procedure</p><empty-line /><p>
    in analyzing evaluator</p><empty-line /><p>
    in nondeterministic evaluator, 
[2], [3]</p><empty-line /><p>
    in register-machine simulator, 
[2]</p><empty-line /><p>exp register</p><empty-line /><p>expand-clauses</p><empty-line /><p>explicit-control evaluator for Scheme</p><empty-line /><p>
    assignments</p><empty-line /><p>
    combinations</p><empty-line /><p>
    compound procedures</p><empty-line /><p>
    conditionals</p><empty-line /><p>
    controller</p><empty-line /><p>
    data paths</p><empty-line /><p>
    definitions</p><empty-line /><p>
    derived expressions</p><empty-line /><p>
    driver loop</p><empty-line /><p>
    error handling, 
[2]</p><empty-line /><p>
    expressions with no subexpressions to evaluate</p><empty-line /><p>
    as machine-language program</p><empty-line /><p>
    machine model</p><empty-line /><p>
    modified for compiled code</p><empty-line /><p>
    monitoring performance (stack use)</p><empty-line /><p>
    normal-order evaluation</p><empty-line /><p>
    operand evaluation</p><empty-line /><p>
    operations</p><empty-line /><p>
    optimizations (additional)</p><empty-line /><p>
    primitive procedures</p><empty-line /><p>
    procedure application</p><empty-line /><p>
    registers</p><empty-line /><p>
    running</p><empty-line /><p>
    sequences of expressions</p><empty-line /><p>
    special forms (additional), 
[2]</p><empty-line /><p>
    stack usage</p><empty-line /><p>
    tail recursion, 
[2], [3]</p><empty-line /><p>
    as universal machine</p><empty-line /><p>expmod, [2], 
[3]</p><empty-line /><p>exponential growth</p><empty-line /><p>
    of tree-recursive Fibonacci-number computation</p><empty-line /><p>exponentiation</p><empty-line /><p>
    modulo <emphasis>n</emphasis></p><empty-line /><p>
expression, <emphasis>see also</emphasis> compound expression; primitive expression</p><empty-line /><p>
    algebraic, <emphasis>see</emphasis> algebraic expressions</p><empty-line /><p>
    self-evaluating</p><empty-line /><p>
    symbolic, 
<emphasis>see also</emphasis> symbol(s)</p><empty-line /><p>expression-oriented vs. imperative programming style</p><empty-line /><p>expt</p><empty-line /><p>
    linear iterative version</p><empty-line /><p>
    linear recursive version</p><empty-line /><p>
    register machine for</p><empty-line /><p>extend-environment, 
[2]</p><empty-line /><p>extend-if-consistent</p><empty-line /><p>extend-if-possible</p><empty-line /><p>external-entry</p><empty-line /><p>extract-labels, 
[2]</p><empty-line /><empty-line /><p>#f</p><empty-line /><p>factorial, 
<emphasis>see also</emphasis> factorial</p><empty-line /><p>
    infinite stream</p><empty-line /><p>
    with letrec</p><empty-line /><p>
    without letrec or define</p><empty-line /><p>factorial</p><empty-line /><p>
    as an abstract machine</p><empty-line /><p>
    compilation of, 
[2]</p><empty-line /><p>
    environment structure in evaluating</p><empty-line /><p>
    linear iterative version</p><empty-line /><p>
    linear recursive version</p><empty-line /><p>
    register machine for (iterative), 
[2]</p><empty-line /><p>
    register machine for (recursive), 
[2]</p><empty-line /><p>
    stack usage, compiled</p><empty-line /><p>
    stack usage, interpreted, 
[2]</p><empty-line /><p>
    stack usage, register machine</p><empty-line /><p>
    with assignment</p><empty-line /><p>
    with higher-order procedures</p><empty-line /><p>failure continuation (nondeterministic evaluator), [2]</p><empty-line /><p>
    constructed by amb</p><empty-line /><p>
    constructed by assignment</p><empty-line /><p>
    constructed by driver loop</p><empty-line /><p>failure, in nondeterministic computation</p><empty-line /><p>
    bug vs.</p><empty-line /><p>
    searching and</p><empty-line /><p>false</p><empty-line /><p>false</p><empty-line /><p>false?</p><empty-line /><p>fast-expt</p><empty-line /><p>fast-prime?</p><empty-line /><p>feedback loop, modeled with streams</p><empty-line /><p>Feeley, Marc</p><empty-line /><p>Feigenbaum, Edward</p><empty-line /><p>Fenichel, Robert</p><empty-line /><p>Fermat, Pierre de</p><empty-line /><p>Fermat test for primality</p><empty-line /><p>
    variant of</p><empty-line /><p>Fermat's Little Theorem</p><empty-line /><p>
    alternate form</p><empty-line /><p>
    proof</p><empty-line /><p>fermat-test</p><empty-line /><p>fetch-assertions</p><empty-line /><p>fetch-rules</p><empty-line /><p>fib</p><empty-line /><p>
    linear iterative version</p><empty-line /><p>
    logarithmic version</p><empty-line /><p>
    register machine for (tree-recursive), [2]</p><empty-line /><p>
    stack usage, compiled</p><empty-line /><p>
    stack usage, interpreted</p><empty-line /><p>
    tree-recursive version, 
[2]</p><empty-line /><p>
    with memoization</p><empty-line /><p>
    with named let</p><empty-line /><p>Fibonacci numbers, 
<emphasis>see also</emphasis> fib</p><empty-line /><p>
    Euclid's GCD algorithm and</p><empty-line /><p>
    infinite stream of, <emphasis>see</emphasis> fibs</p><empty-line /><p>fibs (infinite stream)</p><empty-line /><p>
    implicit definition</p><empty-line /><p>FIFO buffer</p><empty-line /><p>filter, [2]</p><empty-line /><p>filter</p><empty-line /><p>filtered-accumulate</p><empty-line /><p>find-assertions</p><empty-line /><p>find-divisor</p><empty-line /><p>first-agenda-item, 
[2]</p><empty-line /><p>first-class elements in language</p><empty-line /><p>first-exp</p><empty-line /><p>first-frame</p><empty-line /><p>first-operand</p><empty-line /><p>first-segment</p><empty-line /><p>first-term, 
[2]</p><empty-line /><p>fixed point</p><empty-line /><p>
    computing with calculator</p><empty-line /><p>
    of cosine</p><empty-line /><p>
    cube root as</p><empty-line /><p>
    fourth root as</p><empty-line /><p>
    golden ratio as</p><empty-line /><p>
    as iterative improvement</p><empty-line /><p>
    in Newton's method</p><empty-line /><p>
    <emphasis>n</emphasis>th root as</p><empty-line /><p>
    square root as, 
[2], [3]</p><empty-line /><p>
    of transformed function</p><empty-line /><p>
    unification and</p><empty-line /><p>fixed-length code</p><empty-line /><p>fixed-point</p><empty-line /><p>
    as iterative improvement</p><empty-line /><p>fixed-point-of-transform</p><empty-line /><p>flag register</p><empty-line /><p>flatmap</p><empty-line /><p>flatten-stream</p><empty-line /><p>flip-horiz, 
[2]</p><empty-line /><p>flip-vert, [2]</p><empty-line /><p>flipped-pairs, 
[2], [3]</p><empty-line /><p>Floyd, Robert</p><empty-line /><p>fold-left</p><empty-line /><p>fold-right</p><empty-line /><p>for-each, [2]</p><empty-line /><p>for-each-except</p><empty-line /><p>Forbus, Kenneth D.</p><empty-line /><p>force, [2]</p><empty-line /><p>
    forcing a thunk vs.</p><empty-line /><p>force a thunk</p><empty-line /><p>force-it</p><empty-line /><p>
    memoized version</p><empty-line /><p>forget-value!, 
[2]</p><empty-line /><p>formal parameters</p><empty-line /><p>
    names of</p><empty-line /><p>
    scope of</p><empty-line /><p>formatting input expressions</p><empty-line /><p>Fortran, [2]</p><empty-line /><p>
    inventor of</p><empty-line /><p>
    restrictions on compound data</p><empty-line /><p>forwarding address</p><empty-line /><p>fourth root, as fixed point</p><empty-line /><p>
fraction, <emphasis>see</emphasis> rational number(s)</p><empty-line /><p>frame (environment model)</p><empty-line /><p>
    as repository of local state</p><empty-line /><p>
    global</p><empty-line /><p>frame (picture language), 
[2]</p><empty-line /><p>
    coordinate map</p><empty-line /><p>frame (query interpreter), 
<emphasis>see also</emphasis> pattern matching; unification</p><empty-line /><p>
    representation</p><empty-line /><p>frame-coord-map</p><empty-line /><p>frame-values</p><empty-line /><p>frame-variables</p><empty-line /><p>framed-stack discipline</p><empty-line /><p>Franz Lisp</p><empty-line /><p>free register, 
[2]</p><empty-line /><p>free list</p><empty-line /><p>free variable</p><empty-line /><p>
    capturing</p><empty-line /><p>
    in internal definition</p><empty-line /><p>Friedman, Daniel P., 
[2]</p><empty-line /><p>fringe</p><empty-line /><p>
    as a tree enumeration</p><empty-line /><p>front-ptr</p><empty-line /><p>front-queue, 
[2]</p><empty-line /><p>full-adder</p><empty-line /><p>
    full-adder</p><empty-line /><p>
function (mathematical)</p><empty-line /><p>
     <image xlink:href="#_45.jpg" />   notation for</p><empty-line /><p>
    Ackermann's</p><empty-line /><p>
    composition of</p><empty-line /><p>
    derivative of</p><empty-line /><p>
    fixed point of</p><empty-line /><p>
    procedure vs.</p><empty-line /><p>
    rational</p><empty-line /><p>
    repeated application of</p><empty-line /><p>
    smoothing of</p><empty-line /><p>function box, in digital circuit</p><empty-line /><p>functional programming, 
[2]</p><empty-line /><p>
    concurrency and</p><empty-line /><p>
    functional programming languages</p><empty-line /><p>
    time and</p><empty-line /><empty-line /><p>Gabriel, Richard P.</p><empty-line /><p>garbage collection</p><empty-line /><p>
    memoization and</p><empty-line /><p>
    mutation and</p><empty-line /><p>
    tail recursion and</p><empty-line /><p>
garbage collector</p><empty-line /><p>
    compacting</p><empty-line /><p>
    mark-sweep</p><empty-line /><p>
    stop-and-copy</p><empty-line /><p>
GCD, <emphasis>see</emphasis> greatest common divisor</p><empty-line /><p>gcd</p><empty-line /><p>
    register machine for, 
[2]</p><empty-line /><p>gcd-terms</p><empty-line /><p>general-purpose computer, as universal machine</p><empty-line /><p>generate-huffman-tree</p><empty-line /><p>generating sentences</p><empty-line /><p>generic arithmetic operations</p><empty-line /><p>
    structure of system</p><empty-line /><p>generic operation</p><empty-line /><p>generic procedure, 
[2]</p><empty-line /><p>
    generic selector, 
[2]</p><empty-line /><p>Genesis</p><empty-line /><p>get, [2]</p><empty-line /><p>get-contents</p><empty-line /><p>get-global-environment</p><empty-line /><p>get-register</p><empty-line /><p>get-register-contents, 
[2]</p><empty-line /><p>get-signal, 
[2]</p><empty-line /><p>get-value, [2]</p><empty-line /><p>glitch</p><empty-line /><p>global environment, 
[2]</p><empty-line /><p>
    in metacircular evaluator</p><empty-line /><p>global frame</p><empty-line /><p>Goguen, Joseph</p><empty-line /><p>golden ratio</p><empty-line /><p>
    as continued fraction</p><empty-line /><p>
    as fixed point</p><empty-line /><p>Gordon, Michael</p><empty-line /><p>goto (in register machine)</p><empty-line /><p>
    label as destination</p><empty-line /><p>
    simulating</p><empty-line /><p>goto-dest</p><empty-line /><p>grammar</p><empty-line /><p>
graphics, <emphasis>see</emphasis> picture language</p><empty-line /><p>Gray, Jim</p><empty-line /><p>greatest common divisor, 
<emphasis>see also</emphasis> gcd</p><empty-line /><p>
    generic</p><empty-line /><p>
    of polynomials</p><empty-line /><p>
    used to estimate <image xlink:href="#_37.jpg" /></p><empty-line /><p>
    used in rational-number arithmetic</p><empty-line /><p>Green, Cordell</p><empty-line /><p>Griss, Martin Lewis</p><empty-line /><p>Guttag, John Vogel</p><empty-line /><empty-line /><p>half-adder</p><empty-line /><p>
    half-adder</p><empty-line /><p>
    simulation of</p><empty-line /><p>half-interval method</p><empty-line /><p>
    half-interval-method</p><empty-line /><p>
    Newton's method vs.</p><empty-line /><p>halting problem</p><empty-line /><p>Halting Theorem</p><empty-line /><p>Hamming, Richard Wesley, 
[2]</p><empty-line /><p>Hanson, Christopher P., 
[2]</p><empty-line /><p>Hardy, Godfrey Harold, 
[2]</p><empty-line /><p>has-value?, 
[2]</p><empty-line /><p>Hassle</p><empty-line /><p>Havender, J.</p><empty-line /><p>Haynes, Christopher T.</p><empty-line /><p>headed list, [2]</p><empty-line /><p>Hearn, Anthony C.</p><empty-line /><p>Henderson, Peter, 
[2], [3]</p><empty-line /><p>
    Henderson diagram</p><empty-line /><p>Heraclitus</p><empty-line /><p>Heron of Alexandria</p><empty-line /><p>Hewitt, Carl Eddie, 
[2], [3], 
[4]</p><empty-line /><p>hiding principle</p><empty-line /><p>hierarchical data structures, 
[2]</p><empty-line /><p>hierarchy of types</p><empty-line /><p>
    in symbolic algebra</p><empty-line /><p>
    inadequacy of</p><empty-line /><p>high-level language, machine language vs.</p><empty-line /><p>higher-order procedures</p><empty-line /><p>
    in metacircular evaluator</p><empty-line /><p>
    procedure as argument</p><empty-line /><p>
    procedure as general method</p><empty-line /><p>
    procedure as returned value</p><empty-line /><p>
    strong typing and</p><empty-line /><p>Hilfinger, Paul</p><empty-line /><p>Hoare, Charles Antony Richard</p><empty-line /><p>Hodges, Andrew</p><empty-line /><p>Hofstadter, Douglas R.</p><empty-line /><p>Horner, W. G.</p><empty-line /><p>Horner's rule</p><empty-line /><p>
"how to" vs. "what is" description, <emphasis>see</emphasis> imperative vs. declarative knowledge</p><empty-line /><p>Huffman code</p><empty-line /><p>
    optimality of</p><empty-line /><p>
    order of growth of encoding</p><empty-line /><p>Huffman, David</p><empty-line /><p>Hughes, R. J. M.</p><empty-line /><empty-line /><p>IBM 704</p><empty-line /><p>identity</p><empty-line /><p>if (special form)</p><empty-line /><p>
    cond vs.</p><empty-line /><p>
    evaluation of</p><empty-line /><p>
    normal-order evaluation of</p><empty-line /><p>
    one-armed (without alternative)</p><empty-line /><p>
    predicate, consequent, and alternative of</p><empty-line /><p>
    why a special form</p><empty-line /><p>if-alternative</p><empty-line /><p>if-consequent</p><empty-line /><p>if-predicate</p><empty-line /><p>if?</p><empty-line /><p>imag-part</p><empty-line /><p>
    data-directed</p><empty-line /><p>
    polar representation</p><empty-line /><p>
    rectangular representation</p><empty-line /><p>
    with tagged data</p><empty-line /><p>imag-part-polar</p><empty-line /><p>imag-part-rectangular</p><empty-line /><p>imperative programming</p><empty-line /><p>imperative vs. declarative knowledge, 
[2]</p><empty-line /><p>
    logic programming and, 
[2]</p><empty-line /><p>
    nondeterministic computing and</p><empty-line /><p>imperative vs. expression-oriented programming style</p><empty-line /><p>
implementation dependencies, <emphasis>see also</emphasis> unspecified values</p><empty-line /><p>
    numbers</p><empty-line /><p>
    order of subexpression evaluation</p><empty-line /><p>inc</p><empty-line /><p>incremental development of programs</p><empty-line /><p>indeterminate of a polynomial</p><empty-line /><p>indexing a data base, 
[2]</p><empty-line /><p>inference, method of</p><empty-line /><p>infinite series</p><empty-line /><p>infinite stream(s)</p><empty-line /><p>
    merging, [2], 
[3], [4]</p><empty-line /><p>
    merging as a relation</p><empty-line /><p>
    of factorials</p><empty-line /><p>
    of Fibonacci numbers, <emphasis>see</emphasis> fibs</p><empty-line /><p>
    of integers, <emphasis>see</emphasis> integers</p><empty-line /><p>
    of pairs</p><empty-line /><p>
    of prime numbers, <emphasis>see</emphasis> primes</p><empty-line /><p>
    of random numbers</p><empty-line /><p>
    representing power series</p><empty-line /><p>
    to model signals</p><empty-line /><p>
    to sum a series</p><empty-line /><p>infix notation, prefix notation vs.</p><empty-line /><p>inform-about-no-value</p><empty-line /><p>inform-about-value</p><empty-line /><p>
information retrieval, <emphasis>see</emphasis> data base</p><empty-line /><p>Ingerman, Peter</p><empty-line /><p>initialize-stack operation in register machine, [2]</p><empty-line /><p>insert!</p><empty-line /><p>
    in one-dimensional table</p><empty-line /><p>
    in two-dimensional table</p><empty-line /><p>insert-queue!, 
[2]</p><empty-line /><p>install-complex-package</p><empty-line /><p>install-polar-package</p><empty-line /><p>install-polynomial-package</p><empty-line /><p>install-rational-package</p><empty-line /><p>install-rectangular-package</p><empty-line /><p>install-scheme-number-package</p><empty-line /><p>instantiate</p><empty-line /><p>instantiate a pattern</p><empty-line /><p>instruction counting</p><empty-line /><p>instruction execution procedure</p><empty-line /><p>instruction sequence, 
[2]</p><empty-line /><p>instruction tracing</p><empty-line /><p>instruction-execution-proc</p><empty-line /><p>instruction-text</p><empty-line /><p>integer(s)</p><empty-line /><p>
    dividing</p><empty-line /><p>
    exact</p><empty-line /><p>integerizing factor</p><empty-line /><p>integers (infinite stream)</p><empty-line /><p>
    implicit definition</p><empty-line /><p>
    lazy-list version</p><empty-line /><p>integers-starting-from</p><empty-line /><p>
integral, <emphasis>see also</emphasis> definite integral; Monte Carlo integration</p><empty-line /><p>
    of a power series</p><empty-line /><p>integral, [2], 
[3]</p><empty-line /><p>
    with delayed argument</p><empty-line /><p>
    with lambda</p><empty-line /><p>
    lazy-list version</p><empty-line /><p>
    need for delayed evaluation</p><empty-line /><p>integrate-series</p><empty-line /><p>integrated-circuit implementation of Scheme, [2]</p><empty-line /><p>integrator, for signals</p><empty-line /><p>interleave</p><empty-line /><p>interleave-delayed</p><empty-line /><p>Interlisp</p><empty-line /><p>internal definition</p><empty-line /><p>
    in environment model</p><empty-line /><p>
    free variable in</p><empty-line /><p>
    let vs.</p><empty-line /><p>
    in nondeterministic evaluator</p><empty-line /><p>
    position of</p><empty-line /><p>
    restrictions on</p><empty-line /><p>
    scanning out</p><empty-line /><p>
    scope of name</p><empty-line /><p>Internet "Worm"</p><empty-line /><p>interning symbols</p><empty-line /><p>interpreter, <emphasis>see also</emphasis> evaluator</p><empty-line /><p>
    compiler vs., 
[2]</p><empty-line /><p>
    read-eval-print loop</p><empty-line /><p>intersection-set</p><empty-line /><p>
    binary-tree representation</p><empty-line /><p>
    ordered-list representation</p><empty-line /><p>
    unordered-list representation</p><empty-line /><p>interval arithmetic</p><empty-line /><p>invariant quantity of an iterative process</p><empty-line /><p>inverter</p><empty-line /><p>
    inverter</p><empty-line /><p>
iteration contructs, <emphasis>see</emphasis> looping constructs</p><empty-line /><p>iterative improvement</p><empty-line /><p>iterative process</p><empty-line /><p>
    as a stream process</p><empty-line /><p>
    design of algorithm</p><empty-line /><p>
    implemented by procedure call, 
[2], [3], 
<emphasis>see also</emphasis> tail recursion</p><empty-line /><p>
    linear, [2]</p><empty-line /><p>
    recursive process vs., 
[2], [3], 
[4]</p><empty-line /><p>
    register machine for</p><empty-line /><empty-line /><p>Jayaraman, Sundaresan</p><empty-line /><empty-line /><p>Kaldewaij, Anne</p><empty-line /><p>Karr, Alphonse</p><empty-line /><p>Kepler, Johannes</p><empty-line /><p>key</p><empty-line /><p>
key of a record</p><empty-line /><p>
    in a data base</p><empty-line /><p>
    in a table</p><empty-line /><p>
    testing equality of</p><empty-line /><p>Khayyam, Omar</p><empty-line /><p>Knuth, Donald E., [2], 
[3], [4], 
[5], [6], 
[7]</p><empty-line /><p>Kohlbecker, Eugene Edmund, Jr.</p><empty-line /><p>Kolmogorov, A. N.</p><empty-line /><p>Konopasek, Milos</p><empty-line /><p>Kowalski, Robert</p><empty-line /><p>KRC, [2]</p><empty-line /><empty-line /><p>label (in register machine)</p><empty-line /><p>
    simulating</p><empty-line /><p>label-exp</p><empty-line /><p>label-exp-label</p><empty-line /><p>Lagrange interpolation formula</p><empty-line /><p><image xlink:href="#_51.jpg" />  calculus (lambda calculus)</p><empty-line /><p>lambda (special form)</p><empty-line /><p>
    define vs.</p><empty-line /><p>
    with dotted-tail notation</p><empty-line /><p>lambda expression</p><empty-line /><p>
    as operator of combination</p><empty-line /><p>
    value of</p><empty-line /><p>lambda-body</p><empty-line /><p>lambda-parameters</p><empty-line /><p>lambda?</p><empty-line /><p>Lambert, J.H.</p><empty-line /><p>Lamé, Gabriel</p><empty-line /><p>Lamé's Theorem</p><empty-line /><p>Lamport, Leslie</p><empty-line /><p>Lampson, Butler</p><empty-line /><p>Landin, Peter, [2]</p><empty-line /><p>
language, <emphasis>see</emphasis> natural language; programming language</p><empty-line /><p>Lapalme, Guy</p><empty-line /><p>last-exp?</p><empty-line /><p>last-operand?</p><empty-line /><p>last-pair, [2]</p><empty-line /><p>
    rules</p><empty-line /><p>lazy evaluation</p><empty-line /><p>lazy evaluator</p><empty-line /><p>lazy list</p><empty-line /><p>lazy pair</p><empty-line /><p>lazy tree</p><empty-line /><p>leaf?</p><empty-line /><p>least commitment, principle of</p><empty-line /><p>lecture, something to do during</p><empty-line /><p>left-branch, 
[2]</p><empty-line /><p>
Leibniz, Baron Gottfried Wilhelm von</p><empty-line /><p>
    proof of Fermat's Little Theorem</p><empty-line /><p>
    series for <image xlink:href="#_37.jpg" />, 
[2]</p><empty-line /><p>Leiserson, Charles E., 
[2]</p><empty-line /><p>length</p><empty-line /><p>
    as accumulation</p><empty-line /><p>
    iterative version</p><empty-line /><p>
    recursive version</p><empty-line /><p>let (special form)</p><empty-line /><p>
    evaluation model</p><empty-line /><p>
    internal definition vs.</p><empty-line /><p>
    named</p><empty-line /><p>
    scope of variables</p><empty-line /><p>
    as syntactic sugar, 
[2]</p><empty-line /><p>let* (special form)</p><empty-line /><p>letrec (special form)</p><empty-line /><p>lexical addressing</p><empty-line /><p>
    lexical address</p><empty-line /><p>lexical scoping</p><empty-line /><p>
    environment structure and</p><empty-line /><p>lexical-address-lookup, 
[2]</p><empty-line /><p>lexical-address-set!, 
[2]</p><empty-line /><p>Lieberman, Henry</p><empty-line /><p>
LIFO buffer, <emphasis>see</emphasis> stack</p><empty-line /><p>
line segment</p><empty-line /><p>
    represented as pair of points</p><empty-line /><p>
    represented as pair of vectors</p><empty-line /><p>linear growth, [2]</p><empty-line /><p>linear iterative process</p><empty-line /><p>
    order of growth</p><empty-line /><p>linear recursive process</p><empty-line /><p>
    order of growth</p><empty-line /><p>linkage descriptor</p><empty-line /><p>Liskov, Barbara Huberman</p><empty-line /><p>
Lisp</p><empty-line /><p>
    acronym for LISt Processing</p><empty-line /><p>
    applicative-order evaluation in</p><empty-line /><p>
    on DEC PDP-1</p><empty-line /><p>
    efficiency of, [2]</p><empty-line /><p>
    first-class procedures in</p><empty-line /><p>
    Fortran vs.</p><empty-line /><p>
    history of</p><empty-line /><p>
    internal type system</p><empty-line /><p>
    original implementation on IBM 704</p><empty-line /><p>
    Pascal vs.</p><empty-line /><p>
    suitability for writing evaluators</p><empty-line /><p>
    unique features of</p><empty-line /><p>
Lisp dialects</p><empty-line /><p>
    Common Lisp</p><empty-line /><p>
    Franz Lisp</p><empty-line /><p>
    Interlisp</p><empty-line /><p>
    MacLisp</p><empty-line /><p>
    MDL</p><empty-line /><p>
    Portable Standard Lisp</p><empty-line /><p>
    Scheme</p><empty-line /><p>
    Zetalisp</p><empty-line /><p>lisp-value (query interpreter)</p><empty-line /><p>lisp-value (query language), 
[2]</p><empty-line /><p>
    evaluation of, 
[2], [3]</p><empty-line /><p>list (primitive procedure)</p><empty-line /><p>list structure</p><empty-line /><p>
    list vs.</p><empty-line /><p>
    mutable</p><empty-line /><p>
    represented using vectors</p><empty-line /><p>list(s)</p><empty-line /><p>
    backquote with</p><empty-line /><p>
    cdring down</p><empty-line /><p>
    combining with append</p><empty-line /><p>
    consing up</p><empty-line /><p>
    converting a binary tree to a</p><empty-line /><p>
    converting to a binary tree</p><empty-line /><p>
    empty, <emphasis>see</emphasis> empty list</p><empty-line /><p>
    equality of</p><empty-line /><p>
    headed, [2]</p><empty-line /><p>
    last pair of</p><empty-line /><p>
    lazy</p><empty-line /><p>
    length of</p><empty-line /><p>
    list structure vs.</p><empty-line /><p>
    manipulation with car, cdr, and cons</p><empty-line /><p>
    mapping over</p><empty-line /><p>
    <emphasis>n</emphasis>th element of</p><empty-line /><p>
    operations on</p><empty-line /><p>
    printed representation of</p><empty-line /><p>
    quotation of</p><empty-line /><p>
    reversing</p><empty-line /><p>
    techniques for manipulating</p><empty-line /><p>list-&gt;tree</p><empty-line /><p>list-difference</p><empty-line /><p>list-of-arg-values</p><empty-line /><p>list-of-delayed-args</p><empty-line /><p>list-of-values</p><empty-line /><p>list-ref, [2]</p><empty-line /><p>list-structured memory</p><empty-line /><p>list-union</p><empty-line /><p>lives-near (rule), 
[2]</p><empty-line /><p>local evolution of a process</p><empty-line /><p>local name, [2]</p><empty-line /><p>local state</p><empty-line /><p>
    maintained in frames</p><empty-line /><p>local state variable</p><empty-line /><p>local variable</p><empty-line /><p>location</p><empty-line /><p>Locke, John</p><empty-line /><p>log (primitive procedure)</p><empty-line /><p>logarithm, approximating ln 2</p><empty-line /><p>logarithmic growth, 
[2], [3]</p><empty-line /><p>logic programming, 
<emphasis>see also</emphasis> query language; query interpreter</p><empty-line /><p>
    computers for</p><empty-line /><p>
    history of, [2]</p><empty-line /><p>
    in Japan</p><empty-line /><p>
    logic programming languages</p><empty-line /><p>
    mathematical logic vs.</p><empty-line /><p>logic puzzles</p><empty-line /><p>logical and</p><empty-line /><p>logical or</p><empty-line /><p>logical-not</p><empty-line /><p>lookup</p><empty-line /><p>
    in one-dimensional table</p><empty-line /><p>
    in set of records</p><empty-line /><p>
    in two-dimensional table</p><empty-line /><p>lookup-label</p><empty-line /><p>lookup-prim</p><empty-line /><p>lookup-variable-value, 
[2]</p><empty-line /><p>
    for scanned-out definitions</p><empty-line /><p>looping constructs, 
[2]</p><empty-line /><p>
    implementing in metacircular evaluator</p><empty-line /><p>lower-bound</p><empty-line /><empty-line /><p>machine language</p><empty-line /><p>
    high-level language vs.</p><empty-line /><p>Macintosh</p><empty-line /><p>MacLisp</p><empty-line /><p>macro, 
<emphasis>see also</emphasis> reader macro character</p><empty-line /><p>
magician, <emphasis>see</emphasis> numerical analyst</p><empty-line /><p>magnitude</p><empty-line /><p>
    data-directed</p><empty-line /><p>
    polar representation</p><empty-line /><p>
    rectangular representation</p><empty-line /><p>
    with tagged data</p><empty-line /><p>magnitude-polar</p><empty-line /><p>magnitude-rectangular</p><empty-line /><p>make-account</p><empty-line /><p>
    in environment model</p><empty-line /><p>
    with serialization, 
[2], [3]</p><empty-line /><p>make-account-and-serializer</p><empty-line /><p>make-accumulator</p><empty-line /><p>make-agenda, 
[2]</p><empty-line /><p>make-assign</p><empty-line /><p>make-begin</p><empty-line /><p>make-branch</p><empty-line /><p>make-center-percent</p><empty-line /><p>make-center-width</p><empty-line /><p>make-code-tree</p><empty-line /><p>make-compiled-procedure</p><empty-line /><p>make-complex-from-mag-ang</p><empty-line /><p>make-complex-from-real-imag</p><empty-line /><p>make-connector</p><empty-line /><p>make-cycle</p><empty-line /><p>make-decrementer</p><empty-line /><p>make-execution-procedure</p><empty-line /><p>make-frame, 
[2], [3]</p><empty-line /><p>make-from-mag-ang, 
[2]</p><empty-line /><p>
    message-passing</p><empty-line /><p>
    polar representation</p><empty-line /><p>
    rectangular representation</p><empty-line /><p>make-from-mag-ang-polar</p><empty-line /><p>make-from-mag-ang-rectangular</p><empty-line /><p>make-from-real-imag, 
[2]</p><empty-line /><p>
    message-passing</p><empty-line /><p>
    polar representation</p><empty-line /><p>
    rectangular representation</p><empty-line /><p>make-from-real-imag-polar</p><empty-line /><p>make-from-real-imag-rectangular</p><empty-line /><p>make-goto</p><empty-line /><p>make-if</p><empty-line /><p>make-instruction</p><empty-line /><p>make-instruction-sequence</p><empty-line /><p>make-interval, 
[2]</p><empty-line /><p>make-joint</p><empty-line /><p>make-label</p><empty-line /><p>make-label-entry</p><empty-line /><p>make-lambda</p><empty-line /><p>make-leaf</p><empty-line /><p>make-leaf-set</p><empty-line /><p>make-machine, 
[2]</p><empty-line /><p>make-monitored</p><empty-line /><p>make-mutex</p><empty-line /><p>make-new-machine</p><empty-line /><p>make-operation-exp</p><empty-line /><p>make-perform</p><empty-line /><p>make-point</p><empty-line /><p>make-poly</p><empty-line /><p>make-polynomial</p><empty-line /><p>make-primitive-exp</p><empty-line /><p>make-procedure</p><empty-line /><p>make-product, 
[2]</p><empty-line /><p>make-queue, 
[2]</p><empty-line /><p>make-rat, [2], 
[3]</p><empty-line /><p>
    axiom for</p><empty-line /><p>
    reducing to lowest terms</p><empty-line /><p>make-rational</p><empty-line /><p>make-register</p><empty-line /><p>make-restore</p><empty-line /><p>make-save</p><empty-line /><p>make-scheme-number</p><empty-line /><p>make-segment, 
[2]</p><empty-line /><p>make-serializer</p><empty-line /><p>make-simplified-withdraw, 
[2]</p><empty-line /><p>make-stack</p><empty-line /><p>
    with monitored stack</p><empty-line /><p>make-sum, [2]</p><empty-line /><p>make-table</p><empty-line /><p>
    message-passing implementation</p><empty-line /><p>
    one-dimensional table</p><empty-line /><p>make-tableau</p><empty-line /><p>make-term, [2]</p><empty-line /><p>make-test</p><empty-line /><p>make-time-segment</p><empty-line /><p>make-tree</p><empty-line /><p>make-vect</p><empty-line /><p>make-wire, [2], 
[3]</p><empty-line /><p>make-withdraw</p><empty-line /><p>
    in environment model</p><empty-line /><p>
    using let</p><empty-line /><p>
making change, <emphasis>see</emphasis> counting change</p><empty-line /><p>map, [2]</p><empty-line /><p>
    as accumulation</p><empty-line /><p>
    with multiple arguments</p><empty-line /><p>map-over-symbols</p><empty-line /><p>map-successive-pairs</p><empty-line /><p>
mapping</p><empty-line /><p>
    over lists</p><empty-line /><p>
    nested, [2]</p><empty-line /><p>
    as a transducer</p><empty-line /><p>
    over trees</p><empty-line /><p>mark-sweep garbage collector</p><empty-line /><p>
mathematical function, <emphasis>see</emphasis> function (mathematical)</p><empty-line /><p>
mathematics</p><empty-line /><p>
    computer science vs., 
[2]</p><empty-line /><p>
    engineering vs.</p><empty-line /><p>matrix, represented as sequence</p><empty-line /><p>matrix-*-matrix</p><empty-line /><p>matrix-*-vector</p><empty-line /><p>max (primitive procedure)</p><empty-line /><p>McAllester, David Allen, 
[2]</p><empty-line /><p>McCarthy, John, [2], 
[3], [4]</p><empty-line /><p>McDermott, Drew</p><empty-line /><p>MDL</p><empty-line /><p>means of abstraction</p><empty-line /><p>
    define</p><empty-line /><p>means of combination, 
<emphasis>see also</emphasis> closure</p><empty-line /><p>measure in a Euclidean ring</p><empty-line /><p>member</p><empty-line /><p>memo-fib</p><empty-line /><p>memo-proc</p><empty-line /><p>memoization, [2]</p><empty-line /><p>
    call-by-need and</p><empty-line /><p>
    by delay</p><empty-line /><p>
    garbage collection and</p><empty-line /><p>
    of thunks</p><empty-line /><p>memoize</p><empty-line /><p>
memory</p><empty-line /><p>
    in 1964</p><empty-line /><p>
    list-structured</p><empty-line /><p>memq</p><empty-line /><p>merge</p><empty-line /><p>merge-weighted</p><empty-line /><p>
merging infinite streams, <emphasis>see</emphasis> infinite stream(s)</p><empty-line /><p>message passing, [2]</p><empty-line /><p>
    environment model and</p><empty-line /><p>
    in bank account</p><empty-line /><p>
    in digital-circuit simulation</p><empty-line /><p>
    tail recursion and</p><empty-line /><p>metacircular evaluator</p><empty-line /><p>metacircular evaluator for Scheme</p><empty-line /><p>
    analyzing version</p><empty-line /><p>
    combinations (procedure applications)</p><empty-line /><p>
    compilation of, 
[2]</p><empty-line /><p>
    data abstraction in, 
[2], [3], 
[4]</p><empty-line /><p>
    data-directed eval</p><empty-line /><p>
    derived expressions</p><empty-line /><p>
    driver loop</p><empty-line /><p>
    efficiency of</p><empty-line /><p>
    environment model of evaluation in</p><empty-line /><p>
    environment operations</p><empty-line /><p>
    eval and apply</p><empty-line /><p>
    eval-apply cycle, 
[2]</p><empty-line /><p>
    expression representation, 
[2]</p><empty-line /><p>
    global environment</p><empty-line /><p>
    higher-order procedures in</p><empty-line /><p>
    implemented language vs. implementation language</p><empty-line /><p>
    job of</p><empty-line /><p>
    order of operand evaluation</p><empty-line /><p>
    primitive procedures</p><empty-line /><p>
    representation of environments</p><empty-line /><p>
    representation of procedures</p><empty-line /><p>
    representation of true and false</p><empty-line /><p>
    running</p><empty-line /><p>
    special forms (additional), 
[2], [3], 
[4], [5], 
[6]</p><empty-line /><p>
    special forms as derived expressions</p><empty-line /><p>
    symbolic differentiation and</p><empty-line /><p>
    syntax of evaluated language, 
[2], [3]</p><empty-line /><p>
    tail recursiveness unspecified in</p><empty-line /><p>
    true and false</p><empty-line /><p>metalinguistic abstraction</p><empty-line /><p>MicroPlanner</p><empty-line /><p>Microshaft</p><empty-line /><p>midpoint-segment</p><empty-line /><p>Miller, Gary L.</p><empty-line /><p>Miller, James S.</p><empty-line /><p>Miller-Rabin test for primality</p><empty-line /><p>Milner, Robin</p><empty-line /><p>min (primitive procedure)</p><empty-line /><p>Minsky, Marvin Lee, [2]</p><empty-line /><p>Miranda</p><empty-line /><p>MIT</p><empty-line /><p>
    Artificial Intelligence Laboratory</p><empty-line /><p>
    early history of</p><empty-line /><p>
    Project MAC</p><empty-line /><p>
    Research Laboratory of Electronics, 
[2]</p><empty-line /><p>
MIT Scheme</p><empty-line /><p>
    the empty stream</p><empty-line /><p>
    eval</p><empty-line /><p>
    internal definitions</p><empty-line /><p>
    numbers</p><empty-line /><p>
    random</p><empty-line /><p>
    user-initial-environment</p><empty-line /><p>
    without-interrupts</p><empty-line /><p>ML</p><empty-line /><p>mobile</p><empty-line /><p>
modeling</p><empty-line /><p>
    as a design strategy</p><empty-line /><p>
    in science and engineering</p><empty-line /><p>models of evaluation</p><empty-line /><p>
modified registers, <emphasis>see</emphasis> instruction sequence</p><empty-line /><p>modifies-register?</p><empty-line /><p>modularity, [2]</p><empty-line /><p>
    along object boundaries</p><empty-line /><p>
    functional programs vs. objects</p><empty-line /><p>
    hiding principle</p><empty-line /><p>
    streams and</p><empty-line /><p>
    through dispatching on type</p><empty-line /><p>
    through infinite streams</p><empty-line /><p>
    through modeling with objects</p><empty-line /><p>modulo <emphasis>n</emphasis></p><empty-line /><p><emphasis>modus ponens</emphasis></p><empty-line /><p>
money, changing, <emphasis>see</emphasis> counting change</p><empty-line /><p>monitored procedure</p><empty-line /><p>Monte Carlo integration</p><empty-line /><p>
    stream formulation</p><empty-line /><p>Monte Carlo simulation</p><empty-line /><p>
    stream formulation</p><empty-line /><p>monte-carlo</p><empty-line /><p>
    infinite stream</p><empty-line /><p>Moon, David A., [2]</p><empty-line /><p>
morning star, <emphasis>see</emphasis> evening star</p><empty-line /><p>Morris, J. H.</p><empty-line /><p>Morse code</p><empty-line /><p>Mouse, Minnie and Mickey</p><empty-line /><p>mul (generic)</p><empty-line /><p>
    used for polynomial coefficients</p><empty-line /><p>mul-complex</p><empty-line /><p>mul-interval</p><empty-line /><p>
    more efficient version</p><empty-line /><p>mul-poly</p><empty-line /><p>mul-rat</p><empty-line /><p>mul-series</p><empty-line /><p>mul-streams</p><empty-line /><p>mul-terms</p><empty-line /><p>Multics time-sharing system</p><empty-line /><p>multiple-dwelling</p><empty-line /><p>multiplicand</p><empty-line /><p>multiplication by Russian peasant method</p><empty-line /><p>multiplier</p><empty-line /><p>
    primitive constraint</p><empty-line /><p>
    selector</p><empty-line /><p>Munro, Ian</p><empty-line /><p>mutable data objects, 
<emphasis>see also</emphasis> queue; table</p><empty-line /><p>
    implemented with assignment</p><empty-line /><p>
    list structure</p><empty-line /><p>
    pairs</p><empty-line /><p>
    procedural representation of</p><empty-line /><p>
    shared data</p><empty-line /><p>mutator</p><empty-line /><p>mutex</p><empty-line /><p>mutual exclusion</p><empty-line /><p>mystery</p><empty-line /><empty-line /><p>
name, <emphasis>see also</emphasis> local name; variable; local variable</p><empty-line /><p>
    encapsulated</p><empty-line /><p>
    of a formal parameter</p><empty-line /><p>
    of a procedure</p><empty-line /><p>named let (special form)</p><empty-line /><p>
naming</p><empty-line /><p>
    of computational objects</p><empty-line /><p>
    of procedures</p><empty-line /><p>
naming conventions</p><empty-line /><p>
    ! for assignment and mutation</p><empty-line /><p>
    ? for predicates</p><empty-line /><p>native language of machine</p><empty-line /><p>
natural language</p><empty-line /><p>
    parsing, <emphasis>see</emphasis> parsing natural language</p><empty-line /><p>
    quotation in</p><empty-line /><p>
needed registers, <emphasis>see</emphasis> instruction sequence</p><empty-line /><p>needs-register?</p><empty-line /><p>negate</p><empty-line /><p>nested applications of car and cdr</p><empty-line /><p>nested combinations</p><empty-line /><p>
nested definitions, <emphasis>see</emphasis> internal definition</p><empty-line /><p>
nested mappings, <emphasis>see</emphasis> mapping</p><empty-line /><p>new register</p><empty-line /><p>new-cars register</p><empty-line /><p>new-cdrs register</p><empty-line /><p>new-withdraw</p><empty-line /><p>newline (primitive procedure), 
[2]</p><empty-line /><p>
Newton's method</p><empty-line /><p>
    for cube roots</p><empty-line /><p>
    for differentiable functions</p><empty-line /><p>
    half-interval method vs.</p><empty-line /><p>
    for square roots, 
[2], [3]</p><empty-line /><p>newton-transform</p><empty-line /><p>newtons-method</p><empty-line /><p>next (linkage descriptor)</p><empty-line /><p>next-to (rules)</p><empty-line /><p>nil</p><empty-line /><p>
    dispensing with</p><empty-line /><p>
    as empty list</p><empty-line /><p>
    as end-of-list marker</p><empty-line /><p>
    as ordinary variable in Scheme</p><empty-line /><p>no-more-exps?</p><empty-line /><p>no-operands?</p><empty-line /><p>node of a tree</p><empty-line /><p>non-computable</p><empty-line /><p>non-strict</p><empty-line /><p>nondeterminism, in behavior of concurrent programs, [2]</p><empty-line /><p>nondeterministic choice point</p><empty-line /><p>nondeterministic computing</p><empty-line /><p>nondeterministic evaluator</p><empty-line /><p>
    order of operand evaluation</p><empty-line /><p>nondeterministic programming vs. Scheme programming, [2], 
[3], [4]</p><empty-line /><p>
nondeterministic programs</p><empty-line /><p>
    logic puzzles</p><empty-line /><p>
    pairs with prime sums</p><empty-line /><p>
    parsing natural language</p><empty-line /><p>
    Pythagorean triples, 
[2], [3]</p><empty-line /><p>normal-order evaluation</p><empty-line /><p>
    applicative order vs., 
[2], [3]</p><empty-line /><p>
    delayed evaluation and</p><empty-line /><p>
    in explicit-control evaluator</p><empty-line /><p>
    of if</p><empty-line /><p>
normal-order evaluator, <emphasis>see</emphasis> lazy evaluator</p><empty-line /><p>not (primitive procedure)</p><empty-line /><p>not (query language), 
[2]</p><empty-line /><p>
    evaluation of, 
[2], [3]</p><empty-line /><p>
notation in this book</p><empty-line /><p>
    italic symbols in expression syntax</p><empty-line /><p>
    slanted characters for interpreter response</p><empty-line /><p>nouns</p><empty-line /><p><emphasis>n</emphasis>th root, as fixed point</p><empty-line /><p>null? (primitive procedure)</p><empty-line /><p>
    implemented with typed pointers</p><empty-line /><p>number theory</p><empty-line /><p>
number(s)</p><empty-line /><p>
    comparison of</p><empty-line /><p>
    decimal point in</p><empty-line /><p>
    equality of, [2], 
[3]</p><empty-line /><p>
    in generic arithmetic system</p><empty-line /><p>
    implementation dependencies</p><empty-line /><p>
    integer vs. real number</p><empty-line /><p>
    integer, exact</p><empty-line /><p>
    in Lisp</p><empty-line /><p>
    rational number</p><empty-line /><p>number? (primitive procedure)</p><empty-line /><p>
    data types and</p><empty-line /><p>
    implemented with typed pointers</p><empty-line /><p>numer, [2]</p><empty-line /><p>
    axiom for</p><empty-line /><p>
    reducing to lowest terms</p><empty-line /><p>numerical analysis</p><empty-line /><p>numerical analyst</p><empty-line /><p>numerical data</p><empty-line /><empty-line /><p>obarray</p><empty-line /><p>object program</p><empty-line /><p>object(s)</p><empty-line /><p>
    benefits of modeling with</p><empty-line /><p>
    with time-varying state</p><empty-line /><p>object-oriented programming languages</p><empty-line /><p>old register</p><empty-line /><p>oldcr register</p><empty-line /><p>ones (infinite stream)</p><empty-line /><p>
    lazy-list version</p><empty-line /><p>op (in register machine)</p><empty-line /><p>
    simulating</p><empty-line /><p>open coding of primitives, 
[2]</p><empty-line /><p>operands</p><empty-line /><p>operands of a combination</p><empty-line /><p>
operation</p><empty-line /><p>
    cross-type</p><empty-line /><p>
    generic</p><empty-line /><p>
    in register machine</p><empty-line /><p>operation-and-type table</p><empty-line /><p>
    assignment needed for</p><empty-line /><p>
    implementing</p><empty-line /><p>operation-exp</p><empty-line /><p>operation-exp-op</p><empty-line /><p>operation-exp-operands</p><empty-line /><p>operator</p><empty-line /><p>operator of a combination</p><empty-line /><p>
    combination as</p><empty-line /><p>
    compound expression as</p><empty-line /><p>
    lambda expression as</p><empty-line /><p>
optimality</p><empty-line /><p>
    of Horner's rule</p><empty-line /><p>
    of Huffman code</p><empty-line /><p>or (query language)</p><empty-line /><p>
    evaluation of, 
[2]</p><empty-line /><p>or (special form)</p><empty-line /><p>
    evaluation of</p><empty-line /><p>
    why a special form</p><empty-line /><p>
    with no subexpressions</p><empty-line /><p>or-gate</p><empty-line /><p>
    or-gate, 
[2]</p><empty-line /><p>order, [2]</p><empty-line /><p>order notation</p><empty-line /><p>
order of evaluation</p><empty-line /><p>
    assignment and</p><empty-line /><p>
    implementation-dependent</p><empty-line /><p>
    in compiler</p><empty-line /><p>
    in explicit-control evaluator</p><empty-line /><p>
    in metacircular evaluator</p><empty-line /><p>
    in Scheme</p><empty-line /><p>
order of events</p><empty-line /><p>
    decoupling apparent from actual</p><empty-line /><p>
    indeterminacy in concurrent systems</p><empty-line /><p>order of growth</p><empty-line /><p>
    linear iterative process</p><empty-line /><p>
    linear recursive process</p><empty-line /><p>
    logarithmic</p><empty-line /><p>
    tree-recursive process</p><empty-line /><p>
order of subexpression evaluation, <emphasis>see</emphasis> order of evaluation</p><empty-line /><p>ordered-list representation of sets</p><empty-line /><p>ordinary numbers (in generic arithmetic system)</p><empty-line /><p>origin-frame</p><empty-line /><p>Ostrowski, A. M.</p><empty-line /><p>outranked-by (rule), 
[2]</p><empty-line /><empty-line /><p>P operation on semaphore</p><empty-line /><p>package</p><empty-line /><p>
    complex-number</p><empty-line /><p>
    polar representation</p><empty-line /><p>
    polynomial</p><empty-line /><p>
    rational-number</p><empty-line /><p>
    rectangular representation</p><empty-line /><p>
    Scheme-number</p><empty-line /><p>painter(s)</p><empty-line /><p>
    higher-order operations</p><empty-line /><p>
    operations</p><empty-line /><p>
    represented as procedures</p><empty-line /><p>
    transforming and combining</p><empty-line /><p>pair(s)</p><empty-line /><p>
    axiomatic definition of</p><empty-line /><p>
    box-and-pointer notation for</p><empty-line /><p>
    infinite stream of</p><empty-line /><p>
    lazy</p><empty-line /><p>
    mutable</p><empty-line /><p>
    procedural representation of, 
[2], [3]</p><empty-line /><p>
    represented using vectors</p><empty-line /><p>
    used to represent sequence</p><empty-line /><p>
    used to represent tree</p><empty-line /><p>pair? (primitive procedure)</p><empty-line /><p>
    implemented with typed pointers</p><empty-line /><p>pairs</p><empty-line /><p>Pan, V. Y.</p><empty-line /><p>parallel-execute</p><empty-line /><p>parallel-instruction-sequences</p><empty-line /><p>
parallelism, <emphasis>see</emphasis> concurrency</p><empty-line /><p>
parameter, <emphasis>see</emphasis> formal parameters</p><empty-line /><p>
parameter passing, <emphasis>see</emphasis> call-by-name argument passing; call-by-need argument passing</p><empty-line /><p>
parentheses</p><empty-line /><p>
    delimiting combination</p><empty-line /><p>
    delimiting cond clauses</p><empty-line /><p>
    in procedure definition</p><empty-line /><p>parse</p><empty-line /><p>parse-...</p><empty-line /><p>parsing natural language</p><empty-line /><p>
    real language understanding vs. toy parser</p><empty-line /><p>partial-sums</p><empty-line /><p>Pascal</p><empty-line /><p>
    lack of higher-order procedures</p><empty-line /><p>
    recursive procedures</p><empty-line /><p>
    restrictions on compound data</p><empty-line /><p>
    weakness in handling compound objects</p><empty-line /><p>Pascal, Blaise</p><empty-line /><p>Pascal's triangle</p><empty-line /><p>password-protected bank account</p><empty-line /><p>pattern</p><empty-line /><p>pattern matching</p><empty-line /><p>
    implementation</p><empty-line /><p>
    unification vs., 
[2]</p><empty-line /><p>pattern variable</p><empty-line /><p>
    representation of, 
[2]</p><empty-line /><p>pattern-match</p><empty-line /><p>pc register</p><empty-line /><p>perform (in register machine)</p><empty-line /><p>
    simulating</p><empty-line /><p>perform-action</p><empty-line /><p>Perlis, Alan J., [2]</p><empty-line /><p>
    quips, [2]</p><empty-line /><p>permutations of a set</p><empty-line /><p>
    permutations</p><empty-line /><p>Phillips, Hubert</p><empty-line /><p><image xlink:href="#_37.jpg" />  (pi)</p><empty-line /><p>
    approximation with half-interval method</p><empty-line /><p>
    approximation with Monte Carlo integration, [2]</p><empty-line /><p>
    Cesàro estimate for, 
[2]</p><empty-line /><p>
    Leibniz's series for, 
[2]</p><empty-line /><p>
    stream of approximations</p><empty-line /><p>
    Wallis's formula for</p><empty-line /><p>pi-stream</p><empty-line /><p>pi-sum</p><empty-line /><p>
    with higher-order procedures</p><empty-line /><p>
    with lambda</p><empty-line /><p>picture language</p><empty-line /><p>Pingala,  Áchárya</p><empty-line /><p>pipelining</p><empty-line /><p>Pitman, Kent M.</p><empty-line /><p>Planner</p><empty-line /><p>point, represented as a pair</p><empty-line /><p>
pointer</p><empty-line /><p>
    in box-and-pointer notation</p><empty-line /><p>
    typed</p><empty-line /><p>polar package</p><empty-line /><p>polar?</p><empty-line /><p>poly</p><empty-line /><p>polynomial package</p><empty-line /><p>polynomial arithmetic</p><empty-line /><p>
    addition</p><empty-line /><p>
    division</p><empty-line /><p>
    Euclid's Algorithm</p><empty-line /><p>
    greatest common divisor, 
[2]</p><empty-line /><p>
    interfaced to generic arithmetic system</p><empty-line /><p>
    multiplication</p><empty-line /><p>
    probabilistic algorithm for GCD</p><empty-line /><p>
    rational functions</p><empty-line /><p>
    subtraction</p><empty-line /><p>polynomial(s)</p><empty-line /><p>
    canonical form</p><empty-line /><p>
    dense</p><empty-line /><p>
    evaluating with Horner's rule</p><empty-line /><p>
    hierarchy of types</p><empty-line /><p>
    indeterminate of</p><empty-line /><p>
    sparse</p><empty-line /><p>
    univariate</p><empty-line /><p>pop</p><empty-line /><p>Portable Standard Lisp</p><empty-line /><p>porting a language</p><empty-line /><p>power series, as stream</p><empty-line /><p>
    adding</p><empty-line /><p>
    dividing</p><empty-line /><p>
    integrating</p><empty-line /><p>
    multiplying</p><empty-line /><p>PowerPC</p><empty-line /><p>predicate</p><empty-line /><p>
    of cond clause</p><empty-line /><p>
    of if</p><empty-line /><p>
    naming convention for</p><empty-line /><p>prefix code</p><empty-line /><p>prefix notation</p><empty-line /><p>
    infix notation vs.</p><empty-line /><p>prepositions</p><empty-line /><p>preserving, 
[2], [3], 
[4]</p><empty-line /><p>pretty-printing</p><empty-line /><p>prime number(s)</p><empty-line /><p>
    cryptography and</p><empty-line /><p>
    Eratosthenes's sieve for</p><empty-line /><p>
    Fermat test for</p><empty-line /><p>
    infinite stream of, <emphasis>see</emphasis> primes</p><empty-line /><p>
    Miller-Rabin test for</p><empty-line /><p>
    testing for</p><empty-line /><p>prime-sum-pair</p><empty-line /><p>prime-sum-pairs</p><empty-line /><p>
    infinite stream</p><empty-line /><p>prime?, [2]</p><empty-line /><p>primes (infinite stream)</p><empty-line /><p>
    implicit definition</p><empty-line /><p>primitive constraints</p><empty-line /><p>primitive expression</p><empty-line /><p>
    evaluation of</p><empty-line /><p>
    name of primitive procedure</p><empty-line /><p>
    name of variable</p><empty-line /><p>
    number</p><empty-line /><p>
primitive procedures (those marked <emphasis>ns</emphasis> are not in the IEEE Scheme standard)</p><empty-line /><p>
    *</p><empty-line /><p>
    +</p><empty-line /><p>
    -, [2]</p><empty-line /><p>
    /</p><empty-line /><p>
    &lt;</p><empty-line /><p>
    =</p><empty-line /><p>
    &gt;</p><empty-line /><p>
    apply</p><empty-line /><p>
    atan</p><empty-line /><p>
    car</p><empty-line /><p>
    cdr</p><empty-line /><p>
    cons</p><empty-line /><p>
    cos</p><empty-line /><p>
    display</p><empty-line /><p>
    eq?</p><empty-line /><p>
    error (<emphasis>ns</emphasis>)</p><empty-line /><p>
    eval (<emphasis>ns</emphasis>)</p><empty-line /><p>
    list</p><empty-line /><p>
    log</p><empty-line /><p>
    max</p><empty-line /><p>
    min</p><empty-line /><p>
    newline</p><empty-line /><p>
    not</p><empty-line /><p>
    null?</p><empty-line /><p>
    number?</p><empty-line /><p>
    pair?</p><empty-line /><p>
    quotient</p><empty-line /><p>
    random (<emphasis>ns</emphasis>), 
[2]</p><empty-line /><p>
    read</p><empty-line /><p>
    remainder</p><empty-line /><p>
    round</p><empty-line /><p>
    runtime (<emphasis>ns</emphasis>)</p><empty-line /><p>
    set-car!</p><empty-line /><p>
    set-cdr!</p><empty-line /><p>
    sin</p><empty-line /><p>
    symbol?</p><empty-line /><p>
    vector-ref</p><empty-line /><p>
    vector-set!</p><empty-line /><p>
primitive query, <emphasis>see</emphasis> simple query</p><empty-line /><p>primitive-apply</p><empty-line /><p>primitive-implementation</p><empty-line /><p>primitive-procedure-names</p><empty-line /><p>primitive-procedure-objects</p><empty-line /><p>primitive-procedure?, 
[2]</p><empty-line /><p>principle of least commitment</p><empty-line /><p>print operation in register machine</p><empty-line /><p>print-point</p><empty-line /><p>print-queue</p><empty-line /><p>print-rat</p><empty-line /><p>print-result</p><empty-line /><p>
    monitored-stack version</p><empty-line /><p>print-stack-statistics operation in register machine</p><empty-line /><p>printing, primitives for</p><empty-line /><p>probabilistic algorithm, 
[2], [3]</p><empty-line /><p>probe</p><empty-line /><p>
    in constraint system</p><empty-line /><p>
    in digital-circuit simulator</p><empty-line /><p>proc register</p><empty-line /><p>procedural abstraction</p><empty-line /><p>procedural representation of data</p><empty-line /><p>
    mutable data</p><empty-line /><p>procedure, [2]</p><empty-line /><p>
    anonymous</p><empty-line /><p>
    arbitrary number of arguments, 
[2]</p><empty-line /><p>
    as argument</p><empty-line /><p>
    as black box</p><empty-line /><p>
    body of</p><empty-line /><p>
    compound</p><empty-line /><p>
    creating with define</p><empty-line /><p>
    creating with lambda, 
[2], [3]</p><empty-line /><p>
    as data</p><empty-line /><p>
    definition of</p><empty-line /><p>
    first-class in Lisp</p><empty-line /><p>
    formal parameters of</p><empty-line /><p>
    as general method</p><empty-line /><p>
    generic, [2]</p><empty-line /><p>
    higher-order, <emphasis>see</emphasis> higher-order procedure</p><empty-line /><p>
    implicit begin in body of</p><empty-line /><p>
    mathematical function vs.</p><empty-line /><p>
    memoized</p><empty-line /><p>
    monitored</p><empty-line /><p>
    name of</p><empty-line /><p>
    naming (with define)</p><empty-line /><p>
    as pattern for local evolution of a process</p><empty-line /><p>
    as returned value</p><empty-line /><p>
    returning multiple values</p><empty-line /><p>
    scope of formal parameters</p><empty-line /><p>
    special form vs., 
[2]</p><empty-line /><p>
procedure application</p><empty-line /><p>
    combination denoting</p><empty-line /><p>
    environment model of</p><empty-line /><p>
    substitution model of, <emphasis>see</emphasis> substitution model of procedure application</p><empty-line /><p>procedure-body</p><empty-line /><p>procedure-environment</p><empty-line /><p>procedure-parameters</p><empty-line /><p>process</p><empty-line /><p>
    iterative</p><empty-line /><p>
    linear iterative</p><empty-line /><p>
    linear recursive</p><empty-line /><p>
    local evolution of</p><empty-line /><p>
    order of growth of</p><empty-line /><p>
    recursive</p><empty-line /><p>
    resources required by</p><empty-line /><p>
    shape of</p><empty-line /><p>
    tree-recursive</p><empty-line /><p>product</p><empty-line /><p>
    as accumulation</p><empty-line /><p>product?</p><empty-line /><p>program</p><empty-line /><p>
    as abstract machine</p><empty-line /><p>
    comments in</p><empty-line /><p>
    as data</p><empty-line /><p>
    incremental development of</p><empty-line /><p>
    structure of, [2], 
[3], 
<emphasis>see also</emphasis> abstraction barriers</p><empty-line /><p>
    structured with subroutines</p><empty-line /><p>program counter</p><empty-line /><p>
programming</p><empty-line /><p>
    data-directed, <emphasis>see</emphasis> data-directed programming</p><empty-line /><p>
    demand-driven</p><empty-line /><p>
    elements of</p><empty-line /><p>
    functional, <emphasis>see</emphasis> functional programming</p><empty-line /><p>
    imperative</p><empty-line /><p>
    odious style</p><empty-line /><p>programming language</p><empty-line /><p>
    design of</p><empty-line /><p>
    functional</p><empty-line /><p>
    logic</p><empty-line /><p>
    object-oriented</p><empty-line /><p>
    strongly typed</p><empty-line /><p>
    very high-level</p><empty-line /><p>Prolog, [2]</p><empty-line /><p>prompt-for-input</p><empty-line /><p>prompts</p><empty-line /><p>
    explicit-control evaluator</p><empty-line /><p>
    lazy evaluator</p><empty-line /><p>
    metacircular evaluator</p><empty-line /><p>
    nondeterministic evaluator</p><empty-line /><p>
    query interpreter</p><empty-line /><p>propagate</p><empty-line /><p>propagation of constraints</p><empty-line /><p>proving programs correct</p><empty-line /><p>pseudo-random sequence</p><empty-line /><p>pseudodivision of polynomials</p><empty-line /><p>pseudoremainder of polynomials</p><empty-line /><p>push</p><empty-line /><p>put, [2]</p><empty-line /><p>
puzzles</p><empty-line /><p>
    eight-queens puzzle, 
[2]</p><empty-line /><p>
    logic puzzles</p><empty-line /><p>
Pythagorean triples</p><empty-line /><p>
    with nondeterministic programs, 
[2], [3]</p><empty-line /><p>
    with streams</p><empty-line /><empty-line /><p>qeval, [2]</p><empty-line /><p>quantum mechanics</p><empty-line /><p>quasiquote</p><empty-line /><p>queens</p><empty-line /><p>query, 
<emphasis>see also</emphasis> simple query; compound query</p><empty-line /><p>query interpreter</p><empty-line /><p>
    adding rule or assertion</p><empty-line /><p>
    compound query, <emphasis>see</emphasis> compound query</p><empty-line /><p>
    data base</p><empty-line /><p>
    driver loop, 
[2]</p><empty-line /><p>
    environment structure in</p><empty-line /><p>
    frame, [2]</p><empty-line /><p>
    improvements to, 
[2], [3]</p><empty-line /><p>
    infinite loops, 
[2]</p><empty-line /><p>
    instantiation</p><empty-line /><p>
    Lisp interpreter vs., 
[2], [3]</p><empty-line /><p>
    overview</p><empty-line /><p>
    pattern matching, 
[2]</p><empty-line /><p>
    pattern-variable representation, 
[2]</p><empty-line /><p>
    problems with not and lisp-value, [2]</p><empty-line /><p>
    query evaluator, 
[2]</p><empty-line /><p>
    rule, <emphasis>see</emphasis> rule</p><empty-line /><p>
    simple query, <emphasis>see</emphasis> simple query</p><empty-line /><p>
    stream operations</p><empty-line /><p>
    streams of frames, 
[2]</p><empty-line /><p>
    syntax of query language</p><empty-line /><p>
    unification, 
[2]</p><empty-line /><p>query language, [2]</p><empty-line /><p>
    abstraction in</p><empty-line /><p>
    compound query, <emphasis>see</emphasis> compound query</p><empty-line /><p>
    data base</p><empty-line /><p>
    equality testing in</p><empty-line /><p>
    extensions to, 
[2]</p><empty-line /><p>
    logical deductions</p><empty-line /><p>
    mathematical logic vs.</p><empty-line /><p>
    rule, <emphasis>see</emphasis> rule</p><empty-line /><p>
    simple query, <emphasis>see</emphasis> simple query</p><empty-line /><p>query-driver-loop</p><empty-line /><p>question mark, in predicate names</p><empty-line /><p>queue</p><empty-line /><p>
    double-ended</p><empty-line /><p>
    front of</p><empty-line /><p>
    operations on</p><empty-line /><p>
    procedural implementation of</p><empty-line /><p>
    rear of</p><empty-line /><p>
    in simulation agenda</p><empty-line /><p>quotation</p><empty-line /><p>
    of character strings</p><empty-line /><p>
    of Lisp data objects</p><empty-line /><p>
    in natural language</p><empty-line /><p>quotation mark, single vs. double</p><empty-line /><p>quote (special form)</p><empty-line /><p>
    read and, 
[2]</p><empty-line /><p>quoted?</p><empty-line /><p>quotient (primitive procedure)</p><empty-line /><empty-line /><p>Rabin, Michael O.</p><empty-line /><p>radicand</p><empty-line /><p>Ramanujan numbers</p><empty-line /><p>Ramanujan, Srinivasa</p><empty-line /><p>rand</p><empty-line /><p>
    with reset</p><empty-line /><p>random (primitive procedure)</p><empty-line /><p>
    assignment needed for</p><empty-line /><p>
    MIT Scheme</p><empty-line /><p>random-in-range</p><empty-line /><p>random-number generator, 
[2]</p><empty-line /><p>
    in Monte Carlo simulation</p><empty-line /><p>
    in primality testing</p><empty-line /><p>
    with reset</p><empty-line /><p>
    with reset, stream version</p><empty-line /><p>random-numbers (infinite stream)</p><empty-line /><p>Raphael, Bertram</p><empty-line /><p>rational package</p><empty-line /><p>rational function</p><empty-line /><p>
    reducing to lowest terms</p><empty-line /><p>
rational number(s)</p><empty-line /><p>
    arithmetic operations on</p><empty-line /><p>
    in MIT Scheme</p><empty-line /><p>
    printing</p><empty-line /><p>
    reducing to lowest terms, 
[2]</p><empty-line /><p>
    represented as pairs</p><empty-line /><p>rational-number arithmetic</p><empty-line /><p>
    interfaced to generic arithmetic system</p><empty-line /><p>
    need for compound data</p><empty-line /><p>Raymond, Eric, [2]</p><empty-line /><p>RC circuit</p><empty-line /><p>read (primitive procedure)</p><empty-line /><p>
    dotted-tail notation handling by</p><empty-line /><p>
    macro characters</p><empty-line /><p>read operation in register machine</p><empty-line /><p>read-eval-print loop, 
<emphasis>see also</emphasis> driver loop</p><empty-line /><p>read-eval-print-loop</p><empty-line /><p>reader macro character</p><empty-line /><p>real number</p><empty-line /><p>real-part</p><empty-line /><p>
    data-directed</p><empty-line /><p>
    polar representation</p><empty-line /><p>
    rectangular representation</p><empty-line /><p>
    with tagged data</p><empty-line /><p>real-part-polar</p><empty-line /><p>real-part-rectangular</p><empty-line /><p>rear-ptr</p><empty-line /><p>receive procedure</p><empty-line /><p>record, in a data base</p><empty-line /><p>rectangle, representing</p><empty-line /><p>rectangular package</p><empty-line /><p>rectangular?</p><empty-line /><p>recursion</p><empty-line /><p>
    data-directed</p><empty-line /><p>
    expressing complicated process</p><empty-line /><p>
    in rules</p><empty-line /><p>
    in working with trees</p><empty-line /><p>recursion equations</p><empty-line /><p>recursion theory</p><empty-line /><p>
recursive procedure</p><empty-line /><p>
    recursive procedure definition</p><empty-line /><p>
    recursive process vs.</p><empty-line /><p>
    specifying without define</p><empty-line /><p>recursive process</p><empty-line /><p>
    iterative process vs., 
[2], [3], 
[4]</p><empty-line /><p>
    linear, [2]</p><empty-line /><p>
    recursive procedure vs.</p><empty-line /><p>
    register machine for</p><empty-line /><p>
    tree, [2]</p><empty-line /><p>red-black tree</p><empty-line /><p>reducing to lowest terms, 
[2], [3]</p><empty-line /><p>Rees, Jonathan A., 
[2]</p><empty-line /><p>referential transparency</p><empty-line /><p>reg (in register machine)</p><empty-line /><p>
    simulating</p><empty-line /><p>register machine</p><empty-line /><p>
    actions</p><empty-line /><p>
    controller</p><empty-line /><p>
    controller diagram</p><empty-line /><p>
    data paths</p><empty-line /><p>
    data-path diagram</p><empty-line /><p>
    design of</p><empty-line /><p>
    language for describing</p><empty-line /><p>
    monitoring performance</p><empty-line /><p>
    simulator</p><empty-line /><p>
    stack</p><empty-line /><p>
    subroutine</p><empty-line /><p>
    test operation</p><empty-line /><p>register table, in simulator</p><empty-line /><p>register(s)</p><empty-line /><p>
    representing</p><empty-line /><p>
    tracing</p><empty-line /><p>register-exp</p><empty-line /><p>register-exp-reg</p><empty-line /><p>
register-machine language</p><empty-line /><p>
    assign, 
[2]</p><empty-line /><p>
    branch, 
[2]</p><empty-line /><p>
    const, 
[2], [3]</p><empty-line /><p>
    entry point</p><empty-line /><p>
    goto, [2]</p><empty-line /><p>
    instructions, 
[2]</p><empty-line /><p>
    label</p><empty-line /><p>
    label, 
[2]</p><empty-line /><p>
    op, [2]</p><empty-line /><p>
    perform, 
[2]</p><empty-line /><p>
    reg, [2]</p><empty-line /><p>
    restore, 
[2]</p><empty-line /><p>
    save, [2]</p><empty-line /><p>
    test, [2]</p><empty-line /><p>register-machine simulator</p><empty-line /><p>registers-modified</p><empty-line /><p>registers-needed</p><empty-line /><p>relations, computing in terms of, 
[2]</p><empty-line /><p>relatively prime</p><empty-line /><p>relativity, theory of</p><empty-line /><p>release a mutex</p><empty-line /><p>remainder (primitive procedure)</p><empty-line /><p>remainder modulo <emphasis>n</emphasis></p><empty-line /><p>remainder-terms</p><empty-line /><p>remove</p><empty-line /><p>remove-first-agenda-item!, 
[2]</p><empty-line /><p>require</p><empty-line /><p>
    as a special form</p><empty-line /><p>reserved words, [2]</p><empty-line /><p>
resistance</p><empty-line /><p>
    formula for parallel resistors, 
[2]</p><empty-line /><p>
    tolerance of resistors</p><empty-line /><p>resolution principle</p><empty-line /><p>resolution, Horn-clause</p><empty-line /><p>rest-exps</p><empty-line /><p>rest-operands</p><empty-line /><p>rest-segments</p><empty-line /><p>rest-terms, 
[2]</p><empty-line /><p>restore (in register machine), 
[2]</p><empty-line /><p>
    implementing</p><empty-line /><p>
    simulating</p><empty-line /><p>return (linkage descriptor)</p><empty-line /><p>returning multiple values</p><empty-line /><p>Reuter, Andreas</p><empty-line /><p>reverse</p><empty-line /><p>
    as folding</p><empty-line /><p>
    rules</p><empty-line /><p>Rhind Papyrus</p><empty-line /><p>right-branch, 
[2]</p><empty-line /><p>right-split</p><empty-line /><p>ripple-carry adder</p><empty-line /><p>Rivest, Ronald L., 
[2]</p><empty-line /><p>RLC circuit</p><empty-line /><p>Robinson, J. A.</p><empty-line /><p>robustness</p><empty-line /><p>rock songs, 1950s</p><empty-line /><p>Rogers, William Barton</p><empty-line /><p>root register</p><empty-line /><p>
roots of equation, <emphasis>see</emphasis> half-interval method; Newton's method</p><empty-line /><p>rotate90</p><empty-line /><p>round (primitive procedure)</p><empty-line /><p>roundoff error, [2]</p><empty-line /><p>Rozas, Guillermo Juan</p><empty-line /><p>RSA algorithm</p><empty-line /><p>rule (query language)</p><empty-line /><p>
    applying, [2], 
[3]</p><empty-line /><p>
    without body, 
[2], [3]</p><empty-line /><p>Runkle, John Daniel</p><empty-line /><p>runtime (primitive procedure)</p><empty-line /><p>Russian peasant method of multiplication</p><empty-line /><empty-line /><p>same (rule)</p><empty-line /><p>same-variable?, 
[2]</p><empty-line /><p>
sameness and change</p><empty-line /><p>
    meaning of</p><empty-line /><p>
    shared data and</p><empty-line /><p>satisfy a compound query</p><empty-line /><p>satisfy a pattern (simple query)</p><empty-line /><p>save (in register machine), 
[2]</p><empty-line /><p>
    implementing</p><empty-line /><p>
    simulating</p><empty-line /><p>scale-list, 
[2], [3]</p><empty-line /><p>scale-stream</p><empty-line /><p>scale-tree, 
[2]</p><empty-line /><p>scale-vect</p><empty-line /><p>scan register</p><empty-line /><p>scan-out-defines</p><empty-line /><p>scanning out internal definitions</p><empty-line /><p>
    in compiler, 
[2]</p><empty-line /><p>Scheme</p><empty-line /><p>
    history of</p><empty-line /><p>Scheme chip, [2]</p><empty-line /><p>scheme-number package</p><empty-line /><p>scheme-number-&gt;complex</p><empty-line /><p>scheme-number-&gt;scheme-number</p><empty-line /><p>Schmidt, Eric</p><empty-line /><p>scope of a variable, 
<emphasis>see also</emphasis> lexical scoping</p><empty-line /><p>
    internal define</p><empty-line /><p>
    in let</p><empty-line /><p>
    procedure's formal parameters</p><empty-line /><p>
search</p><empty-line /><p>
    of binary tree</p><empty-line /><p>
    depth-first</p><empty-line /><p>
    systematic</p><empty-line /><p>search</p><empty-line /><p>secretary, importance of</p><empty-line /><p>segment-queue</p><empty-line /><p>segment-time</p><empty-line /><p>segments</p><empty-line /><p>segments-&gt;painter</p><empty-line /><p>selector</p><empty-line /><p>
    as abstraction barrier</p><empty-line /><p>
    generic, [2]</p><empty-line /><p>self-evaluating expression</p><empty-line /><p>self-evaluating?</p><empty-line /><p>semaphore</p><empty-line /><p>
    of size <emphasis>n</emphasis></p><empty-line /><p>semicolon</p><empty-line /><p>
    comment introduced by</p><empty-line /><p>separator code</p><empty-line /><p>sequence accelerator</p><empty-line /><p>
sequence of expressions</p><empty-line /><p>
    in consequent of cond</p><empty-line /><p>
    in procedure body</p><empty-line /><p>sequence(s)</p><empty-line /><p>
    as conventional interface</p><empty-line /><p>
    as source of modularity</p><empty-line /><p>
    operations on</p><empty-line /><p>
    represented by pairs</p><empty-line /><p>sequence-&gt;exp</p><empty-line /><p>serialized-exchange</p><empty-line /><p>
    with deadlock avoidance</p><empty-line /><p>serializer</p><empty-line /><p>
    implementing</p><empty-line /><p>
    with multiple shared resources</p><empty-line /><p>series, summation of</p><empty-line /><p>
    accelerating sequence of approximations</p><empty-line /><p>
    with streams</p><empty-line /><p>set</p><empty-line /><p>
    set</p><empty-line /><p>
         (special form), <emphasis>see also</emphasis> assignment</p><empty-line /><p>
    data base as</p><empty-line /><p>
    operations on</p><empty-line /><p>
    permutations of</p><empty-line /><p>
    represented as binary tree</p><empty-line /><p>
    represented as ordered list</p><empty-line /><p>
    represented as unordered list</p><empty-line /><p>
    subsets of</p><empty-line /><p>set! (special form)</p><empty-line /><p>
    environment model of</p><empty-line /><p>
    value of</p><empty-line /><p>set-car! (primitive procedure)</p><empty-line /><p>
    implemented with vectors</p><empty-line /><p>
    procedural implementation of</p><empty-line /><p>
    value of</p><empty-line /><p>set-cdr! (primitive procedure)</p><empty-line /><p>
    implemented with vectors</p><empty-line /><p>
    procedural implementation of</p><empty-line /><p>
    value of</p><empty-line /><p>set-contents!</p><empty-line /><p>set-current-time!</p><empty-line /><p>set-front-ptr!</p><empty-line /><p>set-instruction-execution-proc!</p><empty-line /><p>set-rear-ptr!</p><empty-line /><p>set-register-contents!, 
[2]</p><empty-line /><p>set-segments!</p><empty-line /><p>set-signal!, 
[2]</p><empty-line /><p>set-value!, 
[2]</p><empty-line /><p>set-variable-value!, 
[2]</p><empty-line /><p>setup-environment</p><empty-line /><p>shadow a binding</p><empty-line /><p>Shamir, Adi</p><empty-line /><p>shape of a process</p><empty-line /><p>shared data</p><empty-line /><p>shared resources</p><empty-line /><p>shared state</p><empty-line /><p>shrink-to-upper-right</p><empty-line /><p>Shrobe, Howard E.</p><empty-line /><p>side-effect bug</p><empty-line /><p>sieve of Eratosthenes</p><empty-line /><p>
    sieve</p><empty-line /><p>sum  (sigma) notation</p><empty-line /><p>
signal processing</p><empty-line /><p>
    smoothing a function</p><empty-line /><p>
    smoothing a signal, 
[2]</p><empty-line /><p>
    stream model of</p><empty-line /><p>
    zero crossings of a signal, 
[2], [3]</p><empty-line /><p>signal, digital</p><empty-line /><p>signal-error</p><empty-line /><p>signal-flow diagram, 
[2]</p><empty-line /><p>signal-processing view of computation</p><empty-line /><p>simple query</p><empty-line /><p>
    processing, [2], 
[3], [4]</p><empty-line /><p>simple-query</p><empty-line /><p>simplification of algebraic expressions</p><empty-line /><p>Simpson's Rule for numerical integration</p><empty-line /><p>
simulation</p><empty-line /><p>
    of digital circuit, <emphasis>see</emphasis> digital-circuit simulation</p><empty-line /><p>
    event-driven</p><empty-line /><p>
    as machine-design tool</p><empty-line /><p>
    for monitoring performance of register machine</p><empty-line /><p>
    Monte Carlo, <emphasis>see</emphasis> Monte Carlo simulation</p><empty-line /><p>
    of register machine, <emphasis>see</emphasis> register-machine simulator</p><empty-line /><p>sin (primitive procedure)</p><empty-line /><p>
sine</p><empty-line /><p>
    approximation for small angle</p><empty-line /><p>
    power series for</p><empty-line /><p>singleton-stream</p><empty-line /><p>SKETCHPAD</p><empty-line /><p>smallest-divisor</p><empty-line /><p>
    more efficient version</p><empty-line /><p>Smalltalk</p><empty-line /><p>smoothing a function</p><empty-line /><p>smoothing a signal, 
[2]</p><empty-line /><p>snarf</p><empty-line /><p>Solar System's chaotic dynamics</p><empty-line /><p>Solomonoff, Ray</p><empty-line /><p>solve differential equation, 
[2]</p><empty-line /><p>
    lazy-list version</p><empty-line /><p>
    with scanned-out definitions</p><empty-line /><p>
solving equation, <emphasis>see</emphasis> half-interval method; Newton's method; solve</p><empty-line /><p>source language</p><empty-line /><p>source program</p><empty-line /><p>Spafford, Eugene H.</p><empty-line /><p>sparse polynomial</p><empty-line /><p>special form</p><empty-line /><p>
    as derived expression in evaluator</p><empty-line /><p>
    need for</p><empty-line /><p>
    procedure vs., 
[2]</p><empty-line /><p>
special forms (those marked <emphasis>ns</emphasis> are not in the IEEE Scheme standard)</p><empty-line /><p>
    and</p><empty-line /><p>
    begin</p><empty-line /><p>
    cond</p><empty-line /><p>
    cons-stream (<emphasis>ns</emphasis>)</p><empty-line /><p>
    define, [2]</p><empty-line /><p>
    delay (<emphasis>ns</emphasis>)</p><empty-line /><p>
    if</p><empty-line /><p>
    lambda</p><empty-line /><p>
    let</p><empty-line /><p>
    let*</p><empty-line /><p>
    letrec</p><empty-line /><p>
    named let</p><empty-line /><p>
    or</p><empty-line /><p>
    quote</p><empty-line /><p>
    set!</p><empty-line /><p>split</p><empty-line /><p>sqrt</p><empty-line /><p>
    block structured</p><empty-line /><p>
    in environment model</p><empty-line /><p>
    as fixed point, 
[2], [3], 
[4]</p><empty-line /><p>
    as iterative improvement</p><empty-line /><p>
    with Newton's method, 
[2]</p><empty-line /><p>
    register machine for</p><empty-line /><p>
    as stream limit</p><empty-line /><p>sqrt-stream</p><empty-line /><p>square</p><empty-line /><p>
    in environment model</p><empty-line /><p>square root, <emphasis>see also</emphasis> sqrt</p><empty-line /><p>
    stream of approximations</p><empty-line /><p>square-limit, 
[2]</p><empty-line /><p>square-of-four</p><empty-line /><p>squarer (constraint), 
[2]</p><empty-line /><p>squash-inwards</p><empty-line /><p>stack</p><empty-line /><p>
    framed</p><empty-line /><p>
    for recursion in register machine</p><empty-line /><p>
    representing, 
[2]</p><empty-line /><p>stack allocation and tail recursion</p><empty-line /><p>stack-inst-reg-name</p><empty-line /><p>Stallman, Richard M., 
[2]</p><empty-line /><p>start register machine, 
[2]</p><empty-line /><p>start-eceval</p><empty-line /><p>start-segment, 
[2]</p><empty-line /><p>
state</p><empty-line /><p>
    local, <emphasis>see</emphasis> local state</p><empty-line /><p>
    shared</p><empty-line /><p>
    vanishes in stream formulation</p><empty-line /><p>state variable, [2]</p><empty-line /><p>
    local</p><empty-line /><p>
statements, <emphasis>see</emphasis> instruction sequence</p><empty-line /><p>statements</p><empty-line /><p>Steele, Guy Lewis Jr., 
[2], [3], 
[4], [5], 
[6]</p><empty-line /><p>stop-and-copy garbage collector</p><empty-line /><p>Stoy, Joseph E., [2], 
[3]</p><empty-line /><p>Strachey, Christopher</p><empty-line /><p>stratified design</p><empty-line /><p>stream(s), [2]</p><empty-line /><p>
    delayed evaluation and</p><empty-line /><p>
    empty</p><empty-line /><p>
    implemented as delayed lists</p><empty-line /><p>
    implemented as lazy lists</p><empty-line /><p>
    implicit definition</p><empty-line /><p>
    infinite, <emphasis>see</emphasis> infinite streams</p><empty-line /><p>
    used in query interpreter, 
[2]</p><empty-line /><p>stream-append</p><empty-line /><p>stream-append-delayed</p><empty-line /><p>stream-car, 
[2]</p><empty-line /><p>stream-cdr, 
[2]</p><empty-line /><p>stream-enumerate-interval</p><empty-line /><p>stream-filter</p><empty-line /><p>stream-flatmap, 
[2]</p><empty-line /><p>stream-for-each</p><empty-line /><p>stream-limit</p><empty-line /><p>stream-map</p><empty-line /><p>
    with multiple arguments</p><empty-line /><p>stream-null?</p><empty-line /><p>
    in MIT Scheme</p><empty-line /><p>stream-ref</p><empty-line /><p>stream-withdraw</p><empty-line /><p>strict</p><empty-line /><p>
string, <emphasis>see</emphasis> character string</p><empty-line /><p>strongly typed language</p><empty-line /><p>sub (generic)</p><empty-line /><p>sub-complex</p><empty-line /><p>sub-interval</p><empty-line /><p>sub-rat</p><empty-line /><p>sub-vect</p><empty-line /><p>subroutine in register machine</p><empty-line /><p>subsets of a set</p><empty-line /><p>substitution model of procedure application, [2]</p><empty-line /><p>
    inadequacy of</p><empty-line /><p>
    shape of process</p><empty-line /><p>subtype</p><empty-line /><p>
    multiple</p><empty-line /><p>success continuation (nondeterministic evaluator), [2]</p><empty-line /><p>successive squaring</p><empty-line /><p>sum</p><empty-line /><p>
    as accumulation</p><empty-line /><p>
    iterative version</p><empty-line /><p>sum-cubes</p><empty-line /><p>
    with higher-order procedures</p><empty-line /><p>sum-integers</p><empty-line /><p>
    with higher-order procedures</p><empty-line /><p>sum-odd-squares, 
[2]</p><empty-line /><p>sum-of-squares</p><empty-line /><p>
    in environment model</p><empty-line /><p>sum-primes, 
[2]</p><empty-line /><p>sum?</p><empty-line /><p>summation of a series</p><empty-line /><p>
    with streams</p><empty-line /><p>supertype</p><empty-line /><p>
    multiple</p><empty-line /><p>Sussman, Gerald Jay, 
[2], [3], 
[4], [5], 
[6], [7]</p><empty-line /><p>Sussman, Julie Esther Mazel, nieces of</p><empty-line /><p>Sutherland, Ivan</p><empty-line /><p>symbol(s)</p><empty-line /><p>
    equality of</p><empty-line /><p>
    interning</p><empty-line /><p>
    quotation of</p><empty-line /><p>
    representation of</p><empty-line /><p>
    uniqueness of</p><empty-line /><p>symbol-leaf</p><empty-line /><p>symbol? (primitive procedure)</p><empty-line /><p>
    data types and</p><empty-line /><p>
    implemented with typed pointers</p><empty-line /><p>symbolic algebra</p><empty-line /><p>symbolic differentiation, 
[2]</p><empty-line /><p>symbolic expression, 
<emphasis>see also</emphasis> symbol(s)</p><empty-line /><p>symbols</p><empty-line /><p>SYNC</p><empty-line /><p>
synchronization, <emphasis>see</emphasis> concurrency</p><empty-line /><p>
syntactic analysis, separated from execution</p><empty-line /><p>
    in metacircular evaluator</p><empty-line /><p>
    in register-machine simulator, 
[2]</p><empty-line /><p>syntactic sugar</p><empty-line /><p>
    define</p><empty-line /><p>
    let as</p><empty-line /><p>
    looping constructs as</p><empty-line /><p>
    procedure vs. data as</p><empty-line /><p>
syntax, <emphasis>see also</emphasis> special forms</p><empty-line /><p>
    abstract, <emphasis>see</emphasis> abstract syntax</p><empty-line /><p>
    of expressions, describing</p><empty-line /><p>
    of a programming language</p><empty-line /><p>syntax interface</p><empty-line /><p>systematic search</p><empty-line /><empty-line /><p>#t</p><empty-line /><p>table</p><empty-line /><p>
    backbone of</p><empty-line /><p>
    for coercion</p><empty-line /><p>
    for data-directed programming</p><empty-line /><p>
    local</p><empty-line /><p>
    <emphasis>n</emphasis>-dimensional</p><empty-line /><p>
    one-dimensional</p><empty-line /><p>
    operation-and-type, <emphasis>see</emphasis> operation-and-type table</p><empty-line /><p>
    represented as binary tree vs. unordered list</p><empty-line /><p>
    testing equality of keys</p><empty-line /><p>
    two-dimensional</p><empty-line /><p>
    used in simulation agenda</p><empty-line /><p>
    used to store computed values</p><empty-line /><p>tableau</p><empty-line /><p>tabulation, [2]</p><empty-line /><p>tack-on-instruction-sequence</p><empty-line /><p>tagged architecture</p><empty-line /><p>tagged data, [2]</p><empty-line /><p>tagged-list?</p><empty-line /><p>tail recursion</p><empty-line /><p>
    compiler and</p><empty-line /><p>
    environment model of evaluation and</p><empty-line /><p>
    explicit-control evaluator and, 
[2], [3]</p><empty-line /><p>
    garbage collection and</p><empty-line /><p>
    metacircular evaluator and</p><empty-line /><p>
    in Scheme</p><empty-line /><p>tail-recursive evaluator</p><empty-line /><p>
tangent</p><empty-line /><p>
    as continued fraction</p><empty-line /><p>
    power series for</p><empty-line /><p>target register</p><empty-line /><p>Technological University of Eindhoven</p><empty-line /><p>Teitelman, Warren</p><empty-line /><p>term list of polynomial</p><empty-line /><p>
    representing</p><empty-line /><p>term-list</p><empty-line /><p>terminal node of a tree</p><empty-line /><p>test (in register machine)</p><empty-line /><p>
    simulating</p><empty-line /><p>test operation in register machine</p><empty-line /><p>test-and-set!, 
[2]</p><empty-line /><p>test-condition</p><empty-line /><p>text-of-quotation</p><empty-line /><p>Thatcher, James W.</p><empty-line /><p>THE Multiprogramming System</p><empty-line /><p>the-cars</p><empty-line /><p>
    register, [2]</p><empty-line /><p>
    vector</p><empty-line /><p>the-cdrs</p><empty-line /><p>
    register, [2]</p><empty-line /><p>
    vector</p><empty-line /><p>the-empty-stream</p><empty-line /><p>
    in MIT Scheme</p><empty-line /><p>the-empty-termlist, 
[2]</p><empty-line /><p>the-global-environment, 
[2]</p><empty-line /><p>theorem proving (automatic)</p><empty-line /><p><image xlink:href="#_214.jpg" /> (<emphasis>f</emphasis>(<emphasis>n</emphasis>)) (theta of <emphasis>f</emphasis>(<emphasis>n</emphasis>))</p><empty-line /><p>thunk</p><empty-line /><p>
    call-by-name</p><empty-line /><p>
    call-by-need</p><empty-line /><p>
    forcing</p><empty-line /><p>
    implementation of</p><empty-line /><p>
    origin of name</p><empty-line /><p>
time</p><empty-line /><p>
    assignment and</p><empty-line /><p>
    communication and</p><empty-line /><p>
    in concurrent systems</p><empty-line /><p>
    functional programming and</p><empty-line /><p>
    in nondeterministic computing, 
[2]</p><empty-line /><p>
    purpose of</p><empty-line /><p>time segment, in agenda</p><empty-line /><p>time slicing</p><empty-line /><p>timed-prime-test</p><empty-line /><p>timing diagram</p><empty-line /><p>TK!Solver</p><empty-line /><p>tower of types</p><empty-line /><p>
tracing</p><empty-line /><p>
    instruction execution</p><empty-line /><p>
    register assignment</p><empty-line /><p>transform-painter</p><empty-line /><p>transparency, referential</p><empty-line /><p>transpose a matrix</p><empty-line /><p>
tree</p><empty-line /><p>
    B-tree</p><empty-line /><p>
    binary, 
<emphasis>see also</emphasis> binary tree</p><empty-line /><p>
    combination viewed as</p><empty-line /><p>
    counting leaves of</p><empty-line /><p>
    enumerating leaves of</p><empty-line /><p>
    fringe of</p><empty-line /><p>
    Huffman</p><empty-line /><p>
    lazy</p><empty-line /><p>
    mapping over</p><empty-line /><p>
    red-black</p><empty-line /><p>
    represented as pairs</p><empty-line /><p>
    reversing at all levels</p><empty-line /><p>tree accumulation</p><empty-line /><p>tree-&gt;list...</p><empty-line /><p>tree-map</p><empty-line /><p>tree-recursive process</p><empty-line /><p>
    order of growth</p><empty-line /><p>trigonometric relations</p><empty-line /><p>true</p><empty-line /><p>true</p><empty-line /><p>true?</p><empty-line /><p>truncation error</p><empty-line /><p>truth maintenance</p><empty-line /><p>try-again</p><empty-line /><p>Turing machine</p><empty-line /><p>Turing, Alan M., [2]</p><empty-line /><p>Turner, David, [2], 
[3]</p><empty-line /><p>type field</p><empty-line /><p>type tag, [2]</p><empty-line /><p>
    two-level</p><empty-line /><p>
type(s)</p><empty-line /><p>
    cross-type operations</p><empty-line /><p>
    dispatching on</p><empty-line /><p>
    hierarchy in symbolic algebra</p><empty-line /><p>
    hierarchy of</p><empty-line /><p>
    lowering, [2]</p><empty-line /><p>
    multiple subtype and supertype</p><empty-line /><p>
    raising, [2]</p><empty-line /><p>
    subtype</p><empty-line /><p>
    supertype</p><empty-line /><p>
    tower of</p><empty-line /><p>type-inferencing mechanism</p><empty-line /><p>type-tag</p><empty-line /><p>
    using Scheme data types</p><empty-line /><p>typed pointer</p><empty-line /><p>typing input expressions</p><empty-line /><empty-line /><p>unbound variable</p><empty-line /><p>unev register</p><empty-line /><p>unification</p><empty-line /><p>
    discovery of algorithm</p><empty-line /><p>
    implementation</p><empty-line /><p>
    pattern matching vs., 
[2]</p><empty-line /><p>unify-match</p><empty-line /><p>union-set</p><empty-line /><p>
    binary-tree representation</p><empty-line /><p>
    ordered-list representation</p><empty-line /><p>
    unordered-list representation</p><empty-line /><p>unique (query language)</p><empty-line /><p>unique-pairs</p><empty-line /><p>unit square</p><empty-line /><p>univariate polynomial</p><empty-line /><p>universal machine</p><empty-line /><p>
    explicit-control evaluator as</p><empty-line /><p>
    general-purpose computer as</p><empty-line /><p>University of California at Berkeley</p><empty-line /><p>University of Edinburgh</p><empty-line /><p>University of Marseille</p><empty-line /><p>UNIX, [2]</p><empty-line /><p>unknown-expression-type</p><empty-line /><p>unknown-procedure-type</p><empty-line /><p>unordered-list representation of sets</p><empty-line /><p>
unspecified values</p><empty-line /><p>
    define</p><empty-line /><p>
    display</p><empty-line /><p>
    if without alternative</p><empty-line /><p>
    newline</p><empty-line /><p>
    set!</p><empty-line /><p>
    set-car!</p><empty-line /><p>
    set-cdr!</p><empty-line /><p>up-split</p><empty-line /><p>update-insts!</p><empty-line /><p>upper-bound</p><empty-line /><p>upward compatibility</p><empty-line /><p>user-initial-environment (MIT Scheme)</p><empty-line /><p>user-print</p><empty-line /><p>
    modified for compiled code</p><empty-line /><empty-line /><p>V operation on semaphore</p><empty-line /><p>val register</p><empty-line /><p>
value</p><empty-line /><p>
    of a combination</p><empty-line /><p>
    of an expression, 
<emphasis>see also</emphasis> unspecified values</p><empty-line /><p>value-proc</p><empty-line /><p>variable, <emphasis>see also</emphasis> local variable</p><empty-line /><p>
    bound</p><empty-line /><p>
    free</p><empty-line /><p>
    scope of, 
<emphasis>see also</emphasis> scope of a variable</p><empty-line /><p>
    unbound</p><empty-line /><p>
    value of, [2]</p><empty-line /><p>variable</p><empty-line /><p>variable-length code</p><empty-line /><p>variable?, [2]</p><empty-line /><p>vector (data structure)</p><empty-line /><p>
vector (mathematical)</p><empty-line /><p>
    operations on, 
[2]</p><empty-line /><p>
    in picture-language frame</p><empty-line /><p>
    represented as pair</p><empty-line /><p>
    represented as sequence</p><empty-line /><p>vector-ref (primitive procedure)</p><empty-line /><p>vector-set! (primitive procedure)</p><empty-line /><p>Venus</p><empty-line /><p>verbs</p><empty-line /><p>very high-level language</p><empty-line /><empty-line /><p>Wadler, Philip</p><empty-line /><p>Wadsworth, Christopher</p><empty-line /><p>Wagner, Eric G.</p><empty-line /><p>Walker, Francis Amasa</p><empty-line /><p>Wallis, John</p><empty-line /><p>Wand, Mitchell, [2]</p><empty-line /><p>Waters, Richard C.</p><empty-line /><p>weight</p><empty-line /><p>weight-leaf</p><empty-line /><p>Weyl, Hermann</p><empty-line /><p>
"what is" vs. "how to" description, <emphasis>see</emphasis> declarative vs. imperative knowledge</p><empty-line /><p>wheel (rule), 
[2]</p><empty-line /><p>width</p><empty-line /><p>width of an interval</p><empty-line /><p>Wilde, Oscar (Perlis's paraphrase of)</p><empty-line /><p>Wiles, Andrew</p><empty-line /><p>Winograd, Terry</p><empty-line /><p>Winston, Patrick Henry, 
[2]</p><empty-line /><p>wire, in digital circuit</p><empty-line /><p>Wisdom, Jack</p><empty-line /><p>Wise, David S.</p><empty-line /><p>wishful thinking, 
[2]</p><empty-line /><p>withdraw</p><empty-line /><p>
    problems in concurrent system</p><empty-line /><p>without-interrupts</p><empty-line /><p>world line of a particle, 
[2]</p><empty-line /><p>Wright, E. M.</p><empty-line /><p>Wright, Jesse B.</p><empty-line /><empty-line /><p>xcor-vect</p><empty-line /><p>Xerox Palo Alto Research Center, 
[2]</p><empty-line /><empty-line /><p><emphasis>Y</emphasis> operator</p><empty-line /><p>ycor-vect</p><empty-line /><p>Yochelson, Jerome C.</p><empty-line /><empty-line /><p>Zabih, Ramin</p><empty-line /><p>zero crossings of a signal, 
[2], [3]</p><empty-line /><p>zero test (generic)</p><empty-line /><p>
    for polynomials</p><empty-line /><p>Zetalisp</p><empty-line /><p>Zilles, Stephen N.</p><empty-line /><p>Zippel, Richard E.</p><empty-line />
</section>

</body><binary id="_209.jpg" content-type="image/jpeg">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
tuiIiIiIv//Z
</binary><binary id="_157.jpg" content-type="image/jpeg">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
fdW666p9bji1FSlqL7hJJPeSfXXYUpSv//Z
</binary><binary id="_191.jpg" content-type="image/jpeg">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
QrowqRAkIksBW0PN8oWcDO1XZQ5xkEjII7ggSdSeF8dC8tdHyF0nfE+Jx0OtlvpdTPG3HVx
u9Hdt/tbKuMstRmG2GGkNNNJCG20JCUoSBgAAdgB6q5O+Qo5mvRtMbI90cUo3RNvCEOKZWk
lRWrICHTuCmlKyd3+AuEdNbHYT9qiPW4IEJxhCo4QjYkNlIKcJwMDGOMcVzmqLDe5c5SrJL
eaTcWvDyXVz3kJg4KVB5ptKgCrCSkgEZOz+yXN1mwzFzIshPQ6bMSS5FYcMhTxeS2dhUSoB
W7cFJOc8pJyoEE7U+4M21hLz6JK0qVtAjxnH1ZwT9VtKiBx3xj+dIFwZuTCnmESUJSraRIj
OMKzgH6riUkjnvjH8q2qi2L7X1H+ZI/aR6tUpSlKUpSlKUqfcrk7GfYhQo6JM6QlbjbTjpa
QEIKQtSl7VYAK0jABJKhxjcU858xd/p+TNIsbuel5B6uz/Dv6qd2O27anPfA7VQjz2tJsMQ
bwm12+CpRbjSooEdgrIKylTZ/qiRuwdygopOSklKTuaWZdY03D6zS2FOpLwjrSUmMlaitLO
D2DYUEDgcIHA7CvXKy/k10pPQhE2BJkpbUtaEvXCSsJUs7lkZc4KjyT6z3rqqUqLYvtfUf5
kj9pHq1SlKUpSlKUpSp9ytrsl9ibCkIjTo6VttuuNF1BQspK0qRuTkEoScgggpHONwVq+K1
V7GtH/lXf/nqZqONdXbFJuNyfZadh7ZMKBEWooXIQoKaStZwXty0pSEBKPrkYUoIUOtpSlK
VFsX2vqP8AMkftI9WqUpSlKUpSlKUqLf5d1jzLTHtj8Nnx0lbDipMZTuMNLcBG1xH+7Ix/i
B4xz9s2u4SH23L1OjTG2FBxpmNFUwjeDkKWFOL3lJAKRkAHnBISU16nz2b04+k264QY7W3B
RIhLeUVZPOUuo4xjjH8a3GQ6lhsPrQt0JAcWhBSlSsckAk4GfVk/5mslKVFsX2vqP8yR+0j
1apSlKUpSlKUpSot9+19OfmS/2kirVKUpSleC6/11qXTHyg3qFZrl4WO46y6pHQbXlRYaBO
VJJ7JH8qged3Xft33Rj4Ked3Xft33Rj4Ked3Xft33Rj4Ked3Xft33Rj4Ked3Xft33Rj4Ked
3Xft33Rj4Ked3Xft33Rj4Ked3Xft33Rj4Ked3Xft33Rj4Ked3Xft33Rj4Ked3Xft33Rj4Ke
d3Xft33Rj4Ked3Xft33Rj4Ked3Xft33Rj4Ked3Xft33Rj4Kv6A11qXU/yg2WFebl4qO2686
lHQbRhQYdAOUpB7KP8696pSlf/9k=
</binary><binary id="_112.jpg" content-type="image/jpeg">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
9k=
</binary><binary id="_167.jpg" content-type="image/jpeg">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
VTYXzwSsliluFc+ORjg5r2mqlIII7QR81dRf/9k=
</binary><binary id="_102.jpg" content-type="image/jpeg">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
</binary><binary id="_203.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAALAJoBAREA/8QAGg
AAAgMBAQAAAAAAAAAAAAAABAUAAwYCB//EADEQAAICAQMCAwcDBAMAAAAAAAECAwQRAAUSE
yEGMUEUFRYiNlFhMnWzByMzkVSV0//aAAgBAQAAPwD0z4r27/jbv/01v/y0Nu0UM+/eGNyQ
2Q0ltlCO8iKFNWw3eJiAG/JXkPL8abbvukOzbXNuFheUUPHkOrHH5sB+qRlUefqw/wB9tZ+
l/UXar16CpHDh55VjU+8aLd2OB2WwWPn5AE/YHRvjupHb8D7z1GmXo0Z5V6Uzx5IjbAbiRy
X7qcg+o08mlWCCSZw5WNSxCIXYgDPZVBJP4AydZav4sq/FV8Mm7mv7DW4Re67Z4tzn5Hh08
jI4jOO/HGTxOHO+7dBuNeA3B1adaUz2KxgMy2VEbgIUGeWGZXAwe6DAzginwhTej4YqQNHN
EnzvBDOWMkELOzRRty7hkQqpGTgrjJxnSyx4sq/FVAKm7iv7DZ5xe67Y5Nzg4nh08nA5DOO
3LGRyGdBZ3jbaNGK7euw0a82OD3G6HcjIBD4IbAPY9+x7dtLPB281d326z0NzhvSxXrXLhO
JGRDYl6ecE4UoBx9MAY7aCseLKvxVQCpu4r+w2ecXuu2OTc4OJ4dPJwOQzjtyxkchkrxbOt
nYKyxPZ6luePoUxAQbxAMhryBlyiuqsGLYCjPLtlTX4JlQV9wqtWh221FZDS7RE6su3ho04
qCvylXwZMqAMuw8w2qbHiyr8VUAqbuK/sNnnF7rtjk3ODieHTycDkM47csZHIZ0cl5UpQ2k
r2ZVmaJQiwkOA7KuWVsFQvLLZ7gA9u2u57PQmrR9CaT2iUx8o0ysfyM3Jz6L8uM/dlHrqJZ
5XpavQmHTiSTqlP7bciw4g+rDhkj0DL99X6mle5+Htv3e1DZtm51YP8RhvTwhDhhkBHA5YZ
hnzwcZxppqaC3baae90WpXhM1d880isSRcwQQQxRgSpBOQex+2rqdSOjVStC0zImcGaZ5X7
nPdnJY+fqdLKv1xun7bT/ktaYX9vh3KBYZ3soqtyBr2ZIGzgj9UbKSO/lnH+tSht1XbIGhq
q4Dtzd5JWkeRsAZZ2JZjgAZJOAAPIDS+19cbX+23P5KunWl+07HR2RJUo+0hZWLss1uWYci
SxI5scEliSRjJPfOhbX1xtf7bc/kq6N3XaKG9VVrbhB1UjlWaMh2R43U5VlZSGVh9wQe5++
u6G3VdsgaGqrgO3N3klaR5GwBlnYlmOABkk4AA8gNL7X1xtf7bc/kq6damppRN4aoTzyTPY
3QNIxYhN2tIoJOeyrIAB+AMDX//Z
</binary><binary id="_159.jpg" content-type="image/jpeg">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
==
</binary><binary id="_119.jpg" content-type="image/jpeg">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
E/wDMr/8Aq5ev/9k=
</binary><binary id="_64.jpg" content-type="image/jpeg">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
9ZJ7azClK//9k=
</binary><binary id="_114.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCACMAYwBAREA/8QAGg
ABAAMBAQEAAAAAAAAAAAAAAAQFBgMCB//EADsQAAIBBAEDAQQIBgAGAwEAAAECAwAEBRESB
hMhIhQWMUEVIzJRVHWV0wc1NmGztCQzQlJxkTRigXL/2gAIAQEAAD8A+zUpSlKUpSlKUpSl
KUpSlKUpXC9s4MhY3FldR9y3uYmilTZHJWGiNjyPB+VY+x6PwtxfZ0WuNsbO5tMpC9pPHaJ
uBkgt5FA1o8S29gEbDN5BO68W3VmffH5i7dMdKmHxs7XDxxSKPbo3lBjHrPoCxgnZDEOjaX
loV+W616zxXUFr0uMdi73L3cHtMUtuGEZXtuTHwd10eaN6+f2fPHfirq46i6hfK4T2e2sbb
G5CC3lmmmDTIrM31kazRtxDaaMIWXi5J029KdhSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlK
UpSlKhPi7VLq4yFpaWcOTniKG8NuGc+BrkRpmUcV8ch8B5FVPuxev0lkcTPlknyGUV1usg9
roSFlEe+0rAAiNVUaIG1BIPncyHprCtio7KfAYtIiwmktUt0aFZeOiwBUbOvHLQOvu+Fd36
fwsk9tO+IsWltFRLeQ2yFoVU7UIdekA/AD4VYUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSl
KUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpXzzo28lyOZAxVzc3Nta3d2L26nzBuUeDu
SLAiRGRyCfQeZVDqM6LBvNnh+qjl557S/ubYRHHtc3gtw8LYryB2ZpeR+s0X8jtsvaY8Rsa
i2HVdrZdDXt1ZZeG7lsr6WIPJOLpkR7tkiLlpV9JQjTM4GhvZAqmk/ijkn6fa5s58QbsZtM
cXuV7cSRtGT3HCTPpeat6wxUqpIr6HhLmW8xwuZMnY5JZGJjuLGMpEVHjX232QQfO/7a8VY
UpSlUt1/XGL/Lbz/Ja1dUpSsl1xjo8leYCH2CG4lF831lxjHvIokMTqeYXWlLmP4sBsBvgp
1nzfdVY6zx1jbpeQRQ+1pctbWkqqJRKCiIDbT6hVG1GR4ZR/0leJs8hmc+1qBdSZHH3AxqT
xHD4uS6SadjJtWEkRK6CxkIxQjmQWPghhri6sM/fS3d1nbhry+hdYYsSUt5RJBCvNmMW41Q
72DICoj88m3yhS9QdSR9ViCWPOxYxrm6jlkisjOIUUOsbKBaDe24MpDyDQ9W914fMdW2+Is
5Le4zV3e3eLaS4jmxC6tpw8QbgBHGOQUXBVGbTFU+PJeXeyyXUE+Zygtsxmri1xzWMyQ3WM
iheWF5D3/T2g7gIj64hSSCAG0CWVvTnulOp4MhispdkTyrio7vDvzHKDUbIFj8AP3NMfUoK
8iCRuw6tz2VS1sbnB2+XKSxTuwgtmRyUKhUZXtpWVm23HYQeDsnxVQma6pucrhhd3max+Pf
DRyXr2+EMjvecmV08wtwOxv7OtDx9oGvo0MbRQRxvM8zIoUyOAGcgfE8QBs/2AH9q6UpSlK
UpSlKUpSlKUpSlKUpSlKUpSqW6/rjF/lt5/ktauqUpSlKUpUWwxmPxUDQY6xtrKJm5mO3iW
NS2gN6UDzoDz/apVKUpSlKUpSlKUpSlKVS9WF/oRUSaaHu31nEzQytG/F7mNWAZSCNqSPB+
dPdTHficv+s3f7tPdTHficv8ArN3+7T3Ux34nL/rN3+7T3Ux34nL/AKzd/u091Md+Jy/6zd
/u091Md+Jy/wCs3f7tPdTHficv+s3f7tPdTHficv8ArN3+7T3Ux34nL/rN3+7T3Ux34nL/A
Kzd/u091Md+Jy/6zd/u091Md+Jy/wCs3f7tPdTHficv+s3f7tPdTHficv8ArN3+7T3Ux34n
L/rN3+7T3Ux34nL/AKzd/u1U3PTVgOscbCLjKcXx92xJy10W2JLcDTdzYHqOwDo+N/Aatvd
THficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdT
Hficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTH
ficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTHf
icv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tPdTHficv+s3f7tXVKUpS
lKUpSqXqv+UQfmVh/txVdUpSlKUpSlKUpSqW6/rjF/lt5/ktauqUpSlKUpSlKUpSlKVV3nU
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
6j4/ufvqVSlKUpSv/9k=
</binary><binary id="_82.jpg" content-type="image/jpeg">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
</binary><binary id="_205.jpg" content-type="image/jpeg">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
V9H4j7GX8Rdm0Z3HwPhtfy2q0iIiIi//2Q==
</binary><binary id="_161.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAPAF8BAREA/8QAGQ
AAAwEBAQAAAAAAAAAAAAAABAUGAwAC/8QALRAAAgICAQQABQEJAAAAAAAAAQIDBAUREgAGE
yEUIjEyQVEVFiNCVmGBlNL/2gAIAQEAAD8Ao8F3TVoTl58jZu2lwLZDM1mmaVq08RXkqqx4
xMS8oaMaA4J6X8tqva+VvYc28lnMjVztnU5eCywhpv6IiWEMY3RdcTy2W+Y79+qANHhcPEs
0ly0lWJIzIY3sTSa0vIhAWZj9SQP1PQsPctCeeOFK+UDSMFBfE2kUEnXtmjAA/uTodY90xZ
WSLHvijeBit8rHwDwrKY/FIPpMeDDmU9Hf6j2AehTcTOSYnFGSZ680ViS6JwoebwMsTwyBd
L7kk23H5T4yuir9Ju8Lko7zSEQZ2WGniHsmHGWLKpamZysUTiEHh9kh5+t+t+l0bDE4o4kW
oxcs2Ipp/JEtiZ5WhXgilObsxI5KzfX+bXQv759q/wBS4j/ei/66KyPLI4Rnx9l2WVUkV6r
AtNHsMVRuSgF12ocMNcgwI11MYRMnawEkWTuvSp08pZNlZrsi2YqgDsiSyhiQwYxtsPoxhf
ZB9jWsnPgOxKPdryzZF8b5FiadwJLlOWXjEGbXpivw8hYry2mjrk3VHV7UrxwWIchkL2XWe
p8ETedCyQkEMqsiqdtscmJJbiuz8o690u3DX8C3MzkcpDW4mKK6YioZftdiqKzsNbHIn3pv
uAIZ3KVXIVXq3a0NqvJrnFNGHRtHY2D6PsA/46Xw9p9t1p454O3sXFLEweORKUasjA7BBA9
EH89b5bEjKiqRds0pak/nimrhCwbg6EadWBHF2/HSi/jE7f8A2fmYZ5vh8X8S2QLcS0sM38
SWQjX3CVUkIXXoOFB9L0bjO2YcZ3Fk83HfuTTZTj54pfH4xw9Jx0gI4rsD37B97Pvp113S/
NYeLN0krS2bNYxTxzxy13CsrowZTogqw2B6YEfnWwCMI8C8NSSODMXobM8/nsXFWEyzNxCA
EGMoBxVB8qj7R+Sdqc/g0y1WHtK1euWEyfOzbtSuok8cRT0mlCK3NoRoIFKhyfmOz//Z
</binary><binary id="_130.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAPAFYBAREA/8QAGQ
AAAwEBAQAAAAAAAAAAAAAAAwUGBAAC/8QAKhAAAgICAQMEAQMFAAAAAAAAAQIDBAUREgAGI
RMUIjFBB1FhFSMyQpH/2gAIAQEAAD8AvJs3k7HcmZoU8ti6tXEQQSzvaoyOYy6uxDN6qDQV
Q2wNabX+p2z7Wy1jOdt08lahSKWdST6YcI4DEB1DgMFcAMNjemH399M45opXkSOVHaFuEiq
wJRtBtH9jpgdfsR+/ROlHcGSyGMiqS069aSKS3BBO8srBkWSaOPaqF+R05+2XXg/L667JZL
IU85iasdesaV2doZJmlb1Qwhlk0E461/bHy5H8jj+ej3+4MLip1gyOXo0pWXmI7FlI2K7I3
piPGwfP8dInxQm/UmK9Wj9A14nktWPayo1jlGqLD6gRY3QaV/kztyGgFAPVBlcj/TKcdj0v
V52YIOPLjr1ZUj39fjnvX51rx1t6mKWW7uk9vWsYPEe79sstgDLMvpE+ACoiYjkQ+tFh8G+
R0N5sL2e093LXe7cThb9m5bM8MoQTtHHxVViJaNfChBo/nZJAP2Dtdcda7+ztnFWqwWopr3
IoY3R5pmlZuUo4qhKFXRSAzEElmOx1ZxmUvIJERVDajKuSWXQ8kaGjvY158AHfnQJ0l7mqZ
W/Tr18ZBTk42YZ5Gs2Wi16UqSADjG298CN+NeD56Dl62ft3MRYq0cc3spfcSrLekXbmKSMo
uoTtR6mwx0TrXEdeMlicnc7yxeV9jRkq41ZUid7siygyhAz8BGRsKrgKW0eQO111R9Tnc3b
KZWJZoWvNO1uq7omRmjQIs0ZchA4UEIrHYG9jY+WunNDHw42BoYHsurNyJsWZJ23oD/KRmI
Hj63r/AL1lxmJ9jlczedIeeRspIroPnwWGNArHX4ZXIHkfL+T1/9k=
</binary><binary id="_116.jpg" content-type="image/jpeg">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
</binary><binary id="_165.jpg" content-type="image/jpeg">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
Q==
</binary><binary id="_92.jpg" content-type="image/jpeg">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
</binary><binary id="_117.jpg" content-type="image/jpeg">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
8a8V71Slf/Z
</binary><binary id="_7.jpg" content-type="image/jpeg">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
vUaRyTsMi8eK8F8e+idD8/wD/2Q==
</binary><binary id="_118.jpg" content-type="image/jpeg">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
5xJJ/cnZUiIiIiIiIiIiIiIiIiIi//9k=
</binary><binary id="_149.jpg" content-type="image/jpeg">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
</binary><binary id="_103.jpg" content-type="image/jpeg">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
RCiuU2nJxjFRTetedI/9k=
</binary><binary id="_190.jpg" content-type="image/jpeg">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
=
</binary><binary id="_200.jpg" content-type="image/jpeg">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
p6//9k=
</binary><binary id="_164.jpg" content-type="image/jpeg">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
p8Z1DfeLXFw4xD4MuQlEsin32IomKsp9tmVSDs68DltWGGt7KdruR3vL914Pe3CoZmTYPDa
qAq+B6VAG/JGySaFKUpSlaWRxUGR7bu80FxDvs3FvIUkj3r5jwy7CkqwKkqNg6rS7vUON9M
ltDmLdf9pC4guSPYAo31bt7EtzjHk6QaAL6dyP8Aunl//VtP+fT4bP5H0X09njrZvTJDZPJ
LK4/4Zzw4b9jpCQNkMCQVp2dnBYWqW1tHwiTegSWJJOyST5ZiSSSdkkkkkms9fP8A8tmO+N
/J5Lcd3h8BcxT8eO+eyY9e/j+c3vz7a+dclN1dazY/r/NqIT9KWOPhSETg6eW3KsobXqZNs
SNb9B9vOvo35N8d9Gfk8wtv3e7zthPy48dd0mTXv8uet/PW/FdPSlKUpSlKUpSlKUpSlKUp
SlKUpSlKUpSlKUpWrk7CLK4q7x07OsV3A8EjIQGCspUkb350a/LnTtldZDMQdJT20yJe5KD
4pVjImi7fNW8H20sjk7Hjj+41+raUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUr5L0/0p
8N+XzL3RivBb28T3sUrL6GeYAEb1ort5gNefR7nia+tUpSlKUpSlKUpSlKUpSlKUpSlKUpS
lKUpSlKUrHJKsbxowcmVuK8ULAHRPkgekaB8nQ3oe5ArwlnAl9LerHq4miSJ32fKoWKjXt4
Lt/5/wBlZ6UpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKV8yw2ZxGPvrGxgyd4s1r1JdWt3
E887r9cbkRK3IkPtkjO/OjsnRZifYubCee1muctlA0nU91jbsJkbpFBJnMUYVXAA/mPKjQ+
Z96mZfIJaXGPgzvVOUxGHDZKOCezupjcSSx3hQLI2nLKI+PEnz4bZ9t/VrLufAwd7vd3tLz
7/Dub155cPTy+/j437eKz0pSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlK//Z
</binary><binary id="_95.jpg" content-type="image/jpeg">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
</binary><binary id="_120.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAOAEwBAREA/8QAGQ
ABAAMBAQAAAAAAAAAAAAAABQACBgQH/8QAJxAAAgICAQQBBQADAAAAAAAAAQIDBAUREgYTI
TEAFCIyQWEVUpH/2gAIAQEAAD8A9D6L6ml6mxSWZ3xZl7ETyJRumZkZlJIdCo7Z2PW2/Y34
89MmbwGbo3adXL07u60hljpvHZkCa0SIwG5e/RUgkgaO9fObofHyUMJMzRpXjtW5Z4accc0
aVEJ121WUKwGwW/FRtzpQNfFpcj2s5Vxna39RWmn7nL8e20S61rzvu+9+OP8AfEy9qeli5r
FYQh047edgscSlgGkbZG1RSXI2NhdbG9/CenOqosh0/ZyeTs1oIqtuau13QhrTqsnFZIyzN
9rAqN8j92x8ZoZPH5WBp8derXYlbgZK8qyKG0Drak+dEeP78pLke1nKuM7W/qK00/c5fj22
iXWted933vxx/viZaXJQ48via0Nm33Ywscz8EKl1Dkt+tIWO9H16PomVsp1Pa7pjwuIKRym
MOMw7K5Xw2tQHWm5KQdEFT49E0xtDqEz1b+WWi92jj5Ky9qwxW1I5jJdj217Y3EPADfmf9d
G/SWIu4eHILdqU4HuXprjPWtPN3Gkck7DIvHivBfHvROh+9B8x9npqgOscbCLGU4vj7bEnL
Wi2xJXA03c2B9x2AdHxv0NOZStlY8XBDgp4Vmgli2Ljs3diVhyQyHkQzKNcyGPv9nkCbuEz
U3TGZoww0Vs5hpQYDacQ1Fki4MVYR7YlgZCOK7Mjed+Wdw9Z6WHq1Hqw1fp4hEsMM7TIir4
UB2VSftA9j/vv5nLPTVAdY42EWMpxfH22JOWtFtiSuBpu5sD7jsA6Pjfoa1kMSwQRwoXKxq
FBdy7EAa8sxJJ/pOz8P6axP+C6ZxuLKQq9WskcnZGkZwBzYeBvbbO9bO9n5//Z
</binary><binary id="_188.jpg" content-type="image/jpeg">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
</binary><binary id="_83.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCABaALQBAREA/8QAGw
AAAgMBAQEAAAAAAAAAAAAABAYCAwUBBwD/xAA5EAABAwMDAgQDBwMEAgMAAAABAgMRAAQhB
RIxBkETIlFhcYGRBzJCobHB8BQj0RVSU3IkNILh8f/aAAgBAQAAPwDt1cuPGPEkT3oVSoxm
exmKHWSFAqOScE0O4pKVDygyJioLBKSqfKTyc1Q58ZEZIzVSgGxvWoATAJUKFdvmUYEqjGE
81Ub24dIDNuVfEz+9EMt3bqQXGlJ3f7BJHyotdgthCXHHSiTA3LJPwippe0pJ2XF6lC4yFN
KE1p2bOgXSw2q4BVH4C5k/AJNa56T0F3IvVsk9isfvFC3H2fN3CVK07VmnlchC45+ImsK+6
R1qxQXHLFS0AxubIX+QM1huoUlRSobSDwQRUUgCTtE1LgAwTGc13gnt/mupOZElPFTS6Uxg
g+1GN6iQnJWT3g1vLcgciDxFVrcjPBHfih1LkmfKR6Go4SSQTBxXHFNISoqhH/y/asa81q3
aAaYO5SSRM4FZzl4LpUKWn4E+UfQ0Tb2bywVstpVHdCB8vvKFWli6dchbTgIGIeiD8AaPtt
FuVKSpx1SUjkKdUI/nxpk03S2xgPpTuH4rlwj6boNb6OnmX2h4mm2d4n/kWhO75BI/U0M30
zpLF1vd07wlEyPDTiByY3HFbNnZ22wlvYttQxzuNcutCZWkOIdDah+ICDzxNDzqVuk7li5Z
zML3GsDUdNsNUeAWlbTisbkGSD86XtX6Wu9NQp9qLpgTK0DKP+w7VixB5r4p5AJiaiMjHYc
1xeEQTE/WuErSYCVfKabnFgk4IhPBHt2+lDLSSRnH6VUoEEAEjk4/SuKWIlSoETJxWHqeoI
ugLdtPkHcmg0aW04BmJ70UnpgOAFK895FWDox5WUPJj1OKJT0LqKh/7Kce5xRLXQOrJQfCv
ikTkBZGflV6Oh+oWVb2r5YWO/iqBq61HU2jOpU9dXCwg8rPi+vE/tTna6/e3jCmb23bdbc8
oVEp+YPI+vagnnnLJ/x7TxbdsffYI3pQR2R3CTzHH6A2w6naWhSrl1LRbMGDKOByfX51oXT
VhqAStl0Bac+VXI+ANUN2O9Xhl5UHsAFR6H+CjmbUoUoeIpSoG7emNwpU6t6SYVaOanpyQl
afM42nhWeRXn5POCDxXYk5mKrVG3iJr7cR+KPnTWsGASoR7CKpUYEFMT7djUCZI3SMmszVb
ptlkplRUT5QTwPWse3abWvc66E+20maZbLTGikHxTkSne3z8P53ouBbgeZCSOwJg45yMVoW
oSRKVJIMbR8u9aqGXFFOyOOUpyPyo+3KxEwkJPAEzgZo1K1Ngk9h3wfpUSGnkEvNpOc4kyc
VBu2abTtQkJSTJECKAvnbTxfCWjcSPuEc5wMUPcaY2ykXPh/2FYlQGDPBkfr7c1axpNy0oO
WSiQcEKJkd5z/jvRlrfah/VFlyx2FI+/4gkj14zWk228VBTjijHEECauWC2SNvlXM+gry7q
+wRZ6oVtoSlDo3Y4ml2TyOKg5BO4EH4d64QFGSRj3puUnJTk9/Wq1IC0wQQrM85qQZlOCrH
pSbrzzzeoLbdZLZHbmgmL4NGS0pUccDPv7Y4osa6shJ8yVAxOCIj0rRuV6vflh0Nu3CdsBS
ATPJ/erBr72nIW3cWtyhyPKlQEDEd/lVrX2g3TaCBa7jGCV8fl+9Fsdc62+zNrpwCYhawkk
GOc/zvWpY9Z6mhgPXGh3XhkHappnyqPt+frTBo/V+l6qQ352VqO0JfSEz7Ayc1tpQ2WyRJI
gCDSZ1ih+1vEXtqFygZIzHb+etMXT2tWmoaKlbSQgHhucgzkR/O9XoJtdyrVSXG1CUBSife
KiOo7crLK1OsuiJBSDI9fUii275D6DDzbmPwGCJ9qDcD43EOuAHgK9PTFLXUds4tlCiUrSP
ypOuWtowAIMHOfnQxUeIqCjJymKdlRO1UjvioZA3YJNTZACvKTgciljq54XC0JbSiEGAocm
lxVg6nJSR6069GdAM6xtu9RC/AwUtJJSV88n6cV6ta6NYabahm2tm0hIgAJ7D3rA13ou11v
+4UJQuMlMifavLtf6VOjXxZIdS2T5XFjynnE/Kq7HQbp64bFn/UIKspWlQJHzBHrT3a9P6q
ptpK7i7C2mvvEpKvdO4JCs/9qleaAGQh1Vow+8idzjaSkqHwM5nHc8Ga1NGurgW4acZcR5Q
BuAjjAgVdq1kzqNsthYJWpPJMbvekS2s9R0O7VaICv7hJTA8pIzmeKOb6lu9KWlN6w6wV93
EQPkfr2rUa6j0y8Sg3fhqKiCCqUn4gj0rXb1NtSJaabcbT/uUD9O9Re1ZhtG9Vs4mB5SIWP
pzWUvWmNRYct/DTIGcKSB8c4pKvmEWzx2OBSSTxmM+tCTKYkT6VEmCRIpzLnlk4Hv8Az+TU
goJ4Mnnn/NQuG3bhots3JZUcTtk0pa1p7+n+G+t4vBRglQ4P/wCUd0zo3+sXIVck+AmJTP3
q9h0m3atrVDbKQEJSEgDtRVw9sIEGQM0JcXt3bNFxFql4ASUJchR9hIgn5is1jWdA6nSbUr
QVp8xbeQUqBGO/xrOd6EtrNS3rEvISMpS25j3Edx8TXydUbsQW37q5Kwn7rzJSARgesfnVL
PUgW4pG5K4VG5R547fz51qN6o06hTgIVA+6AfWq13SHFQgHcrHzrFvG7g37SlMFYTMKPAwe
frQGu251rwrd5YZQyCrcOB24+MfSlS/0Zi2tlXCNQHjpVHgpTlWeecVLR+pXtNfLD1s5dpJ
EBtwpP0g/tTWxfr1B5LLWnu28yVKWsK2j6flWujwNOtHkpSlauV7kgTj2FIt+lHjOOsp2JX
nYcj5Gs8cmTz3FcK9piac1oJQCPvTUQFAeUE9+akknGFA+hHFRv7VGpae4wuMiUkic+opFt
dUvbBzdbPqR2icGmKx+0DWG0eEhRK+Ad0D9Kg1rHUWtX5bd1R1hJOQ0soP5Zn/FOFjpzKVN
qXqWpkiJm9WUrPuJ/KtC50LQ7hKlG38N9MnxUSFA5/FV+muXehWZX4r97ZIJUtTigVtJ/cd
/b35rfKbbUWEOANuJVkKKRml/UembdX9xtKAuRiMfWvrHSUNp8w2pPv8ApRP+nNNJCkQrg+
bJFUvMKdkkmO4NIGu3NojXlsWt4ll+QV+KSUGBhPtWhpdnpwvhc3S9PhYGEhSxPslRgfQ1q
alquhNEWyFPOPJHkbSSgfMjtissdSItmFpbt9r3aB90enwrHc1y6Ljrn/KIWndIrKdccWvP
HMDtUMnG0CRUcdwKeXG1gmSfb0qBQZnAgdu9RGPKoGZxVzfl5VniZrze7aLN082FA7FqGPY
1KyWllzepS44OwgH8waZtJvNKSsBx68ZKskqUg/P7k0229np7yEFjVnEmDtCwkxj2Aq93Sd
ZQn/x9UtnFGYSq3UmZHrvP6GuWeo67ph23dnbuyQCppwx8wQK1rZ5GnpD1upaWliV26s+H7
g9hRN1rLJbxMKHpMUENRCZUiM5INDu6yQTlsTwT29qoutdWGiUJSpf4Y4JmkK86bddD12dy
1qJUokYJ71q9EXKNKvBarQhBX5leN5VE0y6zZaB439fdW4KnMw24QfqKT9Wctnnz/SsqSic
KWSSfnNZy0J+6BnvjioFAJic1Et4mSSKipAB5r0BTYg4I/SqFslRJiTODVKkKWSdoJHHvUg
kDbuORgjj+c0tdVaE6Ff6jbt7kkS8lPIj8UenrWLYX7FuSS32GaZ9I17SHlkXlvJJx3AmK2
grp1Y8RCkpCRiVAbZopGs6Jp7E/1ykgdyZkgf8A1Qtx1to10lVu5eNqbV2cZUQT2z2j1rNX
rrtpv/prxh5gmUoU+lSh7AzJHMSPrzQSOpru+um7Zu2CnnVhpCAYKlEwB9abWPs/6guXSm+
1a0ZbjBY3OE+0EJH51uWH2eaZbFC7q5uLxxIzuUEIn2AyPrTBb6NpdskBuzYATgFSQo/U5r
up6zpuiWpudQu2rZoHbKjyfQDuccCvFOqeo9J6g6tXe26FJtw2lvc4mN5BPmjsOKiGm9oLZ
EHMjtXC2Ugg/SqiiSf0NQLSR5QDPtUVJjABx3Br5DbikyEKV7ivQSgRkwPjVTyfKTEkVQps
mZHl9agtvYDtECfzrsJbQVunalIJKlYA9zSP1LrelurWxZ2Vu6snzP7BJPsRk0r+IZqW8kS
FEe018l1c5M/GmbppOh6glVnqJ/p7heEPboT7TmiNQ6W1LSXVlDTb7XZaSMj4UV9nK2Het2
37xSGUWrK3EhZCRujbn5KNep3vXnTFggKd1q1UCYAZX4p+iZpW1L7aNNZWpGnaa9dRje6oN
pPuOT9YpT1H7Weqb0jwX2LFMHDDQJPxKp/KKU7u+vNQd8a8uXrhw/jecKj9TQ0krEZjmtXT
dVXYq2LG5skc8j4UytONPth1paVTmRkV8pPrJx9aqW2PvAYqnZJgCPeuhAGCDPxp/Xgg94q
nuB23HFRRl4Tn+GqpJWiT+IftST1o+8HC0HVhv/ZuMfSk7vXO1dFSTUoz86Kc1K/U0GTe3B
aTwguq2j5TQskiSZrh5r4VYj7iqiuus/vUu9aGirWm+G1REjsabFZbXOeP0qp0CU4H8NDHC
zHr+9SAlSpzn9q//9k=
</binary><binary id="_115.jpg" content-type="image/jpeg">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
TpWqv9mtH8q7/x6dK1V/s1o/lXf+PTpWqv9mtH8q7/AMenStVf7NaP5V3/AI9Olaq/2a0fy
rv/AB64F3vUa5W+NcbVBaanPqYDkeet1SFBpbmdqmU5GGyPH21u0pSlKUpSlKUpWL2z0r5l
tHxzXzU7Z6V8y2j45r5qds9K+ZbR8c181O2elfMto+Oa+anbPSvmW0fHNfNTtnpXzLaPjmv
mp2z0r5ltHxzXzU7Z6V8y2j45r5qds9K+ZbR8c181O2elfMto+Oa+anbPSvmW0fHNfNTtnp
XzLaPjmvmp2z0r5ltHxzXzU7Z6V8y2j45r5qds9K+ZbR8c181O2elfMto+Oa+anbPSvmW0f
HNfNTtnpXzLaPjmvmp2z0r5ltHxzXzU7Z6V8y2j45r5qds9K+ZbR8c181Q6XmxbhN1DKhSW
ZUdy5J2OsuBaFYixwcEcjzBH+KpXXXCrZqJu19CZdaXOYhcXiPpUFu7Dj/scPcEr3beJkge
w8qyZGtpUg2K/rSiJaXFS30x2J6XH5LTcd5WVthAAI2jkHCEqUAoZwU6dovF0uOsbeZio0Z
qRZnZCYUW4CSkZcZ2uKw2nngqAUFKScHbjmVbmo7q/ZLFJuMWD095nbsjB0Nl0lQTgEg97n
yABKjgAZIrJtOr5dxlR2XrSiOHLguC4S86FIUI3HSoIcaQogjIOQnHIjcDWfF1Lcp96tcyA
qGvrONLZMJ244jLVGfCQ40sNEqUUqWeQGUgE/Zr02nL0jUNijXRDPB425Kmw4lwJUlRQoBa
SQpO5JwoeIwfbWHJ1rcIuo12tdmjFpEtMcvpnK3bSuMkK2cLxxLbON3sUM8gTdiaqdeftDD
8OM07cJcuI42mWVKbUwXAVIBQN6SWuZ7uNyeRzVnTzszj3iJLnvTuhzg0068htK9pYZcwdi
Uj7S1eyu9Q3xVkYhhmMiRJnS0RGEOPhlG9QJypZzgYSrwBJOAASa84xe7zGsOq55WzLegzn
isIn7kx0JjNqUlpfBIKkqyAlSAM53EnJVp6u1a/pNTL71uZegOtO/wDUqmBspeQ0txLe0pO
d+zaCD4nw8N3F2uao7emLhfkxrSrrBSn0LlBSGSYsgAFwhIJ5gfhk4BPidDtnpXzLaPjmvm
p2z0r5ltHxzXzU7Z6V8y2j45r5qds9K+ZbR8c181O2elfMto+Oa+anbPSvmW0fHNfNTtnpX
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
CiN6sJTnakFZA5AE+FIesbjOZQhmzMpmLuRghp6Q60jlH4+8lbIWOQxgo/XOK9SyXVMNl9C
EOlILiELKkpVjmASBkZ9uB/8AArJi/fi6ftsP+yVW1SlK8LOud9e1a7Dt064ngXeO0qM3AQ
qMIvBacdK3lIG1XeX/AKyr7ICeYI9AzqeK9eGreIkxKJDrzLEwtgsuutZ4jYIJUlQ2r+0lI
OxWCeWck64bsmjrJdbuxJkqmW9D7z7XBQnfw0qUO+tA3K3EpQnJO1WByrcYvRk3mTbmbZMU
iK6GnpeWg0lRbS5jBXvPJaRyT4n/ADWpSlYus/uPfv22R/WqtqlKUpSlKUpSlKUpSlKUpSl
KxdGfcew/tsf+tNaFyt0W7W5+3zUrXGkJ2OoQ6psqT7RlJBwfAjPMZB5GqUvS9nnLQ5Kirc
cREXCLhfcC3GFjCkLUFZWPb3iSDzHPnXDmkbK9FVHfjPP5dQ6HnpTrjyFIJKCl1SitO0lWM
KGNyv8A3HJekbK5wuJGecLe/KlynVKeC9u4Okqy6khtAIXuGEgYwMVCzoewMMqZbZmBCmmm
sG4yDtS0sLbCcr7u1QynGMZOPE541Hpxye0s29lAdefMhaxOeiuoe4QaS6hxAVghA27Skg5
yfAhVK0aHcdsiYmqp0m5voU+htQmvBSI7hTlpbidhdB2gkqA/ADAFazmkLE9FVFdg746oKI
CmlOrKCygkoGN2NySSQv7QzyNcDRtlAXhM7ct9MguG5ySviBBbCgvibgdiik4PMYB8BjdrF
i/fi6ftsP8AslVtUpSs+3WkW6bcZQmyZBuD4fWh0I2tqCQjCdqQcbUoHMn7I9pJMDGnY7Fx
RKEmSppp9ySzEUUcJp5zdvWCE7yTxHOSlEDecAYTjMe0DEet0aELxdG0x7eu270raJcjrxl
JBbKQcJSNyQFEAZJwK1rdZTbrhKli5zH+l7VPNOhrYpwIQ3xO6gEKKWxkZ28zgDljUpSsXW
f3Hv37bI/rVW1SlKUpSlKUpSlKUpSlKUpSlYujPuPYf22P/WmtqlKUpSlKVixfvxdP22H/A
GSq2qUpSlKUpSsXWf3Hv37bI/rVW1SlKUpSlKxevbj5Tu/vYnr069uPlO7+9ievTr24+U7v
72J69Ovbj5Tu/vYnr069uPlO7+9ievTr24+U7v72J69Ovbj5Tu/vYnr069uPlO7+9ievTr2
4+U7v72J69Ovbj5Tu/vYnr069uPlO7+9ievTr24+U7v72J69Ovbj5Tu/vYnr069uPlO7+9i
evTr24+U7v72J69Ovbj5Tu/vYnr069uPlO7+9ievWfp+bdrVpy2W5/St0U7EiNMOKQ9EKSp
KAkkZeHLIrQ69uPlO7+9ievTr24+U7v72J69Ovbj5Tu/vYnr069uPlO7+9ievTr24+U7v72
J69Ovbj5Tu/vYnr069uPlO7+9ievTr24+U7v72J69Ovbj5Tu/vYnr069uPlO7+9ievWezNu
zeo5txOlbpwpESOwlIeibgptbyiT9d4YcTj/4P+dDr24+U7v72J69Ovbj5Tu/vYnr069uPl
O7+9ievTr24+U7v72J69Ovbj5Tu/vYnr069uPlO7+9ievTr24+U7v72J69Ovbj5Tu/vYnr0
69uPlO7+9ievTr24+U7v72J69Ovbj5Tu/vYnr1n6gm3a66cuduY0rdEuy4jrDalvRAkKUgp
BOHjyya0Ovbj5Tu/vYnr069uPlO7+9ievTr24+U7v72J69Ovbj5Tu/vYnr069uPlO7+9iev
Tr24+U7v72J69Ovbj5Tu/vYnr069uPlO7+9ievTr24+U7v72J69Ovbj5Tu/vYnr1tUpSlKU
pSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpUbzzUZhx991DTTSStxxaglKEg
ZJJPgAPbR15phAW86htJUlAUtQAKlEJSOftJIAHtJFSUpSlKUpSqsi5Qok2JCfkIRJmqUmO
0ftOFKSpWB+AA5nw8B4kZtVG881GYcffdQ000krccWoJShIGSST4AD21JUbrzTCAt51DaSp
KApagAVKISkc/aSQAPaSKOvNMIC3nUNpKkoClqABUohKRz9pJAA9pIqSlKUqBiYxJekssub
lxXQ08MEbVFCV45+PdWk8vxrtp5p9BWy6hxIUpBUhQICkkpUOXtBBBHsINSUpUbTzT6Ctl1
DiQpSCpCgQFJJSocvaCCCPYQa4hTGLhBYmxXOJHktJdaXgjclQyDg8xyPtqelRl5pL6GC6g
OrSpaWyoblJBAJA9oBUnJ/UfjUlKUpSlKUpSlKUpSsLXDzTGhb6t51DaTb30BS1AAqUgpSO
ftJIAHtJFZ981nZ+AwbXqSGXWpMdx/gPNuI4Bfabc4isEJTh3OcpPLIOAa4cuFyVr561G7r
VGfSrhMwXo61w/qU4LzamitIKipSV7inJQkjCsHvT1ycm/Rg1JiX5l6ci29+dIeQoMP8Ld9
aQMDYSM7gTgd7JyTkx77IXGss+4ahkxY7d5dYfkLkxlRpCAw4pJS6htCVtkpA5gEKUsHvJS
UzMam6PcWJUzVaA0LzKhzIjy46WozY6Twtx2BaSeEjBUrnz8c1St+rF3KKhEnWK7U06w+5b
7i8wyhMvEl5vv8RsJJShLB2J2K75z+k6b4u3Lupc1XJU5HukFZancFC0xViMFlSC2ktpPGO
ThOCkeB3buzqtMsOuM6p4FsVqBcQXABhIQ0Ihc2BS0bSnijAUQSRjmc5K3XW9OaxlRpmq2Y
qYc5MVFmdjNPvS2+GjD2W9qhv3FZIG1HPPdSRU30jajmWbY1b7v1dITBkSQl0NttvFO3aEr
cbWFrBzhpOCQrJUnCd3b95lybjcJULUK1NRbpAZbiMhhbS47/R+8TsK8K4jmFBQ8OXhWZa7
83PnaYk3LVKHrg5cHBJta0ssCI4WH07OGU8UFKiGxuUdxIPtFeg1Zc1xLrBhnUqNPtSIkpY
kLDO1TqVMhAPFByAFrOAQTjxrGumorqYkhx+9rs9wa061cGoCG2UlyQUvqcG11ClkJ4acgH
kM5/Grmo7zLU/d3LZqFcZMOwouMRuOGFpfOXsr76FFSe439kgd79a4m3aba3n3Bqd6TBZ6r
kiQ8mNsLT0hxtzKktgbCgA58RjIOM1xKvS7Xcb4HNTrQ5GvMNRjPuM4bir6OlfIpylv64jd
ywUg5yVFV2RM1BA1sizmXJkxLqpEiK/0drbDbaKlPtq2gEhWWkBShy4viVJ71LR95vFyvKn
blqWMXHH5Lbmn0x23HYWxxYGXWyCANoG9Q2ncB4qSataqudwYnXtEO+PQV26yCfHjtIYVxV
Av7lKC0KUUjY2DgjGf1qrdL3LtLU9CdTSX2HGLe5FnLaYKWy886kkrQ2EJbUlCe+oKCc5AU
cJOfbNXPXFhUSfrRm1uoae4E5BjrafcS+6ghS1NhCtqBHUAkNqUlzdjBGLrEmSxcLrKh32Y
Fou9uQ7FcaZSXUOoitlbiC2FoUoFQ5bQCk4Awast3mW9brZFVqFbLq79Jt0iWkMcXCOkcNB
BQUBR2Nf6QTkY8ayZl9v6pcK3uasZsUcdPzdJjUdfSlNSi0lsoISEqSjacjGcnlyNeq1LeH
bfpFqZ09cR99UdAlCMW0oUtaclYcCuCkjIJWDsz4KUAk+ftGpJF16oiydWojKfVPaW/GdjL
L7rchtDKApTe0ktryNqUlQIOOdTWm9LOpbYifqdaglVyhrZccZQl51uShDSVJCR9YULScDB
5DAAUrdn2q53C16Mgvwb49KaVpaTJbQtDCkR3mUMhISUoBO0qUkhRV4c+Yq7dJ9xi9c9D1l
Me6JZE3OH3IiuNnjZPJnvI7jfMf+7x5iu4l5vEnXE1qTqWNb241wEdqxKjtvuyGtiCHApJC
wFBRXnBCMHdySRVK3ajnQJMyGxqBd3nIYuykQJBaWvjsv8A1KdqEpXlSNx25xgd0AAY9Hpm
4xrjOU9C1e9fI64yVpYLTP1JJzuWpttJSoggBCsHkvkcd309KUpSlKUpSlKUpSlKUpSlKUp
SsW7f9PqOwykc1vOvwlA+AQtoukj/APdujoH4YKuXgRtUpSlKUpSlKUpSlKUpSlKV/9k=
</binary><binary id="_74.jpg" content-type="image/jpeg">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
D8df/2Q==
</binary><binary id="_121.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAARAIcBAREA/8QAGg
AAAgMBAQAAAAAAAAAAAAAAAAUCBAYDB//EAC8QAAICAgEDAwIFAwUAAAAAAAECAwQFERIAE
yEGIjEUQTI2UXWzFRYzByM1YbT/2gAIAQEAAD8A9Mx2YSTFyZ/IXYamOn01busqRpDyIjkL
HR5SAq2jrQKroEMWpeuY6d7By05K0N+wumSrJXknXbq6KziJHkRfxkMvE7TQYbPT3GVZaOK
qU57T25a8CRyWH3ylZVALnZPkkb+T89Qo5H625kq/a4fQWRBy5b57ijk38eP8mtefjf36q+
oMlkMZFUlp160kUluCCd5ZWDIsk0ce1UL7jpz8suvB93x1Oe5PT9RVoZpOVO/EYoRoDtzpy
fXjyeacj50F7P6v10l9QYWDIjHTZejHdLKgrPZQSlm1xHEnezsaH32Os/6UaQ+o8hPSx1mr
i70C2HSxWmrvBZLszh1kGpGfmduh0BEqnwFJ0d7I/RXMbX7XP6+yYOXLXDUUkm/jz/j1rx8
7+3Xa7cgx9GxdtSduvWiaWV9E8VUbJ0PJ8D7dJoruclxOPmWLtXMrKGZZ67MmOUxM/FkBVm
1wCEsw9778DSddsFnfrcfUXKSU62TmlngMEc3iV4XZJDGG0xX28ta2ARv9eoSZaWH1bSgFp
JsbkIJoYwkRYR2oW2V7g8Asvc2rfBhOvOx1dl9QYWDIjHTZejHdLKgrPZQSlm1xHEnezsaH
32OmHVLDZH+r4Ohk+12frK0c/b5cuHNQ2t6G9b+ddVTksgnq2HGSV6y0pqk08cqys0rMjQj
RXiAo/wBw/dt+D4+Dn4pFg/0v/p2TnrUmoKmMuCSQ9tgrrFxZuPKNZU4+/W1WUN50D009Hx
y2RlM5ZqVoJcrb5oYJDJzijRYkPMqvJWKM6nWuMgI+T08uVI71V60zTKj62YZnifwd+GQhh
8fY9Z/D+k4aeVyVmR8iqteSWsTlLDCRRDENsO4eXvVh79+AB+HXV31NUyt+nXr4yCnJxswz
yNZstFrtSpIAOMbb3wI3414PnqF0y3c5g6zIi2ajNetLG5dIl7MkQXloHbNKeOwOQjkPgrr
rjXxOT/vqbO2KNERNUFKOVLshlSMO774dsKSxKbHL28ToneutH1mMx6ThuZXG2Y3yLKt55b
JGUsKI1MMo2o7g4+9lHs14JH4d9MMphTP6SyGFpSPysVJoIntTvKQzqwBZ2LMRs/8Aeh8dQ
S/dzPpmvapUoTNbiAnry3XgMBIIdO4iFg6ttT4Ugg/BGus/lbU3puvhxNFju9SimOPw62pB
z4RrGojmKEyyhXZQhVeXe+5j5G1jsXLjZfSXp+GGtvEwNauvCxCqwhaEaAX5keV2BOt9tz5
O9Xa+Jyf99TZ2xRoiJqgpRypdkMqRh3ffDthSWJTY5e3idE7102yOKrZPt/USXE7e+P012a
vvevntsu/j7715/XpZ6Q9PDCYPHCY3FuJRiinilvSyxowVeQVC5QaI0OI8DwPHRka2fPqaD
I0qOOlr1q0sCCa9JG79wxMSQIWA0YiNbO978fHXar+eMp+20/5LXTro6OjpLV/PGU/baf8A
Ja6ddHR0dJcF/wAv6j/ck/8AJX6ddJav54yn7bT/AJLXTro6Ojr/2Q==
</binary><binary id="_93.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAPAUcBAREA/8QAGQ
AAAwEBAQAAAAAAAAAAAAAAAwQFBgIA/8QALBAAAgICAQQBBAIBBQEAAAAAAQIDBAUREgAGE
yEiFBUxQQcyURYjM2GRQv/aAAgBAQAAPwDbY/CWO4MAma++5SrkMkq3a8kdp/FUDANHGIQR
G6qNKeS7f5E636dpd4C9BTFfDXrNqzj699oa/ArGkobQ8jsi7BUjR0TvYB03FVO9IaGCqzz
YfIl0rWXsQJNHK9cVWEc3J3kHPTH0QSW/OujVu4Mm96WGftm5VvyY02IIZb0TRzPEdNGvFi
F+UqAOQCwPsDiOvQ97Q2cHkcnHi7kP0eNXIpHZaNfPE6uyEFGfW/G35Gx69dT83iq+IOEkt
3MpLLYt+PITUZrKtbb6eVi5ihbe+SJ+B8VUL6VQB7A5laUrGsmavx5NrBqUJWMrwmvL4pCZ
JmVkDgo3GQgKQwB2wU2r3d+Mx2fhw9nnHLMyIrs8ags50oCFhI4JIHJFZQSdkcW48Td2qkl
da+FyNsWbM1WN4jAAZYmlDL85FI9QuwOta1+/XSt7+QsTjaVGe3Xswy3p54I68jwoytCzLI
WdpBGACuv7+9jW/wBd1stVu5TEZzHPzhy/OhMuwfcayyKeQJB4Mky/E6byb5EKuz939y0sF
g8iPu1Opk1oyy1YpZkEjNxbgVRv7fIaHo7I11Tx2ZxWX8n2zJ073i15Ppp1k4b3rfEnW9H/
AMPU+XumOPu0dtJi70towLZ8qeHxCEsFL7MgOgx0Rrfo6B9dVp7kFaatDNJxe1KYoRonkwR
n16/HxRj7/wAdZzvCufrsNNGuUmae2YJK9DIPAZUEEz615ETYZQd7B0utn8dLdv2ftsM+TB
y8/wBystUrYmxb+okilheZX4ySPxHJYy5BbQKkBm2o6Ng83Jj+3KflpZG5Ys5K3VhrmZJJl
4yzsFZ5JNHikRG+Z/A1vpUfyhjo0qC7jrNWe5AbUMUtisgNcnUchd5VXbA/03yBVtjQBOto
5KlkoIpqdhJVmgjsIB6bxuCUYqfYB0dbH6P+D1ibKNb7Mqdz3pLkN2/ZrTOaNucMK8tlOMW
o+JfjE/EAL/YuR8mJJsZlq2Pys1qo+dlqyWftqULBmmeWbwrOsgE5Dxei6HZ4n4sSoBPVrM
95Y7t/6b7nDNW88XlfyPEvhH7Htx5GHvaxcyPXr5Ly7yHdMdB51TF3rYrW46crQeEBZHERT
+8i7BMyjf6IO9DRKt3vvHYvGzXMlTuU3hvJRNeUxczKyK4+QcxheDbLMwA0ek7Gbq5n7R3J
i/k1DJLRsp9SP6T8Yyu4y8b/ACeCT8kfDWwwI602RzOKxHj+55OnR8u/H9TOsfPWt65Eb1s
f+jqZ2h3LSzuDxw+7U7eTajFLaiimQyK3FeZZF/r8jo+honXRsh3PVxkmSSzUuboRQSARxi
Q2PMzJGsYUkli6ldMB71+vfVOe5BWmrQzScXtSmKEaJ5MEZ9evx8UY+/8AHWc7wrn67DTRr
lJmntmCSvQyDwGVBBM+teRE2GUHewdLrZ/HQe3plxtG/nZZsp4LM4qxY23bNl4Zo53gCq7M
QDIxTYLaB/8Arj7HeLzclCvnrlqlkTwy8cMVKWZJJUMsdcBVJkKBS8mwA2gG/X46DN/JVOl
x+44m5T+osywVRLPXXy+LYlJYyBE4uCui3vald7IW5i+6cLlkqitkawntqzRVmmTytxLK2g
CeQBRxyXaniSCR76zk6TXv40yHcVmSavkbVGXIJLVtyI0a8HeCPkvHaojAcdcS3JtEkk8RZ
Khj8y92nY7giq49a4swWfqpjaFiR4lAin+QKOqMGTZILLo9Wsp3tRwaV2y1SzRMyl3WeSBT
EoOif+T/AHDob4xc2AI2AWUE2Q7pjoPOqYu9bFa3HTlaDwgLI4iKf3kXYJmUb/RB3oaJVu9
947F42a5kqdym8N5KJrymLmZWRXHyDmMLwbZZmAGj1G7h7sqtg6/e+Li+obB2WhswfVgckl
UKY+UZeN/k0D/kgcdbDAjqy/YtL6Wxj4MlkauJsyl5MZBIiw6JBdFPDmiMQdqrAfJtaB6dT
ttYMpLep5O5TWSslZa0EcAijRFYIFBjJHEuzD3rfo7Ua6y2T7QydXO0JIvrspQrLYnimiSk
1mG1LKkjHUyqgXYLKVHIEsNgaHVyt29lLklfJ389kal6OKSJEiWsfHGzKdNuJgXIjjLaJXl
y46XQ6DB/H1aGN4TncvJDJjftjQs8IQwcWVRoRjbLyJDfn/JIJB7rY23noqbXc5erZLDMsV
layQcPqfEQ0g5RtsMk2wPwAw2qsCBWt4U2s5Vyy5O5XerE0QhiERjdWZWcNyQt8uCA6I0F9
a2SZmU7HrZO1kJxlsjT+4ywyzrV8KEtEF8ZDmMuNFAR8vR3r8nr0fZbxeDh3Llx9PZktRfG
r8ZZOfNv+H3vyv6PocvX4GiRdmxwpXaLN5RLVaeeWO0rQh9THlKhXx8GUv8ALRUkEDRGgOu
1reXuKjjvPNMuIi+ulmmfckssvljT3+OOvOSoCgHxhdKCBTzOO+74O/jPL4frK0kHk48uHN
Su9bG9b/G+nepFfAvBn5sucxekaZRG9d1h8RRS5RfUYbSmRiDy2fWyeq/UjLYF8rdq2hmL1
I1G8kSV1hKh+LoW+cbEni7DW9f9b99Jy9mx2J2t2c3lJbvKFobfKFHgMRk48QkYUgiaQEMr
AhtdRe4e0L/0mLo1/qcvj48hPcuB0qtYDurkcFkVYSvORyQwJHIcfx6p0MBkrc7ZO1lMpjr
nHwKwauZZYAQyiZAjQ8lcycSgB4sATsnprF4+Sj3fkpI8bNFUmo1YhceRG87xGTZY8zIzcX
QcmGzwOz+Nz6OBefGxdr2MxeryYZo5EMKwnywCUtVYloz7URBSAFJZG2CCpNnI4F8iMcTmL
1eXHsZEmiWHlI5QpyYNGRviz+gAPkfXoaWzfZ9bN3rFtshcqPao/QTiusJ5w7YldvGzLvmd
8SN6H+B0qnY3CB4f9TZplknisOXNd2aSIRhGLGEkkeKP9+9e97Ozns2NxM8ubyklmS3HdSz
yhR4ZkTx8l4xhSDGAhVgQR+tknod/HyPexOFbJXJ2ksnI2ppynKVIChVBpQq/7jQelVQQrn
fInlp+ksNjvtGDoYzy+b6OtHB5OPHnwULvWzrevxvrP3MLkL/c7LHFcpY766G3ZcSwNDc8a
IUIBBlR/IkakelKxk723vW9SMtgXyt2raGYvUjUbyRJXWEqH4uhb5xsSeLsNb1/1v30tJ2h
Dahvrey2Rty3YoYzOzxxSQ+J2eNkMSLpg7ltkH2B+vXUjuPtPJfZLUFG1ZyxyGQrT3o7K1+
ZjQoGMQ4LGW1HH6fakKfWz7Pje3b9t4JZ7OUxYx6+Oi7Gqs6qw1JGUiVoTFpYioK8gyn8Dj
0bJ4Ca5lcRUP101StOluxblMcvOSNmdBtnBjJYnl44/alUBVRocUsKbPbs/ZdrJ3ITTiMTS
QiLlNTfyJECShH9F4nQVuUZP4ILVr2BfI4iGhPmL3KKdJzaVYRK7I/NAR4+GgwU+lH9Rvfv
aeU7Mgy08s8uVvRy2MeMfYkjSvymi2xOy0R4li53w4j0PXodATsbhA8P+ps0yyTxWHLmu7N
JEIwjFjCSSPFH+/eve9nZz2bG4meXN5SSzJbjupZ5Qo8MyJ4+S8YwpBjAQqwII/WyT0l3Fg
BmIKnadnKXpY8g0lu7Ydk5yRRBQFXScUPkeA6VQCFck7J5f//Z
</binary><binary id="_198.jpg" content-type="image/jpeg">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
NEREREREREREREX/9k=
</binary><binary id="_168.jpg" content-type="image/jpeg">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
</binary><binary id="_8.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAgADwBAREA/8QAGg
AAAwEAAwAAAAAAAAAAAAAAAAUGAgMEB//EAC0QAAICAgECBAUDBQAAAAAAAAECAwQFERIAI
QYTFTEUIlaT00FCcSMlMmGB/9oACAEBAAA/APT5fE+Khz4wTyWTkCqv5SU5mHAkAPyCFeOz
otvQOwSNHphL5jWoFXzlQcnd04cG0NBG383flyHEfs7kezKbWewmRxSwvbcLk1sQRRGqzTO
Y1cSgQuhJK8WBDKRvQ0dgHh8D4+ShhJmaNK8dq3LPDTjjmjSohOvLVZQrAbBb/FRtzpQNdM
5r8sfiOljgqeVYqWJ2Yg8g0bwqAP8AWpG3/A/7vLfHnHlcb2sPLGhccdxozqJHHLtyVCzDY
I2B2PsVOJzEtGC1FmL73I48p8DVuisf6vIJxD+WOIKyM0RbSryTR0djpzSyVLIvaSnYSc1J
zXn4dwkgAJXf6kBhvXsdj3BHSyvg8hH4tmzk12jIssArCNaLLKkSs7KokMh7kuOXy6bgOw6
7uMVpZ7t6RHVppzFGJa4jdI4yUC7HdlLCSRSf0l6nPCFS7NkobjiaOhSotDXFqg9ay8kzq8
nm8mPNx5SFnUBXaRiPY9WfUxL4EwDZyraTAYgVI600csXwcfzOzRFG1x0dBHGz3HLt7np7L
WlhxwrYpq1No1VIecBeKNRrtwVl7aGgARrt/HUzfxtjD4qnG8qcYratBBjMK7VYSFkblJXR
i7Dkd7DaDiI6GmLOfC9K7R8P148jwF2ZpLNhEGljklkaVkHc9lLld7O9b6x6FkfqzL/aqfg
6PQsj9WZf7VT8HR6FkfqzL/aqfg6X3v7bbhq2vGWaEszIqhKleQKXbgnMrXIQM3YFtAkHXs
dMPQsj9WZf7VT8HR6FkfqzL/aqfg6PQsj9WZf7VT8HR6FkfqzL/aqfg6ddHR1BeO7GFyRv4
exZeK5DBBK9Iqkfqyhy6QIxHmOdoygxn5Wl/cdr1e9HR0df/9k=
</binary><binary id="_123.jpg" content-type="image/jpeg">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
BV5aUKPCgD4A+3X/2Q==
</binary><binary id="_104.jpg" content-type="image/jpeg">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
5ZtDOqx+7JblpkI3FzSPU1JaIZb6Ce626226soaQ1LZaZstBPCwxiCFhO6Roy7e12cnceTz
3VaiLzXRWmy7U8lxbb6aioqOeolp2/RT6SoDnyztYC97BvjMUgOARt2xjAwd3oFzhpam1Vc
FbE+WllgeyaNjXOc9haQ4AN9xJGeBz9ixtEPhZZ5qKGiqaNsFXUuZFLRSU7RG+okdHtD2tB
G0jgdsgHCo0RERFl6h09bdUWeW13SHqQyctcOHxO8PafDhn9QcgkLM0hfLlU9ex6kEMV9oP
nEZw2rh4DahnABaTkHHYjkNyGjPlFbFFq6spaJ7qz6UgbK2hdmeWmbFTlzWu9p3dIyEAHIc
47TnBPTRdLTUt8uLLZp76LoG00ETZSyaLrbHSbDskhYS/a4l7tzvqDJ5K7a4iDqywVEdJ1K
ilrnStnNrlrWwNETxktj5HvMeORyAedvGFbrXDQfDqngprWxlTS36J8LailkpdzzWtEb/wB
4C8Axua3d7iGnaSSCF6UvNdVthOpLgItPXSAtbG+W622gkkrqiQtY0NppgNsbWsbh5J5y5o
bkkn0pEREREREREREREREREREREREREREReRfEGKt1jrahotGF/wBKWdr2V1whf0m04eQAw
yg5Jb+8y0ZPLgATuAvdI3Vl0oSKxnTvtHFHTXRkkbWSiRoJBO3gscS5zCPaQ448hUCLnJDF
K+N8kTHuhdvjc5oJY7BbkfYcOIz9hP2roiIiIiIiIiIiIiIiIiIiIiIiIiIiIihdQ6huWor
xLpDSE3Tmj4ul1HLKFvYsaR3lOCOO3PYgllNp7T1t0vZ4rXa4enDHy5x5fK7y9x8uOP0AwA
Avm1Bp+Wunhu9onZRXukaWwTuBLJmZyYZgPmjJ/Np9zee/bT+oIr5BMx8D6K4UjhHW0MpBf
Tvxkcj5mkcteOHD8wNdEREREREREREREREREREREREREREREULqHUNy1FeJdIaQm6c0fF0u
o5ZQt7FjSO8pwRx257EEsptPaetul7PFa7XD04Y+XOPL5XeXuPlxx+gGAAFqIsLUGn5a6eG
72idlFe6RpbBO4EsmZnJhmA+aMn82n3N579tP6givkEzHwPorhSOEdbQykF9O/GRyPmaRy1
44cPzA10REREREREREREREREREREREREREREXCmoqWj6vpaaGDrymaXpRhvUee7nY7uOOSe
V3REXMQxNnfOImCV7WsdIGjc5oJIBPkAudgfiftXREREREREREREREREREREREREREREURq
O+VplvRpr6+1ts7TF06ej9Q50joWysmmOx5ZEMubw0fK47uwFnDK2eCOZgeGyNDgHsLHAEZ
5a4Ag/gRkLGtL7jFqe60NZcn1kTYIamFromMEIklqBsG0ZIDY2DLiSSCeM4W6iLnNG6WCSN
kz4XPaWiRgBcwkdxuBGR+II/BQ2krtqG5XWxm4VVcylqbM6qeyaKlDamUOjy8GPLg3Eww0h
hG1uc5crO409VV0ToaOufQyucw9dkbXua0OBcAHAjJaCMkHGc4OF8umaye4aVtNbVSdSoqa
GGWV+ANznMBJwOByfC1ERERERERERERERERERERERERERF/P/wAev+uKP/bWf8kq/oBfz/p
T/wBw0/8AuVf/APmVf0AiLF1n/wBD37/baj/jcvAPhF/3PtH/AJv+GRezfF3/ALYXf/w/80
axfgL/AND1n+5P/wCOJemr/9k=
</binary><binary id="_113.jpg" content-type="image/jpeg">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
7mtHmrv6enStVfc1o81d/T06Vqr7mtHmrv6enStVfc1o81d/T06Vqr7mtHmrv6enStVfc1o
81d/T06Vqr7mtHmrv6eqVugXW0cTqzSenIPFxxOjTlN78ZxnbGGcZP+pq70rVX3NaPNXf09
Olaq+5rR5q7+np0rVX3NaPNXf09Olaq+5rR5q7+np0rVX3NaPNXf09Olaq+5rR5q7+np0rV
X3NaPNXf09Olaq+5rR5q7+np0rVX3NaPNXf09Vp8a9XVhLFx0xp+a0lW8NyLgtxIVgjOFRj
zwTz/AJ1My5qSMw2wxYbK000kIbbRdHEpQkDAAAj8gB7K76Vqr7mtHmrv6enStVfc1o81d/
T06Vqr7mtHmrv6enStVfc1o81d/T06Vqr7mtHmrv6enStVfc1o81d/T06Vqr7mtHmrv6enS
tVfc1o81d/T06Vqr7mtHmrv6eqUaBdYc52dF0npxiW/niyGpykuOZOTuUI2TkjJz7au9K1V
9zWjzV39PTpWqvua0eau/p6dK1V9zWjzV39PU2noMq32oszQymQ5JkPrSysrQniPLcACilJ
OAsDOB4VqUpSlKUpSlKUpSlKUpSlRh5pT62A6guoSlamwobkpJIBI9gJSrB/kfsqSlKUpSo
2XmpLDb7DqHWnUhbbiFBSVpIyCCPEEe2pKUpSlKUpSlKUpSlKUpSlKUpSleM01ZtN31N2lT
LZDuM5F3lsyXZbAdWkpdIQkFYOEhrhgBPIf55rtq8yIIZRZUQV2K3y4lt4e5alrbdQ1sdbd
3EEDjt90g5CSd3MABeNSSH4pYmWtpqbdJUFtC4Di1NpaL+FEh4biQx9g+t/LmavepJ3RYcJ
61omrTcStb0VwtOKjyEsoAAcygK3ZJyrHsFUn9UuxoV21SxBWt1enYEpuOkFzYpapBG7GMp
SVZUeXdBNLrqXV+nbQ5Juh0+/NafZSiBB4qnZaXFhKUJCiChXdcIOF7sHkNpz622XJL+nIl
1lyIwS5ERIefRlDIBQFKUN+CE+J73MDxryVv1dqGTBfU+mCl1SbcuK8Iqg0tMl8tlYTxSpS
cDKd3DV9qRVq6XC+W+LqYmTbunwrQ1KZmMQFIOMv91QU4rdjhkp54BWSQeYMd5lXq13W93G
HLg8WDYY776XYi1JeUhUpWE4dGwEg+O7xH2c7VzvN/RKuKoUm3NR4lyiwUNvQ3HFnihjKyo
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
ujmPtDfECgNmD9c8wT4HA7t+m5Vpuk5yBcGWIE+cZrzAjFTu8pTvAcUsgJUpOT3MgKIBHIj
MT+z1tMVzZIhx5QnR50dMWItqKy6yeSgxxT3lJylWFAEbTjIydliz3IXiFc5d0ZfdYafadQ
mJsQpLnDICO+SnBaBO4rzuV4DAGYNHXKPBTEgag6GDaGLct5uL9KCyHNriFb8JyXOYwTgcl
JOFDiFou4W474dwtcZSLgJzTbFqU2yhXR1MKTsD3gQQrkRzz455aCNNymoqUtXBkSI1yfnR
HFRiUI4pcyhad4K8B5zBBT/Dy5EHuDp12DPt8tE1CjHTLEhJYP0qpDiXVFHe7gC08gd3dOM
571aFmt3VFjgWzi8bocZtjibdu/YkJzjJxnHhmrtKUpWLF/xxdP6bD/3JVbVKUpXmLtpBd4
j3+DJmsmDecOBvo6uIw8lttCV7w4ApILQVt2jJ5Zx4w3qLfG37M+/dYank3IBLvQVJjsAsP
oBUnibipSlpRkrAyUADOd0zmkFuJjIM1lbRaltTm3I6iJCZLqXHQgpcBb5pITzVgHnkjJnt
NguUGxptMu5Q5kdiCIbLZgbW1AJCQp1JcUV8gOQKAQVZzkbcy26CeslyRdLTPhx5imnWXUq
huLjhC1pWEtNcYcJIUlSsbiMuK8BgDT7MvnpqHLnxUSp0SYFLYAcCmeDu3EEJO/gJ8Ep2lR
5HkKpSdH3KQz0Y3iGuGmc/KER+3cRp0OrcWUvDiDibVLBTjaAU5IJwU8SdFXB6wQbY3eYyF
RrW/a3HVQVKDjTgbG4J4o2qAaHPJBJJwPCtC56blXLj5uDLfWEFEK44jE8RA382u/8ARq+l
c+tvH1eXI7u3tOuvP3EmagNTLhFnJQGDubUyWcpJ3d4KDCcchjJ+tW7SlKUpSlYvau3e7Xf
yaX6VO1du92u/k0v0qdq7d7td/JpfpU7V273a7+TS/Sp2rt3u138ml+lTtXbvdrv5NL9Kna
u3e7XfyaX6VO1du92u/k0v0qdq7d7td/JpfpU7V273a7+TS/Sp2rt3u138ml+lTtXbvdrv5
NL9Knau3e7XfyaX6VO1du92u/k0v0qdq7d7td/JpfpU7V273a7+TS/Sp2rt3u138ml+lTtX
bvdrv5NL9Knau3e7XfyaX6VO1du92u/k0v0qdq7d7td/JpfpU7V273a7+TS/Sp2rt3u138m
l+lWZHv8AFRqqfNVDu4jvQYzSF9Ty+akLfKhjh55Baf8AX/OtPtXbvdrv5NL9Knau3e7Xfy
aX6VO1du92u/k0v0qdq7d7td/JpfpU7V273a7+TS/Sp2rt3u138ml+lTtXbvdrv5NL9Knau
3e7XfyaX6VO1du92u/k0v0qdq7d7td/JpfpU7V273a7+TS/Sp2rt3u138ml+lTtXbvdrv5N
L9Knau3e7XfyaX6VO1du92u/k0v0qdq7d7td/JpfpU7V273a7+TS/Sp2rt3u138ml+lTtXb
vdrv5NL9Knau3e7XfyaX6VO1du92u/k0v0qdq7d7td/JpfpU7V273a7+TS/Sp2rt3u138ml
+lW1SlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSoETGFznYSXMyGWkOrRg8k
rKgk58OZQr/AE/yrsOpL62QF7kJSokoITgkgYVjBPdOQDkcs+IzJSlKUpSlKpW+6sXJ6c0w
h5JgyTGc4rZRlQQleUg8ynCxg+3xGRgm7UZdSH0MkL3LSpQIQSnAIByrGAe8MAnJ548DiSo
w6kvrZAXuQlKiSghOCSBhWME905AORyz4jJt1Li3EJCwWlbVbkFIJwDyJHeGCOYyM5HiCKk
pSlVbnPatVql3F9K1NRGFvuJQAVFKUlRAzjngVM66llAWsLIKkp7iCo5JAHIA8snmfADJOA
CakpSo3HUtrbQoLJdVtTtQVAHBPMgd0YB5nAzgeJAqGXPahyYTDiVlU18sNlIGAoNrcyf5Y
bP288VapSo2nUvIK0BYAUpPfQUnIJB5EDlkcj4EYIyCDUlKUpSlKUpSlKV5hy6M27WdydkR
biWlwYrSXGbbIeQpSVvqUApCCDgOI/wBceIOIVuSZsq8FKrvb2rlZGXmVLZeWYrhDoXtSMh
LqQWiUJIUSMjJyaybBHkx9R2yfcI10I2y47UgKnOIcytjhqW26VKZBHEBC+7lvdkgJI1tcM
T1uW963uTHXUb09BY6U2iTlTfJTzCgGlABQSpzKe8c4AJGSwymFbmICmtQIYZv0pc3gpmla
mldJ4ZStPeUkkNElBIyQVc1EmaU5Kt0120R2dQPK6+iLjOgynUIj7WC6VvKJBb/fApKjzPh
yyM+VCdu2lZaJMfVJvnVshEuOp2SmOt8IOVgbuGtJWnCUNkghz6mB3bV+nPR4V6Tbo+pnkz
LWwm3hpmYVpkJU8gnKubZGGlKyRuAzhW7nNf2ro4dVrtxugurSSqBlctMcs9HaCuGEnhqcy
Xdo5nfg+zNa2lWOroM3o0vUd1aThaOtxtcUvByhvipQr2J+t3MkYOd+PM2Ry9JseoGkqvqp
DtkS5FTJZl8Rp8Jd3IC3chToKm+aNoUcFKRg4u3OJMiTh0JWo1WV7oLsnhPSHHwgmRuCd5L
ie90felGFhOeVbOjQyh++Ijs3FDK5yHWlT2pCVrSWGk53PDcrvIWPE4wPAEV5m0LukjSrku
1yr68t/TazIEgvqzM2JLS2S4NxUrLv7slPJHh3c+jtzTUXUdtegG9KhTIklKxMXLcSlxK2i
jcl4nhnAdwSE59mcismyWpyR2c6a5qMdKtrvTeJNnI2yk8L6/eHD/8A2xnCT7M92oFQ7pJ0
rdIUxu7uyJelozgQsvndJSh0OJB8AsnhbkcirnkHKqusW2RfbLqC22+bfYC0yQ7bZEl2Wwt
P0CABvdG5SOIHAU88Zzgd01SuKdRXS02iZcFXe0R7jOdfuDNuU8uVETwlJYQgISohBCElYI
+uvOE5IHpJDc1r9nc1uG9dHpaLe+mM5JGJayEq4ZO0A7j3cZAX4bhuzWFdLU5/9z1e5qP+5
Eybd/bZ37/6bI5q+v8Aufo1c/5eNVb7I1ANUS37Y3emXw+6yyypp9xleYiktuBQJjpbLpR3
VAqBypSkjKU3Xo8ebpy+LtkbUxdkWZ5vo1xVJKW1lBwlKXSdziicZRuA2eI3d/ubEkQXn5M
BV9VDR1XJbCnpbq+chwPjaolR+iI3N4+zIzijUS78ZqZBVceset57S0zXpPRtmySWSpsnbw
v3GFJGPAA5rv8AZ7EkR2G3JFx1NKkvREKmN3ZKwyy9gZCOIhKiclf1SoYHeOduYXJFxH7RG
3y3emYwuHBWypqS4ytoxilLgUgllLZcKe6QVA5UpSRlKViaeZhaYn51AZRfQxc0ylzFDcYy
9xU24SNvFKO+BtB9owahi21oMQLauPekpY1FJW+v+1hSULEpLa0u+O05bypKsd7Kj3iTch2
+U9NtkCeu9CKFXNIUmTKSciSngcRxKgccIK2lZwR4ZyKyVxNQs6UjybSq7m4v6ff6UJr0tR
EhJYB2pUcodxxtmAMnwyKmatzMJ+0yxM1dc4kS5cRbk5uQpaMsOg4QlCXCncGgSUlPeIB7z
gq0hyUy1Di3BnUDltZlz2XlsGUXkqD26OpSkHirb4W4BQ3JyU55gY9bYWksWSM0gzlJSkgL
uCyp9wZPfWVHIKvHBwQCBhONo0KUpSlKUpSlKUpSlKUpSlKUrF0l3bAmOnk1EkyYrKf+Vpp
9xttP88IQkZPM4ycmtqlKUpSlKUpSlKUpSlKUpSlf/9k=
</binary><binary id="_170.jpg" content-type="image/jpeg">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
</binary><binary id="_148.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCADFARcBAREA/8QAGg
ABAQADAQEAAAAAAAAAAAAAAAUEBgcCA//EAE4QAAEDAwIBBQwIAgcFCQEAAAECAwQABREGE
iETFDFBdQcVFiI1NlFVVpWz1CMyVGGUtNLTcYEYQmaRk6TjMzdSg8EkJTRDRFNikqGx/9oA
CAEBAAA/AOzUpSlKi6z8x792bI+GqngZpX2atH4Fr9NPAzSvs1aPwLX6amXXTGnY1xsjLOn
bQlEqcpp4d72TuSI7y8cU8PGQk8PRVPwM0r7NWj8C1+mngZpX2atH4Fr9NYTNmtVo1xb+9l
shweVtsvlObMJb34cjYztAzjJ/vNbPSlKUpWsPWa1XfXFw752yHO5K2xOT5ywlzZlyTnG4H
GcD+4Vm+BmlfZq0fgWv008DNK+zVo/AtfpqZatMadk3G9svadtCkRZyWmR3vZG1JjsrxwTx
8Zajx9NU/AzSvs1aPwLX6aeBmlfZq0fgWv0140cy1GsK2GGkNNNXCchttCQlKEiU6AAB0AD
qq7StP0npPTcnR1lff09a3XXbewtxxcJtSlqLaSSSRxJPXVbwM0r7NWj8C1+mpmptMadt+l
btNi6dtDciNBedaX3vZO1SUEg4KcHiOuqfgZpX2atH4Fr9NY1y09omz25+4XCxWWPFjp3OO
LgtYA/+vEk8ABxJIArkuq9Pi+6VuGs0WiNYbXHS2LXDYjIadkJW4hJedKR0EHxR/AjhxXu1
q7oU2dqtq0uXG0GA5JcYZuSI6wia4gNFTKE8qdivpFYWSpKvF2g9e+z3Lg2wk26NGkO7sFE
iQplITg8cpQvjnHDH86n861V6mtHvV35enOtVeprR71d+XpzrVXqa0e9Xfl6k6luerIlqLy
LchlSVZAtctch5w7Sdm1UNYAPpIAzjiM8efm/d1iXo67JuNmQ9CUw8mRImsJjvNt8n421O5
GQBkg7Txz04wO4VxXuXXvXcrXkmHdlTnoxSV3BE1KhzYkFTZSk42EkgBIGCknhhII6hffK+
nO0l/lJFeNau3tjSM97TgWbo2lKmQhCVqIC0lWEqBBO3dwxk9XHFal3Frlqa6WSZIvciTJh
BSUwXpGCpZyvlPGPjKGSkZJI4YHQQNwlefFr7NmfEi1apSlKUqLF8+Lp2bD+JKrVu7FP1TB
sEY6eTJRGUpap0mKDyrSUgKTxHFKeCiVD/AIQCQDg1u5pJ1JJ0g0dTsPNS23VNtGQgpdcaA
GFLB47s7hkgEgA8c5NOxeV9R9pI/KR65z3X7vq626qtXeR+4sxOSbDfNkK5N2QpavEOBhai
Ep8Q54Z4cTnoEKZrFcFhcqyWhEhTSS6nvm4nCscRgMqA49QUr+J6an6ak6kFreDNpta098J
pJXc3Endzl3cMBg8AcgHrABwM4GTd52qmrW8vvfDjY2/SwpzrzqfGH1Uc0Xn0HxTgZPDpGj
aZvfdllblOWtl9px1LfKXWOmPyPpUEpKFFPjDJwro4cciujaM8x7D2bH+GmuWaxvndAh91d
tm2CZsU6luBESVGNJSEgqzkJSr6xKj/AFM/W8UGup6z8x792bI+GqqFyuUKz25+4XCQiPFj
p3OOL6AP+pJ4ADiSQBWpDTk3W1xiXjUqFx7VHUXIdicTxJ/quSOPFRGfo8YSCAT9cH6d13/
dhd/+T8ZutzpSlKVI1Yy7J0demGGluuu299DbaElSlqLagAAOkk9VePCu3fZrv7ml/tVJs2
pYDd0v61R7oQ7cEKTttMpRA5swOIDfinIPA4OMHoINe7rf4sm42R5mHd1IizlOvHvPLG1Jj
vIzxb4+MtI4emqfhXbvs139zS/2qk6T1LAY0dZWVx7oVN29hJKLTKWkkNpHBSWyCPvBwazY
89F11jCfjRpyWmLfKQ45IgvMJClORykZcQnJIQrgPRWx0pSlKVrkiei1axmvyY05TT9viob
cjwXn0lSXJBUMtoVggLTwPprC1ZqWA/o69Moj3QKct76QV2mUhIJbUOKlNgAfeTgVW8K7d9
mu/uaX+1Uy1X+LGuN7eeh3dKJU5LrJ7zyzuSI7KM8G+HjIUOPoqn4V277Nd/c0v9qnhXbvs
139zS/2qaTC+8ilrZeZ5WdMdSl5pTa9q5LqkkpUARlJB4jrq1StS0zf4tv0raYUqHd25EaC
y06jvPLO1SUAEZDeDxHVXiTqWAdY214R7ptRb5aSDaZQVkuRyMJ5PJHinJAwOGekZ96mv8W
4aVu0KLDu7kiTBeaaR3nljcpSCAMlvA4nrrX7HLkXi8HUOsI13bW07ut9nRa5a2Ye3IS4rD
e1bvE4V1Zzw4BG5+Fdu+zXf3NL/arWe6NdEX7Qlxtlst93flv8lybfeiUndh1CjxU2B0A9d
dApSlKUpUWxeV9R9pI/KR6tUqLozzHsPZsf4aatUpSlKUpWmd1LUPeDSL6XYvLR7k09CU4l
zC2lraXsO3GFJyDniCOoHoqzpPUPhVYkXlEXm0d91wR0lzctSEqKQpQwAlRKT4oKgOHE1ap
SlKUrj+qdVX2B3S02Bl95l6Q6I8G4OtIPItSFxidqNgC0pU04kEnJ3cTlPHsFKUpSlKUpSo
ti8r6j7SR+Uj1apUXRnmPYezY/w01apSlKUpUibflxrqu3RrPOuDrTDb7io6mUpQlalpSPp
HE5OW1dGa1nX0e7as0jKtMbSU4SlqbWw5IdibW1BYJOQ8SDt3DIHXjrqhpp+42LTNttZ0hc
UrixkNuci5ECFLAG9Q+mGcqyc4yc5NXbTdhdRKBhSYTsR/kHWZBQVBWxCwcoUoEbVp66oUp
SlRXdQvd8JkSJYbjO5m6lp11lUdKNxQlzA3upP1Vp6q1y4WuZN15a9WDT96bdgMLYUwVQ1J
cSQsAg84G0guKz054dHXsff24+yd3/AMWJ+/VC2T2rraolxYStLUthD7aVgBQSpIUAcZ44N
ZVKUpSlKUqLYvK+o+0kflI9WqVF0Z5j2Hs2P8NNWqUpSlKVFi+fF07Nh/ElVQn3GLbGEvSl
LAWrYhDbSnFuKwThKEgqUcAnABwAT0A14tV3gXqKqTb3+VQ26plwFCkLbWk4UlSVAKSoegg
HiPTWFYvK+o+0kflI9WqUpSoti8r6j7SR+Uj1hap1nGssG5twP+13SDG5ZTIYecbayCU8op
tJCOAJwopyB0pB3DZ6i6M8x7D2bH+GmrVKUpSlKUqLYvK+o+0kflI9WqVF0Z5j2Hs2P8NNW
qUpSlKVFi+fF07Nh/ElVlXa0i6iKRNkwnYj/LtPRwgqCti0EYWlQI2rV1V7tVvctsVTDtym
XAqdU5yssoKxuOSkbUpG0HOBjhnA4AAYVi8r6j7SR+Uj1apSlKi2LyvqPtJH5SPWNedFx7w
u4Yu90gtXRKUzGIryAh0pG3PjJUUkpCUnaQFBIBBq+y2pphttby3lISElxYAUsgdJ2gDJ+4
AfdUnRnmPYezY/w01apSlKUpSlRbF5X1H2kj8pHq1SoujPMew9mx/hpq1SlKUpSosu03Xv4
9c7Zcocfl4zTDjcmEp7/ZqcUCCl1GM8qeGD0CnNdVeubR7qd+YpzXVXrm0e6nfmK+1ltkq3
qnvTZbMqROkh9amWCyhOGm2wAkrUehsHOeuqlKUpUI2i9RrlcJNuusFpqc+l8tyIC3VIUGk
N43JeTkYbB6OuvfNdVeubR7qd+YpzXVXrm0e6nfmKzbNbu9FjgWzleW5nGbY5Tbt37EhOcZ
OM46M1m0pSlKUpSoti8r6j7SR+Uj1apUXRnmPYezY/w01apSlKUpUKVKvUnUci3W6XBitRo
jD5VIiLeUtTi3U48V1GAA0PT0175rqr1zaPdTvzFOa6q9c2j3U78xWFBe1VNmXKP30tCOYS
Qxu72OnflptzP/iOH+0xjj0Z66zea6q9c2j3U78xTmuqvXNo91O/MV9tPTpVwtRemllUhuT
IYWplBQhXJvLbBCSpRGQgHGT01UpWsWZ7VV3scC599LQzzyM2/wAn3sdVs3pCsZ5wM4z04r
N5rqr1zaPdTvzFYV5e1VaLHPuffS0PczjOP8n3sdTv2JKsZ5wcZx04rN5rqr1zaPdTvzFOa
6q9c2j3U78xWh6p7o+pLHLmMWpdrvCbYkG4voguNNRlKUEJRu5c7lZPEDowenCtvVqUpSlK
Vr6I1/t91ur0KDbpUedJS+hT05xlacMttkFIZUOlsnOeuvtzrVXqa0e9Xfl6c61V6mtHvV3
5epOk5OpE6OsoYtNrW0LewG1rubiVKTyacEgMHBx1ZP8AE1W51qr1NaPervy9Odaq9TWj3q
78vTnWqvU1o96u/L051qr1NaPervy9Odaq9TWj3q78vTnWqvU1o96u/L051qr1NaPervy9c
81PrPW1u1c5GtDkaY/HSkv2SOy7L2Aozv3hhs7fGQfrk7j6OA2bQlxv10vNxlajtSLbNVb4
eG0HgtBcklKtpJKDxwUk5yk9GcDN15ryFoW3MPPRly5UpRSxHSrYFBONxKsHAAI6iSSOHSR
m6P1XC1lYG7rDQtohRafZX0tOAAlOf6wwQQR1EdByB7sXlfUfaSPyketf1x3UIuib5Dtj1s
el8u0HnnEOBPJoKinxQQdyvFVwJSOjjx4WoWu9KzILErv/AG5jl2kuck/MaS43kZ2qG7goZ
wR6an6a1Zpti1vIe1Da21G4TVhK5rYJSqS6pJ4noIIIPWCKybvryyQ7W9Itl0tFylo28nF7
6ss8plQB8dRwMAk/yxUOB3a9LPPqjXESbc62n6RZSH2d4IBShbRVuGc4VgAgZ6xW06M8x7D
2bH+GmtSu3dns1q1eqyOQ3lxGHSzJnBWOSWCQrDeMqSDgE5B6cA4Gdt1n5j37s2R8NVWq09
6/O6zfctWlpi24Laii4XhoEcng8WmCR4zhHHeMpSkgjJIqf3SLPbbF3I7rCtcJmJHTyHiNJ
xuPKtjKj0qVgDJOSccTXQKUpSlKUpSoujPMew9mx/hpq1SlKUpSosXz4unZsP4kqsLuiWiB
d9D3PnzHLczjOymPHUnY6hte1XAjOMngeFWrRaIFhtbNstjHIRGN3Jt71K25UVHiok9JPXW
FYvK+o+0kflI9fG/6F01qecibebbzqQ20Gkr5dxGEgkgYSoDpUf76uMstRmG2GGkNNNJCG2
0JCUoSBgAAdAA6qk6U8kP9pT/zbtULlbot2tz9vmpWuNITsdQh1TZUnrGUkHB6CM8RkHgan
2jR2m7DyKrZZYbDrG7k3+TCnU5zn6RWVdZHT0cOimjPMew9mx/hpqNctIWKX3S7dc34O+W5
GelKc5VYy6yuMltWArHAE8MYPXmrOs/Me/dmyPhqrVrlcpvdIuL9gsEhcfTsdXJ3O6t9Mk9
bDJ6wR0q6MH/hwHN5ttthWe3MW+3x0R4sdO1ttHQB/wBSTxJPEkkmtW7rv+7C7/8AJ+M3W5
0pSlKUpSlRdGeY9h7Nj/DTVqlKUpSlS52nrfcJxmvGY3IU0lpS4059jclJUUghtaQcFaun0
mtZ1ra7NbdNz2VyruJEmDK5uF3KY42tSGVLIVlZR0JJwrpAPA8arwbLZLkh5cWXelpYfWwt
SrrOQN6DtUBucG4AgjIyMg8eFfZvR1paW4tty6IU8re4pN3lgrVgJyfpOJwkDPoA9Fe/BS3
fabv75l/u08FLd9pu/vmX+7VC3W6LaoSYcNK0tJUtfjuqcUVKUVKJUokklSick9dZVKhM6O
tMZhthhy6NNNJCG20XeWlKEgYAADnAAdVaZcZun4msW4jir1zmMl6IYnfl3l3nFuReSLZL/
BKg4TxUnISSRlHDc3tHWmSw4w+5dHWnUlDja7vLUlaSMEEFziCOqvEPRFjt8VEWELjFjt52
NM3aUhCcnJwA5gcST/Ovt4KW77Td/fMv92vjM0RY7hFXFmi4yo7mN7T12lLQrByMguYPEA/
yrYKUpSlKUpSoujPMew9mx/hpq1SlKUpSp8/UFltT6WLjd4MJ1Sd4bkSUNqKckZwojhkHj9
1c/wC65d9N3zQb6I1+gyJUV9t9hmPLbWpas7CNoJJAStR4eiq2g77pWyaGs8E6jtyFpjJcc
Q9NaC0LX460kZGMKURjpGONbhAudvurCn7dOjTWkq2FyO6lxIVgHGUk8cEcPvrKpSlKlzNT
WC3ylxZt8t0WQ3je09LbQtORkZBORwIP865hek6bmd2u03pNytblvLAflSBcm9ofbCggnx+
BB5HAHA4PA4VXSfDPSvtLaPxzX6qrMvNSWG32HUOtOpC23EKCkrSRkEEdII66+lKUpSlKUp
SlRdGeY9h7Nj/DTVqlKUpSlRYvnxdOzYfxJVWqVFsXlfUfaSPykerVKUpUWxeV9R9pI/KR6
oR7lClzZcJiQhcmEpKZDQ+s2VJCk5HoIPA9HSOkHGVUXRnmPYezY/w01apSlKUpSlKUqLoz
zHsPZsf4aatUpSlKUqLF8+Lp2bD+JKr46xj3WTbYzdpYedXzkF7kXlNrSjYviNrzO7xtowV
445wcCmh27yzphlm/xnmJ7bru8OyOWyCsqTtXvWSkJUEjcc+L/An7WLyvqPtJH5SPVqlKUq
LYvK+o+0kflI9a/qS33aTqa4SI9ju77LltbYjyYF2REPLJLihw5QZT9KPGUk4KThKga3C2N
zWrVEbuLyHpqGEJkOIGErcCRuI4DgTnqH8Kn6M8x7D2bH+GmrVKUpSlKUpSlRdGeY9h7Nj/
AA01apSlKUpWvyV3C36qlzWbLMnx5MGO0lcZxgbVIW+VAhxxJ6HE9Geuvt39uPsnd/8AFif
v07+3H2Tu/wDixP36aeamcveJcuA9B55ODrTTy21L2hhlvJ2KUPrIV11apSlK1xl65Wq8Xk
iwTprUuWh9p6O7HCSnm7KCMLdSQdyFdVZPf24+yd3/AMWJ+/Tv7cfZO7/4sT9+vtpmG/b9K
2mFKb5ORGgstOoyDtUlABGRwPEdVVKUpSlKUpSlKi6M8x7D2bH+GmrVKUpSlKUpSlKUpSlK
UpSlKUpSlKUqLozzHsPZsf4aatUpSlKVr9111pqyXhNpuly5nLXt2pdYcSghXQd+3bt9Jzg
YOSMGsKO5bNVaqn83u70qJGgxtve+6OobStS392eSWAVYSjp44Aqn4KW77Td/fMv92ngpbv
tN398y/wB2p9tscOZOuzDj90CYUtLDZTeZmSksNOZP0vTlw+jhiqHgpbvtN398y/3aeClu+
03f3zL/AHaaTK+8ikLeee5KdMaSp51Ti9qJLqUgqUSThIA4nqq1StS0zYItw0raZsqZd3JE
mCy66vvxLG5SkAk4DmBxPVVPwUt32m7++Zf7tT9QWOHatOXO4sP3RTsSI6+2ld5mFJUlBUA
cOjhkVQ8FLd9pu/vmX+7Xh7TVpjMOPvzbo000krccXe5aUoSBkkku8AB11ynU0273KzXHUu
mrjd7ZYLdtbZfduMlblxWpxKCpIWs7UJycHpzwPHIR3OlKUpSlKUqL4GaV9mrR+Ba/TTwM0
r7NWj8C1+mngZpX2atH4Fr9NPAzSvs1aPwLX6aeBmlfZq0fgWv008DNK+zVo/Atfpp4GaV9
mrR+Ba/TTwM0r7NWj8C1+mtcu3cks16myFPuohwlKQqPGt0GPHU0QnCtzmwqWCeOOAH38MU
NLactOmNVXeFZonNY7kGG6pHKLXlRXIBOVEnoSP7qn91rVd70pYIr1mQhsyX+ScmK2qLJA3
BIQekqAVxIIASesgih3NNS3LVWkGrhdI/JyEOqZ5UJ2pkhIH0gGMDiSDjhlJxjoFOxeV9R9
pI/KR65/wB1buhah0pqq3wrS+y1HEZMhxC2QvliVqG1RPEJwj+rg8Tx6Mb1C1HdJMFiQ5o+
7tLdaStSOVjeKSMkeM6lXD70g+kDoqfpq8z27W8lGmLo6DcJqtyHIuATJdJHF4cQTg9WQcE
jBpqnUtziabmSUWy6WUtJCufLEJ4NAKGfEL/jEjxQOnKhjjitS0/3WdWXZ97m2kF3iMp8Ms
PxW1x0pOf/ADCeUSk4KSfGAT1kjjXQ9GeY9h7Nj/DTXL9T91HVtn7pTltZhoMWM+llNtSlK
1Skn6qt4BUFKCgQB0eKCDg56hrPzHv3Zsj4aqrPPNRmHH33UNNNJK3HFqCUoSBkkk9AA660
x2A73SUByaqTD0wFJVHjpJbduWCDyjnWlrh4qeCjncSPFp3V2Wo3cqubDDSGmmksIbbQkJS
hIebAAA6AB1Vu9KUpSlKUpSlQtZ3K72fS8y6WVuM7Jhp5ZbchBUlTY+v0KTggZV1/VxjJFN
K3O53qE/c5nNkwpD6zbktMONrVHCiELXvPSoYIwBwwevA+z0nUiX3AxabWtoKIbWu5uJUpO
eBIDBwcdWT/ABNeOdaq9TWj3q78vTnWqvU1o96u/L051qr1NaPervy9c/1ZP7oEO+rTYI9x
TLmutpcQwtUqGyAkABJdjJSjOclSVkZCt2OGK+mNSXGJqO6ua9Va7HNciRUsNmShCXGwt/i
MrVk5Jzx9HD009Was03J0demGNQ2t1123vobbRNbUpai2oAAA8ST1VW8M9K+0to/HNfqqTZ
tWabaul/W5qG1oS9cELbUqa2AtPNmE5HHiMpIz6QfRVNzVmkHVtrc1DZVqZVvbUqa0ShWCn
I48DhRGfQT6a9+GelfaW0fjmv1V40c81JsK32HUOtO3CcttxCgpK0mU6QQR0gjrq7StP0nq
zTcbR1lYf1Da2nWrewhxtc1tKkKDaQQQTwIPVSTqzTatY218ahtZaRb5aFOCa3tSouRyATn
gSEqwPuPopqzVmm5Ojr0wxqG1uuu299DbaJralLUW1AAAHiSeqtVh3qz6/vCLxqa826DY4b
pNvs0iY2lbyhw5V9O7+OEn/wDmS50Dwz0r7S2j8c1+qtS7qWprBcO51dIsK+W6VIc5HY0zL
bWtWHkE4AOTwBP8q6PSlKUpSlKUpWFdrTDvcFUKcHlR153oakONbwQQQooUCUkE5B4H0V9o
UNi3wWIUVvk48ZpLTSMk7UpGAMnieA66+9KUpStM7p2oe8em3o78XdEucaTFVK5THIullRb
TsAJVvIIzwAxk1Z0tqHwntbtzbi8jEVJdbiOcpu5w0lW0OYwCnJCvFIyMffVqlKUpSuU6h1
5cIHdE7zR2ozl1aUqFCW4ypLG2QqKtHKYWVZAS4CR17SBxIHVqUpSlKUpSlKUpSlKUpSlSJ
t+XGuq7dGs864OtMNvuKjqZSlCVqWlI+kcTk5bV0ZrVu6FBumsNKPWyPpO4plpdQ7GW9IjJ
QhQOCTteP9QrHQen+YoaVVP05pe3WgaRugVGYSl3Y/FUlTh4rIJfzgqKj/PoHRWwWm7C6iU
DCkwnYj/IOsyCgqCtiFg5QpQI2rT11QpSlKiu6he74TIkSw3GdzN1LTrrKo6UbihLmBvdSf
qrT1Vp95s12ufdKs2qTpec5FgsKbejuriFQUN5QtP0xBIUsHjjG0EZ6tw7+3H2Tu/+LE/fq
hbJ7V1tUS4sJWlqWwh9tKwAoJUkKAOM8cGsqlKUpSlKUpSlKUpSlKVFi+fF07Nh/ElVQn3O
32phL9xnRoTSlbA5IdS2kqwTjKiOOAeH3V9mXmpLDb7DqHWnUhbbiFBSVpIyCCOkEddSbF5
X1H2kj8pHq1SlKVFsXlfUfaSPykevGoNYWnTj7MaW8hcp5JcSwJDLSggHG4l1aE4zwAzk8c
A7VYssuKdYbcWytlS0hRbWQVIJHQdpIyPuJH31J0Z5j2Hs2P8ADTVqlKUpSlKUpSlKUpSlK
VFi+fF07Nh/ElV41Ppxy/iCtieuG/CfLqFBT21QKFIIIbcbOfG4HORxHQog5On7MLFa+acr
yq1OrdcWFOlKlKUSSA44tQz0nxjkknrNfGxeV9R9pI/KR6tUpSlRbF5X1H2kj8pHpc7TdZF
8jXO33KHG5vGcYDciEp7PKKQpRyHUf+2jAx6enIxaqLozzHsPZsf4aatUpSlKUpSlKUpSlK
UpSuZa47oXgHrhz/uvn/PbbH/9RyWzY4//APFWc7//AMqN/SE/st/n/wDTp/SE/st/n/8AT
rc+5pqHwqt94vfNea85uX+x5Tft2x2U/WwM/Vz0ddbnSlKVyXUHdT8CNZ322d5ufcrJaf5T
nXJ4zGZTjGw/8PTnrrD/AKQn9lv8/wD6dP6Qn9lv8/8A6ddM0Z5j2Hs2P8NNWqV//9k=
</binary><binary id="_65.jpg" content-type="image/jpeg">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
</binary><binary id="_124.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAOALYBAREA/8QAGg
AAAgMBAQAAAAAAAAAAAAAABQYAAwQCB//EAC0QAAICAgEEAgIBAgcBAAAAAAECAwQFERIAB
hMhMUEUIlEyYRUWJDNCcZHB/9oACAEBAAA/APSe9MtdwvaWQu46F5biQOYuI9RkKSXJIIAV
QW/b0SAvywHRalcgyFGC7Vk8lezEssT6I5Kw2Do+x6P313DNFZgjnglSWKVQ8ciMGV1I2CC
PkEffVnVc00VaCSeeVIoolLySOwVUUDZJJ+AB99LmbymNz+Cnr4rNzOvliE9nCSeeauvLlv
UZLDlxKbAOuWyCobW3s+vaqdqY+pcXT1ovChMZjLxISsTFCSVZkCsVPsEkED4G2jkfzbmSr
+Lh+BZEHLlvnuKOTfx6/wBzWvfxv764y1jIRCrBjo08tqfxmeSJpErqEd+bKpXYJQJ/UPbj
5+DixnccS9vw3+4LNHHSieWrMxnCwtLHI8bcC+vRMZYA+9fzrfQzu7PiTD1ZcZi72aqyW60
y2sWqWEPjsK7LpX5b1Gw3rjsgbH04dYsNkf8AF8HQyfi8P5laOfx8uXDmobW9Det/OugWV7
nu4zuqhjmWs0Vu2ldaka+S1JG0bN+QNOOMauCpBU6CM2/YHRqXuDCwZEY6bL0Y7pZUFZ7KC
Us2uI4k72djQ+9joFgsUI++Mrka0f41cRGKQfiywtbkaQv5H2iRtw/ZVZebEMSz+x029Tpc
w2YzU+VqQZStWiiyOPN2GNEeOaqysgaKQMTyIEqfsOPtW/UeuidDuDC5WdoMdl6N2VV5mOv
ZSRguwN6Un1sj3/foh1Olzt3uaXMZO7RmfFhq09hBHBdLWAscxjUvCV/UaA98jvY9DegPzf
amU7io5OzeWGLJy1mp0YoMnOteGNgOTOVVeTFiSQVKkJGPono/21RtYvtnG466IRYp1kgcw
uXQ8AFBBKg+wAda9b17+eiEJlaCMzoiSlQZERyyq2vYBIGxv70P+h1Z1Rce0lV2pQwzWBrh
HNKYkPv3tgrEet/R/wDvQnszD2O3+16eIs160LVF4f6ed5VkJ9s+2VSCzFjx9gfR+gWuVI7
1V60zTKj62YZnif0d+mQhh8fR6WcB2/STN5uQT5Emtko+AOTskHVaBv2BfT+z/wAt+tD4AH
TBlluvRaKjXhneTaOstt62lIOyrojMG+Na1/Oxrpcy/buWyPaMPb4xuL/F5Qq1Y3plWKCJ4
yIxJ4yzlgjAtpCvIem1stkJlaCMzoiSlQZERyyq2vYBIGxv70P+h1myOKrZPx/kSXE8e+P4
12avvevnxsu/j73r3/PQXsTFVqnauGuRyXGlmxsHJZbs0kY2ik8Y2Yqv9tAaHoeurJ8b3Dc
yLx2pKLU0yEdqrajdkmrxrx3GI+PssA6FvJ7Eretfp1K+Jyf+eps7Yo0RE1QUo5UuyGVIw7
vvh4wpLEpscv14nRO9dMfQu52/SvWnszT5FXfWxDk7MSehr0qOFHx9DrVQx8ONgaGB7Lqzc
ibFmSdt6A/qkZiB6+N6/wDehNSpm48payDY3HQTWIlEhGSmn8vBW8cYDRqIl5OSWUH7/Ult
idpYi7h4cgt2pTge5emuM9a083kaRyTsMi8eK8F9fOidD7IX8JUyU6zTzXkZV4gV8hPAutk
/0xuoJ9/Ot/8AnXeOxVbGeT8eS4/k1y/JuzWNa38eRm18/Wt+v46Uu6ezs53pizh8nbp1a8
N57MNyJmlkZeTiONouKBdI4BPM+1+97H//2Q==
</binary><binary id="_210.jpg" content-type="image/jpeg">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
</binary><binary id="_182.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAA3AI4BAREA/8QAGg
ABAQADAQEAAAAAAAAAAAAAAAUDBAYCB//EADUQAAEDAwIDBAgGAwEAAAAAAAECAwQABRESI
QYTMRQVQVEWIjJUdZGV0yQ1NmGztAcjwXH/2gAIAQEAAD8A+vzFykRVqhMsvSBjQ286WkHf
fKglRG2fA/8Aak8KOXpcGQLzGQyoS5BaPaFuKKS+5gYUhOEgaQkjOU4OE9Ku0pSlKi8S2Lv
iKy/Fbh96QHQ/AelM8xDawQSD46VAYJG42UPWSnHvhjh6PwzZG7cwULVqU686llDXNcUcqV
pSAAPADwSEjwqvSlKUrSuLV1d5fdk2HGxnmdpiKe1dMY0uIx4+edunjmholIioTNeZekDOt
xlotIO+2ElSiNseJ/5WelKUpSlKUpSsD8xiM9GZec0rlOlpkYJ1KCFLxt09VCjv5VnrAuYw
ic1CU5iQ80t1CMHdKCkKOemxWn5/+1npSlKUrGHmlPrYDqC6hKVqbChqSkkgEjwBKVYP7Hy
rJWNt5p1biG3ULUyrQ4lKgShWArB8jhQOPIjzrJWNt5p1biG3ULUyrQ4lKgShWArB8jhQOP
IjzrJSlRb7+b8OfEl/1JFWqiyv1xa/hsz+SLVqlcxd+K3O63u5I0zt/q8rttmncr2hnVpaz
7OcY8cVz/Cv+X4d8ld3SrZMVLb1a37dHckMqSkAczSBzEpKtgCk4ynJ64630rt3u13+jS/t
U9K7d7td/o0v7VeHuLoDTDjiIN6eUhJUG0WaUFLIHQamwMn9yB+9aXYHeH1scQyVIMt5QF7
W2Ty1JUEp1jp6rRSjBV7LfNJyokm7d7j3Xa3paWuc6nShlnVp5rqlBLaNWDp1LUlOTsM5Ow
qK1bvReRb5fN5yZGIlxe06ea644pSHtOTjLzi06U7fiMk6UCrV2uPdsFTrbXaJK8ojRgrSq
Q7glKAcHGcHJ6JAKjgAmorVu9F5Fvl83nJkYiXF7Tp5rrjilIe05OMvOLTpTt+IyTpQKtXO
7Q7Q2yuWXv8Ae7ymksx3HlrVpUrAShJPspUenhWl6V273a7/AEaX9qnpXbvdrv8ARpf2qnz
b3EuV+4dZYZnIUm4LUTIt77CcdlkD2nEJBO/TOflXVVzl5uDNt4xtLz6JK0qt8xIEeM4+rP
MjH2W0qIG3XGPnWz6V273a7/Rpf2qeldu92u/0aX9qtq92G18R242+7w0SoxUF6FEgpUOhB
BBB6jIPQkdCa92qFaoMVTdnjQ48cuq1JiNpQjWDpVkJ21ApwfHbHhW7SlY3mWpLDjD7SHWn
UlDja0hSVpIwQQeoI8KgWu3XRVxis3RK1RrMlXZpC3Qsy1q1IQ4TnVqSzkK1ABS3VEDCUk3
JsNi4QZEKU3zI8lpTTqMkakqGCMjcbHwqNaId2kzmZF8bwba0phhRKPxLhJCpOlOQnUgJ0j
ZSeY6k5BBNmbDYuEGRClN8yPJaU06jJGpKhgjI3Gx8KjWCHdnZy5t9bxIhtGDGXlH+9OQXJ
GEbJ5pS36h9jl7H1jXQUqLffzfhz4kv+pIq1UWV+uLX8NmfyRatUpUjhU3RXC9ucvUhb9wd
YS4+pbIZUlSvW0FA6FIIT0Hs5qvSlKVpXG82q0cvvO5w4PNzy+0vpb14xnGojOMj5it2lKU
qLffzfhz4kv8AqSKtVFlfri1/DZn8kWt243m1Wjl953OHB5ueX2l9LevGM41EZxkfMVu0pS
lKUr5rxlMuMri1+bapaGmuE4iHZnKjoXIw+oF0Nl0aAQw3qBG++nfUQPocKGxb4LEKK3y48
ZpLTSMk6UpGAMnc7DxrPSlKUpXEWS9WE8SXfh25toTfp8t5Mhp1jUJTASSzlQBTpDGkaSQc
hWRkknt6/9k=
</binary><binary id="_84.jpg" content-type="image/jpeg">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
opUyRuVhgjI7HR+K3pSlK/9k=
</binary><binary id="_136.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCACpATYBAREA/8QAGg
ABAQADAQEAAAAAAAAAAAAAAAUDBgcCBP/EAEEQAAEDAwICBwYDBwIFBQAAAAEAAgMEBREGE
hMhFBYiMVaU0gcVNkF1szJRYSMkNVSVtNM0QhdVgcHUJTdSYoT/2gAIAQEAAD8A7MiIiIi1
Wi0/ZbrftRT3G0UNbK24MYJKimZI4N6LTnGXA8sk8v1VDqZpXw1aPIxelOpmlfDVo8jF6U6
maV8NWjyMXpTqZpXw1aPIxelOpmlfDVo8jF6U6maV8NWjyMXpTqZpXw1aPIxelOpmlfDVo8
jF6U6maV8NWjyMXpTqZpXw1aPIxelOpmlfDVo8jF6U6maV8NWjyMXpTqZpXw1aPIxelOpml
fDVo8jF6U6maV8NWjyMXpTqZpXw1aPIxelOpmlfDVo8jF6U6maV8NWjyMXpTqZpXw1aPIxe
lOpmlfDVo8jF6U6maV8NWjyMXpTqZpXw1aPIxelOpmlfDVo8jF6U6maV8NWjyMXpTqZpXw1
aPIxelOpmlfDVo8jF6U6maV8NWjyMXpTqZpXw1aPIxelOpmlfDVo8jF6Vzz216fstq0dST2
60UNFK64MYZKemZG4t4chxloHLIHL9F11ERERFFsX8X1H9SZ/aU6+243NlBw42wTVdVNnhU
tPt4jwMbj2iGhoyMlxAyQM5c0HWb3riQWKeotNvrHPltEVXBK1rHPZLUO4dOzh5O5xduJ7w
NuO1nCzV/tHs9uo6eSamrHVk8r4226MRuqcslMJ7Ifh3bGAGkk8yAQ1xFa0X8Xmrq4obXXQ
wUk8sBqp2sbFK+N21wZh5cRnPPbjkRnIwp8mvbUy2uro6esmDaFlbwomNL9jmGRwPawHMZt
c7JAHEjAJL2g+KjX1JFAyeGz3SqiNrZdZJImRbYYHBxG4ukHaw13ZGScHGcFZ6fWFP73tdl
qaepNZXtkZx2RsbCJombpWfjdzaeR2lwBy3cS12ItDqu63XR9QZGVNsu8zYZqSX9jIwNqp3
NpufPLQNrXZaHYBIGcKg32j2eoqK+Ogpqy4RUEQkkqaURuhIMgj/ABl4DcHc7L9o2sc8Etw
TtMMjpYI5Hwvhc9ocY3kFzCR3HaSMj9CR+qyIiIiIiIiIiIiLmXt6+B6P6kz7cqzWG/3O83
ypF4dcYrO6Kpc2mqqOJ8VaHOcY44SyJ3FaIRuOJHF55tDmgk1LZWVsOg7HDBHcaLo8UNNcH
toH9IgDYeZZG9hL/wBoGNJDHDDnH5ZEu5u1DRXKW40lLWUt6rLbQF9PR28TU1VUh8gkZLIQ
Q1rQWjdxGkNOcuwAqlNea2TU1wt9xo7jU2eWKoBFTb3vALCBsbsgDSxzeJjLpC4Bn4XHa6t
oqQu0daoHwVMEtLSQwTR1FO+FzXtjaHDDwMjPzGR+quoii2L+L6j+pM/tKdZrxp22X7Z7wi
mfsikh/ZVMsO5j9u9rtjhuadrcg5HJeOq1k6bHVmgYZIXQuiaXOLIjE1zY9jM7WhokfgAAZ
Oe/BWG36MsVqNMbfBU0opmhkbYq6drS0PdIA4B+HjdI84dn8RHdyVO3W6ltVE2jo2vbE1z3
9uV0ji5zi5xLnEkkucTkn5qSdDad9101sbRzR0lNFLDHHFWTM7Erg6Rri14LmuIGQ4kcl9l
Zp22V/vDpMUz/AHlEyGqxUyt3sZna0YcNre07IbgHcc5yVh6o2XiVbzTTO6ZFPFK19VK5m2
Z26UNaXYZucMnaAlJpGy0NDHRU9NMynjqY6prDVSu/aRhoZkl2S1oYzDT2eyOXJKfSdrpaE
UVO+4xU7dmxjLpUjYGghoaeJlrcHuGAcDlyGK0MMVNBHBBEyKKJoZHGxoa1jQMAADuAHyWR
ERERERERERERcy9vXwPR/UmfblW52/SFitddHWUdDw5YOJwGmV7o6fiHL+HGXFsef/qBy5d
ytIiwVj6plK91FDDNUDGyOaUxMPPnlwa4jln5H/upnStVf8mtH9Vl/wDHTpWqv+TWj+qy/w
DjrllbqHWMOqqiLSlTWXGo6c5two+LJWU9O7f2Y8yQRiJmd4y13c3vG0FdG0VLcpheZbxTQ
01e6ujNRFC/exjuiU+QD/2547su7zs6IiIiIiIiIiIiIiIiIiLmXt6+B6P6kz7cqzVtk1cy
svux1xqGT01X0R0Fe6McV8zHQbS6flsbkHDIwA1ze3kZzy23UjbfcJ7fb7uyanqS+ho626l
3SIpKdsTmOe2ckbZMyjJyMANILiRvNFTdDoYKXjzT8CJsfFnfukkwMbnH5uOMk/ms6IiKLY
v4vqP6kz+0p19V9uUtptEtbBTsqJGOY1sT5TGHbntb3hriTz5Na0uccAAkgLWLdr+tuMsob
ZqZkdJV09JVk3DL2PmlDGlrOHuIAc0neIyDubjLCqFJquqmdtqaCjpf3atkMj648Nj6aYRO
DnGMYYch2/GQM9nlz+aXWlzNklr6OwsnnpqtlHPTS1MlO7iSGIR7OJECQeM3JeGYwcZGCfd
drG42y9UtrqrNCXy9G40kNRLIyPjTuibh3B28tue2WZzgZwtpjMpfIJGMa0OxGWvJLm4HMj
Awc5GOfIA554EabWNppoJJ547pFFE0vkkfaKtrWNAySSY+QA+auoiIiIiIiIiIiIiLmXt6+
B6P6kz7cq6aiIiIii2L+L6j+pM/tKdU6yipbhSvpa2mhqqeTG+KaMPY7ByMg8jzAP8A0UO7
6Mt9XTUgtVHa7dU0c8UkM5t7XmNrJOJsbtcwtBd34Pc53zOR950zYDVS1RsduNRNv4kppI9
794Ifk4ydwJB/PJysPUzSvhq0eRi9KoVVst9dPTz1lDTVEtK7fBJLE17onZBy0kdk5A5j8g
s0cMUT5HxxMY6Z2+RzWgF7sBuT+Zw0DP5AfkpOs/ge/fTaj7blaREREREREREREREXMvb18
D0f1Jn25V01ERERFqtFqCy2q/aiguN3oaKV1wY8R1FSyNxb0WnGcOI5ZB5/oqHXPSviW0ee
i9Sdc9K+JbR56L1J1z0r4ltHnovUnXPSviW0eei9Sdc9K+JbR56L1J1z0r4ltHnovUpOrNW
abqdHXqCDUNrlllt87I42VsbnPcY3AAAHmSfkq3XPSviW0eei9Sdc9K+JbR56L1J1z0r4lt
HnovUnXPSviW0eei9Sdc9K+JbR56L1J1z0r4ltHnovUnXPSviW0eei9Sdc9K+JbR56L1J1z
0r4ltHnovUnXPSviW0eei9Sdc9K+JbR56L1J1z0r4ltHnovUnXPSviW0eei9Sdc9K+JbR56
L1J1z0r4ltHnovUnXPSviW0eei9Sdc9K+JbR56L1J1z0r4ltHnovUnXPSviW0eei9Sdc9K+
JbR56L1J1z0r4ltHnovUnXPSviW0eei9S557a9QWW66OpILdd6GtlbcGPMdPUskcG8OQZw0
nlkjn+q66iIiIiIiIiKLrP4Hv302o+25WkRc19sdbW1dqj03bthdPBNXVpznh08Dd43AAkB
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
</binary><binary id="_60.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAfADIBAREA/8QAGQ
AAAgMBAAAAAAAAAAAAAAAABAUABgcD/8QALhAAAgEEAQMCAwgDAAAAAAAAAQIDBAUREgYAE
yEiMRQVFgcjJDJBVpTSUVJx/9oACAEBAAA/ANm6zjl1RTNzOtrJ+N0d9pLLZGeoGsLPFI7l
1Em58KEiYjALDuE4O3Vg43cI7bY+P0dRN8TLdt2gkpYHWnjDK8wRdvyIqehFPnCj0gA6r+Z
rHX8u49bzZaa9LAtRWVVMVhaZY9BGuBIyrqXcEg+5jBH5ehuL8npbXxSK8SUn4G4yy1a09t
jHbtsClI2GhKuyqfU7RoRsznGCCdA6nSX6z4r+5bR/Oi/t0mEv2diqulT89tzS3eJoq0teS
wmUjGMGTAwCQMY1BwMDrm9dxanFjgtfLrLS0donMghmrBOzqUaPQO0oKgLI+M7Y9P6DBK+Y
cC+ovqD6ht3zHtdnu/N/Tp/rp3Ndf1xjGfPv56WSRcFitdHZqDkVijtENSKiajqa9p1kwwO
ozOAFyCdWDKSQdc+9m+s+K/uW0fzov7dT6z4r+5bR/Oi/t0FeL5Ww8qSz0dzt1GiW2SvqGr
KR5O0quqhiwkRdTlv+aHPuMM+OXV71Yqa4umve21YRtGJVDELIFbyquoDgHOAw8n3LToKzX
H5vY6C59rs/GU0c/b2203UNjOBnGffHSzkN3raO82S1W6ro4Ki5yzLippXm9KRlyw1dAMEK
ME+dwR+U57cYvT3uhqJmlhqUgqWgjrKeJo4qoKBl0DE+kMWTIZgShIPnAddUW68MuV9unI6
i6UloqEraH4a0vId5KMqrhT5i8bM5ckEkEADbAIluqhbeZ8ctN4rN718kmglCzSypKQ8ZV8
sANmEMrE4B8YJOFzbbjaqa59v4iSsTt51+GrZqfOce/bZc+365x5/z0s4hx4WSx24TGsWsS
hiinilrpZY0YKuwVC5QYIwNR4HgeOhblxytvHNoK250VrrbFT0jwRU9R946yMVZpdTHjPoV
cbe3nPkjquXGgHF/sqpbXy6a3VEtPK0FM07SzQyllfTYiIyJqrNjTB+7UBlBI60O2UstDaq
Sjnqnq5aeBI5Kh87SsqgFzknySM+59+v/2Q==
</binary><binary id="_126.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAgAM4BAREA/8QAGQ
ABAQADAQAAAAAAAAAAAAAAAAUDBAYH/8QALxAAAgICAQQBAwMEAQUAAAAAAQIDBAURAAYSI
TFBExQiFSNRB1aT03EWM2GBwf/aAAgBAQAAPwD0+XqfFQ58YJ5LJyBVX+klOZh2EgB+4IV7
dnRbegdgkaPIfS1O7X6uyVwz5GxDeiZrK5Cu6GpIsrGKKJmPa6BZJAezuXabDAOBzs+ORen
rOSmnzFfJ2obMtS8IkaGD6SBTBC+gpZj7c+2Pv4GgLXHHHHHHHHHHHHHHHHHHHHIVfB5CPq
2bOTXaMiywCsI1ossqRKzsqiQyHyS47vx03YPA5d5Im6T6bszyTz9PYuWWVi8kj0o2Z2J2S
SR5JPzyhTpVcfVSrSrQ1a8e+yKGMIi7OzoDwPJJ/wDfJmFxOVx+Qv2buSp2kvSiZ0hpNCVc
JHGNEyt+PbGPGt7Pv45a445x+VzcVfrihHRyDzzidKd/HraHciMjMrrAddw3JGzyKSVWPQ8
d/Ow5q4y/FlcVUyMCusVuBJ41cAMFZQwB1vzo82uOOOOOasl6KCeyJ5q0UVaBZpHaYBkUl9
s4I/FdJ4bfnTeu3ztcn1slLNn72Mkroi1oIJ45VlLGRZDINFe0dpBiPydgg+PXKHHHHHJdH
MSXM5fxkmPmq/ZxRSLJK6H6wdpFDKFJ0v7XjZB8+QNecP6Fkf7sy/8Aiqf6OSaMtm9mZsV/
1H1BBLGrvFI8NFop1ST6blHSJhtW0CraYdw2Peq36Fkf7sy/+Kp/o4/Qsj/dmX/xVP8ARzD
gHiyEz2qPV1zL160pikXtrGJm7AddyRKToOp/Fvfg+iOZuocLczH2/wBpkfs/pd3d+Vgd+9
a/7M0XrR979+Ned4cB09fxN57FrK/do0RQJ3Wjo7B3+7YkX4+FB8+/YM/rnDfrl3DRv09Zy
UFK2tmWSI1/KBX3F+64JBYR9w1or87HOshhirQRwQRJFFEoSONFCqigaAAHoAfHNbI0bN36
f2+WuY/s33fbJC3fvXv6iN618a9n3yT0Vir2P6cxRt5G85GPhQ0rEcSrA3Yvj8Y1fa6I0zH
/AM7Pnk/qHp+LNdc4q5c6ZmuVKMUsck5FZo5S/YE7ld+5kTcp1rYbRAO/PTQZNJ8xcxn0Jo
5akUUpd+3skWTvAK6JPgxsDsD18jzyT1dSmvS4hFw9nJ1oLbTWY4ZY02n0ZECnvde4EyDa+
QVDA+Do8xS6OuY3P2ra4q88seQNivNVlpiIwAgpEruv1owIwIvpghDrXcqsSFDp5kfCvkv6
fvaani/tLbOtJzNKBCqN+Uv5ACNwCfIDDQ8nme3gctb6c6Wx9nD2WipVDHdhRakzrIiIiaW
ZzFo6Zu/TMANDt7m4xFLLRT4+3leirMtoYuWjkpBNUla4xMIVnZpQXBWJt93ru1598wdP4L
O46pZx1Ppx8Q1zAxVHvLPAgS5Gso+oRG5YhjIPzH5bUePkLXTuSu43N1sd0o+CGQx9VWggs
V4VkeOV2mjDxk+XR+0My6Oj3ADwSdMWa0tQR9O5SegLYmnqNJRh8LDMh/bhKIQxlQHZJdUZ
WAAUN6H2JRo9lWrtIItRV4Aq+FHhFBIUetDZA/45y3QfTkGFOSnfp98bas25pVklFc6idyU
iQxsSqqqptT47idb+LlzFXbNp5oeocjURtahhjrFF8a8d8TN59+SffNqhUmpwNHPkbN9i3c
JLCxhgNDx+2ijXj+N+ffIX3WUrdVZC6vTWRnry1oK8bxy1vyMbzEtppge0iRdb8+9gc00y8
17+pcuNrdWQrRhrI5oxvXMj2A7BoxtC3aFjJcb7gWHkD1coYQ1s/fzNlq09myqxRSJE6vFE
pJCbaRhryCewICQSQSfCaz1Is8ggxOLeIMRG75ORWZd+CQIDo6+Nn/k8oU3tPVRrsMMNg77
44ZTKg8+NMVUnxr4H/wB5z/S+ZxWQzfUMdLJ07TyXlmRYZ1csgrV1LAA+V7gRv1sa50/HHH
HHHMccMUTyPHEiNM3fIyqAXbQXZ/k6UDf8AfxzJxxxxxxxxxxxxz//2Q==
</binary><binary id="_135.jpg" content-type="image/jpeg">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
</binary><binary id="_160.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAALAEMBAREA/8QAGA
ABAQEBAQAAAAAAAAAAAAAABQYHAwj/xAAoEAACAgEEAQQCAgMAAAAAAAABAgMEEQUGEiEAB
xMUMSJBFVEWYYH/2gAIAQEAAD8Atq+vS7i3JoT6fUvVaXGza+RYlMSW4FURjjECSwLSxuDI
FIAyPs+H+pe7Kum0xBX1KmbOmWatyzRMoEtgCVWSIAg4zjmSO1CL0Q+fE94Nam13QqVanqN
lG+RPZWhqBrOYkVVxj3EDfnJGc8sjicfZ8Q25QNZ5rHybKtLBAk9Ce89s05wGdxzd27IkQY
GBhQf352m3LQgnkhevqhaNipKaTadSQcdMsZBH+wcHxCnbjvVUswrMqPnAmheJ+jjtXAYfX
7HkHdne36garFLDuB4IGp1Ioqdu0ld3k4mWUtH+MZSN0PEkA4J+2yE9doW6OkaPo0Fm9bkt
6yqCdb0sUscBeSZwX58nCwqyYLZPRHYA8Zl3Dt7R3Gn2tdo15a6qpjtXl90DAxy5tyJIwcn
s5z5592ru/Xf5uOT52HpaRYhgYRICqQ1pmjUnj2obBwcgkKTniMU25NXv2fQehemn52dY1J
vnSlF5T4eUjPXWPajAxjAQAdDHk/uDfW5aO7YtVralwuNpFSIy+xGfxeGOVhgrjt2J+v3j6
682b0wuT6nsSnqdyT3bl2WaWxMQA0je6ygnH9KqqP6CgDoAeLTbT23Znknn29pcssrF5JHp
RszsTkkkjsk/vxCnSq6fVSrSrQ1a8eeEUMYRFycnAHQ7JP8A3zLPQrV7+p/5H8yf3edmO03
4KuZZefNuh++C9fQx1jwz1l3Hq2ib90ibTrfsPSomWA+2jcGkZ0c9g5yqqO/rHXjuy9l7f3
ttWpuPcdJ9Q1W80rWLL2ZVLkSMo6VgAAqgAAAAAef/2Q==
</binary><binary id="_94.jpg" content-type="image/jpeg">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
</binary><binary id="_212.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEBLAEsAAD/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8
SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFB
EUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/w
AARCALNA3cDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QA
tRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2J
yggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eX
qDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2
uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL
/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvA
VYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dX
Z3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1
dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDtvEyqL63H2jYcEeWO43tU
mqaTa3VrNYXGnytbyQk+fjK5xUHi2G2muI5DLtnVSU9/nasoX94tsY/tbhOnlljg1rFe5qR
JbM8J0S/uvA3jJostHZyOQ4XhXXPH5V7pBqAvtHa/smm8sKGjcniSuE8Z+HhrdjMkUKJNGu
+GRSPmrE+EXiqSIS+E9TnZVHMDMeN3TH51UGnGzJmr6no2m61d38TtKskYUbQp9K8h8UpqH
hPxgus6e0lrHK/mZHAbnBBr2O0ZirgwCNkPGD1rJ8YaIviLw5NBLHidcvFxzxzSqRUdTOD1
Zr+GPEk2t6fFfRzsVkTJUfwnvWqby9wM3DsCa8Z+C+utpus3Hh/UG2M+VQHsyjkD6mvd/Ds
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
</binary><binary id="_173.jpg" content-type="image/jpeg">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
</binary><binary id="_128.jpg" content-type="image/jpeg">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
</binary><binary id="_206.jpg" content-type="image/jpeg">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
</binary><binary id="_105.jpg" content-type="image/jpeg">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
m0elO/cU7Lqr5zaPSnfuKdl1V85tHpTv3FOy6q+c2j0p37inZdVfObR6U79xTsuqvnNo9Kd
+4p2XVXzm0elO/cU7Lqr5zaPSnfuKdl1V85tHpTv3FOy6q+c2j0p37inZdVfObR6U79xTsu
qvnNo9Kd+4p2XVXzm0elO/cU7Lqr5zaPSnfuKdl1V85tHpTv3FUrq9qq2Q25HtS0O75LDG3
2Y6nHVdQ3n/iPdvzj34xxV3suqvnNo9Kd+4p2XVXzm0elO/cU7Lqr5zaPSnfuKdl1V85tHp
Tv3FOy6q+c2j0p37inZdVfObR6U79xTsuqvnNo9Kd+4p2XVXzm0elO/cU7Lqr5zaPSnfuKd
l1V85tHpTv3FOy6q+c2j0p37inZdVfObR6U79xTsuqvnNo9Kd+4p2XVXzm0elO/cU7Lqr5z
aPSnfuKdl1V85tHpTv3FOy6q+c2j0p37inZdVfObR6U79xTsuqvnNo9Kd+4p2XVXzm0elO/
cU7Lqr5zaPSnfuKdl1V85tHpTv3FOy6q+c2j0p37inZdVfObR6U79xTsuqvnNo9Kd+4rapS
lKUrF1bNft9gVIjSHo6zJjNl1hoOuJSt9tCtqSlW5W1RwNp591efsesTD0pLvtxmTLvEeuS
mLWoR2kSJbZKUJSltO3Kt4c8wFEJJwPIabGt0Soq3Y2nb648w11ZERUVLTzKSVBJ2rWnfu2
Kxs3eWDg8VI3q5YiXeTKsU6Mm1vttKQXGVKXuShRJwvakJDgKiVbQnnP6gntnWEaXZ4Fxh2
+ZK9oSXIzLDSmSsqR1Co7upsKcNKIIUc8Y86qr19EEu3QW7PdHZtwVIQ3HShoFKmVKS4CtT
gRkFCuAo8YzjIz2xriM/Z5lz9k3FtqJBanlC+jvcYc3kLThwjgNqJBIPHkTxSTqg2hd3enN
PSI8e5IjN9MtNpZSYzTmVrWpCQncpQypXmtIHmBVrvS26xa3IVrnTVXSIZjTbXRSpDYDed2
9xIz+KngE++t2lKUpWLqv/lDH/coH/ltVtUpSlKUrxGstXXOyT5UW3S7Wh9qIw7GiSmXHHp
rjjjiChsIWDkbE4ASeVckDkejk6jtMO6NW2RL6ch50MoJbX0+oU7ktlzGwLI5CSQogjjkZr
R9TMtW1Mq4haVO3CTDZRGjuPKWW3XUpwlAUrOxokny4PlUzWp7U+/FZYckvqlsNSGi1DeWk
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
</binary><binary id="_175.jpg" content-type="image/jpeg">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
</binary><binary id="_66.jpg" content-type="image/jpeg">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
Gf1HsP+Wx/wDrTW1SlKUpSlK//9k=
</binary><binary id="_59.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAiAHEBAREA/8QAGg
ABAAIDAQAAAAAAAAAAAAAAAAQFAgMGB//EADMQAAICAgECAwYFAwUBAAAAAAECAwQFEQASI
QYTMRUWQVaU0gcUMlFhInGRMzZ1k7PT/9oACAEBAAA/APZuOOOOOOOOc/4XqR0bviGtC0zI
mSXRmmeV+9Wue7OSx9fiedBxxxxzz/L+KooPFebpTeJMjSWhFWEFGtDWeWzNICSkKtGzPvc
X9mZt6XWu2xkl2XFVJMjCkN14EaxGh2qSFR1Adz2B38T/AH5hkczisR5ftPJ06Pm78v8AMz
rH161vXURvWx/kcwoeIMLlZ2gx2Xo3ZVXrMdeykjBdgb0pPbZHf+eL/iDC4qdYMjl6NKVl6
xHYspGxXZG9MR22D3/jkX3z8K/MuI+ui+7j3z8K/MuI+ui+7j3z8K/MuI+ui+7j3z8K/MuI
+ui+7lZjMj4FxFqazU8TU/Nn/wBUzZxpg50o2Q8hHVpVG/XQ1vXLP3z8K/MuI+ui+7j3z8K
/MuI+ui+7j3z8K/MuI+ui+7j3z8K/MuI+ui+7j3z8K/MuI+ui+7lFZ8A5C/4bz+Hv59JmzV
tbfniowMLBkJUAyHa6jVVGx0gep7aG/nbnjaxi6OVsyigtJ7ixwQJWiZiWlU9YMunjUFelm
0zaLAenVZHFVsn5f5iS4nl76fy12avvevXy2Xfp8d67/vzChhKmNnaaCa87MvSRYyE8662D
+mR2APb11v8AzzXmsxJiFqsuPmspYsxQPKjoqQ+ZKkYLbPUf19goPp3168m3LH5aq8gaEP2
WMTSeWjOx0iltHW2IHoT37A+nKzO5u1jchi6NKrTs2MlLJGiWLhhI6ELlgAjkrpSCfgSv79
t2DzHteO2rxwpYo2WrWBBN50YcKrEK+lJ0HAO1BDBh8Nm05FqX4rlm7BGrhqU4gkLAaLGNJ
Nj+NSD9u++Rc1mJMQtVlx81lLFmKB5UdFSHzJUjBbZ6j+vsFB9O+vXkrJTSwY6d68taOyV6
K7WmIiMrf0xhtd9Fio0O53278r87m7WNyGLo0qtOzYyUskaJYuGEjoQuWACOSulIJ+BK/v2
3YPMe147avHClijZatYEE3nRhwqsQr6UnQcA7UEMGHw2bTjjjjlF4rF6WjXgo4uzeb83XnY
wvEoRYp45CD1uvchTrW+4765NFuaxkakCxvABAbFlDLGXjJ/pSN1HV2YmQ9SnW4dbIPfn8v
iLub/ECk93E2fZFCpKsF2C35LrYk6Sx2kofp6F6PT1Y7BGiKjHHIeGPw1w1bNzew7NPJVop
B5sCJPGbCkjakjp8skt6Mehi2wT1egXIJLNV4Ybc1R21qaEIXXvvt1qy9/TuD685zB4PJQZ
jLyy5zKeX7QRwHhrhbSivDsk+UO2wU2hH6f32eTfFYvS0a8FHF2bzfm687GF4lCLFPHIQet
17kKda33HfXFyRsnm8RSaF4liU5CzE5DdBUdMUcgUldl3LqdkdVc63ra1mXxF3N/iBSe7ib
PsihUlWC7Bb8l1sSdJY7SUP09C9Hp6sdgjRFLVr3sF+E9SlnFfFXKbPEqRZCKm07EP5fRKk
ioD/AFBiX6t9DkoxIPMPYX4y/NmI/wCpf/hz03jjjjmsQxLO84iQSuqo0gUdTKCSAT8QCza
H8n9+bOOOOOUtX/fGU/42n/6WuXXHHP/Z
</binary><binary id="_158.jpg" content-type="image/jpeg">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
tKUpSlf/2Q==
</binary><binary id="_85.jpg" content-type="image/jpeg">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
</binary><binary id="_193.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAA8AVsBAREA/8QAGw
ABAQADAQEBAAAAAAAAAAAAAAUDBAYCBwj/xAA8EAABAwMCAgQJDQEBAQEAAAABAgMEAAURB
hITIRYiMdMUFUFWYXWTlNIHFyMyNTZCUVRVlbO0gTNSkf/aAAgBAQAAPwD7NSlKUpSlKUpS
uS0zYItw0raZsqZd3JEmCy66vxxLG5SkAk4DmBzPkqn0Ut36m7/zMvvadFLd+pu/8zL72nR
S3fqbv/My+9p0Ut36m7/zMvvadFLd+pu/8zL72nRS3fqbv/My+9p0Ut36m7/zMvvadFLd+p
u/8zL72p96sse1RY0yHLuiXU3CGjr3WS4kpVJbSoFKnCCClRGCPLXVUpSuf1RCi3Cbp6LNj
Myo7lyVvaebC0KxFkEZB5HmAf8AlZuhmlfNq0e4tfDToZpXzatHuLXw06GaV82rR7i18NOh
mlfNq0e4tfDToZpXzatHuLXw06GaV82rR7i18NOhmlfNq0e4tfDToZpXzatHuLXw06GaV82
rR7i18Na1mtlvtWsbsxboMaE0q3w1luO0ltJVxJIzhIHPAHP0V0dKUpXzyAbgi8+PHnLoxb
bdLublwkv3BS47zSHHUoQhgKUcpwPwoA2H6xKa2Y+tNUTLMxcU6SZhNSXYng7si4pW26h5x
CPwJ3JV104ynABJPNISqhC1dcbnqSVBt2nly7VDlmG/ckS0JLbiUgr+iWASEqVgkE5AJGey
s9tdueqbVbbhJbRa2FqYmtCJNccW4jaVbF9VAAOUgg7wRuGAcKHuz6leueoJ1pkQ2Ya4u9S
UOOuB5xAcKEuBCmkpKFbSdyVqAykHtrVvOsJFmavc123xjb7OoNLdVLWHXXC0haEhAaIAKn
UJyVcuZ8mK8RtU6lelR7fI0f4HPkcRxKXrk2WQygJ3LK0BSt25aE7dn4s55HG1bdS3CfJbi
m1xm3XWJik4mKUnix3wyUk8MdUlSSFYz29XlzlxNf3G6zY7Fm0yu4pESLJnlE1DaopeTvCA
FhIcITzyCAc4OKyTNbXFtnUDbVuhsS7VGfkNMyn3UuOoQtSQ5sLQCkEJKsoWRnakkbsihO1
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
</binary><binary id="_177.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCABBALMBAREA/8QAGg
AAAwEBAQEAAAAAAAAAAAAAAAQFBgIDB//EADQQAAICAgEEAgIBAgMHBQAAAAECAwQFERIAB
hMhIjEUQRUjUSQyYQcWMzU2dbRScYGzwf/aAAgBAQAAPwDeVDlLXZr5zFok2YykCWV8jhSI
2PJYVYgqCkbFVJXiX+TL8m3Px2SxGKy0mRmyOdoeKIVJsRk3nnZpZJSInjBZ+bHxyAeMuCP
frR3s6VyDIUYLtWTyV7MSyxPojkrDYOj7Ho/vrH9zYyf+XxkMeYsi7lsoOSLkLECpVjQu6x
xo+t8YwC2jtpCfjscXcU2Cs2cz2wuTs5JZmkEkEzzyCJBHEksQnYnkQWBIDbUya0NdVu3bk
93DRtak8tiCWWtLLoL5WikaIyaHpeRTlofW9e9b698zkf4jB38n4vN+HWkn8fLjz4KW1vR1
vX3rqLYx+Zods1Yq0P5l6WWNsu1efxTWNgCVopG0A2wNb46QcVKELxmYrP4DBNbyVjM5eOG
3wjGNyS2JZqkkcRkl0rcn48HRmPtRrfIggDddYW1h5W7vxOL/AJm5K8sVm9kwuTsxMy7Cos
cayajTnJ6H9o9cjo8qBxsOX7Ry2CoZZ7tmtPNFHZeeTlXsB/LEpk2WJjLRjez/AJdH3sdXc
Nkf5fB0Mn4vD+ZWjn8fLlw5qG1vQ3rf3rpXui7do9v2JMdwF2Zo61d3OljklkWJXPo+lLht
aO9a6n5+taxlGnDj8dcs4mLyNdhx9gpbY65KysWDPtuRbTB2Yg7YclZbBZzBYcmp/P3rpyV
tpKsVxJ5Jq681g8bcgWRRKCoL8fZ17IJOsmErQSCB0SUqRG7oWVW16JAI2N/rY/8AcdYmng
0l7zmxaZfIz0cbjYjZ3mbXmexI54luMgA+EZOgF/4gOiCNF+9Wn7M8lO9NeyfavgszGz5qs
zGJAXLqw5DyReQfIEHmfvRI3XR0dHWVx3b838VTws969Wnwc5apciSM84eMkcXtkKMRE3Fh
xBDLv6KszVnt6eJql6pN+dka1nztJekCGwPFJEELImkVRKSAqa2D627N0YXGZbHZBFln/wA
G0ViaeIcDH55rBlAQ65niGdSW0CChC75Ae1vttbncVXNSZO4JafIQQiOAxxhuIcDcZYcuI2
eW9EgEA9T2xeQxrrPJCk9LGW7eTjNZmexYaQTHxCLiACPOQDzO+A9Dl8bWCoS43ERQWGRrL
s89gxklPLI7SSBd++PJ21v3rW/fXtk6EWVxVvHTs6xW4HgkZCAwVlKkje/ej1GrYq9lIKFi
5kb1DL46B6liaCOLjMzCMuw5xspViisCoGtkEAgqO5cHax96rkcUsNuzHFNHP+bOYmnMpiJ
kZ1RvkPCqhQoABAHEKF677bxeRw4NCe289CpUq1q3NEXbohEjqF9hW+HpiSGD/rRPcHbaw9
zPnmydyWw8XhMckcHARbZhGCIw4UFt/wCbZ0uyddJSwZzH1+454YoVsZGypx713aZo2aOOB
XkUoAFUortrloFvvj8ruMoRYrFVMdAztFUgSCNnILFVUKCda96HSvceMny+Cs1Kk/49v4y1
pTrSTRsJIydg/Hmq79H1vpY4p8pbOYrZHKYieaBIJoVjh3/TZyARJG/sF39qeJGiCRolLJ9
rWCl6pikrLVymPFCdppnDwDcpMo+LeViZ2J5MpJXZY8iRaqR5EZvISTzOaDLEtaNwnxcBvI
V4jfE7T/Md8lf0BrauH7bXEZS7kf5O5cmv8TYNiOAcyqhVO0jU+lXQG9eydbO+oU3bV0Yq5
SeJ69nOTx05GrT+eKrSVSTGu4kWJRH5UX4H5SLtiTsbfrzkjZ3jZZnQI3JlUDUg0Ro7B9bI
PrR2B71sEEbCd5DM5VlVRGQOKkE7I9b2djezr4jQHvc+5irtm080PcORqI2tQwx1ii+teuc
TN7+/ZP31Mj7nde2LndUkc0lNtmtXELKFhDlVmb4l+LDUjHieKa0pIJf3wtzOW8lHLJdxGT
ws1Z2S5QjZCJlcDj7kcFdcvY/akHXreg6yWey/c+PtVzWWmkV7JR0qsDUnnkCkbaV2WZQFA
SRwAD8Qu9EtxrVY89NQyVa7ZrQWuTR07levpeJjUiTxs7e1csNE++P+vXfbeVfNdu0shMnj
sSxasR+Nk8cy/GROLexxcMPf9v307duQY+jYu2pPHXrRNLK+ieKqNk6Hs+h+us/Y7gtYztm
rlMkfxpsjLGD+RERDjfIBoS603FfoliOTtrcan4O4KfOT2rRyUuOtUGihkoXKKMgmDBuWwX
b60pBB0QwO/sC11j7OV7sjzeLx4ajC2UaxIEOPeX8SGMbBldZwC3yjU6HHkx0TocqF6buSP
s65YHhTM1vLJGsNcuk4jkJRRHyJ/qIoGuWxz9ex1ZpXIMhRgu1ZPJXsxLLE+iOSsNg6Psej
++ls9llweEs5EwvO0KgRQICWmkYhUQaBO2Yqv0fvqZmc3L2/BQqW8lWhnus4OSuwla0bAcu
JCsNEjYRWcelJLMw07+DbOGO2mdWn5Y7LLXkqKypLDxUqxVmYhtlgRv8AX7GiaE0jRQSSJC
8zIpYRoQGcgfQ5EDZ/1IH+vWThyPd79xx4OS1i1lXHi5YnTGStDExfgsYbzjZJEh2QvpPr2
dO5bJ5fG9r4/MWuFaes1eXKwJAZl8Z0s4HEkgJyL7BP/D/YJ60fR0dHWSwX85F2riadGOmL
mIl/DvVpp2RZFiRoxpvGzLy/pSj4jake9H2rm+3jD2v3PdkoJDeytQo1XEq78nHPgSUVWkZ
nkPIlQOOgQQCzaOLLvPnIaMdbdeWibRmJZZIjyAVXjKgpyBYjZ2SjjXxPSGUxmau93Ym+kd
b+PxrSMF/OdWkaRAhdo/EQSimQAcvfL7X2DIx9KPGdxHISVpoL4vXJcpesRuIzSPMxjzN8C
oCVtKrbUA+h8+tB2jFaj7cgku1/xrFqWa28BJJh80ryhDsA8lDgH0PYPTXcFCXK9uZPHQMi
y26ksEbOSFDMhUE6362ep8WRzmSq4zKYutTMUtZ/y6Vmy0ZimJT1yEbHkhWVCCF9n2NjQkZ
HBQ4Pt+Mx0nSSbM1Lr1cVXkaKIrJFyASNdsojjJJYaZvkACVUaepkpbObyFA10EVNYis6Sl
ubOGJRhxHFlAU62fi6H1vqZFjM0/fRzVmOsKSVGpxIl52KqXLmTxmIDk3GMEBhoKfbetK0s
gMMvd1xKlxzHeM8EdhJU/JYwxIqRu4+XKVGRQu/tQBoru72/QlxXbmMx07I0tSpFBIyElSy
oFJG9etjpXu6K1J25PJSr/k2KssNtIASDN4ZUlKDQJ5MEIHo+yOuLpy9yd5KEGLyuHuVI1W
OxaKKSS/I/GJw6urJ9nXx+vfUyTDw4Gz2rVhisyCvkJ5HNWtJ4IxLHNyJRNqiiSVQvL2qk+
9Bj1oKmSls5vIUDXQRU1iKzpKW5s4YlGHEcWUBTrZ+LofW+pmBxmar9yZbK5SOsq5BYlRYb
zzCFY10qKrRLoEtIxO/sj19k5iLFyVe3O4YcdAkS5po8bSpNBNV2xTxtYZGjUBirF3EcYUL
CfZ0SPpXXnIZQ8YjRGUtqQs5BVdH2Bo7O9DXr0Sd+tEBl87gogiCqVcOeRbZ2CNegBx0dne
z6Gvc+5Yz6WnWljMdNXGuEk2Qkic+ve1ELAe9/s//AJ1xFlqW72TaFIq0LCt+Vrck7o7IUC
gciBISqj7Zi2l0VLcUe4zazgw9nDZHH2GrNZRrIiMbqrKpAaN2HIFh6/QI/uN2us5ke84Mf
OyDFXrMX5aUo7ET1wk07EDgnOVSxDEqdDQKvv8AynTKZU5fE5ZFwszWKvOCTH3GiHmYxK4Q
srMnFhIo2T+zsdUMZfiyuKqZGBXWK3Ak8auAGCsoYA6370emuotXM1f405WOnxTIShqiRAG
a9tBwbj60zKuxs/FFBYrpgveIz4ymRu4+TF3sfZpLE7pbVNOsnLiVKOwYfAgnf36+wdV+sw
/e8QtVYIcJkZ/z5ZEpOj1gLQQMS6BpgSnFeQYgAgr/AOob97vcML9pWM42Imnipys01SYxi
RPDNxkYeypZODONH2VGiCetB14XbkGPo2LtqTx160TSyvoniqjZOh7PofrqeMiMfShU4p0u
WWkkjx1Uo0h23JmJJVAfkCxLceTaDMWXl3g84mbjtkUblGWnZatNDbRVcMFVtjizAqQ4IO/
f2PWj1QmmirQSTzypFFEpeSR2CqigbJJP0AP31nIu9HmvQ0V7ay4tz1jaWu7VVkEWwOTKZg
V9sBptHe/7HTVjO15MVhMymOexWuz1yjNwD1ROvBH0T97kVDxO9Ox9gEG70dHR1hcW2MH+z
TCY61hZrdCxEKd+CKnKWgdUfyM0aIW5CaPRIAIZuW/7u4+vkosfkXq5LLjHHxtVa4m7UWnZ
pigeJpGXiQqrIrMSpA0CrF3tfM2rGPoUs0Jo8vNWewVlqmIyRK/EOwG0VyGjLIG2pb6A6S7
gstc7xwFA0ZpadOy9mzI+PndFl8fGHi4Qp9ylid6Xh7II0TG5PLNmILdrIeapkMlcoR0lhR
EriLycH5aLM3+HfYJ0fL6A46LvY4g/3WiepD4aktm1LWURGMeF7EjRkKQNKUKkevojpnuyG
Wz2dmoIInlllx86RxopZnYxsAAB9kn9dTMrYwV3HYivJirNnDzwC1Uno1ZyazJ4zDxES84y
VckH46CkfvpZ487R7RsSR5TLsI5S1SU1kmu+ERBUDReI82aX3o8W4sCzKQw6v4bKvcjWneT
w5avWgkuwCNgkbSKT8WOwy8lcbUt/lI3vqMbLZD/aXWaSjN+Jj6MsUE8uPnX/ABDuOZWQpw
ChIgA2xvyaBbfp2vkP6Pc/87NDNRo2XVgYPgtf8eKQqV9lvTtv7379AaAZ7ThlrdnYWCeJ4
pYsfAkkbqVZGEaggg/RB/XS3fAg/wB1pXtw+apFZqy2VMRkHhSxG0hKgHahAxPr6B6V7nGN
u5EU8nQykbV4BLTyeOgsNLE8nkRwrwoeJACkgkhuQ2DrpbKyd2UO3Kk0Fm5NkxK/CJa8Upm
LSgxRzhUCqoj2HkV0CkEgvsdamHI1Z8jZx8bP+TUVHlRomUBX3xIJGmB4sNgnRBB99ZzAWW
yXfOZyM1GaJPxoK1GWbHzwuYl28m2kQD28mtAgnx7162ZOTmyk3aXddLNrZu1lgSCm9imOc
lp148I+KL5VEpj4SeNdljrYXfX0PrzklWN40YOTK3FeKFgDon2QPiNA+zob0PsgdAlUzvCA
/JFViShC6JIGm1on4nYB2PW/sbn3O4KVG09aaDIs6a2YcZZlT2N+mRCp+/0emqtCKlPYkgZ
0jsN5Gh2OCuSSzKP0WJ2RvRI3rbMT3cpVchVerdrQ2q8mucU0YdG0djYPo+wD/wDHXEONpV
545oa6RtFAK8QX0sUYO+KL9KPQ3oDfFd74jTXU+zg8fO9yeOBKt25A0El6sipYCkAbEmt7G
hr+3Ef26chhirQRwQRJFFEoSONFCqigaAAH0AP116dK0KEWNgavXZxAG3FESOMK6HwT+yg7
IB3rehpQAC/jMflYFgyNGtdiVuYjsRLIobRG9MD70T7/ANeu4qcENqe0kf8AWscfI5JJIUa
UDf0o2Toetsx1tiT79S5+3cVLDajjpw1vzZUkttXiVGs8X5FZDr5q3yDA/YZh++qnXnNDFZ
gkgniSWKVSkkbqGV1I0QQfsEfrrinW/DqpX880wTYV5n5PrfoFvs6Ghs7J1sknZPFrGY+9P
XnuUa1iWq3OCSWJXaJtg7UkfE7A9j+w67ipwQ2p7SR/1rHHyOSSSFGlA39KNk6HrbMdbYk+
/UtO3cVBHXhqU4adeCyLJr1oljjlcKQC6gaOjxYfsMiH9dVOjo6Ojo6Ojo6Ojo6Ojo6Ojo6
Ojo6Ojo6Ojo6Oovdf/KIP+5UP/Li6M7/zftz/ALk//iWOir/1xlP+20//ALLXVro6Ojo6Oj
o6Ojo6Ojo6Ojo6Ojr/2Q==
</binary><binary id="_192.jpg" content-type="image/jpeg">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
M9x7D3bH+WmrVKUpSv/Z
</binary><binary id="_76.jpg" content-type="image/jpeg">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
f/9k=
</binary><binary id="_131.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAMAFABAREA/8QAGQ
ABAAMBAQAAAAAAAAAAAAAABQIEBgMH/8QALBAAAgIBAwMDAwMFAAAAAAAAAQIDEQQFBhIAE
yEUIjEVFkEHIzIzQmFikf/aAAgBAQAAPwB+WGLU947mzvs3D3DFD2cTHkQYxBmjjLOJGkew
1yKpIBoIBVr1oNis+How0LKWaPM03kHSRWC9sySBDGWZmMQ4MiFiGKoCQARejjMpeQSIiqG
qMq5JZaHkihRuxXnwAb80OnWf13Ej+5duZnKbu+ueLj3n7delyDfbvjy/2q68XXRG4NNYbq
07VsWTGUQapCMrOZxLPjho+2MYJx9sbl0/usNMX415C+ta9quBuLTdI0/R4c36hFK4mkymi
WHt0W51G1L7kAP5LVQ8Wtn6hDpsCzTpkurNxAx8aSdron+MasQPHzVf96C2nuGHPgbHcai8
z52ZxebByFQKJ5SoMjJxWlAFEiq40CK6rbghkwdx5e4KSfGwtPhlyIotTmx5o0jeZy3aQcZ
QQSFDkAlWHgE9OaNt3TNv+p+mxTR+rl70/cyZZeb/AJb3sfcfyfk0Luh1gP0j1/K3brGq6t
qEcMWZj40GPLJjAxjLvlTyrfEuvCgQBQdh8UB6fHEsbyOpcmVuTcnLAGgPAJ9ooDwKF2fkk
9dOi9T29p+r5UOTlnM7sH9Iw508IQ0wsBHA5UzC/mjV11CPa+jxajJnR4rpJNP6iSNZ5BC8
vj9wxcuBa1B5cbsA/Ivqc+3tPyNYTVpDmerj/gy506oo9tjgH48TwWxVGvIPSnVXT8CLTcZ
4IWdleeaclyCeUkjSMPH4tzX+K6q523dM1LOOZlRTNK0SwyKuTKkcqKWIV41YK6+9vDAghi
D46//Z
</binary><binary id="_201.jpg" content-type="image/jpeg">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
KVQE+BuhJwPkk/Ov/9k=
</binary><binary id="_96.jpg" content-type="image/jpeg">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
</binary><binary id="_141.jpg" content-type="image/jpeg">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
K/EuI+ei+qnpn0r8S4j56L6q1sNk8flesctPjr62vYlx9mhkt5VkUN4lydbUnvojt++ujpS
lKUpSlKUpSoud/vfpz+JP/tLirVKUpSlKUpXK/pAhyGUwkXT+NiufFy86wS3MStxtoAQ0js
ew1xHHiWBbkQN9xUn9Dk2Sj6QXF5HHTWwteMttMY9RzwzAyKQ2yGYFm3rWgVB77r6BSlKUp
SlKUpSlKUpSlKUpSlKUpSlKi53+9+nP4k/+0uKtUpSlKUpSlKi9GfsPgf4bb/01q1SlKUpS
lKUpSlKUpSlKUpSlKUpSlKi53+9+nP4k/8AtLirVKUpSpfU15Pj+lcte2snh3FtYzSxPoHi
yoSDo9j3HvrD5iyPxZl/wrT8inmLI/FmX/CtPyKeYsj8WZf8K0/Ip5iyPxZl/wAK0/Ip5iy
PxZl/wrT8isNl0vdY+xgsrXqnLx29tEsUSeHaHiqjQGzBs9h76zeYsj8WZf8ACtPyKeYsj8
WZf8K0/Ip5iyPxZl/wrT8inmLI/FmX/CtPyKw2yZDH9VWllNmry/t7mxuJWS5jgHFkeAKQY
41Pskb2791dBXP9VX91j58E1o8IebJeCY57kwRy8oJtKzBW9rcdDR2wX/zXMZDqvqLF3t3b
8sRZTT5JkM+Supns7cLa27CIOEXTPyZhviNq47k7razXWGdsJb9YpMLC1td29o63AlZLQyQ
pJ4ssinfhli0YJRRsgkjRFWru/wAgemcXe3K4ueWW7sxOIg08EivMih4mPHR2yupIOiNd/t
VpdEdT5DqfHXpnv8W97EqlBZws0UYbnwcnxCWDcd8G8N10QQNg1Fwmdy80lnmRkLG7a5x+J
jvD5OT4hlupoyFKuAjLyYHsQWHsX2Vd6J6kzHUUl3Nf+aEhT2W1rLJ5VZtyI8OdHUet2I32
7qdAg7EKLrCXA2eRhS4tplGQvNNHbmQ2Tm9Kqs+5VUCQOzKzNGAEP2q3cf1Sr2WQ6nkdGY9
O2NxIbaEzKsnK55AIG2QrbBBYa0dsNEjCnXWXvOn1vrGfFmeC0yNzc7hMik20iBEASYhSyu
GJ5OO4I2CDS466yzYRMlZ32FEkk6QT211bzR+aXYt2uWDE6DIY9lEBZg2wBo9th7i6usPa3
F61m1xLEGd7KQyQvv2MjEAlSNH929bPtO7SlKUpSlKUpSlKi53+9+nP4k/+0uKtUpUuz6mw
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
2Q==
</binary><binary id="_150.jpg" content-type="image/jpeg">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
</binary><binary id="_10.jpg" content-type="image/jpeg">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
ccccccc/9k=
</binary><binary id="_133.jpg" content-type="image/jpeg">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
2Q==
</binary><binary id="_180.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAjAGoBAREA/8QAGQ
ABAQEBAQEAAAAAAAAAAAAAAAUGAwQH/8QAMhAAAgEDAwMCBAMJAQAAAAAAAQIDBAURABIhB
hMxFCIHFTJBI1FhFhczQlOBkZOl1P/aAAgBAQAAPwD7NpppppppqQJ6h+sXp3pkFNDb1eGc
0rli7yEOomztAASMlMZOQfC6r6aaaax9Z1FerjPdKbpye1rcLczILXXxP35tpGXzvXarBht
OGUgqSw3ELsNNc5poqaCSeeVIoolLySOwVUUDJJJ8AD76y1LderrrZzfbdS25KebE1Hbp1b
vTwcEbpg+xHcZIG1guVBPnGmovVehg9d2fV9pe/wBjPb34923PO3OcZ5xrjQ3H1tZcqftbP
QVIg3bs78xRyZ8cfxMY58Z++vF1VBfZrPu6dq+xWQyrIYwEzUIM7owzqyoxzwxBGQM8EnXm
ttJLeLdBcLf1pdKilqF3RyJFSYI/0cEHgg8ggg6s22Gtp7dBDcKxK2qRdslQkPaEh/Pbk4O
PODjOcAeBxoOoLLdZ2gt13oa2VV3mOnqUkYLkDOFJ4yRz+uqGsfXfEK0Ud1ldLtQ1Vrgt8k
8zQMGYTBhsjEm7YzOokxH9X4ZOcHVCi636dnoYJqq+2ilqJIlaWD5lC/aYjJXcDg4PGR5xr
ypY7vd0tadR0lrMtuaKb10EplmeRCrHYDEgiDsgLYJ4BXHIZafT89RUpcZaumSnl+YTJhaV
4S6IdkbEsfxCUVDvHGMD+XUP92Fn/r/8y3/+bV+tsqVPStRYY5u0ktC1GsvbX2gpsDbVCrx
5wAB+WNcaL9p6jsR3KO3UYTa081FO8rSkeVVHjARWPk5YgZA5IZadZSR11K9NM0yo+MmGZ4
n4OeGQhh4+x1n7P0nDR3W5VMj3FVauSWmJulQwkUQxDLDuHd71Ye/PAA+nGqHUnUdF0zbo6
qsdFM86U8AkbYhkbxufB2KACSx8AHgnAMa0Xzozpu3Vbr1Na5JKieWurHjq1YySvy5VAzED
gAKMnAHk5J0dHcfmdnS4UEW4TxGSmEzbBID9DEgMVVhg+MgHkA5GpnSVorbPDcFraSjgesr
pqxnpqp5u40jknIZF27V2Lx5wTgffhS09V1D8OJowtHFUXehnaMxRmKP8YMUZlyxViHBblv
cWwT5Mmp6W6krTc45ILXBR1kFNTpSQVsiKkETqeyGWFSqsrVAJwT71AACnO2ovVehg9d2fV
9pe/wBjPb34923PO3OcZ5xrvppppppqR1JeY7Hbo6mRKlw06LimaENge457rAbdqncfKrub
gKWE+0dd2283SG308W2WbdtPr6OTwpP0xzMx8fZT/jnVDpmqrayztJcJ0nqUq6qFpEj7akJ
USIMLk4GFA5JP5knnVCsoqW4Ur0tbTQ1VPJjfFNGHRsHIyDweQD/bXfTTTTTTTTTWSnrJ6n
4s01qmk3UdLaDXwxYA2zmRot+RyfY7DBOOc4zzrW68tBbLfaoGgt1DTUUTNvMdPEsalsAZw
oHOAOf016tNNNf/2Q==
</binary><binary id="_106.jpg" content-type="image/jpeg">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
eRkydn+bceCWMRtM3tyo8fpeROv7df/Z
</binary><binary id="_156.jpg" content-type="image/jpeg">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
</binary><binary id="_134.jpg" content-type="image/jpeg">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
</binary><binary id="_67.jpg" content-type="image/jpeg">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
CzhSClKjtSdyUggjokAkHoKVF0p90P+sp/wDLdq1SlRb7976c9ZL/AIkiveodPM6hjMNOyJ
LBZfbdBZkONghLiFkEIUnJIRgE5KScjjWdb0iFNttviw1yIziVpefW8sqYShI2klQO8k4HF
QVxzhQCiF9tarzaHYTctcR0qQ6zIQgKLTiFpWhW08FAKSMjzjI4ddY7Han7Y3LcmTvHZc2S
qQ86Gg0gHalCUpTk4SEISOJJOCSeNVKUpSvzN4Xf6n3f+z+y3X3/AEp90P8ArKf/AC3atUp
SlKUqLrP8D371bI/bVVqlKVFi/ji6erYf7kqrVKUpSlRdZ/ge/erZH7aqtUpSot9+99Oesl
/xJFWqUpSlKVF0p90P+sp/8t2rVKVFvv3vpz1kv+JIq1SlKUpSlfmbwu/1Pu/9n9luv0E9p
PTcl9x9/T1rdddUVuOLhNqUtROSSSOJJ89eOZmlezVo9xa+WnMzSvZq0e4tfLTmZpXs1aPc
WvlpzM0r2atHuLXy05maV7NWj3Fr5aczNK9mrR7i18tOZmlezVo9xa+WnMzSvZq0e4tfLTm
ZpXs1aPcWvlq1SlKlztPW+4TjNeMxuQppLSlxpz7G5KSopBDa0g4K1df5msPNS3ek3f4zL7
2nNS3ek3f4zL72nNS3ek3f4zL72nNS3ek3f4zL72nNS3ek3f4zL72nNS3ek3f4zL72nNS3e
k3f4zL72vD2jrTJYcYfcujrTqShxtd3lqStJGCCC5xBHmq7SlK0rnaYd3bZRLD31DvKtKZk
OMrQrapOQpCgfsqUOvz1pc1Ld6Td/jMvvac1Ld6Td/jMvvac1Ld6Td/jMvvac1Ld6Td/jMv
vac1Ld6Td/jMvvac1Ld6Td/jMvvac1Ld6Td/jMvvac1Ld6Td/jMvvaoW63RbVCTDhpWlpKl
r6bqnFFSlFSiVKJJJUonJPnrapStK52mHd22USw99Q7yrSmZDjK0K2qTkKQoH7KlDr89aXN
S3ek3f4zL72nNS3ek3f4zL72nNS3ek3f4zL72nNS3ek3f4zL72nNS3ek3f4zL72nNS3ek3f
4zL72nNS3ek3f4zL72nNS3ek3f4zL72nNS3ek3f4zL72pkzwXaPuEpcqbbHpUhzG916fIWt
WBgZJXk8AB/tXW0pSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUp
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
KeB/8AiPypE0/ZYCFohWiDGS4pC1pZjIQFKQdyCcDiUniD5j1VQpSoulPuh/1lP/lu1apSo
uq/uhj1lA/ltVaqe3p+ytW5y3N2iCiE8re5GTGQGlq4cSnGCeiOP+g/KsczTNguEpcqbY7d
KkOY3uvRG1rVgYGSRk8AB/tRzTlnPjq2bbDjyJzTjb8hqK3yiwv7W4lJCsniQoEE9YNbsKG
xb4LEKK3yceM0lppGSdqUjAGTxPAeevbrLT6Ah5pDiQpKwlaQQFJIUk8fOCAQfMQKNMtMIK
GWkNpKlLKUJABUolSjw85JJJ85JrJSvzN4Xf6n3f8As/st19S0z4UtF2/StphSrzyciNBZa
dR4q8dqkoAIyEYPEeaqn0u6E/Xf8R/5KfS7oT9d/wAR/wCSn0u6E/Xf8R/5KfS7oT9d/wAR
/wCSn0u6E/Xf8R/5KfS7oT9d/wAR/wCSn0u6E/Xf8R/5KfS7oT9d/wAR/wCSpepvClou4aV
u0KLeeUkSYLzTSPFXhuUpBAGSjA4nz19HpSlc4y9crVeLyRYJ01qXLQ+09HdjhJT4uygjC3
UkHchXmrZ8u3Hsnd/axO/p5duPZO7+1id/Ty7ceyd39rE7+nl249k7v7WJ39PLtx7J3f2sT
v6eXbj2Tu/tYnf08u3Hsnd/axO/rWeeuV1vFmJsE6E1ElrfdekOxykJ8XeQBhDqiTuWnzV0
dKUrn9bzGLfprx2U5yceNOhOurwTtSmU0ScDieA81TPpd0J+u/4j/wAlPpd0J+u/4j/yU+l
3Qn67/iP/ACU+l3Qn67/iP/JT6XdCfrv+I/8AJT6XdCfrv+I/8lPpd0J+u/4j/wAlPpd0J+
u/4j/yVT0RMYuGmvHYrnKR5M6a60vBG5KpTpBweI4Hz10FKVI1NHlSbOkQ4y5TrUuK/wAih
SUqWluQ2tQBUQM7UnrIrx5duPZO7+1id/Ty7ceyd39rE7+nl249k7v7WJ39PLtx7J3f2sTv
6eXbj2Tu/tYnf08u3Hsnd/axO/p5duPZO7+1id/Ty7ceyd39rE7+nl249k7v7WJ39fH9daA
1hqfWM68wtPPNx5PJ7EvSY4WNraUnIDhHWk+ev//Z
</binary><binary id="_143.jpg" content-type="image/jpeg">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
hl2S3K7bSU95qb1VzagpIaS5uttLy0MJyxv7erDcdZ3a3ae09q5nWN0utu1xPYm1dxNJqGW
3NZU09Q6L2bmRzHNZ2jc8RuP8Pv4HBXTWC4UFTq6upbXeZqoQc4FdBVVTnvE3Kt2iONxy1k
YL2ktAadzBl5B29AKiqks8VRROo6+ofExzHiQxQzZxlwcA8hpGSPve4Z960udaq7mtHmsvp
051qrua0eay+nTnWqu5rR5rL6dOdaq7mtHmsvp051qrua0eay+nTnWqu5rR5rL6dOdaq7mt
Hmsvp051qrua0eay+nTnWqu5rR5rL6dOdaq7mtHmsvp051qrua0eay+nTnWqu5rR5rL6dOd
aq7mtHmsvp051qrua0eay+nTnWqu5rR5rL6dOdaq7mtHmsvp051qrua0eay+nTnWqu5rR5r
L6dOdaq7mtHmsvp051qrua0eay+nTnWqu5rR5rL6dZrLc6q4Or4a2khpaihqRA9sM5mY7MU
cgIcWNPZIBjHuVRERERERFFvv4vpz4k/9JUK0iLzitsmrmVl92OuNQyemq+aOgr3RjlXzMd
BtLp+GxuQcMjADXN6+RnPLbdSNt9wnt9vu7JqepL6GjrbqXc4ikp2xOY57ZyRtkzKMnIwA0
guJHc0VNzOhgpeXmn5CJsfKzv3SSYGNzj73HGSf5rOiIii0v78XT4bR/wByqWat1HabfXVF
FVVfJ1FNQur5Wcm87YGnBfkDB4jsHH+iUGpLNdKqGlobjDPUTUwqmxMPXERDCHOHa3IkYQH
YJz/QqoiIiIiIiIiIiIiIoti/F9R/EmfpKdWkREREREUW+/i+nPiT/wBJUK0iIiIiIii0v7
8XT4bR/wByqXP/AGi6HuuqpKeostwht9RHTS087y5zDUse5mI3OaMlmBIcHIyQMcSR0EtJd
ZdX0tfyFGKCnppoN/OXcq7lDE7Ozk8DDosY3cQ7Puwd00cj7fLTwv8AZj3yvcJKPY4jLy7d
12Fu53a7LTxceJ+8pM0NytV4swN/rq2Krq3wSw1EVOGlvN5ng5ZE0g7mN966NERERERERER
ERFFsX4vqP4kz9JTq0iIiIiIii338X058Sf8ApKhWkREREREXMTXm1WjXFw9p3OjoeVttJy
fOZ2x78SVOcbiM4yP/ANC3emelfEto+ei+pOmelfEto+ei+pOmelfEto+ei+pSbzqzTct0s
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
Wqu5rR5rL6dOdaq7mtHmsvp051qrua0eay+nTnWqu5rR5rL6dOdaq7mtHmsvp051qrua0ea
y+nTnWqu5rR5rL6dOdaq7mtHmsvp051qrua0eay+nTnWqu5rR5rL6dOdaq7mtHmsvp051qr
ua0eay+nTnWqu5rR5rL6dOdaq7mtHmsvp051qrua0eay+nTnWqu5rR5rL6dOdaq7mtHmsvp
051qrua0eay+nWF9Nf7hdbVNW0NupaehqXTvdDXSTPdmGSMANMLR2yA5z7l0CIiIiIiIiIi
IiIiIiItW5x1stqq47dMyGtfA9tPI8ZayQtO0ngeAOPcf9l5f9n+p9Q3/AFnJStjmgp4P29
5dUQhrpZhTRQbMBvUcJYnOAy3IzwG3C+PtH1be9L6s2VJe6ie01VqljjaeQk5tNCWnLQHHl
JGvOScNxw62F6nbI62K1UkdxmZNWsgY2okYMNfIGjcRwHAnPuH+y2kRERERERERERERERER
ERERERERERERFLtenLTZa64VtvpORqLlLytU/lHu5R2XHOCSBxc7sx2pdNOWm9V1vrbhSct
UW2XlaV/KPbybstOcAgHi1vbnsVRERERERERERERERERERERERERERERFzmrqyqopbQYblX
UUVRVugnFFStne9vIyPBDTG85Dox2DsLs/zHPs1Dqmlis01XS3R8rmxmsj9nnY+J0zm7yyO
KQiXkhvczlGBp24DuLVuWqovEst8rJrzqCejom/8JTutMcM0zeRyXN3wt3u3lwa0AYLBuyH
KNWaj1Y60FkLr1FWwTzNY6K0vk5ePm5fGXOfTNGeXAZwYzqk5B++t0XbWEkunpgK5sVRBRN
q2Gj2kzcrtqd7eQJaNuDkujGOLd3FbNLDeqC46ppKSqu9VXSxSTUctRSxNp3yCngax3Kcm1
pfuy0AHbhh3DPEz3XXVL7BO83G9U1b7QbHTPZaDUAwEQb3vBpmEhu6UjqsJII62FXuc99t+
pLdRQXK71NMeQ5WQUDHtfumdu3OZDt+7gO60WxoDhyhJC6yB2ZqkcpM/bKBiSPa1nUbwYcD
c335yeJcM8MDk7te7rR6tdTRtu/s5+YppI6B0zYcwlwkh2QO3YfsGXPdxLwY8AOEjTV91hP
BdI7iLo9zYKJ8Mk9r5J0YIbzssxG0Oczc7a0hxO0YD+Od27XTU1LbWzRzXQSTW+sEAgtwlc
ZmStNM97RESx0kZO4ODQOOAwjgiu93qNRGNldqBtHPcHRMa+zFjI6d1OS1+51PkFs5DQXHs
ALgRkmnohlVS+06GqkukjoauZ+6spmxRHfUTEGNwY3eXDa9x4tG9uMcQOqRERERERERERER
ERERERERERSLtFaprvZ2V5qRVCd7qHk3zNZygYSdxYQ3OwO4P7RuAzkhV1qm40rbqy2FzxV
PgdO1pidtcwODSQ/G0kFzcjOeIOOK2kRERERERERERERERERERERERERERERFC1TZpbzFbx
HQ0Ne2kq+Xkpa95bFK3kpGYzsfxBeD933KLbNF3OhitTJqqmldSNiHKh8hNCGTOkcyDducW
vY5sJy5p2Mbnd90STo2Oz0bukcVojtz6aeir7o2Z/OKkzyxmOd4fG7Dw9rTlzyGlxcCA3Cu
6G06626Rppay1ULbpXOiqKxogEAyHgsy0MAa6NuCGhoG8HiCS5dZMZWwSGBjHyhpMbHvLWu
djgCQDgZ9+D/sUkMofGI2Mc0uxIXPILW4PEDByc4GOHAk54YIGXl3gsYIg1pa8PO4uycgjH
AAbcHJzk8BjjkREREREREREREREREREREREX//2Q==
</binary><binary id="_194.jpg" content-type="image/jpeg">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
SlKUpSlKV/9k=
</binary><binary id="_86.jpg" content-type="image/jpeg">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
npuox//Z
</binary><binary id="_139.jpg" content-type="image/jpeg">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
R0jJYY2tO/AA7pdsfJmvU6uoiIiIiIi/9k=
</binary><binary id="_153.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAB4AXMBAREA/8QAGg
ABAAIDAQAAAAAAAAAAAAAAAAUGAwQHAv/EAD8QAAEDAwICBgYJAwMFAQAAAAECAwQABREGE
hQhEzFBVZXUBxUWIlZ1NTZRk5SztNLTMmGBIzNUFyRCkbFS/9oACAEBAAA/AOzUpSlKVT9J
6T03J0dZX39PWt1123sLccXCbUpai2kkkkcyT21Lexmlfhq0fgWv21E6s0npuNo69Psaetb
TrVvfW24iE2lSFBtRBBA5EHtqW9jNK/DVo/Atftp7GaV+GrR+Ba/bUZf9M2C3wosqFY7dFk
N3KDsdZiNoWnMpoHBAyORI/wA1baUpSlKUpSlKUpSlKUpSlKUpSlKUpXPLTrq7XS92SHx1l
Q5cn30ybcI7xkwkthStiyVD3sJ2kqSnmcpChmrzPcuDbCTbo0aQ7uwUSJCmUhODzylC+ecc
sf5qP4rVXc1o8Vd8vTitVdzWjxV3y9OK1V3NaPFXfL1rXN7U7tqltrtcFlK2FpLkW6vF5AK
TzRtjE7h2YBOccq5/YZvpVcfjG02+c3b21FtxvUDzbiiokkrUoobdKRuBGM/04Gf6a6Toz6
j2H5bH/LTXL9O3H0kOelhTE5UktF9SZba2neCSxlQ3Ngj3QQ2diuRURzJyrPUNZ/Ue/fLZH
5aqmq4q8fSYn0sOFhF0XCFwJbQtakwlR88gSAUAdH24Ks9hXV61LJ1IbWyHrTa0J9YQiCi5
uKO7iWtowWByJwCewEnBxgy3Faq7mtHirvl6cVqrua0eKu+XpxWqu5rR4q75enFaq7mtHir
vl6cVqrua0eKu+XpxWqu5rR4q75enFaq7mtHirvl6cVqrua0eKu+XpxWqu5rR4q75enFaq7
mtHirvl6cVqrua0eKu+XpxWqu5rR4q75enFaq7mtHirvl6cVqrua0eKu+XpxWqu5rR4q75e
nFaq7mtHirvl6cVqrua0eKu+XpxWqu5rR4q75enFaq7mtHirvl6cVqrua0eKu+XpxWqu5rR
4q75enFaq7mtHirvl6cVqrua0eKu+XpxWqu5rR4q75enFaq7mtHirvl6RLtdfXjNsudthx+
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
</binary><binary id="_142.jpg" content-type="image/jpeg">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
QeUAJYeTSWYGea9aREREREREREREREREREREREREREREWCkrIK6F01NJvY2WSInBHaY8scO
f8AhzSP/CU1FS0fF6LTQwceUzS8KMN4jz3udjvcccyeazoiIiwUVZBcKGCtpZOJT1MTZYn4
I3NcMg4PMcj71nREREREREREREREREREREXBa2oKK66toLeygstbcKm11bGx3GXYQN0Wxw2
tLyR/VIA2nHEIcMFH6Qv0F4pqpkdrr44YGU9RJPLwn3GPo/DdxzwXucS87sF5bhrezkbl90
Gheg6cucEVisUdzramR2c8WPgulDwzLouztaAGt2Fu5jXFpyQod5+TfUN4s8VDLTWUzwQSw
RVclS5z2sdUMlYBiBoAY1rowG4GHnAaOyr8miaqq1tHfaqKhkgndxKuJ215GaUwOiGYtz25
wcl7WkE/088z8R6FnFkvNoZR2ijhqakT076aMb5g2pfM1ku6PaGhpYwDa8N7Rw4YataL5PZ
X01jpa+zWWqjoat89RK6Yh5jdJM4RANhaHNbxGu29lpLSNoByqcOkJabXUd4gt9rioonDhu
YS2VjRT8IANEfIg9nHE4e3+zf2l1NJFwYXN6PDBmWR2yE5acvJ3HkO07O48u8nme88HdNF3
6sq70YaOyimukFRC6PjcNpc5wMUzmtgy6RuCe093ac4tLQcL7s+iLrb7bXUlRRWiSnmu77g
y3tncaeVj2FnBfmLAaw7HtO1wJYOTcArNW6NurKiGSlit1wlbFbnS1dZM6KV89LI5xkOI35
c9h27i7IGRzC+LHoaWkubHV2n9Ptontq2VDIXmQyNlmbLGC0wtDhHsDQCe7mMYwbuirJVaf
0/Hbqukt1O+LY0GgziXEbGmR5LW5e5zXE8u7aMnGV0CIiIiIiIiIiIiIiIiIiIihXnVENgu
sUFwge2ilpJag1MTJJnRmNzA4OYxh2tw8HeTjkQccs7PWSzcbh+0YdvC4vGz/Rxs344vzN2
zt7c529rG3mpNLr+2zz1T3xVLaGNtK6nqW0lQ50/HLw3+nwgQC5mA4bmu3N55OFat18obrA
2ej6S6N074MvpJY8PaDuBDmjABaRk8tw25zyVBERERERERERERERERERERERERERFIvNgF4
ninZdK63yxQSwcSjcxriyQsLhlzHYOY24LcEf5Wt1Js23gbJug8LZ0Pif088Ho+/d8/dwex
87GOeN3aXOars0dmtXRZ6+uu8l+bHZI+nuhc2J5bIYJHFsYcS2Q8zkntF3aLQF21BbGW222
+3008whoImRNztJla1mwBxx/2PZxzA92QdmWN0jA1kz4iHNduYBkgEEjmDyIGD78E4IOChj
cZ2SCZ4a1rmmMAbXEkYJ5ZyMHGDjtHIPLCONzHyOdM94e7c1rgMRjAGBgDlkE88nJPPGAMi
IiIiIiIiIiIiIiIiIiIiIv/9k=
</binary><binary id="_145.jpg" content-type="image/jpeg">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
pCUnaQFBIBBq+y2pphttby3lISElxYAUsgdZ2gDJ/IAflUnRn2HsPo2P7NNWqUpSlKUpUWx
eN9R+kke6R6tUpSlKUpSlRZdpuvdx652y5Q4/PxmmHG5MJT3+zU4oEFLqMZ508MHqFOi6q8
82j1U78xTouqvPNo9VO/MV9rLbJVvVPemy2ZUidJD61MsFlCcNNtgBJWo9TYOc9tVKUpSoR
tF6jXK4SbddYLTU59L5bkQFuqQoNIbxuS8nIw2D1dte+i6q882j1U78xTouqvPNo9VO/MVm
2a3dyLHAtnO890OM2xzm3bv2JCc4ycZx1ZrNpSlKUpSlRbF431H6SR7pHq1SlKUpSlKVClS
r1J1HIt1ulwYrUaIw+VSIi3lLU4t1OPBdRgANDy9de+i6q882j1U78xTouqvPNo9VO/MVhQ
XtVTZlyj91LQjoEkMbu5jp35abcz/AOI4f7TGOPVntrN6LqrzzaPVTvzFOi6q882j1U78xX
209OlXC1F6aWVSG5MhhamUFCFc28tsEJKlEZCAcZPXVSlaxZntVXexwLn3UtDPTIzb/N9zH
VbN6QrGekDOM9eKzei6q882j1U78xWFeXtVWixz7n3UtD3Q4zj/ADfcx1O/YkqxnpBxnHXi
s3ouqvPNo9VO/MU6LqrzzaPVTvzFaHqnlH1JY5cxi1Ltd4TbEg3F9EFxpqMpSghKN3PncrJ
4gdWD14Vt6tSlKUpStfRGv9vut1ehQbdKjzpKX0KenOMrThltsgpDKh1tk5z219ulaq8zWj
1q78vTpWqvM1o9au/L06VqrzNaPWrvy9Olaq8zWj1q78vTpWqvM1o9au/L06VqrzNaPWrvy
9Olaq8zWj1q78vTpWqvM1o9au/L06VqrzNaPWrvy9Olaq8zWj1q78vXPNT6z1tbtXORrQ5G
mPx0pL9kjsuy9gKM794YbO3wkH65O4+TgNm0Jcb9dLzcZWo7Ui2zVW+HhtB4LQXJJSraSSg
8cFJOcpPVnAzdea8haFtzDz0ZcuVKUUsR0q2BQTjcSrBwACOwkkjh1kZuj9VwtZWBu6w0La
IUWn2V9bTgAJTn+sMEEEdhHUcge7F431H6SR7pHrX9ccqEXRN8h2x62PS+faDzziHAnm0FR
T4IIO5Xgq4EpHVx48LULXelZkFiV3ftzHPtJc5p+Y0lxvIztUN3BQzgjy1P01qzTbFreQ9q
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
/ANOumaM+w9h9Gx/Zpq1Sv//Z
</binary><binary id="_97.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAdACkBAREA/8QAGg
AAAwADAQAAAAAAAAAAAAAAAAUGAwQHAv/EACsQAAIBAwQABQIHAAAAAAAAAAECAwQFEQAGE
iEHExQiMUFhFTIzVoGT0//aAAgBAQAAPwCsut1n3BeLVbjQ0dNSG9lYJ55RJUSGk5PI8cQH
sUvGY+fInDdr7hp1bL9dbhue52prPDDSW2VUes9Ux8zmnNeC+WAWAK8hy9vIdnrNBo0aNRB
Hhy1elab9QmVJ2nUG+NwVzIJSQnm8QDIqsRjGQOutbVsuOxbRVTVNJuaj82f9UzXxpg5woy
Q8hHLCqM/OBjONU1ZVx0NK9TMszImMiGF5X7OOlQFj8/QaXw7loJ544Up7oGkYKC9pqkUEn
HbNGAB9ycDWHdQqo6Wiqae4VNMI7hSJJFEVCzK9TEpDEqWxgnpSM5IOR1p7qfvu5oKGuo7b
QV1HLc5a6CGShwZZfLYgueKsCnFMvyYFcL9xphFuCyz3E26G70MlaGZDTJUoZQy55DiDnIw
cj6YOtmsoqW4Ur0tbTQ1VPJjnFNGHRsHIyD0ewD/Gl8O09t008c8G3rXFLEweORKKNWRgcg
ggdEH6693uym9wwwm51lEkUqS4phF72R1dCeaN8MoPWM95zrD+BXH92Xf+qk/w1ymHe7Uvi
HSWGnt6Rin3FUmSUOMTyTTtHzYcc5WJ3Ue75Kk9LxL3wx3tBufet9ZbP6Sor4kqXl9SZMLE
scSx44gfLM2evzY7wDrqejRo1//Z
</binary><binary id="_196.jpg" content-type="image/jpeg">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
K/9k=
</binary><binary id="_154.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCACdASkBAREA/8QAGw
ABAQEAAwEBAAAAAAAAAAAAAAUGAwQHAgj/xABGEAABAwMCAgQJCQYGAgMBAAABAgMEAAURB
hITIRQWMUEHFSIyUVZ1lNIjNTZUYZWztNMYM2ZxpONSVYGRk9QXNCZCYrH/2gAIAQEAAD8A
9mpWMhagXB1bdYdz1HbkoNybaZgraV0hQcZZDYb+VOE7lDPkEEhavJz5MiXr2PK1IvTt2lw
U2qW/LhyeMhDJQ2hLiTucElRSSoJAKkI3AkjFNK6ycnQLLClXuDcY0q3uCcprjMSYAbbG5x
1zerAyCkrPDJKkqTkV2mdXot2hpEm1z2bk9FuS2FOOykyOAyuWtDa3Ct1JKdmNpKhnySTty
RoNIagk6ggvuyGmTwHdiZEd1lTb3IHzW3XNihnBBUcjBzzwnQUpSlKUpSlKUpSlKUpSlKUp
SlKUpSulebj4osc+58LjdDjOP8Pdt37ElWM4OM47cV3aUpSlKUpSlKUpSlKUpSlKUpSlKUp
SlKi6z+g9+9myPw1VapSlKUpSlKUpSlKUpSlKUpSlKUpSlKUqLrP6D372bI/DVVqlKUpSlK
UpSlKUpSlKUpSlKUpSlKUpSs5rme0xpi6wnErCpVrmFtwgbCpLROzP+IglQHeELPdVm3z2r
lGW+ylaUofeYIWADubcU2o8u7KDj7MV2qUpSlKUpSlKUpSlKUpSlKUpSlKUpSlY/wAKbLp0
LNlx2luvw0qWlCUlQ2rQplwkDngNurVnuKQTyBB0dnt3imzxYBd4y2Gglx4p2l5fatw8z5S
lZUeZJJOSa7tKUpSlKUpSlKUpSlKUpSlKUpSlKVF1n9B797Nkfhqp1M0r6tWj3Fr4adTNK+
rVo9xa+GpN50nptq6WBDenrWhL1wWhxKYTYC09GfVg8uYykHHpA9FVupmlfVq0e4tfDTqZp
X1atHuLXw1Pm6fstqv2nX7daIMJ1VwWguR4yG1FPRZBxlIHLIHL7K1VKUqLrP6D372bI/DV
TqZpX1atHuLXw06maV9WrR7i18NSbzpPTbV0sCG9PWtCXrgtDiUwmwFp6M+rB5cxlIOPSB6
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
n+0J/C39f/bp+0J/C39f/AG68Zr//2Q==
</binary><binary id="_155.jpg" content-type="image/jpeg">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
V45o7WOvLh4UE2O+LW202p5UuImKgJZSEKKfOAJ27ijCtxzlPM55+k336X053kv9pIq1Sou
q/ohjvKB+7arh13dblZNFXO5WlG6Yw0Cg8PfsBUApeP/AKpJVz5DGTkZrMeB7VmodVQbmu+
OdIRHdbDEjgBvcSDuRlICTjCT1ZG/n1itbK9OLX3bM95Fr71VKukLS9xkWWKuTcEMK4DaMb
go8twBB3FIyrbjzsY7awfge1pqXVM65s3l7pkdhptSX9rbfCUSQE7UpBVuGTns2fjW5lenF
r7tme8i1apSlKUpSlKVF1n6D37u2R7tVWqUpSlZ/VE2Lb5unpU2SzFjt3JW915wIQnMWQBk
nkOZA/vXN5Z6V9ZbR+ua/lTyz0r6y2j9c1/KnlnpX1ltH65r+VPLPSvrLaP1zX8qeWelfWW
0frmv5U8s9K+sto/XNfypoz0HsPdsf3aatUpWP0nqzTcbR1lYf1Da2nWrewhxtc1tKkKDaQ
QQTyIPZSzas021dL+tzUNrQl64IW2pU1sBaejMJyOfMZSRn6wfqr71BqfTs63NMxtRWha0z
ojpHjBkeaiQ2tR5q7EpJ/tVPyz0r6y2j9c1/Kstry8aem25i92rUlrN5sajJhBNwThwci40
UpVlQWlOMDBJwMgE5oNauseqJul3rXcGXHXJy3FRitIeaHRZAO5GcjBOM9XVgkEGtnSoWsX
mo1hQ++6hppq4QVuOLUEpQkSmiSSeoAdtfflnpX1ltH65r+VSbNqzTbV0v63NQ2tCXrghba
lTWwFp6MwnI58xlJGfrB+qvuRqfTq9VQJqdRWgx2YMlpa/GDPJS1sFIxuzzCFf8f0qn5Z6V
9ZbR+ua/lWSu+prBZ9c22/26+W56PcsW+5tMS21fi0+QCB5pylS1E4SQAK0DN5tV31xb/Fl
zhzuFbZfE6M+lzZlyNjO0nGcH/g1p6UpSlKUpSlRdZ+g9+7tke7VVqlKUpSlKUpSlKUrjeL
qWHCwhC3QkltC1lKVKxyBIBwM9uD/AENZPTOoGp12lKiMLWLtLTKCVkJU0wIMZRWesEhS2k
7Qc+fnmEmthSlefzXV6A1fIeixnpFv1JuU0xvUUpuWchO4+a2l3OMnPMdiU8tzCmMXCCxNi
ucSPJaS60vBG5KhkHB5jke2ueldW5ynYNqlzGIq5bsdhbjcdGdzqkpJCBgHmSMdR66z9hu7
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
Hbv2XUvsNvICwlxIUAtBQoAjPNKgCD+BGRUnVf0Qx3lA/dtVapSouq/ohjvKB+7ar41rBu9
y0jPi2GQti5KSlTC0PFpWUrSogKHUSAR2DnzIFYzwJ2K92SFeE3NlbMZx9KWEF5K08RtTjb
uACcHKUgntwOsCttK9OLX3bM95Frm1KxcpOmbkxZ3OHPcjLTHUOR3YOADuTtUeoKzyODzxi
vLfAnGvNo1Ne7JcH+iojNBTtvdX55dJADiR2p2jBUDg7kdfIj0yV6cWvu2Z7yLVqlRZXpxa
+7ZnvItZbwxWTU18sEZmxJW/FbUtc2K0oBboABQQP/ACAIV5oOSSnAOOVnwZNTWfBzZUTys
ulgqTvXuPDKiW+eTy2FOB2DA5YxVCxfS+o+8kftI9QvCzbr9c9HcDT6ZK3Q/ukNx3dqlscN
YUnGRvBJHmjJP1GvjwPruR0Mlm5yuM7HkuMIZUflIqUYTwlgjKVAgkA9SVJ7MAaCxfS+o+8
kftI9WqVF1X9EMd5QP3bVfGtYN3uWkZ8WwyFsXJSUqYWh4tKylaVEBQ6iQCOwc+ZArGeBCD
d4NuvTNxkL4UWX0NuKp4rDDje4u4HzQCXBzSeZB/DO2lenFr7tme8i196qi3Sbpe4x7LKXG
uC2FcBxGNxUOe0EkbSoZTuz5uc9leZ+BeBfrHqO7We6KXCabYDhgPnCnF79odbH/kkBKklS
Tg5R18sekyvTi192zPeRatUpSlKUpSs/JXcLfqqXNZssyfHkwY7SVxnGBtUhb5UCHHEnqcT
1Z7a5vHtx9U7v+bE+PTx7cfVO7/mxPj08e3H1Tu/5sT49PHtx9U7v+bE+PTx7cfVO7/mxPj
10rpKul3YjxEaauMf/AH0V1TrzsbYhLb7biidrxPzUnqBrT0pUjU0eVJs6RDjLlOtS4r/BQ
pKVLS3IbWoAqIGdqT1kV8ePbj6p3f8ANifHqTpq8z27W8lGmLo6DcJqtyHIuATJdJHN4cwT
g9mQcEjBrmem3ZzUcK4jSt04UeJIYUkvRNxU4tlQI+W6sNqz/Uf2oePbj6p3f82J8estq6X
eo82Fqy3aXnMybSlzpfSJEZCH4hSStKih1SiUkBSRggHJwTyq5aZ0nUF8tt7btMyJA8WvbH
pK2flOKphSMJQtR+ahR5gdlaelQruJ0bUduuMa1ybg01EksOJjraSpClrYUk/KLTkYbV1Zr
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
W1S7c/BtaWpbC2HFIacCglSSkkZWeeDX6Jr/2Q==
</binary><binary id="_11.jpg" content-type="image/jpeg">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
4df/Z
</binary><binary id="_147.jpg" content-type="image/jpeg">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
</binary><binary id="_107.jpg" content-type="image/jpeg">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
</binary><binary id="_186.jpg" content-type="image/jpeg">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
h7Np/htVpEREREREREREX//Z
</binary><binary id="_2.jpg" content-type="image/jpeg">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
lnh8W45XE+LvxO7HhY0+hoiIiIiIiIiIiIv/Z
</binary><binary id="_68.jpg" content-type="image/jpeg">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
</binary><binary id="_24.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAANAAgBAREA/8QAFQ
ABAQAAAAAAAAAAAAAAAAAAAAb/xAAhEAACAgICAQUAAAAAAAAAAAABAwIRBAUGEgATFCEiI
//aAAgBAQAAPwC/12xyuSJ12zVr8Nike8mucMsyWMhcyhfVgAuE4Scb6GhRq6txzT6/E2u0
hhpdiq1+cVpQrLeEgTStsvy7+mPs2VARAHxQsX5//9k=
</binary><binary id="_14.jpg" content-type="image/jpeg">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
</binary><binary id="_87.jpg" content-type="image/jpeg">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
wfDcJnClKznSP/AG5Meiv/2Q==
</binary><binary id="_19.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAOAAsBAREA/8QAFw
AAAwEAAAAAAAAAAAAAAAAAAwUGB//EACcQAAECBQMCBwAAAAAAAAAAAAECEQMEBRITACExB
iIUFhcjJCUy/9oACAEBAAA/ANSl+pKNN0eaq8rUYMxIyeTPGhG8IxuVcbnYOG5BBDgh0Hpz
Qq/9t1NSc1Wm/cmPkLTjf8w+xQSbE2ouA7rX5OjTFMj+efCKjvTqjbVFwixOaWxotDAEJJM
st7jvCUGZR1W6/9k=
</binary><binary id="_152.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAB4AXMBAREA/8QAGg
ABAAIDAQAAAAAAAAAAAAAAAAUGAwQHAv/EAEAQAAEDAwICBAsHAwQCAwAAAAECAwQABREGE
hMhFDFBlQcVFiI2UVVWdbPUNWGTlLTS0yMygTNCVJEXsSQlcf/aAAgBAQAAPwDs1KUpSlU/
Sek9NydHWV9/T1rdddt7C3HFwm1KWotpJJJHMk9tS3kZpX3atH5Fr9tROrNJ6bjaOvT7Gnr
W061b31tuIhNpUhQbUQQQORB7alvIzSvu1aPyLX7aeRmlfdq0fkWv21GX/TNgt8KLKhWO3R
ZDdyg7HWYjaFpzKaBwQMjkSP8ANW2lKUpSlKUpSlKUpSlKUpSlKUpSlKVzy066u10vdkh9O
sqHLk++mTbhHeMmElsKVsWSoedhO0lSU8zlIUM1eZ7lwbYSbdGjSHd2CiRIUykJweeUoXzz
jlj/ADUf0rVXsa0d6u/T06Vqr2NaO9Xfp6dK1V7GtHerv09a1ze1O7apba7XBZSthaS5Fur
xeQCk80bYxO4dmATnHKuf2Gb4VXH4xtNvnN29tRbcb1A824oqJJK1KKG3SkbgRjP9uBn+2u
k6M9B7D8Nj/LTXL9O3HwkOeFhTE5UktF9SZba2nehJYyobmwR5oIbOxXIqI5k5VnqGs/Qe/
fDZHy1VNVxV4+ExPhYcLCLouELgS2ha1JhKj55AkAoA4fbgqz2FdXrUsnUhtbIetNrQnxhC
IKLm4o7uktbRgsDkTgE9gJODjBlulaq9jWjvV36enStVexrR3q79PTpWqvY1o71d+np0rVX
sa0d6u/T06Vqr2NaO9Xfp6dK1V7GtHerv09Olaq9jWjvV36enStVexrR3q79PTpWqvY1o71
d+np0rVXsa0d6u/T06Vqr2NaO9Xfp6dK1V7GtHerv09Olaq9jWjvV36enStVexrR3q79PTp
WqvY1o71d+np0rVXsa0d6u/T06Vqr2NaO9Xfp6dK1V7GtHerv09Olaq9jWjvV36enStVexr
R3q79PTpWqvY1o71d+np0rVXsa0d6u/T06Vqr2NaO9Xfp6dK1V7GtHerv09Olaq9jWjvV36
ekS7XXx4zbLnbYcfjxnX23I01T3+mptJBCmkYzxRzyeo1NUpSlKUrSnWmHcZUOTJDxdgu8V
gtyHGwlWMZISoBXLI87PIqHUTndpSlKVUtM3+Lb9K2mFKh3duRGgstOo8TyztUlABGQ3g8x
2V4jalgDWNyeMe6bV2+IkAWmUVZDkgnKeHkDzhgkYPPHUce9TX+LcNK3aFFh3dyRJgvNNI8
TyxuUpBAGS3gcz21J+Vdu/4137ml/wAVPKu3f8a79zS/4qj71eo91ixocOJdFOquENfn2qS
2kJTJbUolSmwAAlJOSeyrVSlKUpSlKUpSlKUpSlKUpULK9OLX8NmfMi1NUpSlKUpSlKUpSo
WL6cXT4bD+ZKqapSlKUpSlKUpSlKUpSlKUpSlKhZXpxa/hsz5kWpqlKUpSlKUpSlKVCxfTi
6fDYfzJVazeqn5mpHLTAti1tx3+BIfkIkNBKgkKUUkMqQRtIxuWncerkUqV7tWudO3ptT1v
mPOx293EkmG8hlvancrc4pAQnA58yOseuszmrbQzFVIdXMQEuoaU2qA+HQVkhB4ezftUQUh
WMFQwDnlWtI1vbWnYiWmJzwflqiugQJAWypLJd5o4e4kjZgY5hRUMhJrfk6lscHhCddocFb
zQdQ1MeSw5tPUSheFDqI5jrBHZWm7rnTrXGUmY9IaYaDzj8WG8+0lHPzuIhBTt81QznAKVD
rBx7tOrIN4uUqFHakqDL/DafTGdUy6nhIc38TZsSDuOMq84BJGQoUi6zsU66yLZDfkyJUV/
gPpagvrS0vcU4UsI2pGQeZOOROanaUpSlKUpSlKUpSlKUqFlenFr+GzPmRa0rnqi5MazZ0z
bLMzMdcg9MW+9N4KG071J5gIUTzAHLP8Ad1YBNaydcyk3eRDdsMlTUR9EeQ5FZlPKCyhClF
IDASUgr6yoEpG4JOUg+4+uFParjWQwmdkqTIYbeS4+CeCFlR89hKFYKNpCVnBV2140xrG96
ksjd7b0whEJxSkoQ3cErfcAO3KUqQlGNwI85aTgEgHlnZu2q7hbLeZi9OvRWkOtocduMxhl
pIWtKAdzanDyKwTkAbQo5yADp3DVd52zILMCGxc4E6Ah0JncRpTT7qQPO4e4KPNJCkAhKtw
J5A7OodXzbBaobotcadcpNwRAVDjzvNbcWkqSOIpA5kbDgpH93q5mQ6Vqr2NaO9Xfp6mqUp
SlKVCxfTi6fDYfzJVe4VhXCu8qei8Tlplvl96KtLPCUrYEAZDYWAEpSB53+0Zzk507LoqJZ
bIuxi4zpdqWw4wYkgtbQlZJUdyEJXnmr/d2/wD5g7o1t5EhTt7ui5Ul9h1yUpTJXhk7mkBP
D2JSF+dgJBJJyTkivbukkuTHpab1cWnnJwmpUgMf0l8Is4SC2Rt4ZCfOyfNBznJMtboSoEJ
MdcyTMUFLUX5KgVqKlFXPaAABnAAAAAA7Krlz01ebjq9+e3cXrfAfgohqXCm7XSAVqKihTK
hu3LwCFApGSDzwN2NpBmA9/wDX3a4w4nFYcMNlbfDPCQ2hKSooLm0paQCN/MZ9Zr3aNLN2S
4y5UO6TuFNluzH4i+CWlOOdfPh7wBywArsHXzzO0pSlKUpSlKUpSlKUpULK9OLX8NmfMi1t
T9P2W6vpfuNogzXUp2ByRGQ4oJyTjKgeWSeX30d0/ZX7iLi9aILk0KSsSVxkF0KTjadxGcj
AwezArH5M2Dp3TvEdu6XxeN0jojfE35zu3Yzuzzz15rJA0/ZbU+p+3WiDCdUnYXI8ZDainI
OMpA5ZA5fdWPUFiZ1Fa/F0mQ8yyp1Diw0ltW/aoKCVBxKgU7gCRjnjHUSCi6cs8Wzm0i2w1
xF4LzRitpQ8oY89SEpCSrzQeodQxjAp5M2DoPQfEdu6JxeN0fojfD34xu24xuxyz14rdhwo
tvioiwozMWO3nY0y2EITk5OAOQ5kn/NZ6UpSlKVzi0a7bm+EF23IjMi5yOHBfjh5exngOS1
OLC+H5/m7CBgZ3gZGDjo9KUpSlKUpSlKUpSlKUpSlKUpXNbtr5MPwkItS4CBcIqVwo6C+eF
IMhyKWyVhBKCEhRUNpA24BOa6VSlKUpSlKUpSlV+FqiVcILE2Lpa7uR5LSXWl8SINyVDIOC
/kcj21T7XYbtB8Klz1UrR8noUljDDaHInFbdIQFLxxcAnDmSDk7j6zVwm6olW+DImytLXdu
PGaU66viRDtSkZJwH8nkOys3j24+6d3/ABYn89PHtx907v8AixP568OalkRiyZmnLpFadfa
Y4y1xlJQpxaUJJCXicblDqBqdpSlKr8LVEq4QWJsXS13cjyWkutL4kQbkqGQcF/I5HtrN49
uPund/xYn89YZeqJUFlL0nS13QhTrbQPEiHzlrCEjk/wBqlAf5rN49uPund/xYn89PHtx90
7v+LE/nrw5qWRGLJmacukVp19pjjLXGUlCnFpQkkJeJxuUOoGp2laV2uaLRbzLWw9I/qttJ
aZ271qcWltIG4gf3KHWRWl49uPund/xYn89PHtx907v+LE/nrC/qiVGejMvaWu6VynS0yOJ
EO5QQpeOT/LzUKPP1Vm8e3H3Tu/4sT+enj24+6d3/ABYn89e4V+XJuqLdJs863uusOPtqkK
ZUlaUKQlQ/puKwcuJ68VL0rVuc9q1WqXcX0rU1EYW+4lABUUpSVEDOOeBUf49uPund/wAWJ
/PTx7cfdO7/AIsT+eqHe7bPd8LVk1K5pOSmKU8FTS1RS69IS26pKsB0jISlJCiRjYMdQq+e
Pbj7p3f8WJ/PTx7cfdO7/ixP56jLb4RLdctTnTybZcWZaXSy4taWltNLCFL2qWhxQ3YQrl1
5SR2HFtpSlKUpSlKVC6M9B7D8Nj/LTWG6670vZLwm03K8Mx5ituWylRCN3VuUBtR6/OIwCD
1HNZtZ+g9++GyPlqqaqv2rXel73eFWm23hmRMTuw2EqAXt69qiNq/X5pOQCeoZrNqv7IY+J
QP1bVTVKUqsW7wkaNufE6PqGGjh43dJUY+c56uIE56uzOOXrrd0Z6D2H4bH+WmsMvXWmoOo
k6fk3LZc1OttBjgOHzl4KRuCdvPcO3trNqv7IY+JQP1bVTVV+1a70ve7wq0228MyJid2Gwl
QC9vXtURtX6/NJyAT1DNZtV/ZDHxKB+raqaqLv+o7TpiCibeZfRY7joaSvhrXlRBIGEgnqS
f+qhrrqWx320Rha7tDlrVOgO8Jp5JcSnpbPNSP7k9YByBgnBq21X7VrvS97vCrTbbwzImJ3
YbCVAL29e1RG1fr80nIBPUM1mvv2vpz4kv9JIqWeeajMOPvuoaaaSVuOLUEpQkDJJJ6gB21
Daf1rpzVL7zFmuaJLrKQtbZbW2raTjICgMjPWR1ZGesV7lenFr+GzPmRamqi7/qO06Ygom3
mX0WO46Gkr4a15UQSBhIJ6kn/AKqM1FebVd9D6i8WXOHO4Vtf4nRn0ubMtrxnaTjOD/0as9
V+1a70ve7wq0228MyJid2GwlQC9vXtURtX6/NJyAT1DNZr79r6c+JL/SSKmqouodQ3LUV4d
0hpB7hvN8rpdRzRBT1FCSOt04I5dXPqIJRutaetulxpe12tnhst3JZUo81uq6JIytR7VHH/
AKAwABVtpSlKUpSlKVC6M9B7D8Nj/LTVG1j4L4upfCOxJXc3o6LhGU/IQGwo/wBEstkJOeW
5KxzIOCk9ecC86z9B798NkfLVU1XMtP8AgStVm1F4xlT/ABnEb38KFIipKeeQN5JIVgHsSO
eDyxip3Uuk9NsWtlbOnrW2o3CEgqRCbBKVSWkqHIdRBII7QTUt5GaV92rR+Ra/bTyM0r7tW
j8i1+2nkZpX3atH5Fr9tPIzSvu1aPyLX7apn/hWHP8Atu8cbZ/peLbdHg4z17tqTv6hjPVz
9dW3QUNiDoKxsxm9iFQWnSMk+ctIWo8/WpRP+aot88E0C4+EtuQqbsiXDiznovCUc7FshxG
/fnzy6o5GNvUB6ugar+yGPiUD9W1U1XMtP+BK1WbUXjGVP8ZxG9/ChSIqSnnkDeSSFYB7Ej
ng8sYqd1LpPTbFrZWzp61tqNwhIKkQmwSlUlpKhyHUQSCO0E1LeRmlfdq0fkWv21GX/wAH1
ruEFDNmh2i0SEuhSn/E7D+5OCCnaoYHMg5+776rjngrsum3Il8EiTKuCLhCySENspWqU0FK
Q2hI2jBUAnJAB+4GuoVyzQvgvi2LW866IubzyLTJUxHZLYBVvYQoFSs88JeIwAMkA8v7avN
9+19OfEl/pJFSFzgNXW1S7c+paWpbC2HFIICglSSkkZzzwaoWkPA3atOzn5VzkM3viNcNtq
RDSG0cwSrCirKuQAPLAz155S8nSem06xtrA09aw0u3y1qbEJvapQcjgEjHMgKVg/efXUt5G
aV92rR+Ra/bUZf/AAfWu4QUM2aHaLRIS6FKf8TsP7k4IKdqhgcyDn7vvquXzwSaWtOnL9cy
3JlykxHn2lOuBCWVpQpQKUNBCcZxyII5AACuoVyzR3gvi6a8I78lFzekIt8ZL8dBbCT/AFi
82Ao557UoPMAZKh1YwbzfftfTnxJf6SRUZeLjctTSpWn9My+hoYy3cLuE7hHVj/RaGRud6t
xBGwdu4jEzp7T1t0vZ2rXa2eGy3zUo81uq7VqPao4/9AYAArDfftfTnxJf6SRU1SlKUpSlK
UquWyzaktVqiW5i92tTURhDDal2pwqKUpCQTiQOeBURcZV1h6qivS9SWJno0GUlx5yEpDbO
VxTtXmRyUd7ZHMcj1HcMS9zs2pLrapdufvdrS1LYWw4pFqcCglSSkkZkHng1s9F1V7ZtHdT
v1FOi6q9s2jup36isMqz3+4JZZm3i3KjtyWH1pZtriFq4bqXAAovqAyUAZweurBSlKVXLZZ
tSWq1RLcxe7WpqIwhhtS7U4VFKUhIJxIHPArSkxtSeWNtBu1rLpt8spWLY5tCeJHyCOPzJO
3ByMYPI55btws2pLlGQw9e7WlKH2XwUWpwHc24lxI5yOrKBn7s1s9F1V7ZtHdTv1FOi6q9s
2jup36isMqz3+4JZZm3i3KjtyWH1pZtriFq4bqXAAovqAyUAZweurBSo++W12623ozEhEd1
L7L7bi2i4kKbdS4AUhScglGOsddavRdVe2bR3U79RVfskq6ru90bZ1JYg7MnJUyDCUrpOIk
dW5sCQMpCCnq3evODgS8uzakmSYT7l7tYVCfL7YTanMFRbW3g//I6sOH1c8Vs9F1V7ZtHdT
v1FOi6q9s2jup36ikS03Xx4zc7ncocjgRnWG240JTP+optRJKnV5xwhywOs1NUrSvNu8b2O
fbOLwemRnGOJt3bN6SnOMjOM9Wa0ui6q9s2jup36iq5b7hcJWsZAjap0+67Mt8csLRDUpMh
KXJOQ2BI5lJCtxBPWOQxz3dRaU1JqOJHYc1RGgKjv8dt+Bb3GnUq2qRjdxzyIWa3bbY77Z7
cxb7fcbLHix07W20Wl3AH5jmSeZJ5kkk1s9F1V7ZtHdTv1FeBaL1JuVvk3G6wXWoL6nw3Hg
LaUtRaW3jcp5WBhwnq7KnaUpSlKUpSlK4/q2wPueG23ssJzFvrTK5gkoCmnksqC1tjzT/tY
bOPWrmQFV2ClKUpSlKVxnUVrnnw0xrE0qGLZdXUTXIxaSULRltbwV5v9y1RAfUeWSNyq7NS
lKUpSuOeCvTTtt8Il/YWFmHZFONR25Wd6VOqAS6kYwCptrmoYyCOsHl2OlKUpSlcf0lYH2/
DbcGX04i2Jp5cMRkBLTKXlFaGz5o/2vuHHrScEhNdgpSlKUpSlKUpSlU/Sek9NydHWV9/T1
rdddt7C3HFwm1KWotpJJJHMk9tS3kZpX3atH5Fr9tROrNJ6bjaOvT7GnrW061b31tuIhNpU
hQbUQQQORB7auFKUpSlKqtlsse6xZMyZLuinVXCYjzLrJbSEpkuJSAlLgAASkDAHZWdzQOn
nbi3cXGpy5rKdjclV0lF1CefIK4mQPOPL7z662fJS3f8AJu/fMv8Alr3pN52To6yvvurddd
t7C3HFqKlLUW0kkk9ZJ7al6UpSqlpmwRbhpW0zZUy7uSJMFl11fjiWNylIBJwHMDmeyt1rR
FjYlPymRcW5EnbxnUXaUFu7RhO48TJwOQz1Vq3qyx7VFjTIcu6JdTcIaPPuslxJSqS2lQKV
OEEFKiMEdtWqlKUpVS0zYItw0raZsqZd3JEmCy66vxxLG5SkAk4DmBzPZW61oixsSn5TIuL
ciTt4zqLtKC3downceJk4HIZ6q1b1ZY9qixpkOXdEupuENHn3WS4kpVJbSoFKnCCClRGCO2
rVSlKUpSlKUpSlQujPQew/DY/y01WdQxNXHVYlW23zHYbc6OslmcpAWwkILmEqkhG4kKTtL
QBBzuyc1ZtZ+g9++GyPlqqapSlKUpULpT7If+JT/wBW7VWveoWbBrK+Ih6gtdvdXb2ZTrFw
S46hx5IWk42uDYooDOQAVKG0hJxzvNslOzrVEmPxVxHZDCHHI687mlKSCUHIHME46h1VH6M
9B7D8Nj/LTU1SlKVC6M9B7D8Nj/LTUM3rNbt8YjpvFibDlychKtrylJkpCFLRuCwojcooCg
lSEg7gndkgmZ1X9kMfEoH6tqpqlKUpULoz0HsPw2P8tNUzUOqxImBi53a3W5EPUEdpFvUl1
MgoQ8g8VaytKQgpy4CUKRjb527BFz1X9kMfEoH6tqpqlKUpSlKUpSlKqWmb/Ft+lbTClQ7u
3IjQWWnUeJ5Z2qSgAjIbweY7Kk/Ku3f8a79zS/4qjNTX+LcNK3aFFh3dyRJgvNNI8TyxuUp
BAGS3gcz21baUpSlKVUrBqawW+FKizb5boshu5Tt7T0ttC05lOkZBORyIP+ak/LPSvvLaPz
zX7qeWelfeW0fnmv3U0Z6D2H4bH+WmpqlKUqn6T1ZpuNo6ysP6htbTrVvYQ42ua2lSFBtII
IJ5EHsqW8s9K+8to/PNfuqMv+prBcIUWLCvlulSHLlB2NMy21rViU0TgA5PIE/4q20pSlKp
+k9WabjaOsrD+obW061b2EONrmtpUhQbSCCCeRB7KlvLPSvvLaPzzX7qjL/qawXCFFiwr5b
pUhy5QdjTMtta1YlNE4AOTyBP+KttKUpSlK//2Q==
</binary><binary id="_207.jpg" content-type="image/jpeg">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
yC0zx0kjmUZa3jiUNnI3T842MO7c7hg5ydoaVx1fhBuUOnLbcemWinlqumbjPHlj+DLsa5u
Jsbcc3bHSOORsa8Zx6OiIiKLYvS+o+8me6U6tIiIulc7tR2iOF9WZvl5eFE2Gnkme921zsB
rGk/Na49XYul5V271a7+xqv4SeVdu9Wu/sar+EnlXbvVrv7Gq/hJ5V271a7+xqv4SeVdu9W
u/sar+EnlXbvVrv7Gq/hJ5V271a7+xqv4SeVdu9Wu/sar+EnlXbvVrv7Gq/hJ5V271a7+xq
v4SeVdu9Wu/sar+EnlXbvVrv7Gq/hJ5V271a7+xqv4SeVdu9Wu/sar+EnlXbvVrv7Gq/hJ5
V271a7+xqv4SeVdu9Wu/sar+EulSEX2+Xt8IuNJT1Ftp6ZtQ6mlpZGu3VG4sMjQdzQ9pyAc
EhWrTbGWi3ikZPNUfKySulm273uke6RxO0AfOceoBd1ERERRbF6X1H3kz3SnVpERFldQ361
xXa3F9YwG03B761oBLoW9BqJASAMkFvMEZzgjrBC0dFWQXChgraWTiU9TE2WJ+CNzXDIODz
HI9q50RERERERERERERERFFsXpfUfeTPdKdWkRQodY2mpgjngjuksUrQ+ORloq3Ne0jIIIj
5gjtX35V271a7+xqv4S8z8INtlvur7bXWqnvrKGr2Q3Xo1qqYXNaCWGQks89xile3qOACOY
OF6TDqW000EcEFFdIoomhkcbLJVtaxoGAABFyAHYvvyrt3q139jVfwlzUOobfcK4UUIrI6h
0TpWsqaGeDc1paHEGRjQcF7er6wqiIiIiIiIiIiIiIiKLYvS+o+8me6U6tIii6M+g9h7tp/
y2q0iIotV9OLX3bWfmUqtIiIiIiIiIiIiIiIoti9L6j7yZ7pTq0iKLoz6D2Hu2n/LapmptZ
s07qCipJKujEMvC48MobG9jZJCzicR0o80cyQ2N+Nh3FocCOaC4Xzx5UwVLoW1jqYPpLX5z
aZzWuaHy9J4Zc53ngbdrcfskEPPW1FX3OjNlra6sobHL4wfC6R1XJNSmM08jvlAeEHHc0Yz
1HBB5kKzpa7VF803R3KqhZFLO0k8MPDHgOID2h4Dg14AcMjOHDr618VX04tfdtZ+ZSq0iIi
IiIiIiIiIiIii2L0vqPvJnulOrSIoujPoPYe7af8ALarSIii1X04tfdtZ+ZSq0iIiIiIiIi
IiIiIii2L0vqPvJnulOrSIsxZodVWix0Fs8V2ibodNHBxPGcrd+xobnHRzjOOrK7vStVfY1
o9qy/p11qu86ko6migkslrLq2cwRlt1kwHCN8mT/wAP1YjP188Ls9K1V9jWj2rL+nTpWqvs
a0e1Zf06+KWlvVTqOnuNxpKGlipqSeANp6t8znukfE7PnRMwAIj9fWrqIiIiIiIiIiIiIiK
LYvS+o+8me6U6tIiIot99L6c7yf7pUK0iIiIiIiIiIiIiIiIii2L0vqPvJnulOrSIiKLffS
+nO8n+6VCtIiIiIiIiIiIiIiIiIoti9L6j7yZ7pTq0iIii330vpzvJ/ulQrSIiIiIiIiIiI
iIiIiKLYvS+o+8me6U6tIiIvJdd6xvNkvb7Y6Lj3Flc2os/BZzfFLTTQjDcOy5kp6nHLyeQ
Axj1aEStgjE72PlDQJHsYWtc7HMgEnAz2ZP+pXIiIiIiIiIiIiIiIiIoti9L6j7yZ7pTq0i
l6mrJ7fpW7VtLJw6imoZpYn4B2uawkHB5HmO1cPiK4/ey7/hUnwE8RXH72Xf8Kk+Apld4Pq
e5Xiju9bfLjNXUP/TzOhpMs7R/2MHB5jOcHmMFU/EVx+9l3/CpPgJ4iuP3su/4VJ8BcNMy4
W/VVJRTXqsr6epoaiVzKmOAbXMfAGkGONp6pHdeexaBERERERERERERERFFsXpfUfeTPdKd
WkUXWf0Hv3dtR+W5WlwRVtLPVT0sNTDJUU23jRMkBfFuGW7h1jI5jPWudccs0UDA+aVkbS5
rA57gAXOIa0c+0kgAdpIXIotV9OLX3bWfmUqtIiIiIiIiIiIiIiIoRtF6prlcKm3XWhiirp
2zmOooHyuY4RMjxubM3IxGD1dq++i6q+2bR7Kl/UJ0XVX2zaPZUv6hSdWU2pG6OvRnu1rfE
LfOZGMtkjXObw3ZAJnODjtwf9CtgsRqu0XuovtTVWemrhUy0lLFSVlPXNhhgkZLK5xmYXfK
NAe042PyNwGCcqhBp6sp75UymaaSWqpg3x3xIzUxBrmkQ8NzDGGnLjljQDjzm7gHu+NRacq
qqxsYau6Xapgq4JmtFU2ne5gmjc9o4fCYSGscWl3ME8iDhaC2CUWqkE9O+nl4DOJC+YzOjd
tGWmQ/PIPLd29an1X04tfdtZ+ZSq0iIiIiIiIiIiIiIiIii6z+g9+7tqPy3K0iIii1X04tf
dtZ+ZSq0iIiIiIiIiIiIiIiIii6z+g9+7tqPy3L8moiIvTPAL9OKzu1/wCZEv0AiIiIiIiI
iIiIiIi//9k=
</binary><binary id="_15.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAANAJUBAREA/8QAGg
AAAgMBAQAAAAAAAAAAAAAABQYAAwQCB//EADAQAAICAgEEAQMBBgcAAAAAAAECAwQFERIAB
hMhFCIxQWEHFRYyM1E2Q1JidZGz/9oACAEBAAA/AGztCnBWvdvXYY/HYynb7TXnUkfJkU1y
JHH2Z9yyfUfqPI7PTncqR3qr1pmmVH1swzPE/o79MhDD7fg9DOzP8D4H/ja//mvVOdqR/wA
S9uXOU3l+c8XHzP49fFsHfj3x5f7tb163rpg6UkwUdbu/HzwxzPfEtq1cv+F0WSu5cJA7j0
7KzRcVJOlhJHH0CdzteK1iJYJpEVXZAEklEaTNzXjExIP0udIRo7DEaO+hHYlWehi79CyYY
3r5KxqnAoEdNXbyLGrADmvFw4OhoPx0OOhO5sVZyGcxs1UwyPDWsqYDlJqUjBmhPINEpZlH
HRB9bZf06O4y/FlcVUyMCusVuBJ41cAMFZQwB1v3o9IWDnSPO467NHwqW7LtX7hscY5st5F
cpXdOKsqjkOJP0nwJxA5IB6BcqR3qr1pmmVH1swzPE/o79MhDD7fg9K2PpRX/ANnnbMEkda
yxqVjHStzCOG23g/kf6H5ADbgcT7jU+tb6IdiRT1+ysZVtWfkWKsRryngF8bRsUMfr0eBXh
yH83Hf56xd54KO/DYsPHNZtzxQ1cZ44XLUbHNyJw6+412ULsNeogDy9L1tlqRw/tBpWVaYv
PjbfMPM7IOMlYDipPFP14gb/ADvpg6nU6X8hjcZ27g8pk69WZvj0ZmEYtyjggUsY4js+FTx
H9MADivr6RohBij+4K+Lu3LNlooI45bKTPDLKygbfkrcgSRs/V+SDvoRcxVbEV8JiMZJcrR
S5KMRt82Z/GscbSFPqY7RkhKcN8Rz5a2PZPJ9vY/L2obNs3PLB/SMN6eEIdMNgI4HLTMN/f
R1vXVOJLzdx56bzTeKKWCsIHlZ0DLEJDIoJ0nITKpAH+Xv2W9Xfw9jze+ZIbkr+Xy+Oa9PJ
EG3sERM5QaOiPX0kAjWh0MwmJp57srGDJia0k/G/CZbEjS1y7GWMLLy58kDBA+wSB+N66sy
ePhoDEY+i9mBreURmn+TIzsURpW8jFuUoZIvHpiQAR/oA6J5LB0crPBPZ+SssCukcle3LAw
VipYbjZdglF9H+3WKtEqd4mvWL161DFxr8dHIhYSSME1HvipQQMNgbIk16Cjd2O7Xw+JnWW
lVeIRs7xQ+eRoYWYnkY4yxRD9TDagemI+xI6zdt1RkeyqQs2Ljpdi+SD8uUSxrI3lWPyhuZ
4hgm9+wv6667HZmCWpUrLBZC0mLVXF6fywbXgVSTnzVeIA4ghf064lqR1e4sFjqTTV4oYrV
pwszlZgOKMrjf1sXnEnNtnaH8sT0Qv4Spkp1mnmvIyrxAr5CeBdbJ/ljdQT7++t/9dUfwxi
hkYL6R2YpayhIVhuTRxRoOP0LGrhAp4LtdaOhsHqnARm7Sysks9kxW8hZRYzYctCqMYSEfe
1BaNnAXXHnofbfRmSJZHjdi4MTcl4uVBOiPYB+oaJ9HY3o/cA9Zsjiq2T8fyJLiePfH412a
vvevv42Xf2/O9e/79f/Z
</binary><binary id="_122.jpg" content-type="image/jpeg">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
DX/Upa9Hg391xlXly1r9XjW99f/9k=
</binary><binary id="_78.jpg" content-type="image/jpeg">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
</binary><binary id="_9.jpg" content-type="image/jpeg">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
V5YnQl2zt/VlaHq7Whsb7D3/C3X//2Q==
</binary><binary id="_16.jpg" content-type="image/jpeg">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
</binary><binary id="_166.jpg" content-type="image/jpeg">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
2H5PWz6//2Q==
</binary><binary id="_98.jpg" content-type="image/jpeg">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
</binary><binary id="_17.jpg" content-type="image/jpeg">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
pSlKUpSlKUpSlKUpSlKUpSlKUpSlK//Z
</binary><binary id="_12.jpg" content-type="image/jpeg">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
oMjDbSmY7PL2svwfA/9k=
</binary><binary id="_18.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAMAAcBAREA/8QAFQ
ABAQAAAAAAAAAAAAAAAAAABQb/xAAgEAACAgMAAQUAAAAAAAAAAAABAgMEBRESBgAUISIy/
9oACAEBAAA/AHD5ndjvzeW5SikOJpY+N69eI9WTXtSaV2O+C3VdDwCNLIfsSujQeNYLHVc9
nJYYXHtsgqwRmZ2jhBqwfhCeVIDMoIGwp5Gl+PX/2Q==
</binary><binary id="_211.jpg" content-type="image/jpeg">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
j1Tt5HCla9jm44Zbtdw2NcHncWlpCw2+u1DBPp6hNRerXZ4bDCKjo9mdM81LSWFnaicWHkD
zGCG8vtAqnVVGrY9ZdCpK+unomT0rMS0bY2lgDDO4yCAseC3cf9SMh24Bpw0HvUUWxfzfUf
tJn+JTq0iIiIiIiIiIiIiIiIiIiKLrP7j372bUfpuVpERERERERERFFsX831H7SZ/iU6tIi
IiIiIiIiIiIiIiIiIii6z+49+9m1H6blaRERERERERERSKjTNtqa2esLq6KWpcHy9HuNRC1
7g0NB2seBna1ozj0Lx1Ut3ibv5zV/NTqpbvE3fzmr+anVS3eJu/nNX81Oqlu8Td/Oav5qdV
Ld4m7+c1fzU6qW7xN385q/mp1Ut3ibv5zV/NTqpbvE3fzmr+anVS3eJu/nNX81Oqlu8Td/O
av5qdVLd4m7+c1fzU6qW7xN385q/mp1Ut3ibv5zV/NTqpbvE3fzmr+anVS3eJu/nNX81Oql
u8Td/Oav5qdVLd4m7+c1fzU6qW7xN385q/mp1Ut3ibv5zV/NTqpbvE3fzmr+anVS3eJu/nN
X81Oqlu8Td/Oav5qdVLd4m7+c1fzU6qW7xN385q/mp1Ut3ibv5zV/NTqpbvE3fzmr+anVS3
eJu/nNX81Oqlu8Td/Oav5qdVLd4m7+c1fzVJ1Vb7ZpzS9xu5qroHU0DnRb7vWua6Q8mAgS5
wXFo/wCe8d6zW3T1pv1ggnqBdA2rgxUUsl5q3hjiMSROBk5lp3NII7wQQO5dUiIiIiIiIiI
iIiIiIiIiIiIiIiIiIiIi5X+I1BLXaQqy1zOBTQVE88bycSNFPKGjHcSJDG4Z7i0HvAVq0U
EttZVwOcx0D6uWeAgku2yHiODvRniPkxj/AG7fTlUERERERERERERERERERERERERERERER
EUXWf3Hv3s2o/TcrSIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIous/uPfvZtR+m5WkRERERER
EREREREREREREREREREREREWOaaKmgknnlZFFE0vkke4NaxoGSST3AD0qZVOt+rNOXGjt1z
pp4qqCWlNRTvbM2NzmY/2nmQHA4yFXRERERERERERERERERERERERERERERERc/rSgnuVmg
gpqOsq3trqeUspKkQODWSNc47i9n+0EDn9otPLG4Qr9ar3VT6bNvpdQQ22ndUOuFNFdWtqX
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
gGYhL3Zyx/PG3s5BIcwuoO1RRmNvR6O4zTSSiKKB9FJTvlcWudhpmDGnDWPJ5+j8SAdI6wk
qpJaCgsN3NzZE90kMtKxop8OLWOc58jGPa4gkbHncGu5jC07Zro8Ox2uW23G53avtENfI6l
jiDMOb2nOLntDe0D+A5gDmcLZqdf0NHf47LV22up6qR1O0cUwNBMxAbtBkzIGuJDiwOALT/
3rqkUWxfzfUftJn+JTq0iIiIiIiIiIiIiIiIiIiKLrP7j372bUfpuVpERERFFg0laKfovDZ
Wf9JUvqod1fO7Er/tOOX9rOXZByO0/+p2VNpK0UlDLQxsrHUk1MaV1PLXzyRiIjBa1rnkN5
cgRggdy92PS1k02+d9noGUhqWxtl2OcQ4MBDeRJ54Jye8kknJ5raudpo7vHCyrE31EvFidD
USQvY7a5uQ5jgfsucO/0qS7QGm3sc11JUkvbIx7+n1G+Rkh3PY52/Lml2XbSSMlxxlxz7Zo
ewRSU8sMNZDLTUwpIpIrjUMe2EOLgzcHgloJ5A92AO4DG47TtsddJLi6KYzSStmew1MvCc9
rWta4xbthcAxuDtyC0HvAKqIoti/m+o/aTP8SnVpEREREREREREREREREREUXWf3Hv3s2o/
TcrSIiIiIiIiIiKRUaZttTWz1hdXRS1Lg+Xo9xqIWvcGhoO1jwM7WtGceheOqlu8Td/Oav5
qdVLd4m7+c1fzU6qW7xN385q/mp1Ut3ibv5zV/NTqpbvE3fzmr+anVS3eJu/nNX81Oqlu8T
d/Oav5qdVLd4m7+c1fzU6qW7xN385q/mp1Ut3ibv5zV/NTqpbvE3fzmr+anVS3eJu/nNX81
Oqlu8Td/Oav5qdVLd4m7+c1fzU6qW7xN385q/mp1Ut3ibv5zV/NTqpbvE3fzmr+anVS3eJu
/nNX81Oqlu8Td/Oav5qdVLd4m7+c1fzU6qW7xN385q/mp1Ut3ibv5zV/NTqpbvE3fzmr+an
VS3eJu/nNX81Oqlu8Td/Oav5qdVLd4m7+c1fzU6qW7xN385q/mp1Ut3ibv5zV/NTqpbvE3f
zmr+anVS3eJu/nNX81eJtHWmpgkgnkuksUrSySN93q3Ne0jBBBk5gj0K6iIiIiIiIiIiIiI
iIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIi
IiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiLHFNFOwvhlZI0OcwuY4EBzSWuHL0gggj0EFZERE
REREREREREREREREREREREWOaaKmgknnlZFFE0vkke4NaxoGSST3AD0rlnV1Vbqy91FKYe1
qCjhlbKwu3MkipYztw4YcN+QTkcsY58vFZqK/Opro+0w01wNuujqeQ01PxXNgEAkOIzM3fI
17gwgOB5HDc8lu6Qulwuxuc9VcaatpmzxClfBSOgGx1PFLnDnOODxByPMHPPBAbpS6lu82r
Po6gloZLe+rfRCcQGTgzNpnSlr3cUEuDm82hmNvLeHZAkW59ysVLT19P0N8tZe68V4pLbma
sbGal4YPrMl2Y37efLcwcw12/dtuptVN0rV3q7tsX1lofcaCOlfKJDtYHYex3e3tNyWu5HA
57gR0FfPfLZpm4VRlt1ZXwRPkhJY6lhAAz2tz3d2Cc7gDyBLeblzlPqjU/wBEdNrTQ0skza
aGnhqLbNA99XI/twtbJKC8tb3HstcXZLmhjit2233UN1+jqZj6Gjqpm17qh01G6QA09Q2IA
NbN2SQ7J7bhkcitWwV1Vp9tNC826KxT3K4wNaGGF9HslnkBLtxY5mInjGGbct78FaR1pq76
Cr6qCht1VVRU1HU031bomTMmdI3LG8RzpM7GhjTw3nd9nOGnaqNR6yEtJSUcFDJPcqt0VHU
VdunpoeHHCXvMjTIXscXZa0EDIjceYIIu1d9qrbpJtxrpLc2rbLHTzywzF9NE90whc8k7Tt
aSSWkgjaW7v9ywS3G/0dZHbaivtEtXWVLYqd8VLIOCzhSSF8kZlJO4wvYAHAcs5PNow2e41
Vzv1nqK6KGKrZQ3KCdsDi6MviqYI3FuRnaSwkA8wDjmpNvvGpG2rS1j03TUIlfYYquWe5Mk
4LmhsbA1jmHm4F2SCO4t581Tt1+vV+om3Kgu2n6al6W+llY5j6jhua4sbtkEjA8vdsLQWt7
Mg7+W73pq5XKsk07Jcn0dTLXWR9S6dtNsla7dASN24ja4SNyABlzM8hho1et16itUlxmhoX
xVdhmu1E1jXh0LmNa4xSZJ3jErO0NucO7IyFdtNXdfpyutlzno6jgU0E8clNTOh/1HStIId
I/OOEOeR3lWkRERERERERERERERERFjmhiqYJIJ4mSxStLJI3tDmvaRggg94I9C1voa1fRf
0X9GUfQPCcBvC+1u+xjH2ufd381g6s2DoPQfoO3dE4vG6P0SPh78Y3bcY3Y5Z78Lajtlviu
MlxjoaZlbM3ZJUtiaJXt5ci7GSOyOX9h+Cwy6fss9xFxmtFDJWhzXipfTMMoc3G07iM5GBg
+jAWPqzYOg9B+g7d0Ti8bo/RI+HvxjdtxjdjlnvwslLp+y0MFRBR2ihp4qpuyeOKmYxsrcE
YcAO0ME8j+JSaz04sklqt8VNRQFpa2JtMx0OCclro+QLXZIcBgkOOCDzHOWH+G9BablcKqp
6HPT18TWS2+CldHSuIfv3uje+QFwOA3GA0ZwOavxaZsEHB4Njt0fR5TNDspIxw38u03A5O7
LeY59kfgs9NZrVR10tdS2yjgq588Woiga2STJydzgMnJGTn0qZWaNs5pXstlqtFFK/Afutk
ckcrc52PaNpLcgOGHDtNaeYBBn6a/hza7JSVtLWMprhTVU7JmUj4CaeBzW7dzGSOkO45OXF
3PkOQC6noVL0HoPRoeicLg9H4Y4ezGNu3u245Y7sLWj0/ZYrdJbo7RQsopnb5KZtMwRPdy5
luME9kc/7D8FmFst7X0j20NMHUTSylcIm5gaRtIZy7IwAMDHJasumbBPSwUs1jt0lPTbuDE
+kjLItxy7aMYGTzOO9Z/oa1fSn0p9GUfT/F8BvF+zt+3jP2eXf3cl4pdP2WhfE+jtFDTOgc
58ToaZjDG5wDXFuByJAAJHeAF7js1qi6Zw7ZRs6fnpe2Bo6RnOd/LtZ3O7895/FZqeipaTH
RqaGHbEyEcOMNwxudreX+0ZOB3DJ/FZ0RERERERERERERERERERERERERERERERERERERER
EREREREREUI3e9VNyuFNbrVQyxUM7YDJUV74nPcYmSZ2thdgYkA7/QvfStVfk1o81l/bp0r
VX5NaPNZf26dK1V+TWjzWX9unStVfk1o81l/bp0rVX5NaPNZf26dK1V+TWjzWX9unStVfk1
o81l/bp0rVX5NaPNZf26dK1V+TWjzWX9unStVfk1o81l/bp0rVX5NaPNZf26dK1V+TWjzWX
9unStVfk1o81l/bp0rVX5NaPNZf26dK1V+TWjzWX9unStVfk1o81l/bp0rVX5NaPNZf26dK
1V+TWjzWX9unStVfk1o81l/bp0rVX5NaPNZf26dK1V+TWjzWX9unStVfk1o81l/bp0rVX5N
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
u8Nd/Jqv5Sda7d4a7+TVfyk6127w138mq/lJ1rt3hrv5NV/KTrXbvDXfyar+UnWu3eGu/k1
X8pOtdu8Nd/Jqv5Sda7d4a7+TVfyk6127w138mq/lJ1rt3hrv5NV/KTrXbvDXfyar+UnWu3
eGu/k1X8pOtdu8Nd/Jqv5Sda7d4a7+TVfyk6127w138mq/lJ1rt3hrv5NV/KTrXbvDXfyar
+UnWu3eGu/k1X8pOtdu8Nd/Jqv5Sda7d4a7+TVfyk6127w138mq/lJ1rt3hrv5NV/KTrXbv
DXfyar+UnWu3eGu/k1X8pTNTX+luGlbtRUtHd5KipoZoomfQ9WNznMIAyY8DmfSutRERFgr
KKluFK+lraaGqp5Mb4pow9jsHIyDyPMA/8L3DDFTQRwQRMiiiaGRxsaGtY0DAAA7gB6FkRE
RERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERER
ERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERE
RERERERERERERERERERERERERSKjU1tpq2ejLa6WWmcGS9Ht1RM1ji0OA3MYRna5pxn0rx1
rt3hrv5NV/KTrXbvDXfyar+UnWu3eGu/k1X8pOtdu8Nd/Jqv5Sda7d4a7+TVfyk6127w138
mq/lJ1rt3hrv5NV/KTrXbvDXfyar+UnWu3eGu/k1X8pOtdu8Nd/Jqv5Sda7d4a7+TVfyk61
27w138mq/lJ1rt3hrv5NV/KTrXbvDXfyar+UvB1jaWzsgMd0Er2ue2M2ir3OaCASBw+YBc3
J/uPxXvrXbvDXfyar+UnWu3eGu/k1X8pOtdu8Nd/Jqv5Sda7d4a7+TVfyk6127w138mq/lJ
1rt3hrv5NV/KTrXbvDXfyar+UnWu3eGu/k1X8pOtdu8Nd/Jqv5Sda7d4a7+TVfyk6127w13
8mq/lJ1rt3hrv5NV/KTrXbvDXfyar+UnWu3eGu/k1X8pOtdu8Nd/Jqv5S8TaxtNNBJPPHdI
ooml8kj7RVtaxoGSSTHyAHpV1ERERERERERFFsX831H7SZ/iU6tIiIiIiIiIotV9+LX7NrP
1KVWkRERERERERRdZ/ce/ezaj9NytIiIiIotr1ZZ73DObXVw1lRDxf8ApYZ4zK8MeWZA3Y2
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
cQGEnljOzLqMsrLhBDZrjVMt2RNNAInNLhE2XY1peHucQ5oGG95/5Xuy6lt9+eWURfubSU9
W9rtuWNmDnMa7BOHYbkj8HNwTlV0RERERcrRagstqv2ooLjd6GildcGPEdRUsjcW9FpxnDi
OWQef9lQ656V9ZbR79F8Sdc9K+sto9+i+JOuelfWW0e/RfEnXPSvrLaPfoviTrnpX1ltHv0
XxJ1z0r6y2j36L4k656V9ZbR79F8Sdc9K+sto9+i+JOuelfWW0e/RfEnXPSvrLaPfoviTrn
pX1ltHv0XxJ1z0r6y2j36L4k656V9ZbR79F8Sdc9K+sto9+i+JSanVmm3axts41DazEy31b
HSCtj2tcZKcgE55EhrsD+x/BVuuelfWW0e/RfEnXPSvrLaPfoviTrnpX1ltHv0XxJ1z0r6y
2j36L4k656V9ZbR79F8Sdc9K+sto9+i+JOuelfWW0e/RfEnXPSvrLaPfoviTrnpX1ltHv0X
xJ1z0r6y2j36L4k656V9ZbR79F8Sdc9K+sto9+i+JOuelfWW0e/RfEnXPSvrLaPfoviTrnp
X1ltHv0XxKTqzVmm6nR16gg1Da5ZZbfOyONlbG5z3GNwAAB5kn0LsFq3Ogiutqq7dO57Yqu
B8EjmEBwa5paSM554Kn1WmYa3pvSK+sf0+2i31H+mN7RvxJyZyf8AWP7sN5/Z5BINMw0t0q
aymr6ynhqqkVU1FDw2RPl2tBcSGb+ZYCRuw45zkEgrdpmG2/RPCr6x/wBE00lLHxOH9bE7Z
2X4YPs8NmC3B7PPOTnCdHUXQYKKOrrIqdtDHQVDGuYelwMBDWPJaSOTn82bD2zz5DGyaB9q
rbhdaV1dWmrc2R9vjMIaX7WR7ml20g7WDkX47+WcLW0VY/oKxOY+ghoKisqZauamhk3siL3
EtYDyHZZsb2QB2eX4noERERERERERERERERF88pa+Wb+LlXdXtYaJkEdqikALQGufKS9xPp
FRA6EDA3F7cejd9DRERERERERERERERERERERERERERERERFzFLaKDrZdKTgfU9Go6rbvd/
q9Kqpt2c5/1O1ju9HdyXToiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIii0v34uns2j/UqlaRER
ERERERERERERERERERERERERERERFFpfvxdPZtH+pVK0iIiIiIiIiIiIiIiIiIiIiIiIiIi
IiIi4iku2o20V01JcXsbR0DaxwoaepY5j3QOezb2qcPAOwndxDk89oB2gzV9zi0/Bqap0zT
QfSDYI4GxVUk0zw+QCMP4cB2tw9zh3nJDQNzsLJPr+ohp6Zn0BWCunqTDw5KarbERw3P3Mf
0cud9nG3YDnccbRuPR2S6m8W4VL6Opo5A4skiqIXxkOHpbva0uae8HAyDzAOQKCIiIiIiIi
IiIiIiIiIiIiIiIiIiIiIvzN/Dj/ANav/lus/wD0TTH/AGYa3/8AsP1in/sQ/wDyT/8AmX2
b+EX/AGYWj/6360i7NEREREREREREREX/2Q==
</binary><binary id="_184.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCACuAUsBAREA/8QAGw
ABAQADAQEBAAAAAAAAAAAAAAUDBAYHAgj/xABCEAABAwMCAQYMBQIFBAMAAAABAAIDBAURB
hIhExYiMVZ1FBU1NkGTlJWztNLTByMyUVRhgSQzQlXUNERScUNykf/aAAgBAQAAPwD2ZERR
dZ+Y9+7tqPhuTmZpXs1aPYYvpTmZpXs1aPYYvpTmZpXs1aPYYvpTmZpXs1aPYYvpTmZpXs1
aPYYvpTmZpXs1aPYYvpTmZpXs1aPYYvpTmZpXs1aPYYvpWHS9FS2+t1DS0VNDS08dybsihj
DGNzS05OAOA4kn+66BERERERERERERERERERERFF1n5j37u2o+G5WkREREUWxeV9R95M+Up
1aRERERERERERERERERERERRdZ+Y9+7tqPhuVpERERFFsXlfUfeTPlKdWkRERERERERERER
ERERERRbtV3Xx5Q2y2T0dPy9NPPJJU0zpv8ALdE0ABsjMZ5U8cnqCeC6q/3m0e6pf+QvGZd
MaxittxrLPTTWGwR0M0ksE75IRUDYWybqd8spDy3IBOBhrSCDhfoBclf668wauoaejnuLKN
/g/KNgoeUiOZXB+X8m7rbjdl8exuHDeTtH2y5XFlXdBVm9crHBUvbBS0TDDGxjsRGJ7mdOV
7C1wbucM7wQ3AaI3jKuuOn9t4t1dUVNBeaOSnkNtne90Ykje6QfkR8QBM0kMbgADiXAuoX6
46kbqS2SWzwwWup8E6DaY8czHlt7TC5zMRlv6nxY443EEDrIHZmqRykz9soGJI9rWdBvBhw
NzfTnJ4lwzwwODt1oNz1bFdLrbGGO4Vc9XDIbU+OeB1O5kcDXyuy5jXsZymCGZcMZIcWn0N
crRW2rrL9qKSC+V1A0XBjTHTsgLSfBafj+ZG454/vjh1Kh4iuPay7+qpPsJ4iuPay7+qpPs
J4iuPay7+qpPsJ4iuPay7+qpPsJ4iuPay7+qpPsJ4iuPay7+qpPsJ4iuPay7+qpPsJ4iuPa
y7+qpPsJ4iuPay7+qpPsJ4iuPay7+qpPsJ4iuPay7+qpPsJ4iuPay7+qpPsJ4iuPay7+qpP
sJ4iuPay7+qpPsL70zUVVTZ3GsqX1UsVXVQcs9rWue2OokY0kNAGdrR1AKuiIiIiIiIiKLV
efFr7trPiUqtKLrPzHv3dtR8NytIiIiIoti8r6j7yZ8pTq0iIiIiIiIii6U8kT95V/zcqtI
iIiIiIiIii1Xnxa+7az4lKrSi6z8x793bUfDcrSIiIiKLYvK+o+8mfKU6tIiIiIiIiIoulP
JE/eVf8ANyq0iIiIiIiIiKLVefFr7trPiUqtKLrPzHv3dtR8Nyc89K9pbR7dF9Sc89K9pbR
7dF9Sc89K9pbR7dF9Sc89K9pbR7dF9Sc89K9pbR7dF9Sc89K9pbR7dF9Sc89K9pbR7dF9Sc
89K9pbR7dF9Sw6XraW4VuoaqiqYaqnkuTdksMgex2KWnBwRwPEEf2XQIiIiIiIiIoulPJE/
eVf83KrSIiIiIiIiIotV58Wvu2s+JSq0iIiIiIiIiIiIiIiIoulPJE/eVf83KrSwS1tLBVQ
Us1TDHUVO7kYnyAPl2jLto6zgcTjqWdERERERERRarz4tfdtZ8SlVpERERERERERERERERR
dKeSJ+8q/5uVZr/e/ENCyq8V3G5b5RHyVvp+WkbkE7iMjo8MZ/chQIbvpvWupLe2kno7rSO
ttXysEjA7H51NjfG4ZHFpIyOOMhWfE9bbvzLNcZnAcXUlwmfURyfviRxMjHHAGcuaBk7CSn
OB9D0L5b5qEj/54Q6opsekmRrQWNaMZMjWDrwSASq0M0VTBHPBKyWKVofHIxwc17SMggjrB
HpWRERERERRarz4tfdtZ8SlVpFLrNTWC31T6WtvlupaiPG+KarjY9uRkZBORwIP91h556V7
S2j26L6k556V7S2j26L6k556V7S2j26L6k556V7S2j26L6k556V7S2j26L6k556V7S2j26L
6k556V7S2j26L6lmo9TWC4VTKWivluqqiTOyKGrje92Bk4AOTwBP8AZVEREREREREUibSem
6meSefT1rlllcXySPoo3Oe4nJJJHEk+lSb/APh1ZLtQspaGht1q3Sjl5YLbC6R8WCHMaS3o
OOQQ8cQQtLTmibNozV1BDamTF89tq+Wmmk3Pk2y05bnqaMbiOAH9crukUibTdEZ5KmhlqbZ
UyOL3SUUuxrnk9J7ojmN7j1FzmE9XHIBHx4dfLdxuFBDXU7f1VNvLhJ+5cYHZIaBkdF73Eg
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
srprbUQsY3waduS57AP1OaOv0rp0RFF0p5In7yr/m5VaREREUWq8+LX3bWfEpVaRERERERE
RERERERERERERFIm0npupnknn09a5ZZXF8kj6KNznuJySSRxJPpXxzM0r2atHsMX0pzM0r2
atHsMX0qff7HpCw2Cuu02mbKW0kDpAx9JEwPcB0WZLeBccAf1I61w34T0dlr57lZ75p+mku
Bcaxj622sY5zSRHKxrduGtZK0tGCM5PRbggek8zNK9mrR7DF9KczNK9mrR7DF9KczNK9mrR
7DF9K2qDT9ltU7p7daKGilc3YZKemZG4tyDjLQOGQOH9FQRERERERERERERERERERERERFg
rKKluFK+lraaGqp5Mb4pow9jsHIyDwPEA/2UzT9FatktdR0353hNXC6omjbyv/AFMhe0OHH
Zym4gftjPFWkREREREREREREREREREREREREREUvT8sE1uldTU3g7BXVbSzeX5cKiQOdk/+
TgXY9GcehVERERERERERERERERERERERERERFPvd2Fktxrn0VTVxscBIKcsBjaf9bi9zQGj
0nPAcTwBI1dPXGiq5LnR2+jmgioK6WOWR8jHskmc4ySbS17j1vyQcY3YwCCBaRERERERERE
REREREREREREREREWOaGKpgkgniZLFK0skje0Oa9pGCCD1gj0LzmmFFpz8TbdpqkomU/KuE
9JLE7OKQUsjXQOJ445aPlcZIc5xccO6/SkRERERERERERF//9k=
</binary><binary id="_20.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAASAJgBAREA/8QAGg
AAAgMBAQAAAAAAAAAAAAAAAAUDBAYCB//EADIQAAICAgEDBAEDAgQHAAAAAAECAwQFERIAB
iETFCIxQRUjUSQyBxYzYTZCQ3J1gbP/2gAIAQEAAD8A9S/XardzJgoZIZbHtpJ5gkwLwcTE
FDL9jkJdgnX9v534adHS+1fl/Va+MpqjSsvrzyOCVhiDAaIH/M52F3ofF288OLR4XMSZZr6
zY+ag9KyIDFM6M5/ajk2eBKj/AFPoE/X/AKFrJ34sVireRnV2iqQPPIqAFiqqWIG9edDq11
HHNFK8iRyo7QtwkVWBKNoNo/wdMDr+CP56xmQlqZKzBlL2BTOwX7Zp46uyxNwiSORzMglPD
bsjHYYBoxEfsaLqD2+AfHR1MTWxmPvMVnjjiRDDYYL6fLgeAB4shOztzGBvfTaWxwtQV0aE
vJyZkeTi/BR5ZV0eWmZAfoDlvf0Cmwnc0+VvV4ZsZ7avfo++ozrOJPUj2oKuugUcCSM6HJf
kdMddNrWTx9GevBcvVq8tpuEEcsqo0rbA0oJ+R2R4H8jqYzRLOkBlQSurOsZYcmUEAkD8gF
l2f9x/PS/9YkHcyYZsfNGj1pJ0tO6cJOBiBCqCW/6vksF+vG97EmYyy4qCDULz2bc6160Kg
/ORgT8iAeKgBmZtHSqTonQNXL525h+2Z8tNhpppq8TvLXinj0nAMS3MkbT4+CBy0w+G9gd5
LMWIMrBicdTSzdlgex/USPDCI1ZVP7gRttt1+IH15JHx5LLnerJjhksfintVYsfDkrQeYRS
x15eRBRdEOyrG5Kll+gATvxn+1sBaTI2Ki496lmnPTW7kGlV/Wni3NLKG5F2aYWCnkACNjs
7/AGuth3DhbmY9v7TI+z9Lly+Vgc961/ozRfWj97+/GvO4cB29fxN57FrK+7RoigTlaOjsH
f7tiRfx+FB8/f2D3HI0Hf1iN4X43cXE0MgI4kwyycwfOwf6iPXjR8+fHXHbz5D9VzD28Lco
xXLIsRSTSQMNCGGPiQkjHltGP1rX5346471xV7IduZU1MjeQnHzIKVeOJlnbg3j5Rs+22Bp
WH+2j56bY6jZpep7jLXMhz1x9ykK8Nb+vTRfvf539D66zmUwt2l3HL+i1Ur1s/AK9yxWi9N
68iuzmYup2GaOSYBip1Isezo9M8/Qj9hj6sXblbLUoZwslP0oT6UYjcKY1kZUBDcB/2k6HS
+WnPV7axuNlj9OxYy8T16+wfSjW17gR7HxHpwRkaB4/DipPjego2JLVq5Ly/p45fRh4yI6P
xHzbwNq3MshUk69L6GztZjvez9xSXpsRkYPUiEYa9NW9Osg2SsQiZm5O3Ety8EKPPxVTV7k
7ZymXv2bFK1RiiepFH7e1WE6W5I5GdVmDA6jAJAKabbkk/FQTt/ty9R7jmytqGtArVBXCi9
Pemc8+WzLMAUUfhFGiWJP0urVx8h/nOlYjwtyWpBWmrvZWSAJuV4GDaMgbivptv47/AIB64
7rxAzkVIWMQ9+tj8gs8lUsgNlREwBUFgpAeRdhyuwjeCNBqt3H5OL/Dy7iocbNYs3IrUMFa
KSIe2SUyGJWLOFCorIhCkga0uwN9Ve4sZb7jt1xmO271/DNBzXHpZgjlr2VZhzfUg5Bkbxx
kIGjtdkEFvDdxvjrta7GmRu5bDR4+W1W4RxQyj1tu4ZgeP7y+UBJ4seK+F62/R0dJe6fjjq
ky+JY8lS4OP7l5WI0bR/G0dlP8hiPonp10dHR0dJbX/HGL/wDG3P8A6Vem0UMUCFIYkjUsz
lUUAFmJZj4/JJJJ/JJ6k6Ojo6Ojo6Ov/9k=
</binary><binary id="_108.jpg" content-type="image/jpeg">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
APk+QfJ+fX/9k=
</binary><binary id="_13.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAEAA0BAREA/8QAFQ
ABAQAAAAAAAAAAAAAAAAAABQb/xAAhEAEAAQMCBwAAAAAAAAAAAAABAwIEBQAGERIVMVaT0
//aAAgBAQAAPwC223hr+exurg3PlI5JMhd0yNMdqtbRPXGKsKry0UnfgAAAALdCyPlmX9Vp
8Nf/2Q==
</binary><binary id="_151.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAB4ASwBAREA/8QAGg
ABAAIDAQAAAAAAAAAAAAAAAAUGAwQHAv/EAEAQAAEDAwIDAgoJAwQCAwAAAAECAwQABREGE
hMhMRRBBxUWIlFVVnWV1DI1NpOUs7TS0yNhgTNCVJEXcSVSwf/aAAgBAQAAPwDs1KUpSlU/
Sek9NydHWV9/T1rdddt7C3HFwm1KWotpJJJHMk99S3kZpX2atH4Fr9tROrNJ6bjaOvT7Gnr
W061b31tuIhNpUhQbUQQQORB76lvIzSvs1aPwLX7aeRmlfZq0fgWv21GX/TNgt8KLKhWO3R
ZDdyg7HWYjaFpzKaBwQMjkSP8ANW2lKUpSlKUpSlKUpSlKUpSueWnXV2ul7skPt1lQ5cn30
ybcI7xkwkthStiyVDzsJ2kqSnmcpChmrzPcuDbCTbo0aQ7uwUSJCmUhODzylC+eccsf5qP7
Vqr1NaPirvy9O1aq9TWj4q78vTtWqvU1o+Ku/L1rXN7U7tqltrtcFlK2FpLkW6vF5AKTzRt
jE7h3YBOccq5/YZvhVcfjG02+c3b21FtxvUDzbiiokkrUoobdKRuBGM/RwM/RrpOjPsPYfd
sf8tNcv07cfCQ54WFMTlSS0X1Jltrad7EljKhubBHmghs7FciojmTlWeoaz+w9+92yPy1VN
VxV4+ExPhYcLCLouELgS2ha1JhKj55AkAoA4ffgqz3FdXrUsnUhtbIetNrQnxhCIKLm4o7u
0tbRgsDkTgE9wJODjBlu1aq9TWj4q78vTtWqvU1o+Ku/L07Vqr1NaPirvy9O1aq9TWj4q78
vTtWqvU1o+Ku/L07Vqr1NaPirvy9O1aq9TWj4q78vTtWqvU1o+Ku/L07Vqr1NaPirvy9O1a
q9TWj4q78vTtWqvU1o+Ku/L07Vqr1NaPirvy9O1aq9TWj4q78vTtWqvU1o+Ku/L07Vqr1Na
Pirvy9O1aq9TWj4q78vXgXe9Rrlb41xtUFpqc+pgOR563VIUGluZ2qZTkYbI699TtKUpSlK
0p1ph3GVDkyQ8XYLvFYLchxsJVjGSEqAVyyPOzyKh0Jzu0pSlKqWmb/Ft+lbTClQ7u3IjQW
WnUeJ5Z2qSgAjIbweY7q8RtSwBrG5PGPdNq7fESALTKKshyQTlPDyB5wwSMHnjoce9TX+Lc
NK3aFFh3dyRJgvNNI8TyxuUpBAGS3gcz31J+Vdu/413+DS/wCKnlXbv+Nd/g0v+Ko+9XqPd
YsaHDiXRTqrhDX59qktpCUyW1KJUpsAAJSTknuq1UpSlKUpSlKUpSoW+/W+nPeS/wBJIqap
SlKUpSlKUpSlQsX7cXT3bD/MlVNUpSlKUpSlKUpSlKUqFvv1vpz3kv8ASSKmqUpSlKUpSlK
UpULF+3F092w/zJVazeqn5mpHLTAti1tx3+BIfkIkNBKgkKUUkMqQRtIxuWncenIpUr3atc
6dvTanrfMedjt7uJJMN5DLe1O5W5xSAhOBz5kdR6azOattDMVUh1cxAS6hpTaoD4dBWSEHh
7N+1RBSFYwVDAOeVa0jW9tadiJaYnPB+WqK6BAkBbKksl3mjh7iSNmBjmFFQyEmt+TqWxwe
EJ12hwVvNB1DUx5LDm09CULwodCOY6gjurTd1zp1rjKTMekNMNB5x+LDefaSjn53EQgp2+a
oZzgFKh1Bx7tOrIN4uUqFHakqDL/DafTGdUy6nhIc38TZsSDuOMq84BJGQoUi6zsU66yLZD
fkyJUV/gPpagvrS0vcU4UsI2pGQeZOOROanaUpSlKUpSlQt9+t9Oe8l/pJFZr/AKjtOmIKJ
t5l9ljuOhpK+GteVEEgYSCeiT/1WFerLWjhBSLiFvb9jXiuTxCEbdx2cPdtG9IzjGTjPWvc
/U9qtrCZD7klcZTHaBIjw3n2eHgndxG0KSBgZ69OfQ1hkazsUa9v2UvyXbhGSFux48F95SE
kAg+Yg8sKTz/vXvyy0weTeoLc8s/RaYkodcWe4JQklSlHoAASTyAqPneESxRrU7MZVJdc7I
5KitOw32e1JSkHzFKR5wwQSRnCcqPIE1JyNT2qHZH7zMckxYUdQS4uRDeaUCSAPMUgKIyoD
IGP+jWFnWNpksNvsN3R1p1IW24i0S1JWkjIIIb5gjvqdpSlKUpULF+3F092w/zJVe4VhXCu
8qei8Tlplvl96KtLPCUrYEAZDYWAEpSB53+0Zzk507LoqJZbIuxi4zpdqWw4wYkgtbQlZJU
dyEJXnmr/AHd//rB3RrbyJCnb3dFypL7DrkpSmSvDJ3NICeHsSkL87ASCSTknJFe3dJJcmP
S03q4tPOThNSpAY/pL4RZwkFsjbwyE+dk+aDnOSZa3QlQISY65kmYoKWovyVArUVKKue0AA
DOAAAAAB3VXLnpq83HV789u4vW+A/BRDUuFN2ukArUVFCmVDduXgEKBSMkHngbsbSDMB7/4
+7XGHE4rDhhsrb4Z4SG0JSVFBc2lLSARv5jPpNe7RpZuyXGXKh3Sdwpst2Y/EXwS0pxzrz4
e8AcsAK7h155naUpSlKUpSlQt9+t9Oe8l/pJFe9Q6dj6jYhtvyZMZUKWiYy5HKNyXEA7fpJ
UCOfTFR910LAvTkSRcJb0iXFaW12l2LFcW6lSgoBQUyU+bjlhIxlXpOdO7+C2w3hltl1x6O
huMiPiOxHRyStS9w/peYoqWoq2bQc9Kk4mkkwr7JvLF6uKZE3gdrSQwUP8ACSEjI4eRkZzt
KepxjliceLqWHCwhC3QkltC1lKVKxyBIBwM9+D/6NUmyeD5/yfYtuoblMf7LGdjMtNTA402
HG9inE/0kHcEqWlIXvCUnA/tL3HRrd5tE+2XW93SY1OS0lRWplJaDaysbAhsJBJ6kgkgD0C
pmBEehsKbfuMmeoq3ByQlsKAwOX9NCRjl6M8+tbVKUpSlK5xaNdtzfCC7bkRmRc5HDgvxw8
vYzwHJanFhfD8/zdhAwM7wMjBx0elKUpSlKUpSlKUpSlcv1/q69WnVUO2Q2YL81MuM/aWVJ
Xl1Lrb7LgcOQkELIxgjkoHnzx1ClKUpSlKUpSlKr8LVEq4QWJsXS13cjyWkutL4kQbkqGQc
F/I5Hvqn2uw3aD4VLnqpWj5PYpLGGG0OROK26QgKXji4BOHMkHJ3H0mrhN1RKt8GRNlaWu7
ceM0p11fEiHalIyTgP5PId1ZvHtx9k7v8AexP56ePbj7J3f72J/PXhzUsiMWTM05dIrTr7T
HGWuMpKFOLShJIS8TjcodAanaUpSq/C1RKuEFibF0td3I8lpLrS+JEG5KhkHBfyOR76zePb
j7J3f72J/PWGXqiVBZS9J0td0IU620DxIh85awhI5P8AepQH+azePbj7J3f72J/PTx7cfZO
7/exP568OalkRiyZmnLpFadfaY4y1xlJQpxaUJJCXicblDoDU7StK7XNFot5lrYekf1W2kt
M7d61OLS2kDcQPpKHUitLx7cfZO7/exP56ePbj7J3f72J/PVP1THkXPXGlLq/pKclMV91Cg
p2MHXlhBcaAKXuYSW1qwogdeucG4ePbj7J3f72J/PTx7cfZO7/exP560rHru3X3U0vTzUOZ
HnQmlOPB0tKQnBSCnc2tQ3AqGR3YIPMYqz0pSlKUpSlKhdGfYew+7Y/5aaw3XXel7JeE2m5
XhmPMVty2UqIRu6blAbUenziMAg9Dms2s/sPfvdsj8tVTVV+1a70ve7wq0228MyJid2GwlQ
C9vXaojav0+aTkAnoM1m1X9UMe8oH6tqpqlKVWLd4SNG3Pidn1DDRw8bu0qMfOc9OIE56d2
ccvTW7oz7D2H3bH/LTWGXrrTUHUSdPyblsuanW2gxwHD5y8FI3BO3nuHf31m1X9UMe8oH6t
qpqq/atd6Xvd4VabbeGZExO7DYSoBe3rtURtX6fNJyAT0Gazar+qGPeUD9W1U1UXf9R2nTE
FE28y+yx3HQ0lfDWvKiCQMJBPRJ/6qGuupbHfbRGFru0OWtU6A7wmnklxKe1s81I+knqAcg
YJwattV+1a70ve7wq0228MyJid2GwlQC9vXaojav0+aTkAnoM1mvv1vpz3kv8ASSKmqqUy8
P6tlLs+mZuyCjAuF5jqCg2CM8JhXRTpBGVDIQD3qIA926w2vTmp7Vb7RDRFjC3zl7EkkqUX
YuSSSST0GSegA6AVaqUpSlKUpSlQujPsPYfdsf8ALTVG1j4L4upfCOxJXc3o6LhGU/IQGwo
/0Sy2Qk55bkrHMg4KT1zgXnWf2Hv3u2R+WqpquZaf8CVqs2ovGMqf4ziN7+FCkRUlPPIG8k
kKwD3JHPB5YxU7qXSem2LWytnT1rbUbhCQVIhNglKpLSVDkOhBII7wTUt5GaV9mrR+Ba/bT
yM0r7NWj8C1+2nkZpX2atH4Fr9tPIzSvs1aPwLX7apn/hWHP+u7xxtn+l4tt0eDjPXdtSd/
QYz05+mrboKGxB0FY2YzexCoLTpGSfOWkLUefpUon/NUW+eCaBcfCW3IVN2RLhxZz0XhKOd
i2Q4jfvz55dUcjG3oB6Ogar+qGPeUD9W1U1XMtP8AgStVm1F4xlT/ABnEb38KFIipKeeQN5
JIVgHuSOeDyxip3Uuk9NsWtlbOnrW2o3CEgqRCbBKVSWkqHIdCCQR3gmpbyM0r7NWj8C1+2
oy/+D613CChmzQ7RaJCXQpT/idh/cnBBTtUMDmQc/2/vVcc8Fdl025EvgkSZVwRcIWSQhtl
K1SmgpSG0JG0YKgE5IAP9ga6hXLNC+C+LYtbzroi5vPItMlTEdktgFW9hCgVKzzwl4jAAyQ
Dy+jV5vv1vpz3kv8ASSKq1yuU3wkXF+wWCQuPp2Orh3O6t9ZJ72GT3gjqrpg//XAcvNttsK
z25i32+OiPFjp2tto6Af8A6SeZJ5kkk1Hyvtxa/dsz8yLU1SlKUpSlKUquWyzaktVqiW5i9
2tTURhDDal2pwqKUpCQTiQOeBURcZV1h6qivS9SWJns0GUlx5yEpDbOVxTtXmRyUd7ZHMcj
0O4Yl7nZtSXW1S7c/e7WlqWwthxSLU4FBKklJIzIPPBrZ7Lqr1zaPhTvzFOy6q9c2j4U78x
WGVZ7/cEsszbxblR25LD60s21xC1cN1LgAUX1AZKAM4PWrBSlKVXLZZtSWq1RLcxe7WpqIw
hhtS7U4VFKUhIJxIHPArSkxtSeWNtBu1rLpt8spWLY5tCeJHyCOPzJO3ByMYPI55btws2pL
lGQw9e7WlKH2XwUWpwHc24lxI5yOmUDP9s1s9l1V65tHwp35inZdVeubR8Kd+YrDKs9/uCW
WZt4tyo7clh9aWba4hauG6lwAKL6gMlAGcHrVgpUffLa7dbb2ZiQiO6l9l9txbRcSFNupcA
KQpOQSjHUda1ey6q9c2j4U78xVfskq6ru90bZ1JYg7MnJUyDCUrtOIkdW5sCQMpCCnpu9Oc
HAz6o0df8AVltbgy9SQ4qG3S4FxLc4hZyhSCkkvnzSlagR35qQttjvtntzFvt9xsseLHTtb
bRaXcAfiOZJ5knmSSTWz2XVXrm0fCnfmKRLTdfHjNzudyhyOBGdYbbjQlM/6im1EkqdXnHC
HLA6mpqlKUpSlKUpSuP6tsD7nhtt7LCcxb60yuYJKApp5LKgtbY80/7WGzj0q5kBVdgpSlK
UpSlcZ1Fa558NMaxNKhi2XV1E1yMWklC0ZbW8Feb9JaogPoPLJG5VdmpSlKUpXHPBXpp22+
ES/sLCzDsinGo7crO9KnVAJdSMYBU21zUMZBHUHl2OlKUpSlKUpSlKVT9J6T03J0dZX39PW
t1123sLccXCbUpai2kkkkcyT31LeRmlfZq0fgWv21E6s0npuNo69PsaetbTrVvfW24iE2lS
FBtRBBA5EHvq4UpSlKUqq2Wyx7rFkzJku6KdVcJiPMusltISmS4lICUuAABKQMAd1Z3NA6e
duLdxcanLmsp2NyVXSUXUJ58griZA848v7n01s+Slu/5N3+My/wCWvek3nZOjrK++6t1123
sLccWoqUtRbSSST1JPfUvSlKVUtM2CLcNK2mbKmXdyRJgsuur8cSxuUpAJOA5gcz3VutaIs
bEp+UyLi3Ik7eM6i7Sgt3aMJ3HiZOByGelat6sse1RY0yHLuiXU3CGjz7rJcSUqktpUClTh
BBSojBHfVqpSlKUpSlKUpSoXRn2HsPu2P+WmqzqGJq46rEq22+Y7DbnR1kszlIC2EhBcwlU
kI3EhSdpaAIOd2TmrNrP7D373bI/LVU1SlKUpSoXSn1Q/7yn/AKt2qte9Qs2DWV8RD1Ba7e
6u3synWLglx1DjyQtJxtcGxRQGcgAqUNpCTjnebZKdnWqJMfiriOyGEOOR153NKUkEoOQOY
Jx0HSo/Rn2HsPu2P+WmpqlKUqF0Z9h7D7tj/lpqGb1mt2+MR03ixNhy5OQlW15SkyUhClo3
BYURuUUBQSpCQdwTuyQTM6r+qGPeUD9W1U1SlKUpSlKUpSlVLTN/i2/StphSod3bkRoLLTq
PE8s7VJQARkN4PMd1SflXbv8AjXf4NL/iqM1Nf4tw0rdoUWHd3JEmC800jxPLG5SkEAZLeB
zPfVtpSlKUpVSsGprBb4UqLNvluiyG7lO3tPS20LTmU6RkE5HIg/5qT8s9K+0to/HNfup5Z
6V9pbR+Oa/dTRn2HsPu2P8AlpqapSlKp+k9WabjaOsrD+obW061b2EONrmtpUhQbSCCCeRB
7qlvLPSvtLaPxzX7qjL/AKmsFwhRYsK+W6VIcuUHY0zLbWtWJTROADk8gT/irbSlKUpSv//
Z
</binary><binary id="_202.jpg" content-type="image/jpeg">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
</binary><binary id="_21.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAPAD8BAREA/8QAGA
ABAAMBAAAAAAAAAAAAAAAABgAEBQf/xAApEAACAgECBQQCAwEAAAAAAAABAgMEEQUSAAYTI
TEUIiNBFTIzUWGR/9oACAEBAAA/AOjQ820LnN/4Klahm6EUq2yFb45wUKRhv1LFRMSoyfjP
jaeKXI2lCjNqtqvH6anPLHHDWFWWv/GmDMyOiKHfI3dNAvsHcnJ4W8Tg/qHNtCtzPR0CG1C
9t5QbkZVj0ImRthLD2qxk6SgE5PUGB7geEHFLRtR/L6HQ1PpdH1laOfp7t2zeobGcDOM+cc
VTqWoJzbDpklestKapNPHKsrNKzI0IwV2gKPkP22ex7eCW5Z5btLas6VLHThp6VLTqtLXYh
5/ThbCHZtAVneYs7bj9qAT8h6BwY1fkTTdZ1SbULEu2WbbuHoKcnhQP2khZj4+2P/O3GnoG
g1uXqL1Kr7keUyE9CGLuQB4iRF+vJGf98YJry3am5k1XRljppUlrTvNaRisrJdmdpMptwzg
QLGpLYUAMQ2dis9R0qtqfT9RJcTp52+muzV85x56bLnx95x3/AL4zOUOXhomh6cJjcW4lGK
KeKW9LLGjBV3BULlBgjA2jsOw7cTUa2vnmaDUaVHTpa9atLAgmvSRu/UMTEkCFgMGIjGTnO
e3jj//Z
</binary><binary id="_69.jpg" content-type="image/jpeg">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
3AlaW7O9iSBKhkWJnYsVDl13AE4ztGfeB66//9k=
</binary><binary id="_35.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAFAAwBAREA/8QAFQ
ABAQAAAAAAAAAAAAAAAAAABgf/xAAkEAABAwIEBwAAAAAAAAAAAAABAgMEBQYAERIVISIkV
nGT0//aAAgBAQAAPwCmbFUe7Kv6onwwZi2W5Va3XXHrsuNlbU5DZMWWhgOdMwdSkoQE6ubL
MAcEjzj/2Q==
</binary><binary id="_162.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCABjAWUBAREA/8QAGw
ABAQADAQEBAAAAAAAAAAAAAAUDBAYHAgj/xABBEAABAwMBAgkJCAICAQUAAAABAgMEAAURB
hIhExYxQVR1ldLTFCI1NlVWlLO0BxUXMlFhpNQjkTNxQkNSgYLB/9oACAEBAAA/APZqUpSu
Yes1qu+uLh952yHO4K2xOD8pYS5sZck5xtA4zgf6FbvEzSvu1aPgWu7TiZpX3atHwLXdpxM
0r7tWj4Fru04maV92rR8C13acTNK+7Vo+Ba7tOJmlfdq0fAtd2nEzSvu1aPgWu7Xxo5lqNY
VsMNIaaauE5DbaEhKUJEp0AADkAHNV2lKVC1iy1JsKGH2kOtO3CChxtaQpK0mU0CCDygjmr
74maV92rR8C13acTNK+7Vo+Ba7tOJmlfdq0fAtd2nEzSvu1aPgWu7TiZpX3atHwLXdpxM0r
7tWj4Fru04maV92rR8C13a0mbNarRri3/dlshweFtsvhPJmEt7eHI2M7IGcZP+zXT1jecU0
w44hlbykJKg2ggKWQOQbRAyf3IH71AsutI99nsQ41oujSnGFPOrfZQhMYJcca2XPOyFFTSg
EgE/6OOjqLrP1Hv3Vsj5aqcTNK+7Vo+Ba7tOJmlfdq0fAtd2nEzSvu1aPgWu7TiZpX3atHw
LXdpxM0r7tWj4Fru04maV92rR8C13acTNK+7Vo+Ba7tT5un7Lar9p1+3WiDCdVcFoLkeMht
RT5LIOMpA3ZA3ftXVUpSlQjquP5bCaFvnLiT3+AjTkIQpl1WypWQArb2cIV5+xs4G1nZIVV
2lKVFi+vF06th/MlV93bU9qsktqLPckodeSFNhqG86FAqCNxQgjO0pIxy5Un/ANwzh4xOuX
K0CLCQ9arslJZnF8pUVKaddADRTnGy2MkkfnG44OLtKUpUXSnoh/rKf9W7VqlKVF1X6IY6y
gfVtVapSlKi6k1MzpmO1IkQJkppzhMqjcH5mw2pw521p/8ABCzuz+UjlIzpStQ3J6FAudvZ
ZjxFThEmMTG9p4KMpEchJQvZGMuHOVcid284yXm4M23WNpefRJWlVvmJAjxnH1Z4SMfytpU
QN3LjH+62eNdu6Nd+xpfhU4127o137Gl+FWlBuenLbKmSoVpuMd6e7wslbdklguqxjJ/xf9
n/ALKjykk7vGu3dGu/Y0vwqk6s1LAf0demUR7oFOW99IK7TKQkEtqG9SmwAP3JwK6a5zU22
1S569gJisLeO2SE4SkneUhRA3cwJ/Y8lc5adRTdVOXS1Mn7nlwfJ1LeaSta0halEp2H2UYU
UI3EpI88HfjFWdMzH7hpW0zZTnCSJMFl11eANpSkAk4G4bzzVUpSlRb76X051kv6SRVqlKU
rnLVp+92tiBb0aiQq2wVAIQICQ+4ykEIaW4VFOANkFSUJJCeUEk1Zn2y33VhLFxgxprSVbY
bkNJcSFYIzhQO/BO/96n8TNK+7Vo+Ba7tOJmlfdq0fAtd2nEzSvu1aPgWu7WtZrZb7VrG7M
W6DGhNKt8NZbjtJbSVcJJGcJA34A3/tWzedMs3qY3KdnzGFstBDIZ4PDZDzbu2NpByraZbG
/IwOTeTWsnR/BxLVFZ1BdGm7SkJjbKY5IIStAJy0ckIWU/pgA4zvro6UpSoulPRD/WU/6t2
rVT5N2Ee6i3CFJddXEclNKQUbLmwpKVIGVDCsrRy4Tv5dxxmtk9q62qJcWErS1LYQ+2lYAU
EqSFAHGd+DW1UXVfohjrKB9W1VqlKUqfdbFbr2G03FlbyW0uJSgPLQnDiC2rISQCdlSgCd4
ycYzWkdG2UwkQymdwCH1SAkXOSP8hUFlRPCZJ2khQzyKyRvJJONJY1jZ2UFZS3a5aQVrK1E
ByKN6lEkn9ySTV2lKVF1n6j37q2R8tVVnmWpLDjD7SHWnUlDja0hSVpIwQQeUEc1TG9J6ba
Q4hvT1rQl5Ow4lMJsBachWDu3jKQcfqB+lbsC2W+1MKYt0GNCaUrbLcdpLaSrAGcJA34A3/
tW1SlKi330vpzrJf0kirVKUpSlKUqLF9eLp1bD+ZKq1SlcxO1szB1zD0mq1zHJExrhEPJU3
sY5drerOyAlzOcHzNwVkV09T7/cnbPYJ1zZjokqhsKfLS3S2FJSMqG0EqwcA43cuBu5an2n
Uj8y+JtMyJDbW9BE6O9CnCS243tBJzlKFD8ySDgpUM4O4itKwaghQYUqM8xcVLRcp2SzbJL
qN8p07lIQUnl5jVPjXbujXfsaX4VT7vO07fGOBuEC9LTsqQS3bJ7SihQwpBUhAJScDKScHA
yNwrPbb1ZLTbmLfCiXpEaOnYaQu1TnClPMMqbJwOQDO4YA3CtnjXbujXfsaX4VTL/qCFOhR
YzLFxStdyg4L1sktI3SmjvUtASOTnNU9Q3uVZ3ra3Giw3vvCT5MFSphYShZQpSRkIVnOwR+
uSkb87vvT18Ve2JgejIjyYMtcR9Db4eRtpAOUrGMjCk8oBByCARVeuc1prOPom3R50uDJkt
PvpZ2mSgBBO85yQc7IURgYJTglOQavsuKdYbcWytlS0hRbWQVIJHIdkkZH7Ej96yUqLK9eL
X1bM+ZFq1SlKi6z9R791bI+WqrVKVpXi5os1nlXN1h59qI0XXEM7O3sjeojaIG4ZPLzbsnd
WlpLUaNWadj3huE9EQ/kBDqkqyRuUUkHenaCgCQCcZwN1Wq5LVes5um5zjLFk8ujswTLcfD
y/MwVDYKUNrKMhJIUvZScK3+aa3dUS24M3T0l5LykIuSshllbq98WQNyUAqPLzCs3Gu3dGu
/Y0vwqca7d0a79jS/Cpxrt3Rrv2NL8KtqLcmbwxIbiGdGUlOzwjsJxhSSQcFPCoAURj9COT
I315zbpP2j6kgR3LPdJMBxDDTr7t1jsBmQHG0qCmC2ydwO3kEkgbGd5IHq1KUpUWL68XTq2
H8yVVqlKwKhRVykylxmVSE42XS2CsYCgMHl3Bax/wDdX6ms9aV4tiLzZ5VsdfeYaltFpxbO
zt7J3KA2gRvGRyc+7B31gsen7dp+KWYUdlK1/wDK8iO00t3BJG1waEpOMkDd/wDtYdKeiH+
sp/1btWqUpUXVfohjrKB9W1TUemI2pm4rUuS821FdLqW0NMuIWrZKQVJdbWDgKVj/ALzygY
pw4UW3xURYUZmLHbzsNMthCE5OTgDcN5J/+az1glQos5sNy4zMhAzhLrYWN6Sk7j+qVKB/Y
kc9Z6UqLK9eLX1bM+ZFq1SlKi6z9R791bI+WqrVKVjeZaksOMPtIdadSUONrSFJWkjBBB5Q
RzUaZaYQUMtIbSVKWUoSACpRKlHdzkkknnJNZK0pNmtUyc1OlWyG/LYxwUh1hKnG8HI2VEZ
GCcjHPWlffS+nOsl/SSKtUpWN5lqSw4w+0h1p1JQ42tIUlaSMEEHlBHNWGBbLfamFMW6DGh
NKVtluO0ltJVgDOEgb8Ab/ANq2qVjeeajMOPvuoaaaSVuOLUEpQkDJJJ5ABz1J456V95bR8
c13qcc9K+8to+Oa71a1mudvuusbs/bp0aa0m3w0FyO6lxIVwkk4yknfgjd+9aWr9T3CyXeN
Fhz7Ww0thLr/AJWypamUmQ0ztkhxOE4eJ3j/ANJW/f5vP3PWNulMWiY5eFxblOtaJLjiLgt
qJBCQracDQOH3OEyngTtFXB4OyASfUKUpSoulPRD/AFlP+rdq1SlKi6r9EMdZQPq2qtUpSl
Ql6zsTd1NsW/JRKD4YKVQXwkLKkJA29jZxlxvfnHnpOfOGTF+m/f6LXNgRmS8pzgkszOFfD
aSrZecb2BsNqCMbW0cKUlJ3k4+5Xrxa+rZnzItWqUqK7qF77wmRIlhuM7yN1LTrrKo6UbRQ
lzA23Un8q081SdWXme7o69Nr0xdGUrt76S4tyKUoBbVvOy8TgfsCf2ro7zO+7LHPuGceSxn
Hs7G3jZST+XaTnk5NoZ/Uctefx/tBi3O339q93Lgo9sajPbdsIZecyvzkoU2+6CkngkFSVD
HCEEp5a6rQ89NwszriJiHwl/HAolmWIpLaFFrhz/ynKtoqyQCopBISK6OlKVFvvpfTnWS/p
JFWqUpSlKi6z9R791bI+WqrVKixfXi6dWw/mSqtUpSlKVF0p6If6yn/AFbtWqUpUXVfohjr
KB9W1VqlKUrmJ2h406cuabtcWpC5JkFbfA8uWClOC2RspMZrHPuOScms9v0gzbr7Ju7N2uK
lypKpLzK1tlDhKVJSlStjbKEhXmoKsDAOK+LzbLfddY2li4wY01pNvmLDchpLiQrhIwzhQO
/BO/8AetniZpX3atHwLXdrSZs1qtGuLf8AdlshweFtsvhPJmEt7eHI2M7IGcZP+zXT1FsXp
fUfWSPpI9NZ+o9+6tkfLVVqlKUpSot99L6c6yX9JIq1SlKUpUXWfqPfurZHy1VapUudp633
CcZrxmNyFNJaUuNOfY2kpKikENrSDgrVy/qaw8VLd0m79sy/FpxUt3Sbv2zL8WnFS3dJu/b
MvxacVLd0m79sy/FpxUt3Sbv2zL8WnFS3dJu/bMvxacVLd0m79sy/FqhbrdFtUJMOGlaWkq
Wvz3VOKKlKKlEqUSSSpROSeetqlKVq3G3RbrCVDmJWppSkL8x1TagpKgpJCkkEEKSDkHmqf
xUt3Sbv2zL8WnFS3dJu/bMvxacVLd0m79sy/FpxUt3Sbv2zL8WnFS3dJu/bMvxacVLd0m79
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
pzhJEl2Q66vAG0pT7hJwNw3nmrraUpSlf/2Q==
</binary><binary id="_22.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAfAEcBAREA/8QAGQ
AAAwEBAQAAAAAAAAAAAAAAAAUGBAcD/8QAKBAAAgIBBAICAQQDAAAAAAAAAQIDBBEABRIhB
hMiMRQVMkFRFiPB/9oACAEBAAA/AL/YPLZ953KrXm26GpFeovfrD8wSTekOio0kYXCcw+Rh
m+iPsHVPqfXzGkd0v02p7jxpSiFpI9usy8n4hm/ZGQFwy4OcnJOOPFm2U/IKV60laGDcVd8
4M22WYk6Ge2dAo+v5Ommpiv5bPPvtakduhiqW71inBLJcHukMKuZJBEFPwDxlc8s9qSBkad
bjutbbPX+RHcf2Z4/jUprGMY+/WrY+/wCcZ7/rSnwrfE3Pxzaon/Oe0NvheaaxUmVXbgvI+
x1CuSTnIJz99/ekW4eQ/wCKeR+SeQ3atP8ATFlq0n9MnC1I6xBwQhHGRv8AeB+5SEj+jx7o
9v8ADNi2y7WuVYLIlqqEh9l6eRUUKyqArORgLI4Ax1yOPvT3Ro0aRHwzYmvpdMFkypO06g3
p+CuZBKSE58QDIqsRjGQOutPdZdsoRbVtVTboGdoqkCQRs5BYqqhQTjHeBrLW8c2mnuku5V
6nrsTSmZwJH9fsK8WkEeeAcjosAGIJ77Offb9zTcJr0KwTQvRsmvIJePyPBXDLxJ+JV1Izg
/2Brbo0aNGjRo1zjwqaO15BYG0JNBYj3K7Nv0cth8R8pJBFH68mMucIS6HoREFvlg9H1Prt
/lS7pfsrvO3LDNKBXjkoyyeuIKMDAmUBuRbJwSeu8YVdlOvv6Wka7ue3TVxnnHDt8kTnrrD
GZgO8fwf+6aa5TD5lRh86qVZd3vT333mzBagM8oijTm0EEKxACMj5JIWPY9bdkkDXVtGjX/
/Z
</binary><binary id="_189.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAgAGQBAREA/8QAGg
AAAwEBAQEAAAAAAAAAAAAAAAUGBAMHAv/EACoQAAICAQQBBAAHAQEAAAAAAAECAwQFABESI
QYTFCIxIzJBQ1FhgRVx/9oACAEBAAA/APSaWTW35lkqEntnNGCMV3EBSVS4DTJyJ+YA9Bjx
AA9RAe9tYvD/ADZfKyeFesFKyMGq2jNwCvw/EDIhjL/mQEbsoY9bbaqtSV3y7K1r1ivHgfV
SKVkV+F75AHYH41GXv+mI/gn71QYi7NkcXDbsV/bSycuUW0g47MR+4iN+m/aj/R2cvlOTsY
bxu5fp8DaiUCBHgeYSyFgqJxQgksxCjY9Fgf01xnzC0ruCxmHp1rNbIKxRopCqQV0VTzXij
KV2Kgdr2yAdEkMMvdmx2Lmt16/uZY+PGLaQ8t2A/bR2/XfpT/g7E/S8uytm9BXkwPpJLKqM
/C98QTsT8qir1/bAfyR96o79uanAskGOs32LcTHXaMMBse/xHUbdfzv39ay08rds2khm8ey
NRG33mmkrFF6374Ss3f10D96TYTyf3WHgsQVIbuTyNmVeFWP24cL+SeVXJZEMQgJJ5ECSMA
HkoPxY8l80iuz14PBEtrAwUzx5ZURyVDfH1I1JA5bb7bbgj9NUc+Lhb3UlRvYW7fD1blaKP
1W4/W5ZWDbDcdg7AnbbWXFeO18PPDJWs2SsOPhoem5QqyRFuDH478vm30QO/r6030aNcLlK
rkKr1btaG1Xk25xTRh0bY7jcHo9gH/NKcr4w+UyLXRn8pTb0HgRKphURo/DmFJjLAkxqd99
wR0Rp7o0aNJbXi9J/YtjpZsO9D1BA2PCRqFk/OhQqUKkhW7X7UEbabQxtFBHG8zzMihTI4A
ZyB9niANz/AEAP6100aNGjRo0ayx34pMrYxwV/VrwRTsxA4lZGkUAf3vG2/wD6P81aNGjXn
ntsj45h5LhoPjFxdSaH1okSWMPZsK800UabkRQ8OaqwBZTsePEkvMVi6F7KVMzivJ7l6Gt6
qWEjyLTxWZWVdi6hii8QWPFVUbsu2wAGqfUld8Rytm9YsR570kllZ1Tne+IJ3A+NtV6/pQP
4A+tUGIpTY7Fw1LFj3MsfLlLvIeW7E/uO7frt2x/wdDL5TjWzHjdzHrXSwLChXjbbcpyHLh
y6EgXcoT0HCk9amc/bah43kpL15MDez2QjMKTWgktZOUMBcNHIORVEEp2bYcuJ3AO9bjrNL
KYRXxN95KxV4YrSP6jboShYM+/Mgqfkdwdt+we0VfAZQeVX3PkWXVDRrAWPRrfiEPPum/o8
fjuD0N/n3v1sz8moyXqtJko+8FW9FZaNOAm+BLKYy5ChuQUHcj4FwOyNTOVW7Hi8Jga1qGv
mcjkmuz0/+g8EkcbtNYkTnEeRXoxc9ipPewO21N4fd/6PimPu+59wLEXqKTJ6hjBJIjLfbM
g2QseyUJPZOnWv/9k=
</binary><binary id="_88.jpg" content-type="image/jpeg">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
k=
</binary><binary id="_3.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAANAAUBAREA/8QAFQ
ABAQAAAAAAAAAAAAAAAAAABQb/xAAgEAABBAEEAwAAAAAAAAAAAAACAQMEBREABhMhNXW0/
9oACAEBAAA/ALmrqJL9vfE1e2MV0JzbbjjXCXNiJHwRCbZChdrlQQc57yiCiJ0Xl9x+yD5I
+v/Z
</binary><binary id="_1.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAgEAyADIAAD/7QG4UGhvdG9zaG9wIDMuMAA4QklNA+kAAAAAAHgAAwA
AAEgASAAAAAAC2AIo/+H/4gL5AkYDRwUoA/wAAgAAAEgASAAAAAAC2AIoAAEAAABkAAAAAQ
ADAwMAAAABJw8AAQABAAAAAAAAAAAAAAAAaAgAGQGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAA4QklNA+0AAAAAABAAyAAAAAEAAQDIAAAAAQABOEJJTQPzAAAAAAAIAAAA
AAAAAAA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAA
AAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAA
AAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////
////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////
////////////////////////A+gAADhCSU0EBgAAAAAAAgAE/+4ADkFkb2JlAGQAAAAAAf/
bAIQABgQEBAUEBgUFBgkGBQYJCwgGBggLDAoKCwoKDBAMDAwMDAwQDAwMDAwMDAwMDAwMDA
wMDAwMDAwMDAwMDAwMDAEHBwcNDA0YEBAYFA4ODhQUDg4ODhQRDAwMDAwREQwMDAwMDBEMD
AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgCQwGQAwERAAIRAQMRAf/EAaIAAAAH
AQEBAQEAAAAAAAAAAAQFAwIGAQAHCAkKCwEAAgIDAQEBAQEAAAAAAAAAAQACAwQFBgcICQo
LEAACAQMDAgQCBgcDBAIGAnMBAgMRBAAFIRIxQVEGE2EicYEUMpGhBxWxQiPBUtHhMxZi8C
RygvElQzRTkqKyY3PCNUQnk6OzNhdUZHTD0uIIJoMJChgZhJRFRqS0VtNVKBry4/PE1OT0Z
XWFlaW1xdXl9WZ2hpamtsbW5vY3R1dnd4eXp7fH1+f3OEhYaHiImKi4yNjo+Ck5SVlpeYmZ
qbnJ2en5KjpKWmp6ipqqusra6voRAAICAQIDBQUEBQYECAMDbQEAAhEDBCESMUEFURNhIgZ
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
4wIba7B5fVmBCsonDLPY3H946yelI3rcJJmXeFLDfOH5hef/KGj6vrOj31rN5Y0rVzpEFlr
CtPfSPGKTJ6qNG31cEfuOfr3Xo/vpW9PJCET/WriWmOXepx+atL1HWPKkFrp+lFLW8m1LUJ
VtdO0+SWFf8AQI2iWT1LlJ2Zmiji/a+P95MqZZGdALaO8tfmMsUOo6DFNaTmW2mj1SKyuEu
LdRNCBHd2rJRnjUBxc81WaDh+8j+xkjC91D5yjttT0TXtYgvLwJc6IjIYJyT9YWOdI/SQ1I
FUczJv+zmDqtMM0TGR+n6XZdldqZNFnGSH+fD+HJD+b/xLMLW5iureO4hblFKoZT8+3zGch
kxmMiDzD7hpdTDPjjkgbhMcQZx+Tl6dO/MGDVpbF72y06yuJbtoQ0k9ukrRwG5SFAzzLEJK
SqnxrC7yLy4cc3HY0L4+/Z4T29nLhxR/hucv870vpAaH5X80XVp5o0+9a4V7Z7UXdhODBcW
zkkxyceQYKxb7PCRW+Fv5c3ImY7PnFsOtvLnk/Qr2Cy8rJf6/rWnsqraQTo0ELCZbj/S7lk
9G3UyRqXTl63++4Piy0ykR6qiFvvZD/gzzbrFLnzF5ovLGVlFNL8vuLS1i33HryI91cN4yM
0X+REmV8YHIf6ZbYX+eHkq/sfy6vryDzHqN3BZy2kz2OpNHdq5FwkYMcpRJoZKSNVubo6/D
w/ayvORPHIED6Zf8U7HsjLOGqxyj9XiR/wB08BPU5xxfenVAFTsB1OKLcCCKjcHocVBtmv5
TeRR5s167knQTWmh24vfqh/4+Lpi31WFv+K/UjZ5P5uKJ+02bjsjCOLxD/CeH/ingfbntKU
IR08eWX15P6sD6Yf6b6mC2kbx2sMcgZZI0VJFcUYMoowYHowIoc12oiRkkD3l7Ls6Ylp8ZB
4h4cN/81OtW8sHRvLXlzXqNHZ+YbeedpJG+ATRXDAMOW6rNbNBIv7P282Ot037uEgPVQhP/
AEv/AEm8p7Pdsxlqc+KUrx8cs2Kcvp4eL1sWvvM2jWiEtcCVx/uuH4z+Hwj78xMWgyz6UO+
Tudb7S6LTjeYyS/mYv3kv+I/2SSDVtS166hso4jaafdzpam4Joql2FTK+3wiPk3AMn+tm80
nZccZuQ45f7l8+7Y9rM+rBxwHg4T/ysn/Xl/vYvtb8lrfy/pfkuw0Ow1S1vr2BWnuooZ4pZ
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
</binary><binary id="_23.jpg" content-type="image/jpeg">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
</binary><binary id="_144.jpg" content-type="image/jpeg">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
SlKUpSlKUpSlKUpSlKUpSlKUpSlKkdV291edJZazsrZ7m5ubSSCKJGVSWdSoO2IAA3s9/QH
Wz2rn5LXJy457c4HNNKWCnJPdWQvwG8csUIJRQvPgNFSFmbiBx73em8df2XSFljLyXwLmC2
8BZIVUMigcUJBLLzChdjbLy3rYrmet+meoMlYw4y1lvM3Fdc1eS8eyjjs21xWQjwOR/ab9g
hgAdHZFavQ3ReQ6M6nsba9zb36zYu5KW4DCK1YSwFwm2OwS3rpd62R/K712uSdsQLCW8svC
uXlOQtbHzpgYRMgVoR3KsruOQB0QAR7WxpWHTeVyWKsbmCSHCg21nH5O5s2ldBazNJCf/AD
gU5ArtCWI9OWxus9x0BM2Qu7q1zHhpP4hijmikl8JpLiOdyP1oC+0hAMYjYbDciyhq93nRW
QucRZ2SZm2SSBbhZJTYsRJ4rhu48UFgNe0sjOsh7uGPeusAl8dyXQxFVCoEPINs7JO+4I46
GhrR7nfaZlMXkL7L4y6hvraG2sJ/HML2rO8jFHjYcxIABxkOvZOiAe47VXqLgv3v1H9pJ/i
W9WqUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSot1/HGL+zbz+5a1apSlKUqLgv3v1H9pJ/i
W9WqUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSpeTwpyF9bXsOTvLC4topIle2ER5K5QsCJE
Yesa+mvprD8hZH62Zf/AGrT/gp8hZH62Zf/AGrT/gp8hZH62Zf/AGrT/gp8hZH62Zf/AGrT
/gp8hZH62Zf/AGrT/gp8hZH62Zf/AGrT/gp8hZH62Zf/AGrT/graxOJGKF0Te3N7Ldz+PLN
cBAxbgiAaRVAHFF+iqFKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlauRv4sZZNdTK7gMkaIgHKR
3YIijehssyjZIA33IGzUm66uix8lhFkcXeWct/ci3ijlmtueyyKG4iUll243x2RokgDW8GG
y9/d5i1t55+cUnypyXgo34N2kcfoPoQkf19Ts1nXqo+cv7V8PeCW2vhZ26I8Ra7YxCU8duA
uk23tEdtd+RKjZl6it48GMqltcygzrbeXQJ4omMwhKd2C7Eh0Ty12JBI0a0161tBZG6nx19
bhWuPERxEWjigYJNKeLkFUY60CWP/AEqR3rZveqsbj7y4huvGjhtuSy3PDcayLF4xj0DyLe
EOewvHXbfLtU/H9XXEuRvRkcXfWdqsFtNbQmxeS4Ak8XfNYmk7bi+kKRvRHoT7zvXuKwFra
3Nzb3jJdRTSoGRbdwIyoYcZ2Rix5DSgEn6BW1F1THJnDinxd9ERdtZ+YfwfCMghMw9JC2jG
Ng8fpAOjsV4j6xspoY5o7S8KSy2wQ8U7xXDlIZ/2v2GYEa/bH0qKwXPXFtbY9Ls4nIv+qu5
ZYk8HnAts4jlLbkAOmPbiW3WGHqjLPe3uMfHcLt7lrewndUWFJDai4SOYLKzFh3DMgKnQ1r
dU+l8hkspjZLvICFopJQ1lNFF4QuICilZOBdyuyW0CQdAbAParVKUpSlKUpSlKUpSlKUpSl
KUpSlKUpStXJY2yzGOnx+Qt0uLW4XjJG/oR/wDog9wR3BAIqZddGYK9Nu9xBcvLbLwjn89O
JivMSANIH5MA4DAMTxI7aqhb4iwtLhLiCDhLH4/FubHXjSCST1P0uAf6eg0K1bzpfD373L3
Nq7tczxXDsJ5FKyxgKkiab9WwAA5JokDvuuf/AEj29rif0ey8bZJsfazxPdWbs3+rQyAFTI
DyVi7B+eySy997O/HQVlZ9SdFWd7eW/wDpWllFnaiWQ+Wtw3DwGctylQ+Htlb2TsDjpVA6q
bA4u5vZLuezSWSVSsiuS0b7XgWMZPEsU9jlrlx9neu1YMR0xisHP42PjuUbwFtwJLyaVRGp
2qhXcgAbOtDts69TWfL4LHZyDwchC7rxZCY5niYow0yFkIJU6G1J0dDY7CtX5pYj5U+UuF5
5nzPmt+fn4+Lx48uHPj+z7Ota4+z6dq9npfD+SmsxausUzRseE8isnhtyjVGDbRUYbVVIVd
nQGzXzP9JseN6Mu8ZIMe+QglWeWzjmvrhXtLrkrNMJA/JgxZSV2O6bBBZt/Q7Lo3HwTQXt1
NeXWRjlW4luPOToss4TgZPCD8BsduIGgp4+narkMSwQRwoXKxqFBdy7EAa7sxJJ/qTs1kpS
lKUpSlf/2Q==
</binary><binary id="_45.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAGAAwBAREA/8QAFQ
ABAQAAAAAAAAAAAAAAAAAABAb/xAAhEAACAgICAQUAAAAAAAAAAAABAgMFBhEABEETFCIxc
f/aAAgBAQAAPwC2xPrZI2HUpgtqtIjXwGNHrJGZV9NdAkTjZ150PwcFDV5pZXFyYM2Tor1+
2kRijq1kTft4W2okdio+X1sjez55/9k=
</binary><binary id="_26.jpg" content-type="image/jpeg">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
yfIPk/Pr/9k=
</binary><binary id="_99.jpg" content-type="image/jpeg">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
</binary><binary id="_5.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAJAAIBAREA/8QAFQ
ABAQAAAAAAAAAAAAAAAAAABQf/xAAlEAABAgUBCQAAAAAAAAAAAAADAQIABBETIQUGEhQiM
TZBdbP/2gAIAQEAAD8Ar8kKxIgDw4Za2JrbIFqMdEputwnKnRMJjwkGbGdj6D62X+bY/9k=
</binary><binary id="_199.jpg" content-type="image/jpeg">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
Mu2jk8nA4nHUtLU1/pbhpW7UVLR3eSoqaGaKJn5PVjc5zCAMmPA4n1rrUREREREUXWfoPfu
zaj5blaRERERERERERERFFsXnfUfaTPpKdWkRERRaX04unZtH8yqVpERfONS1k5/EuluLZN
1Hp+hfK4EDbG4viFST/qdtpp2PGPWBjJ3NP0dEREREREUXWfoPfuzaj5blaRERERERERERE
RFFsXnfUfaTPpKdWkRERRaX04unZtH8yqVpFpW682q78p+WXOjruSxynNp2ybM5xnaTjOD/
wDRW6ufraKlk1nRxvpoXMqrbW84aYwRNl9K07h/q8kAcfUAF0CIiIiIiIous/Qe/dm1Hy3K
0iIiIiIiIiIiIiKLYvO+o+0mfSU6tIiIil12nrfcK41sxrI6h0TYnPpq6eDc1pcWgiN7QcF
7uv8AUrD0Ut3tN375q/FTopbvabv3zV+KuG0F+F1HZrzeZKm6VlQ+llbRsNNJJSZBjilLiY
37j/GBjOPJJ45G3ueilu9pu/fNX4qzUOnrfb64VsJrJKhsTomvqa6efa1xaXACR7gMljer9
AqiIiIiIiIous/Qe/dm1Hy3K0iIiIiIiIiIiIiKLYvO+o+0mfSU6tIiIiIii2LzvqPtJn0l
OrSIiIiIiIiKLrP0Hv3ZtR8tytIiIiIiIiIiIiIikVGmbbU1s9YXV0UtS4Pl5vcaiFr3Boa
DtY8DO1rRnHqXjopbvabv3zV+KnRS3e03fvmr8VOilu9pu/fNX4qdFLd7Td++avxU6KW72m
7981fip0Ut3tN375q/FTopbvabv3zV+KnRS3e03fvmr8VOilu9pu/fNX4qk2bTVBJdL+x1R
dAIrgxrdt2qmkjm0B4kSeUck8Tk4wOoAKt0Ut3tN375q/FTopbvabv3zV+KnRS3e03fvmr8
VOilu9pu/fNX4qdFLd7Td++avxU6KW72m7981fip0Ut3tN375q/FTopbvabv3zV+KnRS3e0
3fvmr8VOilu9pu/fNX4qdFLd7Td++avxU6KW72m7981fip0Ut3tN375q/FTopbvabv3zV+K
vE2jrTUwSQTyXSWKVpZJG+71bmvaRgggycQR6ldREREREREREREREREREREUWxed9R9pM+k
p1aREREREREREREREREREREREREREREREUWxed9R9pM+kp1aRERERERERERERERERERERER
EREREREU+20EtHXXaeRzC2tq2zxhpOQ0QRR4P75jP68MKgiIiIiIiIiIiIiIiIiIiIiIiIi
IiLBWVtLb6V9VW1MNLTx43yzSBjG5OBkngOJA/wB1Gt+tLPWU9dVz1tHSUdLXGjjqZayMxz
nk2v3NcDt47jgZJw3jg5A9za103BV00El6oQ2qgfPHOaqPki1rgzG7d1kk4/XY/wDRbtfqC
y2qdsFxu9DRSubvEdRUsjcW5IzhxHDIPH9lQUKxattl5ZFTyVFNSXUufFNbX1UbpopGFwe3
APlAFpIOOIweC2abU1grOV5rfLdPyERml5KrjdybB1udg8GjPEngkWprBPSz1UN8t0lPTbe
WlZVxlkW44buOcDJ4DPWt2jraW4UrKqiqYaqnkzslhkD2OwcHBHA8QR/ss6IiIiIiIiIiIi
IiIiIiIiIiIiLj/wAUJXUGkRe4Qx1TZ6uCrgZIwPY5+8R4cCOrEjurBBAIIIXyaP8AES+1O
nrrc5Xs5V15gleIZJYA8SQSs2Exva7a0Qx4Gc5HElLZ+Id6sOm7NcYWU1TUxz3CkL6oPeXt
e6nmc5xDgS7c48f09WeK2fxG1ZeOa2iB1XMfzTT9LLO5s8kY3OL952McGHcOB3NPDqwvuGn
6+W66ctlxnaxstXSRTyNYCGhzmBxAznhkr4lojWF01Zqi2aeuIphRvuklzBjhG+OQb59jXO
zhu/P/AHYJG7BwpOnda3irus4qJeXzZKyA85lkqAcQukL9srnDc50TARjaQMbVdt1bzv8AC
W8ajET4J6OrpIIYIqyo5JrIZGOYATIXgf4zhgOAGGloa4ZXbfg/cnXvT9wuk0PJVEtcY5MV
M8oftjZhx5WR53YOMgjIa0eoL6AiIiIiIiIiIiIiIv/Z
</binary><binary id="_28.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAaAJQBAREA/8QAGg
ABAAMBAQEAAAAAAAAAAAAAAAMFBgQHAv/EADAQAAICAQQBAwIEBQUAAAAAAAECAwQRAAUGE
iETMUEUIhUyUWEHI0JxgVJVldHU/9oACAEBAAA/APYppVggkmcOVjUsQiF2IAz4VQST+wGT
qTTTTTVftu+7du088NKZ5GgVHYmF0VkcsFdGYAOp6NhlJBx767JpVggkmcOVjUsQiF2IAz4
VQST+wGTqTXLuRH4dOG299xV16NVQITKp8EYdlUjBOQT7Z/trP/w74/Hx3i9eq+0vQuhQtp
5fRLzv+YntGT2UFmC9vIA9v11WmozNEs6QGVBK6s6xlh2ZQQCQPkAsuT+4/XUmo4ZVngjmQ
OFkUMA6FGAIz5VgCD+xGRqm5LvdjYDRus1ZdtadYbZlV+yl3RVbuPtjVQXZmbweqqMFshzS
pNuPEtw2+vtj7jLbgeKONTGAjlT1c+oyjCsFORkg4IHjU3F9qqbPsFanT219uVFAeKVYhKz
ABe8hjJVmYKCSD/1rH7fv028WLyW+XentUlEyG/SsV1jgLyKFBJjD1nwSAjlyQxw/aMk8F3
mffaqW4V+aJBdfjrzWIY5q7KbcaoyKUZT1ZjLICowT0AH5da/kXJ6Q4Fa3zbN7hriWs70bI
ZP5kgUsqAOCCxKlSuO3uPBHiw4u00mwVprG9JvEsqhpLUTRtEXAAYRmNVBUMGxkZ/U6qbu4
c0S9YSrt3eusrCJvoYWyufBybqk+Pkqv9h7avdutXRsi2t2heOyiu0saQYbAJxhEeTJwB4D
MT/fwMrxR9nv8qj3jarX1yWNoEaKDGPwuMOrLXKxDqO3fwG+4ei3lsnHFt+/TbxYvJb5d6e
1SUTIb9KxXWOAvIoUEmMPWfBICOXJDHD9oyTwXeZ99qpbhX5okF1+OvNYhjmrsptxqjIpRl
PVmMsgKjBPQAfl16El5982evf47uVP0p8Ok8tdpkZfII6h0IbPvk+MEEZ9pKEO9Rzsdx3Cj
Yi64CV6TwsGyPOWlfxjPjH+dL829RzqNu2+jYi65L2LrwsGyfGFifxjHnP8AjX3t0u6y+p+
J0qdbGPT+mttN29857Rpj4/XPn2+cra5QkXPtngubZZoyyVJ4VjsWaoY+pLAFbAmORlG8D7
j/AEhsHEJ5Dbn5c9ZORoKCtaWf6Z4D9GI0ZcyxvH3iAYZ9Qu6FlH2gSKBXwckpmrskI556L
xXrdKeb6yuzvXUymKSTupUt/JhAcjz3P+vV7xmPZ+abBQ3yed7tt6kVe8Y7EkaSOgJaOWJS
EYdnf7WUghvlSNaPcYt1l9P8Mu062M+p9TUabt7Yx1kTHz+ufHt88X0vKv8Aedo/4qX/ANG
rrTTTTTTTTXLuaRSbVbSe29KJoHEllJBG0K9Tlwx/KQPOfjGs5w2hPte87/Vmgp7ekksFiH
baSgxRK0fT1FcKue7RsCpUYMZP9WTrdNNNNNVHIqUV+pXgkjrWWM+Y6VuYRw226t9j/Y/YA
ZcDqfManxjOubgkU9fhW2VbVn6ixViNeU9AvptGxQx+PB6FenYfm65+daDTTTTTTTTVFziG
Kfgu+pNEkijb53CuoIDKhZT5+QQCD8EDWV/gndtbnxW7e3CzNctm8YTYsSGSQoqIVXsfPUF
3IHsCx/U69H0000015r/HCaWjxjbdxpyvWuwbgEiswsUljVopOwVh5AOBkD3wNbDhvnhmzS
Hy81GKaRj7u7oGdiflmYkk+5JJOv/Z
</binary><binary id="_52.jpg" content-type="image/jpeg">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
</binary><binary id="_183.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAALAAYBAREA/8QAFQ
ABAQAAAAAAAAAAAAAAAAAABgf/xAAhEAABBAICAgMAAAAAAAAAAAABAgMEBRESAAYhMQcTU
f/aAAgBAQAAPwChyKyvue4zWLSDGntR6+KtluU0l1LSluSAopCgcEhCMke9R+Dhv4amP3dT
b9gsXPvs5s4NPv4Cd0ttICBqMJGNleh5z55//9k=
</binary><binary id="_4.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAA2AHsBAREA/8QAGw
AAAgMBAQEAAAAAAAAAAAAAAAUDBAYHAgj/xAA4EAACAQMDAwIDBgILAQAAAAABAgMEBREAE
iEGEzEiQRQVIwc1UXF1tBZhJDIzQlNWZIGDkaPU/9oACAEBAAA/AOzaNGjSXq15xYGipqqa
kepqaamM8BAkRZZ442Kkg4baxwfY86bQwxU0EcEESRRRKEjjRQqooGAAB4AHtqTS+9323dO
243C6zPBSqwVpFheQKT4zsBwM8ZPGSB7jVmjq466lSphWZUfOBNC8T8HHKuAw8e41S6gu0F
ktfxtSaxYUlTuPSU5lZFDAsWG04QKDuPsM4O7GqdNeHuPWdRbY5qyCG30ySGM0jIk7M8iNu
d05UbFKlCN3q5YA4uXnqK2dP/DfMpZo/i5ezB26aWXe/svoU+o+w8nBxnB1d77zUPxFLHud
4t8ST7oskjIDZXcn88rkfh7aXw9S28zx0teXtVZIwSOmrtsbSMTwEYEpIeRwjNjcAcE4176
hrJ6K1B6aTtyy1NPTiQAEoJZkjLAHjcA5IyCMgZBHGuU9U/an1T0b1JWWBXobktIwK1VVTl
ZXV1DgMEZVyAwXIAzjOOddq0aNGkvVf3RB+pUH7uLTrRpL1PZKq/29KGGqo4acypJMlTRmo
Eux1dVxvUbSVwQc5B9tNoRKsEYndHlCgSOiFVZsckAk4GfbJ/M6X9RWyqvNjqrZS1cNJ8XE
8MsksBl9DKVO0B1w3PBJI48HUNstN1p75U3O4XKjqfiKaOAx09E0OO2zspyZX/xHyMfh4wc
+L/Y7heK23zQVtDFFQTipjiqaFp8yhXUMSJF4AfI4yGUHPtpzMZVgkMCI8oUmNHcqrNjgEg
HAz74P5HSn+Hvj/Vf6r5p/pu326Qf8WTv8A/UZ8MMrt8au3a3fNLeaYS9p1ljmjcruAeN1k
TIyMruUZGQSM4I86xl3+yG1dSXSa73u5VjV9Rt7pogsMR2qFG1GDkelRnLHnJ48DYdP18t1
6ctlxnVFlq6SKeRUBChmQMQM54ydE1fLH1HRW4KnaqKSonZiDuDRvCoA/liRs/kP92GjSXq
v7og/UqD93Fp1o0vu1yloBSxU1OlRVVs/YgSSUxpuCPISzBWIG2NvCnnA4zkFiujXm0RVsl
I9JKWeKandwxikR2R13DhgGU4PuMHjxqzV1Hw0KyboRmWNMzSdtfU4Xg4Pq54HucDIznVY3
KV7+bZBToywwJPUyvKVKq5cIEUKdxzG2clcDBGfAYaNGqV2uPyu3mpEXddpY4Y0LbQXkdY0
ycHC7mGTgkDOAfGsTcvtitnT9xntV9tFdT3CmbbKlK0c0WDypVyykgqVPKgjOCONFfaHv/2
T9P2lLRU14mpKJ2kgaFWgVRGXIMjDDFN4BAPkg4B1oKemp6TqeyQ0tAlviFrrGFKiIoiJlp
iRhMrnJOcEjOeTqz1DZay8fD/CXH4Ptbt3qqBvzjH9jNF4wfOfPGOcw2Dp6vtNc9RVXX4tG
iKBN1UcHIOfq1Ei+3soPPnyD76hkakuNmuEkL1FLDViFo0IBikm+lHNkkZALlCv4Slv7g09
0aUX6nqnltlbS0z1Rt9WZ3gjZQ8imGWPC7iFyDIDyRwD74B99PUc9FailTH25ZamoqDGSCU
EszyBSRxuAcA4JGQcEjnVPri3G7dK1lFHZ/mlRNE6U6Yi+jIUYLJmRgBgnyPUM8DVWxW/Z1
jcbr/C72paqkjXvuKfc0gkkaTPbdjlt8Zz77OfAzD1zZvnlbZo36eqblBRVa1MskRp+UCvm
L6rgkFhHuGMFffI1ppqJflUlBSbKVewYYdgKrENuFwEKkAcf1Sp44I86y38FXj/ADF/6XD/
AO3T/qGjnrbUEpo+5LFU09QIwQC4imSQqCeNxCEDJAyRkgc65b1f9lfUnWHU9Xfqc0dBFV7
NtPWzHuptRU9XbDrztyMMeCPB4HX6Kjgt9DBRUsfbp6aJYokyTtVRgDJ5PA99D0cD10Va0e
aiGJ4kfJ4VypYY8clF/wCvz1Po0l6r+6IP1Kg/dxadaNGjUcsqwoHcOQWVfQhY5JAHAB4ye
T4AyTgAnUMlxpY7jHbyztUyLv2JEzhF5wXIBCA7WALEbiCBkg6taNGoKysgoKV6mpk2RJjJ
ALEknAAA5ZiSAAMkkgAEnSmLrfpaVCWv9DAysyNFVTCCVGUkEMj4ZTkHggae6NGjSXqv7og
/UqD93Fp1pRNU9SLPIILTa3iDERu9zkVmXPBIEBwce2T+Z0m62vVxtvSsTLdqGxXmaeNYQa
hJImBkVGyZIwSoVwzEKCuPw86a2gfLoCtwe4q671qnKEyqeQcoqqRgjBA8Y/PSbr2sFB0lV
1a3l7VPAplp3SREM0qKXSL1g7gxUZUcsAR4JBpdP19DW9fXaSj6jS5q9vgZY0lgdVHdmyBs
UHCZXySfqeonK4Oub09BW2akpOp6azyz1aiqWWSEf0Yq7M/1FbBzHtU+NzYOeManbPBQ7I2
+KqI4sK07BO6wHBYquBk+SF4zwPbWPt8lVXOkPW9XU0s9SyiO3NGsFGzEBe2JEZu8WO8dt5
PUCSY8AHT3qziyLIeEhrqOaRj4REqY2difZVUEk+AASdcM+0azXXqDru43SyWysudBP2u1V
0UDTRSbYkU7XUEHDAg4PkEa+jdGjRpX1Fbqq52aSnoZYYqtJYp4GnUtGXikWRQ2DnaSgBI5
AOedWrZXxXW1UlxgV1iq4EnjVwAwVlDAHGecHVrRo0aNGjUc0MVTBJBPEksUqlJI3UMrqRg
gg+QR7ak0a//Z
</binary><binary id="_187.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAgAHcBAREA/8QAGg
AAAwEBAQEAAAAAAAAAAAAAAAUGBAMCB//EACwQAAICAgEEAgICAAcBAAAAAAECAwQFERIAB
hMhFDEiQSNRBxUWJDNDUmH/2gAIAQEAAD8AvMv3RFPkamLwlqzJdGUirzmCAGEBfzmjeV14
bEQY8VbmCAP76xdsR1O26mczMqvTxQaMLBHRnjKiNdNO0RjXTOCC3jjCAJ9nRPVbDkqVjI2
cfDYSS1UVGnjX2Yw++O/6JCk6+9aP7G9XR0dSuX7oinyNTF4S1ZkujKRV5zBADCAv5zRvK6
8NiIMeKtzBAH99Nq3ceJtfCEdvT35ZYq8UkbxyO0XLyDgwDDjwYHYGjofsbadHR0dHR0dSQ
7Qyq5anaTOwpWpXrFuKAU25HzSl3BPl4luLPGGK+hIxA3oht3Qqv2/YR0surNGCteuZyR5F
9NGvt4//AGo9lOQ/fXHtStkEqXb2TZPk5G20/FIGhAQKsUZ4MzMpZI1YgnYLEEAjp70dHUk
O0MquWp2kzsKVqV6xbigFNuR80pdwT5eJbizxhivoSMQN6I49oVLs2ShuOJo6FKi0NcWqD1
rLyTOryeXkx5uPEhZ1AV2kYj6PVn0dK6eY+X3Fk8T44f8AYRQSeSObmx8nP8XXQ4MOG9bOw
yn1vXTTo6OpXP8AerYAXbj4p7GLxs6V7s0cwE0bsiupWMgBl/kjG+YOyfx0NnvkqdjE46fI
Xe780lauvOV0q1pCq/s6WuTofZOvQ2T6HRep2aEEsk3eGU5RwST+MiijMiAciOUIAA2uySA
NjZHXbta09yC28t7KTSwzmCavkoYY3ruo3oeJAGDKysCCwII0fvrTcxV2zaeaHuHI1EbWoY
Y6xRfWvXOJm9/fsn761UKk1OBo58jZvsW5CSwsYYDQ9fxoo16/rfv76hu0cJlcXn8ZPL2y9
UDHtBfuySwtLNYc+SWV3EjM45xoFBH/AGOdgKAaDJU7GJx0+Qu935pK1decrpVrSFV/Z0tc
nQ+ydehsn0OtNfGWkvBG7ryM7w8JJK7pU9qSdcgsIYK3FhsEfR0fXW3I0bN3x/Hy1zH8N8v
jJC3PevvyI31r9a+z99eKGNt052knzl6+pXiI7CQBQdj3/HGp36/vXv66mP8AT+Rs91XLbY
mtUlfKRWVyv4SMaqRxr4kYESKzlCGBXiFaQbb1y49rVRJmcVSFF4oMTUnul4Zk+I8tmT8Hh
COdx6+SE5AFVI37PT3P9vX8teSxVyvxEWIIU5Whs7J3/FYjX9/tSfX39Adu3sLcw/yPl5H5
nl48fysHhre/+aaX72PrX17361P92duZbMY3uDCVKm/85sxWIrjSIIYQiQgq/vny3CdcUYf
kvv70s717ghOQyOOymf8Aj01vVqrY2Fo4y9fgk08krE+QqyF0AjI2QF0xY9M8ehsf4m5srm
tX69ZYa0EscUh8fESEsFjVliDWIwAHDMUbbHXqm7fwseCxfxFEJleV5p5YkdfK7MSWbm7sW
+gSzE+v0NANOjo6+Zd69wQnIZHHZTP/AB6a3q1VsbC0cZevwSaeSVifIVZC6ARkbIC6Ysem
3Yojlz/cdhsu9q58sxzwsISwRCYY2kZIk0xMMhCA6CsDrbcjb9HR1loYzH4qBoMdRrUombm
Y68SxqW0BvSge9Ae//nWro6Ov/9k=
</binary><binary id="_109.jpg" content-type="image/jpeg">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
qIjOYowYkWNREs6qAhPJgSTvY//2Q==
</binary><binary id="_27.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAGAAoBAREA/8QAFQ
ABAQAAAAAAAAAAAAAAAAAABAX/xAAgEAACAgICAgMAAAAAAAAAAAABAgMEBREGEgAiBxMh/
9oACAEBAAA/AGWLicX4/i+SXZJqdS9FC8dnEBVuSyPGzFbQk3HY9f37CA3fZCjsfJlL41yu
bowZaPD8cmS9EthZL1689hw47AyMrBS537EAAnegPP/Z
</binary><binary id="_169.jpg" content-type="image/jpeg">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
CjkygkgE/UAs2B/J++v/Z
</binary><binary id="_29.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAiAFQBAREA/8QAGg
ABAQEBAQEBAAAAAAAAAAAAAAUGBwQCA//EAC8QAAICAgIBAwMBBwUAAAAAAAECAwQFEQASI
QYTMRQiQVEHFRckU6XUJjIzYXL/2gAIAQEAAD8A2yerrF2p6ngxlujayuJnmFWssLl5EjVC
QYu/Zj3LR9hoEgED8GzgLmTtDIR5MIWq2zDFKlSSusyBEJYK7MSOxdewOj12OV+OOZ/1D6m
gwGZwla1ep1a9+WZZjZBXSpGW7CQsFXTdF0Qd9xrWuaDkL1Z6gX05So2ns1q6z5CCu5sISr
I7af7gQEIXs3Ztj7da8jniv5rOpmYzj/prWKmakYXioyymVJpGWQiVX6gIi9+xXWmUH5BNb
6jP/XdP3ZjvpPd17v7wk9zpv/d09nXbXnr21vxv88jYrKVcRlc+k1XL9Z8kZY2GNtzBx7MS
sQwQ/b3VwNHWgNfbrn3hvTuXit1Gytmt7WPt2rcQqE6syTNIQzKy7jCrK4Chm2W8n7fOq45
jP4YYf+v/AGzH/wCNzWUqqUaMFSM7SCJY1PVV8KNDwoCj4+AAP0A5GzeMzljOV7uLnpxotG
er3l7CSu0jRn3VGmWTXtjSHr5HlvPihXwlKDCUsQVeatSWBYu7fcTCVKEka8gop/Q/prxzy
5+jlbNzE28YKcv0Fl5pILLtH7m4njGnVW1r3CddTvx5GvPqwWLbDYiKlJbe3KGeWaw6BTLI
7s7t1HhQWY6H4Gh5+eUOOfhduQY+jYu2pPbr1omllfRPVVGydDyfA/HPFhc4mZjl3RuY+aL
oWrXUVJerKGV+oY/afI/9IwPlTypxxxxxxxxzn+Qf/UfqRbsNOPGZWWrhHkhl9u0zvENMFK
lZG/mR52CEj+D10dZjMZar3rOQyFuGzbsRRwk14DDGEjLlftLue25H2e2ta8DRJqcxn8T8P
/Q/ueP/AMnmspWkvUYLcY0k8SyKOyt4YbHlSVPz8gkfoTyN6wqRzUqNlmmDwZKl0CTOqHta
hB7KD1f/AK7A6/GuaDjjjjnMsD9v7ePUFFfFSOsLaVx/xrOyQhpQvwHIdgW+SGPnyedN444
5yL9vOTyFBMElK9ZrLI0zusMrIGZDEyE6PkqfIP4Pxzo3pOaWz6Ows88ryyy4+B5JHYszsY
1JJJ+ST+eV+OOOf//Z
</binary><binary id="_138.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAC5AYQBAREA/8QAGw
ABAQADAQEBAAAAAAAAAAAAAAUDBAYCBwj/xABCEAABAwMCAgcFBwMBBwUBAAABAAIDBAURB
hITIRQWIjFWlNIVNkF1swcyNVGTtNMjQmEzJFRVcYGRlSVSYsHUgv/aAAgBAQAAPwD7MiIi
Ii5Wi0/ZbrftRT3G0UNbK24MYJKimZI4N6LTnGXA8sk8v8qh1M0r4atHkYvSnUzSvhq0eRi
9KdTNK+GrR5GL0p1M0r4atHkYvSnUzSvhq0eRi9KdTNK+GrR5GL0p1M0r4atHkYvSnUzSvh
q0eRi9KdTNK+GrR5GL0p1M0r4atHkYvSnUzSvhq0eRi9KdTNK+GrR5GL0p1M0r4atHkYvSn
UzSvhq0eRi9KdTNK+GrR5GL0p1M0r4atHkYvSnUzSvhq0eRi9KdTNK+GrR5GL0p1M0r4atH
kYvSnUzSvhq0eRi9KdTNK+GrR5GL0p1M0r4atHkYvSnUzSvhq0eRi9KdTNK+GrR5GL0p1M0
r4atHkYvSnUzSvhq0eRi9KdTNK+GrR5GL0p1M0r4atHkYvSnUzSvhq0eRi9KdTNK+GrR5GL
0p1M0r4atHkYvSnUzSvhq0eRi9KdTNK+GrR5GL0p1M0r4atHkYvSnUzSvhq0eRi9KdTNK+G
rR5GL0p1M0r4atHkYvSnUzSvhq0eRi9KdTNK+GrR5GL0poz3HsPy2n+m1WkREREUWxfi+o/
mTP2lOrSIiIiIiIiIiIiIiIiIiIiIiIiIoujPcew/Laf6bVyVhv9zvN8qReHXGKzuiqXNpq
qjifFWhznGOOEsidxWiEbjiRxeebQ5oJNS2VlbDoOxwwR3Gi6PFDTXB7aB/SIA2HmWRvYS/
8AqBjSQxww5x+GRLubtQ0VyluNJS1lLeqy20BfT0dvE1NVVIfIJGSyEENa0Fo3cRpDTnLsA
KpTXmtk1NcLfcaO41NnliqARU297wCwgbG7IA0sc3iYy6QuAZ91x2uraKkLtHWqB8FTBLS0
kME0dRTvhc17Y2hww8DIz8Rkf5V1EUWxfi+o/mTP2lOrSIiIiIiIiIiIiIiIiIiIiIiIiIo
ujPcew/Laf6bUt+kLFa66Oso6HhywcTgNMr3R0/EOX8OMuLY8/wDxA5cu5WkRYKx9Uyle6i
hhmqBjZHNKYmHnzy4NcRyz8D/9qZ0rVX/BrR/5WX/86dK1V/wa0f8AlZf/AM6+WVuodYw6q
qItKVNZcajpzm3Cj4slZT07t/ZjzJBGImZ3jLXdze8bQV9G0VLcpheZbxTQ01e6ujNRFC/e
xjuiU+QD/wDXPHdl3eenRERERERERERERERERERERERERFF0Z7j2H5bT/TauSrbJq5lZfdj
rjUMnpqvojoK90Y4r5mOg2l0/LY3IOGRgBrm9vIznltupG2+4T2+33dk1PUl9DR1t1LukRS
U7YnMc9s5I2yZlGTkYAaQXEjuaKm6HQwUvHmn4ETY+LO/dJJgY3OPxccZJ/NZ0REUWxfi+o
/mTP2lOrSIiIiIiIiIiIiIiIiIiIiIiIiIoujPcew/Laf6bVaRERERRbF+L6j+ZM/aU6tIi
IiIiIiIiIiIiIiIiIiIiIiIii6M9x7D8tp/ptVpERERFytFqCy2q/aiguN3oaKV1wY8R1FS
yNxb0WnGcOI5ZB5/4VDrnpXxLaPPRepOuelfEto89F6k656V8S2jz0XqTrnpXxLaPPRepOu
elfEto89F6k656V8S2jz0XqTrnpXxLaPPRepOuelfEto89F6k656V8S2jz0XqTrnpXxLaPP
RepOuelfEto89F6k656V8S2jz0XqTrnpXxLaPPRepOuelfEto89F6k656V8S2jz0XqTrnpX
xLaPPRepOuelfEto89F6k656V8S2jz0XqTrnpXxLaPPRepOuelfEto89F6k656V8S2jz0Xq
TrnpXxLaPPRepOuelfEto89F6k656V8S2jz0XqTrnpXxLaPPRepOuelfEto89F6k656V8S2
jz0XqTrnpXxLaPPRepOuelfEto89F6k656V8S2jz0XqTrnpXxLaPPRepOuelfEto89F6k65
6V8S2jz0XqTrnpXxLaPPRepOuelfEto89F6k656V8S2jz0XqTrnpXxLaPPRepOuelfEto89
F6k656V8S2jz0XqTRnuPYfltP9NqtIiIiIii6wv/AFY0pcLyI+I+mi/ptIyC9xDWZGR2dzh
nnnGcLhvsZqrlbG12lbwOFLDuqaSIu3kNEr4pgCCWhokZ3cslzjzByvqaIiIiIi1bnXxWq1
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
tVpERFFqvfi1/Laz6lKsOrrLW6ho4bUyKjktk8sZrxNK9km1ssb8M2g5y1rwQSOZaQRg5uG
JpnZMS/cxrmgB5DcEgnLc4J7IwSMjnjvOZNRpGy1clc+rppqn2hFwqls9VLIxzdxcAGucQ3
a4kt2gbcnbhbtqtFBZaV1Nb4OEySV00hL3PfI9xy5znOJc5x/MknkPyW6oulPwif5lX/ALu
VWkREUWxfi+o/mTP2lOrSIii6r/CIPmVB+7iVpERFF1n7j375bUfTcrSIiL8//b178Ufy1n
1JV+gERERFIrbC+pur7jTXiut8ssEcEjadsLmvaxz3NP8AUjdg5kd3YXj2FcfFl3/SpP4E9
hXHxZd/0qT+BPYVx8WXf9Kk/gT2FcfFl3/SpP4E9hXHxZd/0qT+BULZQRWq1Ulugc90VJAy
CNzyC4ta0NBOMc8BbSIiKXc7KbhXU1bDc6ygqKaKSJr6YRHc15YXAiRjh3xt7sfFYfYVx8W
Xf9Kk/gT2FcfFl3/SpP4E9hXHxZd/0qT+BPYVx8WXf9Kk/gT2FcfFl3/SpP4Fu2m2MtFvFI
yeao/qySulm273uke6RxO0Afece4BbqIiKLLp6b2hWVdJfrjQ9MlbLLFC2nczcGNjyN8Tj9
1jfinsK4+LLv+lSfwJ7CuPiy7/pUn8Cewrj4su/6VJ/AnsK4+LLv+lSfwLxJpqoqTCKzUd0
qoop4p+C9lM1r3Rva9oJbCDjc0dxCuoiItW50EV1tVXbp3PbFVwPgkcwgODXNLSRnPPBU/2
FcfFl3/SpP4E9hXHxZd/0qT+BPYVx8WXf9Kk/gT2FcfFl3/SpP4E9hXHxZd/0qT+Bc/f/AL
KLXqeuZW3m9XeqqI4hE1+6BmGgkgYbEB3uP/dd0iIpbb5A+6V9Ljh09siDqyqlJZHG4tDw0
EjBwztOORtDmd+TtR6msE0bZIr5bnsdv2ubVxkHY0Ofzz/a0gn8gclBqawGqipRfLcaibZw
4hVx737wCzAzk7gQR+eRhVFFuurLPa7E29GrhqaSSVsULoJ48Suc7bhrnODeXMnnyDXE9xV
OiqmV1DBVxjDJ4myNG5ruThkc2ktPf3gkfkStZmoLLJPUwMu9C6Wka99RGKlhdC1pw4vGey
Ae8nuWOPU1gmjbJFfLc9jt+1zauMg7Ghz+ef7WkE/kDkrOy82qSqp6Vlzo3VFVEJqeITtL5
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
bVaRERERERERERERERERERERERERf/9k=
</binary><binary id="_127.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAeACYBAREA/8QAGQ
ABAAMBAQAAAAAAAAAAAAAABgMEBQcA/8QALxAAAgEDAwMBBwMFAAAAAAAAAQIDBAURAAYSE
yExQQcUFRYiUWEjM4FWcZGU0v/aAAgBAQAAPwDpO5r7cLI9sSgtSXFrhVik4mdozGxBYMcI
2VAVix9APB741uu8ND7xVR8XSLnKkHKXBAyQuF5P+MLk/b00Zp92UvzVXhku5p/cabhF8Lq
zxbnPyPDp5GRxGcd+OMnicXd90kdXse89Rpl6NDPKvSmePJEbYDcSOS/dTkH1GkGiVzuOxb
vVQ1NXuaj6sH7RhvjQhDhhkBJAOWGYZ84OM41p/Oe1f6ltH+9F/wBarR7j2hHdai4jc9r6t
RBFAymvi4hY2kYEd/OZGz/YfzHdr5sq90LUVduS3NTvnmkV2EXMEEEMUcEqQTkHsftqej3R
tGhpUpod0W5kTODNdVlfuc92dyx8+p0g0csl2qm3HWWyqqnq4J4BXW+p6ShJYmc8ljZMgqi
tCPq+oli3dSuEevay7LeJLs1es1vmoHoqkQGKZ0Zz+lHJk8CVH7ngE+P4ACive1bz7bZ43t
cz18cRo4mkp4jH14WkZ5Sck8gsaBGHfGQQO2ujW6zWq0dT4ZbKOh6uOp7tAsfPGcZ4gZxk/
wCTqrNZq+WeSRNz3SFXYsI0jpSqAnwOUJOB+ST+daFHBJTUqQzVc1W65zNMEDt3z34Kq9vH
YDxoN7P9+2rc+473S0VPWRvUyitQzIoARYoIiDhj9XJSftj19Nf/2Q==
</binary><binary id="_25.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAKAAkBAREA/8QAFw
AAAwEAAAAAAAAAAAAAAAAAAgUGB//EACUQAAEEAAUDBQAAAAAAAAAAAAECAwQFAAYREiEHF
CIXMlWT0//aAAgBAQAAPwBnUx4d/lhNxPyu93di6JUi7TOjjtfMautvFwuNpaSnUI2+Ozad
eSZL16zV8fUfS7+mDzQ8631rVRodWmql2kNciCFEMPKUGSorb9qiTySRycb7j//Z
</binary><binary id="_30.jpg" content-type="image/jpeg">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
vc/c0gMVd05cP06DfFh4+G+586+w//2Q==
</binary><binary id="_89.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAC8AL0BAREA/8QAHA
AAAwEBAQEBAQAAAAAAAAAABAUGBwMCAQAI/8QAPxAAAgECBQIDBgMGBQMFAQAAAQIDBBEAB
RIhMQZBEyJRFDJhcYGRQqGxBxUjwdHwUmJyguEzkqIWJEOy8cL/2gAIAQEAAD8AKr5PHq2N
r22thTMdSFmUG537E4BmJ1kqCdtsCsAdS2AGPEkipa7LvwL848wsZJgLqEO253PphnHklZV
gGlQMTfg73GFVdTT00pjmiKMB3wE672Xf64/KCLWG2Pce5scPun6jTWKA25VrH0Gk4NqmuL
gAgdx/e2ElZKtMpdgzW2AG5Jx9olVmWWtJpk/zg6QCe/3G/wDTFJm3RSS5OMyymdajRH4kk
YbVcWvdT3+WIi3n/pxhtk1QkVVoubuDe49OO/zxzzKUSVcUEZZ5GIYohsbcC5t623xWt041
T0tOslDTidCDTzQrpckgHSwPN9xcbbg7b4j8tm8BqhyWKrCWIA5tb/nFRS5HOvRNRFVIFqJ
IjUh421LZAWvpIGljuCfQgXPGA8iy/wAavoq5YUnMEce3tDh4+TrEaqwI8tvNsSQOL4XdWT
U0ua+JDC1PIVKzIyhSWDEarC4F108bd++KGZiGMgYAnkEf0wtlUqrW8oG354GlsynSwueDg
GqkWCEu1iDwOST/APuFVLDV11QJCSpHAC3+2HtNUtSKr1IcqoubWIA43Ftt784sumMyySeQ
LTVIWYr5UB4+lyMUGb5FQZ7l8sWmMzBD4Uo5VvjbGOZjRy0NZLS1ERjljYqQdu+Br7/I49L
crY8jjB2UzMMyiWwsAwuAPQn64c1DKXtckDawGJyrqIqusaJVMiQf4d/mdt+bfn9K7pbJ48
womjqYGnWUhvDle4A72F7jk8b4sIMrTLsuilytbLGbEKxJZP8ADvza3zxmnUeXNQ5tKwB8G
pJmia17gncfQ7fbAWVkDMI722BuLX/CcH5Vk9FnmcztVI76X0qUcggC19+caDRUT5c0NEss
tTSqugLKS7IAxZbdzvcX9PgBaBzyiShz7O6XyIghlYBBpChgGAHyvbD+tp6bJqZTFUSVNBN
LKqtKxssEgbZNR7FFt6hSRfVhNkz1UubUkFMJI4pqWNanSy+ZBffYh+59w3454wuz3L6nK8
xaCrK1DPeVZNGjUGJPui2ne+1hb0xRSmxYAgWWxJGA5TeS2nUDYb/pgedWvbsB5SNx/fOEN
ZrqqooHKLD759LngfHH2Iy003s8SqCf9RLfGw/riroKOWupNOYQrJCPfmjBWSNbb+UjcfI4
My7oh8mzFJocxSohdSFCpp/O5xQtTTZHUxzxqdAID2Y2YWHbe2EH7QaX2yGDMY02C2b1A25
xClChF7m/fH4grYmwv6YLyoGTNIlIuWuBb5HDadxErMWFgCxt6AYlaTp6qqmElJMwkv2Nj9
8UeT5Z1LkWY02YM/ixRyI0gIBuNXBuOfjjSKOrWrqamlZzCtQvjQo1i0R9Ae++/oL2HGEfX
GU36aSsuGelmBbtZXsCLet9GILKwJM0iVjf3gL/ACOPsceeU1Pm+b5eQsNFW+DqK31anN+T
bYhR/uxoNBnlRE2XrmKEVNQrRvKV8PSyHy+W5F2V+xPe1xidzWlgq+qa+N5v4U9MbuG35VT
ufrhec+p5+nKajqqKSGZwIoYlXy04VdJldrbs26heykkk+XDDKMyjoswo8vno1dKiGJo6kK
tkfS62dmuAAHY7DVuRve2EOaTLmVSzRTsaeKR0hMuosU1G3vAEC24B4Bt2xRyvuVAuCt7+u
Ayb278WPfbvgTNapaWkZibEA6Ba+/pidpC9RJpAiZ76rNc3v8RhrT0lbJVhTEIUYbXYMLfQ
79/vjQOnstY04hSUEstgB5G+akcYewRClkWnqIIgDtrjUKCfUrx64Y1dAlTRGNmGvezAG2J
l4irjL6xdcdirLyCCDv8A36DGb5lQPl2Y1FHJe8UhUfEdj9sCsCTuBv2wTlZIzGID/MP/AB
ODc4cLl8xPJW2x9cH9P0vgeCv8Jg+6lXB1AW3xeUscctB4MqBkdbaSL4ErKXxa+KSBT4kdr
6G722Fr82LD+nOOvUequ6NrXZCqtErIlrGwKtv/ANv5Yy3K7HNIbjkHg/A2xadKVmX0+WVW
QvG1XUyVTzVMT8iLUv8AEv6hSrADe4Nt+COo6PMZsrkpiFjmMvhowYnzFxoa9r2HlJNuL4k
qmtjkzWaSJ1Ph0h1lBbU1wW535J5J2w+psmmj6HnoqxYy2h6wTxqCdS3NiOx5Gq52IHc4E6
ehhmzGB2qITJHTRuImkdHA3BZSo3N9IC8tc+liu6yqqepzKGVaVqV/C0yR2Cm4Yi5K7G/r6
AYPl8pZhsL8HnAzaVLckncC9sTfU/is8KC+nSTb64QxvPA4eNipHBGGcHUlbCb+UMeWUWP3
w8yTrV6euWSSnZkJAa0ljt3+eNdzGtFf08ua0hSaSnUSE2sZIxuwHo1hf5qMEUVRFXZagRt
QkTUpva/9O2EvimWpSSrj0SwmxI2JF7W+OJr9oGXBWo8wRSA8XhNtyRxf42xGEm9h6d8FZU
bZpEW5Ornbexx36lkWnyzUeHlUHa/xwJl/U607wzS28GJWVdIuQbLt+X54t+muvqHOawUEi
CFm2TW3vGx735NhigglCZvmMTDW0Ps80ZYc3Dg7j4A9vXHvPql6rI51h06JoGO1/MLbWP32
xlOWrbOkT01fkpw46eikfrOvnjkMYEardbHS2hSCRa+nbexHbFHX+N1Vl0rQSO9DlzJLVSE
lfGVBd47i12K7kbbkXttiGUIJMxcqI1ellsoPAP3xX1lPl+QZWr0CuKOfxRG0zA645Qxstj
f8CnzG9lF99sIcrpqmszqgemZ4mjpE1IHGlwAbFkJGuzHcE2PG/B59T5dNk+czI84qvaXeo
EjqA/ncmzAAAG9+BbcfIMZ1uFLA253P998DXUEk3PHPOJysPtGaTDkL5d+2DoskjqFAFrsM
HU/RCS8MdRv8MfqzoaeGB5oLNp3Av2xRdIyS0lOXiYJCFBZe9wfN+WofTDrIKuKkzCWkJKo
XDxo1gVFzvt6/rfDuSnpzWl5LkMSbAcG1zhZ1nRLV9I1eix8MLMnyBF/yvjIVP3IvgnJxfN
Yje4AY2JHocMOqUj/9OzKwu4dNNuzX5+18GZF0LJWfs2qZ2WM1NY4lgYknQo/Qmx/LAPRVN
PJl7xyiGWKnqBMjKD4kbjg34t8RfvztiszrN/3XmlLVamEdVFpc3FvK3c/7vzww9roUoHjZ
3CyXPoCG+e39R8987ygsOpYvFbdTICT/AKTjl1THPNm0LUdMzwpHpnYTaPFW9ynPFu/x+GC
c36lzVelaXpqhQmGCV5KirLDVUHxWdLAm4HusSdyflv2yqOlrnmMo/hNDpdTzuRtt8L8Y7j
OKdeko6ero5WrJJPCGh/4dKoG7HYankOq+7GxJuDse1DmIyuaCKpWnlo6inRW1QqTE3Gst7
1grEC2rltt90ubS+11JjUS0yQM6LDUWDoAxABHY2AFrm1ucO5rF2b4W4/LA9Q2lX0t2vse+
JiANJXSEXHmIviuoEWM6SNxY2I4xU0AsyDXZSB3vb798PBDFNAVdASwIv9MKqTKUpfGXyoG
bVf0BFjhPUUtRT1krqwaTXrvfTvtYfbb47XxV5TIstNHUS7WTSdR4O3I9e2CquNK/LqqntZ
ZYHi2+R/rjD3jMT6W2tzftjrlHlzSIgi/mAuOfKcHdUNUJl6FUBiWQGQk7i1rA/fGsZRDFl
PTlBSTMAkUIRmI2O1iT6DCKky5Mg9soJEjahabVFc3ZVY+7zcjj7fMYX9UpBURGmCGRnp5U
iB4DELb7Gxwg6XrVr6NssrqkNLT1FnhYlWKqb3BG3Yj6YT0VouohdtfnfzE+95Tv9ce8zqI
zUrTieJXADFWbTcXAte49SbX7fHFvJ00s3S3hmSGquFamYKqmNivZr7jULb8A73IuIagkNM
al+dEDMQTbgjbFfS5bp6MnpaiaCdZaZ6hZIlCyFk8wBNyCt78f49gL3wB07RrPmEU8c9P4l
PTJI8T+Ir+Hvcqw2BvpA5vdttgMKurMxjzDMI50gWKQKUlCL7xDHcn8R3tc86fiMMHAvseT
vYXOBKyUJTO7WsLkg/Lb9MKMjpopm8SSYI5ba1jb6d8VUMbLNGl132B4Pb+WKKhhcsNTDcC
4BFxhzGWjsgsQDffbfHqfSGMpBAvvtwDhZJFHNJFOoV0JMZPqbggen4v0x4oTWUtcKKRFeN
1sGKEWAuBf7YoQphpVUAA2sb/L+uMRzSMR5pUxnYLKwta3c485YD+9IrCxu302OHWbJ4+S1
MY7R+ID/pOq35Yd5f1k/VUaZPS08KxyUxFS8zkAA+UqABzY37Da3fDmfJzW5BEJplevywmB
5k5ZVNxf4ldJt8cAZ5Tz0+USyxL/ABgA62G7C4Nh8TwPjhN+76Dp2nWsJIqKqJZHL3V2OoX
uv4dibDnm+JbLZi+bpJuSS1z3PlOHeT5bS5nmlS9dDHKviaQG20hbKcXdDl6ZXUJT5eLU6g
qYCwvZmLCxPYFWI+beuIPqKnSl6jz6JvOGilcmwFtQDbfc4c1cNBkVAs2XxmGhq5ZGj1tfU
kgcstgt1NkXa5NlW9jeyagiqa3Mstgp54KZxFEwZ5CGk02I/hjaSxUkK2x343wP1Ll5ybMR
EtS1Sk2qZXlOuQXdrh2ubtcG5w0kuoIsSLcj9LYV52dGVyFr3Nu33wpySZIXaS4sAbg8EYo
Pb4mr6VY5CUMQcm3BJI+vAxW5bVRywDw3RXYXBIv8r4eQOtQPI4YcKwvdsfKwSLBJtc6Cb9
r2wsyF1q+mneQaWhlMoPJsCfzNj9MUaiGURVBKhgmxHcEA441tckKNC7C9iwY9rf8A5jIOo
YyM6qXFmJcsfjgPKPNmkVr3sd78+U4fZgAMqrCoNvZpLbWv5ThX0IKxZXnpqFptIOoq6k83
929zyOMadkWa0tdQSyK1talJEZdJR1JB1X3vYqN/8OEnXFY0vTtRHTyOlQSmgre62YE7/IH
EznmX1C5VSZhPVib2mGI6GYsynwxqO+wGoHjCfKEP72huP8Q/8TjrHk2cSUGdZxQPMgpa8R
J4bhWYMzBrd9iY/ufjjQFqZ8pegSrlklLq0UlXKgLIwYGMG3HvFSb72PBxO5gtLU9V1wkKt
C9Ob3vY7qp257HAcWazr0mgqqYtLNOYSY0Pg0kYBJsb/wDVd7knzeUsNrkYLymtSmzGippo
faoaiOJY9C7wvZlLsRZiFR3sBff05KbNWlnqmjkR6dYncJBKNJjBYkbXNrix2JHa+2Hh96+
pVuTsuE3VMng5QCqnzyAe925xJw5iY1ChTseSf0HGD4q80c0c7DWAgtY8i+DYet62GQrE0U
as5sxQ3ANx8fX8sPuleuHhqVp8ymBLyW18izd73t3xp0jo8Eu+q673N77f398I+i6gS5PWU
rAkxTujE9iTew/7sMqarDzvRSlRKqhoyPU32+98fq1PHYBvLIi2v2Ixm3UsTJWzC4IDXJt6
cYXZFds6p1PB1Cx/0nFHVUxmjqKcNoaWNkuO19v54U9EUE8aCvoZ1M4HnjZrCxP/ABiszvO
Y8vkkSa0TSKGJJG7gEFfj2+59MHdNdO1HUcH7xzQPT0kgvDGvvSAj3t+B6bbjfi2IzqEyrX
SUBa8FCzU8AA91FYhfmbW3wtyxTHmcVyb77A87HFd0rmEUIn6Zp4NUrTSTVCu11aFtPlueW
0sABtuu5tyd1HlFRJlk1DUThUMmhJj5VVSwIJ3/AA+Xv2xHVWY+NmdRPEzSiCkI9zTqIIJ2
Hqb8YpIMsSDpKWmMkcono3n8ZHAkulmAJ4ZdXa17v2wB0/RU1TUwzI8L18MMUgjmgD+HGAx
LBiwsbgBSDseRvdVXVdeMyrIJBEsc0UbRS6HLhirmzau5PPf5nDdlAtfkn8/7GAeoqQVXT9
RZReICTcenP5Yzg99rdsaZlXSLV3Q3tlRTxiUxAxnuV5BP64zlXEFTd4w+h/dbg/PFxFRZR
nHT8clFEiTobiXSE0NYXR+L/wCVviAd920DpqrnqsjjWpX+LEmjUTqJsLE3xP5JXnLM9zel
vpBlWQAtz5RY+nph3mMEk81LVRykR3YPpvcAkWN/hsMMZhMYAkuhnIHm7MMZ71mTDmhQLtI
gJIFgCMKenRfP6YN/n2/2nFhLDpe6bW5IxntRWVPR+cz09DVeINI5G6g72Pa9v17dmWSVtd
mPUGSzZpKamOrrYXQyAPsZgpUX4F14xq/7Qut4ulMlaKGQnM6tGWnVbeTsZD2sO3qfrbI8n
qXrcu/iOXlVtLkm5Pe5/vtg3LYteaxgjV7xvb4HBmTKrdYZhK8vhFYUs4mKNH5BZ7cEA2Fi
Dzxiqq4Hz/KHzKUCHK6F1lXx2P8A7hoyR4did7sNJJ7n8WIMm7ZhI0SjXTSkqOBfm2K2seh
y2kSpy6ONKConkdPCsSySK7MCAPLwCBbgIDwcT1EjSZrl7tN7OngwxvJ4rx3vq0gaQRqGlm
Ukg3AIItcfOpaBcmzEKkzTpVA1AaaTxGuzG92JN997379+S4INyFY87bAWwHnTvDkNWE3Z1
0HfsecRORZYM0zqlo2vaeQBhcDy97H1tc4/ouahiiytaWJNEenSAo4Fu2MJ6oySly3Pp6dx
KAN/KBfcC30xQ9IZSsVMJ8uaRKm4LO+wkW/u/p9QDxtiq6dmhu6QlAqA3USBiLH6d/7POJP
qQtQdV1c5FknjVlIG9ha9vscUeRZuJYDdfFQgagBsR2Nh+eGL5zG0JSYiNkBEbn17fPEd1j
I9a0FSxUlRY2904UdLqT1DSk9tZP8A2NivqKmJLs7Hi5AU74yutyzOK6vlqpqbzzuWPnW2/
bnDehqswoMqooRlqyVmX1oqaaV3WyqCG0EA3tqF/rhVmMec5nXy1+Y6p6mVtTuzKb/nYAbA
DgcYKyIz0c7rMumKRQGa97Eb9vrioyQLJmiyCxjTUST22I/nhT1alVV5tC1NSJJDTrZmey+
JvfSdwdPHpycfc2zzPJMhpMgpIXpcrpnZ08665/4hZS9jbYEbDa4v6WY5Q0FU0rT2CtBaRD
vyRcY+JnVa3TyR1WWSPrcUzzm3g0qIBpVLH3yVuxPABCjc2PoM4qMtq6Kip0kqaeohUlQ1g
jBTcgAgu24tchQQpuOQkzYGWvqIZEkpEiqJjHBJa6qzlgTpJFyCNwfltbFJcarKwueB6YW9
RSpDk5RrapDYfHbAXQ1KtR1bl+hNXhXdifgLfzxukhDFAdvpjN/2i5Z7LnEGbadULp4cxtc
r2B+7DD/JWpJclhmiKopQXYcXG1/lbHpMtFPM82wD72XjvvhFndHFV5zlyuL62aOTvcFSCP
79MZ/S5icnzaSDxiyRzlVK2swuQcXtTUrX5UyxnUZI7hhyARt/LExndJU0eXUdPP5jIhlDe
h9MA9PuVzunYnjWL/7GxRVZv5gT9eThDmM4gW6AM7HSg7H6Y65eppoPbaxDMikazELuAedj
sAPjiuqciyjqLJlkytPArRHrjDoFEosCQbbX+WIB4nilZHUqyNZgRuD6YPyiYx1Sx22YG/2
v/LHLNKul/eEdNI6R2tIWkU6b32G31P2xfxZVT13Ss8MFbFVx1Q8aMNJdYtRIRlNrrZgQR/
qHwxA0bPRyVTshWSGFyQ9xpIIvf7YrKOCFOk5sv/eUVbDJBNOAjDUsqhTYsBvYlTY2Pm32w
FkPg+0RSPVvTFIYWcNTq0UiEPdWbkE25sALEX82y3rKvNbmMSmIrNTK8DqjFlGl2tudwdzc
Hj1OG4Wx77m2EfVFBLJSrUrJaOJT5Cdxvhz+yqjRpZq07sGCg97W3xqFbUGBQ6oZCBcqBuc
Lsxp6LqHKbOqyxHm3mK/QdwRx8MIKWlXI8tkNNMhQOWFrahbsfjYfl8cMqeuWpiDyE2bi/f
64RZnOYs1iJjuRcqWNgCB/S+M/z3J5UWWuVvIH8QAejHT/ACGKPIc4yzMcnpKdbxVwKxm5O
++/H1OOnWljHSxqf+glwfgRa/5D74nMl2zWAm4A1dv8pw/lJdwdIv8AHtiWbMUrMycLMkYU
FVLsFBFuNwfyxc9C0FOzR6J6c1NroEFzbuurt6Wt8Dfg2fs1PNlqTU58N6ZrLfbQwNmU/UH
n7YzXqvK/YsxFVGtoau7gW2V/xD9D9bYV5YD+8EFt9Lc/6Thv07TUddms61Yp5S0xURy7ny
7cYv6WkgoKlKegUJGtz7Pq2Opr3F+N1J+mIDqSOKDqPPVjPixtDI5N73LKGP5k4d5o1JQ5R
TVuV0SUkNSWZIowXJRhIzIw/CNrkC4DGwuBfCDLqNK7N8ueqmljEVOqRMiv5GZTYhhcI1lJ
DWuNN/wjHDqShiyqtRqSpNRBVhpg7yCQhix1DXc6jcXvfvvvhsjs3lvcEADfbHjMIGmyuqj
sSxiawtbex3wb+zCoSLLUjZh5pCeRubYu63M6KnqR41Qkd7AXNrk4l8gzoZf1vXZO76qWrk
8WDfYMRqNvmSce+rskqaepmq6SdhFOl3jPu33G3pyDhfldWTTNZbWIBG/PH/GDaqlhNPHUN
5pEUjcX7YisznkzQQ0FHZ/HCeRfUC/2vfB/TPTH7sq1SZ1lmjcvIV4XY2H5fnjl1RUhzCxA
BaIEHVf1v/LCXJbHN4NRFmLX52Gk4d1cggjeUiwRbkX+GEeX9NQ5ol1cob7m18P6ToOpyjw
s3pawk07rILLbg4u6avQ180NabGsRdYG667WsBbbt9vicA9bZXG3SLzrcGnkSRdQuSCQpt/
3D7YznKwGzOIHYeb72OO8fTNbW5Hn2cU8zWpq/THEjMSy6jrv6DzIf9pxcPNPkKUELeM1It
4p3dxqUFwYwSeQNRX/jfCGtkgn6qq5ZFJhkpiCjLfYMFIPY3t+eAo8zrh0vJTyZfBOzGNKm
rDm8MSmyKqcLuoJYWBva3BwTQ5pUUNXTUdJK8/jxR6offCgXuVj/ABEki1ipugsTuMJc3DV
WYTe2wtSTJIwMINwm+wvYXOnSL2HA2w+ICPyQT3B746wBibCxBG49b4i8tzifIc2aPWyRRy
kEA7Ag2w2yxj1f1E7ZiZTSxghVDEafj98aBU9PU6ZdSPQjRPRsnhOfeYLbYnbm1vrikm8PN
cojdf4iTRhgfW4xOZblahpFKaSoII4OOmY0wMLpuAUIIPYWxJ9IQTzZkIzl8aRq0oiqzYkx
kjYfG36nDTNa6kyuqq0pz5xHrYju53I+wxBZjVGoESAnTGCN/nj7kzH96xW2B1D/AMThrnT
EZbKTybLa1+cMskhSFqdYpVYuurSQRYbdgLdx98XlItqS1gykbi4OBKynFVXKYkjLwkKGZR
75F1ufoe+2OmfQTydH13tC3kMIYqWB0kWP6jGVZYWGaQ9zY/ocVnTGbCCabpuClQBJWqZmZ
gqyK2kiPTaxJVim5AFr9gMMupMtipcreGuq9NI0oRZBpuqs3YcX7iw2tsDxiOnr/GzGeaBW
C01IQviHcFbEk7+tz9cUmW09Eej56eKvasp5aaaZY3FtMygG4YAE2JXY+pJwL014L1saLLK
lZ7LG+gxgpKlmGkHckklTa3CWuLmyTqmunrq9BLZ5qcNA7BfDXysfKFIFtJJH0v3w4e4B1d
uN+/8AZx6h8rXFzb1/LGeZsB++axQSWNS4/wDI4sOkY1p6mdgDpbTz67XxoNLUK6wK1tDEX
+2GeRxyQUdRSPt7PPIsa3/ATdP/ABIx4ijETu1yCW3vtt88Lc9l8DLK2rttHC7/AGUnEH0T
ntVVQex0tPrqIku7H3QvF/yHGFdTVT1UZqZ2BaQtq0nbY/8AOFzpdvTf74JyhSM2hC2FtXP
HunB/VTPDlIdYzvMAfhsf6YUUed1lNAKyOJ2ijZl+CsQu5I+Q+2LHpjrfMaqvpoa6h0UlS/
gxyohtqJ4JJt9MWUEjR59mCqDpMcEkYJ2uNd7fYY/ZrUHMslleNyAYmBX0Nt1I+eMtytCM+
ijKEHzbE7+6cM8t9lj6pr2rpYaYPHGytKfDawUeZXuLWI44NiDiqMIzzIZc/rXjp6KjcS0S
EgCSWMlVBHZddktyd+NiYS5b94SuA7SUsrOeB6nbFbmk0NHlsOZUUCwx1szVJjiRg13Rywb
fzD1Owvb/AAgYSZfRzZhXZe7zvAsEUYjlSBpGRiptpI3XaMm/A079gROoqSgyqogXKZS9LL
GWFmuobUQQvGw/M3OHBLK5BBN+3pj1D7wJAsR3xnWbiQ55VgMFPtDm5/1HFbkWRZ5URFqLM
KGQPuVLsG2/24a/vGsyKpgjzeklgUtbxVsY2PzH/HGL3LcwSpqvFjGmKohDagDYsDY/W1sc
qmpAkdtQIsQbevphNn1cJsjrY9LHXG6f921vzxKfs20Zf1JURS8vGFt8t/54ZdX5bl2XUUJ
pIgryOQwB4I/riLlQ6twQRzgnJlP72hbew1H/AMThr1KSenpoVAPisg2/1XxRdN9GRVX7MW
pSSsuYt45Ym+m1rW+g+5OJ/ovKJ4crmrQ0r04YkwsfI1gL2sfevbnbYXF7EUPUlfNRVlFmS
odHgn2jSb2AK2/+364Pkz2kGVicIGjewD6trsbG47bk/K2M/wAlKU/UkYJDKjuvPPlbHPqm
Ctrc0gnglhjhpACniHbXe5NrEdgLfDHjPIc+qMopKS5jyWklf2RDcC7MzAubWLgNYfDgbkl
rktQryvJKp1LDdgB3JF7fXHOnrs4XpV4/DgqYRUaK+pAGsKAoSMbbKCqsW2u1htyxeV1sdB
1Dl38RDBPAsD6mVTGGG7Le43G1jzte/ZZn0FRT5nNHmSNHJ4sjJYhkKlzYqbLf4mw3vcA4p
JIyst/eB5OOSbSMDYj7j88QGeFx1BU6gQ/i7C25w86WzSpyiqLE6Ucb3Xn540wvT5tk5EgW
VXS5Gm/pf+v5YFoWhpMtiSlBSKNyAOy9iPyGBJK9TA2tyDqsAe9sAPI1eFihBkUtpsgO/Fs
C1FG/R3UdHXZjFop69HCA+8NIW5I7bsPthfn+YfvKvllRyUDXQjuO2Ez3Xc8/DBOUDTmcVy
ATff8A2nBvUyytlomilskTgsgF9RJAH6nGsUjRZJ0/TIo/gU8QDb+6oAufjtvhI4pOny5pp
0FLVy+NFFYGMhrXKkdje9v5WwB1Afa0aOPSFkhkiLEXC6gAfh3/AC74lekayMSy5RPFI5pq
jUsgsyaRcgG/xG1sLqJ/Dz4GPYAuRc9tJ/lj9mdYnt4gkEgSMhzIFLWJ+Q503+G+NDoKLL8
z6VaKilcpVBhpdSVAJtYITZSr24+HZsZ9CstHNWq6+HLBC+oN+FlIvf7Yrsviy6fo5qWlnE
1L7LNKI31bSIPeVufetsTbn0OA+naimpq6kilZ4KmeBDFKWAEu1hGqlTqJ1C9jceWwN2BTd
R5o2czwzRsKgxB4vHQaUkUMdNh8Bz2vfFJMtkta/p/f984FIvKQB8yPhiNz+BY+qmaQ+Rwj
8drAfyxa5FltNmlC76iWUqvO6gDt/fbD3L6J8qhJhYSLfubE8n/nCGtzmGhrqiD8M7mcIw9
xjfUNzxcE/wC63bCqlFb1Lm6ZdlceqQ+dmZvKi3sWY+m4xrnTfTNLkVLGpIqKgA6pytr/AC
G9hiR/a0glr8hVlv5ag/L/AKe+IPQdRF7X2uMcTGCt22J9MdMsUNXxgMTcN+hw3zOMVGT1q
MTYRFxt/h8w/THbIOpsz6nqaehkqXpKaCL+L4YDGY3sV37EX/sYs0yqCfpuTLrlxl8jLFI6
7lL6hpPoAdN/8uFnUtCYMidFl0udJUk2u2oWBPz2wkzOopMkoYIYFR5/BQOFs2lgysfNa5J
3udu2wxKZW5bNojY/isL/AOU4ouk5KeTPagPKPEMjeVh5bLtzi7WmQZtH7LeJo1vpCnw3DX
JJttyt/mcQHUgip+o879nGqJoHcX31FlBJ39TfDnNcwRspp80gpoh7WxmeABkKakkY3Y7sL
nYi1ywsO2EVHlLZjV5dVVFC89PCkMbymlEyC4NlbzA2Fje17XHNwMcuqKaioa5JspQR0tVq
crGtkDhiGCrYaQNhbsbja1sU8sZItb5nAmkJ5rDk7Yk+taN456WvjN4ynhvb8JBuL/O/5Y8
9LdRHL5HWaXTE3Iw8zL9oRp4LUZ8RnO4bfbCDMs2o84p/ahGy1rW1xrsgb1ueb+nwxsv7Oc
siy/o+hl8GMVFVH40sqqNUisxZNR5NlYD4YqgyovoB6YwnrnrSPOOs1SFtVFQ6oIz/AIiSN
TfcC3ywM67ErweMDyA24573x0yxD+84yACbMbfQ4bVwZcprhYi9PJe/+k4UdDx1k0zex1NM
KjkxSllJF+zWO+NOybMXSkdKyF6eWNTFIjkMAwJZbEGx2ZvsOMIutKn2/IZ6JPM8jLa3axD
fywgzrL6CmyPLqqN39pqaeEyKSLMBGBq+ZIN/W+E2UxkZtEb2Hm7d9J/nhlQdLPmnT2fZ3S
ygyQ1+uDSosEUkud+RZgbf5O/GKiqqJMkpcvnBhakTWtQIiVQanUqVFzsrE7X27W2wprZk/
wDVdTVPG6iSmJVSRe4YL/8Ayf72wrpavO4ulBTmCGSlEuurqy+p5EJCpGpKiwBF9NySRfYc
k0tXWpmVHT5RTxyeJTxpUPLceGh9+zFSiBh7xIPA28u67N4KmGukjzVIhLrd0MBLRMjMSCh
O5Xm17nbc32Fy6BmKm9+2/wDfrgCS7qWA4vYDHiaOBqOX2lFaHQfEU8EWxkUrL4ziEnQGOm
/pgjKUWrzKCmmPllcJf0ucNq2l/dVdV0stiYmNrjn44/ofpyE0nTWVUzneGjiQ/MIBiH/ap
19+6oH6fyx1NXPHpqXH/wAKEcD/ADEH6D5jGJAnWvzxb0cqzZdBICNowD33tvj7LHc2O54+
eOmTgnNYub+bY9vKcOqinWpElO5IWRCrEbGx2NsJ+iKWiqE/h1DQ1cQ1ax9b/McYpM/zqai
q0phE00lVZIvCTWTINvjudhYcW+O1T0z0c8Sivz0CSrcBvA1ApF8CfxH17fPnGZ50Y58yq3
p5fFpTK5gOq4CFyRb4WO2BKFNGYxaTuLkE/I4qOmM5qIs6lyFDFFBFIajxil2Z30sE9ADdw
TYnSbbc4adS0WXUOWtHVzu9LNKEDFyzFXN7A8kkE/O3PfEM2YSS1lXOF8M09GQv4iAgFv0x
UZZPlh6SkpaR6iWCWlnbwpblBIgA1At6EixBK7G2+F+UJSJPTSTVM9BUeFA0EkUrEznf+Gs
Q98klb+9+HYC91PUdc+Z1iOkiVCw6olmS1nsxv7t1IvcgjY3xcyLYWA2t64Cdb37X3uPXCD
rKvGX5A0Nx4lT5Ft2HfGZKbMD2x7R2imEiGzIQQRjQusaSnzTIaXqGGQLJJTIHW/J3v9d/y
xRda/tOp6HKVyzIqgS1kkQV50N1hUjcA3979PnjHpJHlkaSRmd3N2Ym5J9Tj8N5FHpim6bq
b08sG+pTqtfkYaSLdbHYD17YKyJNebQkj/F/9TihnQK24GpdrYzLqCWHLc/qI8rZolUDxAp
2DckD4fDscNOmYZoc46erXd5IqyuiO5JAcTaTf42sfri+/an1/FRUEvT2VTJJVTho6txv4K
WsV9NRvb4C/ci2fdPSifL2hZvNCe/oeP54aZXCWzWJV32YeYb+6cdo6ulyrqKumzR2ip6uA
BFMYZJrKosLXswI9D2PzqfHpqvpc9U5xWLHGxvQRE7+OCQhJ7+YE2H4Rc7XGIn+IorpXLMx
ppSxJvc+t/mcVueVpmyulzOGkSOaQireKJVXw7h7lubglwpvYlmJsL2wqyfKzU1FFXVZkFP
EsSooZQjvpZrNuCw8gBAIPmX1JC3qZKKKvSTLB4ccqXkjXYI4JBUA7jgc9ycW8jXdgbEDb9
cDONrept8ucZr13VzT514Lt/DiXyKO1xc4mDzj0NzY4PbOcwOWx5YaljSISVjsNvrgI849J
urH0x+jP8Q/AYZZJI0eZxaT71wftivnUFb+ovjrkHlzmC3Ytz/pOKaqOmNnAFwAf1/pjEJZ
ZJ53mkYs8jFmY9yecM6XPK+kyxKCCQJGlQKmNwPOkgA3B7cD7YX6i2p2JLHcknk4cdOSumY
CMHyyJZh698WOUC2cpv3b/wCrYmet66oTqVESQqKRVMVvwt71/ne32GF2Z5zX1kUdBLO3sd
HI/s9OD5I9TEn4nk7kk/HFz01/7kq0puz0ysTbgkqf1xPQdQ5nT5XleXrUF4a9RLUlxdpLS
NGiFudKhLgerE77Wosoq6in63yWjglMcNfSoKgAAl1UMbXINgeDbf0thDHVNm8Ir6pF8WZ3
JALWA1GwFyTYDYXJNhj/2Q==
</binary><binary id="_214.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAKAAcBAREA/8QAFA
ABAAAAAAAAAAAAAAAAAAAABP/EACEQAAMAAgEDBQAAAAAAAAAAAAECAwQRBQYSFAAHEyFS/
9oACAEBAAA/AGS8zqvmcTmOLpbEzs/krthcx8E6pHCjOsgqSehcKSQWJRB31G/vt2r2sjJe
tetEWSBcLL8fFUKNQkbWYzT8rsA9o0N+v//Z
</binary><binary id="_31.jpg" content-type="image/jpeg">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
1iP/Ri/wDnr//Z
</binary><binary id="_132.jpg" content-type="image/jpeg">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
</binary><binary id="_54.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAcAFoBAREA/8QAGg
AAAgMBAQAAAAAAAAAAAAAABQYABAcDAv/EADEQAAICAgEDAwICCgMAAAAAAAECAwQFERIAB
iETFDEiQQcVFiMyQlVxgZXB1FFhkf/aAAgBAQAAPwBmn7Svw1Ukr4inNabuD3a81XnXhQqF
b1Gctyk9CIyP9TfrHPBiNdMHbV9LWV7jrDKe+atktBTKrGFTDF9AC/sqHEi/Hyrb22z0wdL
+YwH5r3PirUtaGWpWinNhpV58toY1iCltBWErsxCnl6aA/A6UpaeWxnaWLoNJDh8zNZkFKt
BfSsqSSTLJspzKPEhZl9MLKzKU1wLMBpvU6H5+vLawF6GvWS1OYGMVeRiEmcDao3kbUkAEE
6IJB8E9LFTtybA5urKiVq1KlgRUsZdVjidmAUF2LFtlRDGVDKVAZ9t9IVvGGxv6S0+0MpMY
b1eLGsbk8zeuZHMPpGLy2hyMspc6JJiUN8Dqs9e1hfw1SLLKmInWeV469XILSJeT1GCI4kC
IFdyQCZAUjBK8jxV5xkd2LFVI8jMk11IEWxIg0ryBRyI8DwTv7D+XQmy+fp+l7ruLBQevKI
YvVxsi+o5+FXdnyx14A89XKdfPpaRruTx01cb5xw4+SJz48aYzMB519j/nq6nuvfS8/R9p6
Selrfqc9tz39uOuGted8t/bqtfhzUk6nHZCjXi46KWKTzMW2fO1lTxrXjX9eh9N8/kKqWqX
cWCtV5N8JYcbI6No6OiLOj5BH9OiGRfKV8IzU1SxkFVB9EAKu2xyIRpU8a2dGTx/yfggqWQ
70e9AlrHcK7SqJW9jCul35OxdYjx9wrfyPx0zXEtPVdaU0MNg64STRGVB587UMpPjf3H+Og
0r5+C1BVm7iwUdizy9GJ8bIHl4jbcR7nZ0PJ18ddva91fxnEf2qX/Y6403z+QqpapdxYK1X
k3wlhxsjo2jo6Is6PkEf067e17q/jOI/tUv+x0uXctkMtmcbWu2q1TGzZmRUghiYyslWQqr
SSt9KhrCxDiFBPNQGJJ6cMflYMlNeigSZTRsmtJ6sZTbBFfag+SunGj9/kbGibvS/wByZq7
jbVevUlp1ovbWLlu3aieURQwhN8Y0KlmJkX94aAPgnXQztvPw4nDYincjuTzXOL27QEbLBa
sSOWSRFIaP9dzT9jiD9JOwdOfU6nWf4/N3cvncHcy9mGKEUZcrDSp1nYoXUrCjOdmVzEZzx
QKdox0QB0WyXdNiSpi7WMetUq3MfLk57N6F5TDXRUOhGjDkxMq/veAp+fHVbD5+Htzs7GTX
47lt54pLV+WMRs9dzIGsM8YKtxSSVgwRSU1o6+7n0L/RnAe+99+R473fq+t7j2kfqc975ct
b5b87+d9LPYOftZbuvvSrYjhVKuSXgYwQToGLzsn92BD/ADLf9APXVLI4bFZf0/zPGU73pb
9P3MCycN63rkDreh/4OknKWqtX8VO2u04sTRXGxwPchRUZBDLqY8lRWCbBTYJUkEsQQT1of
U6nS5lMRhe2sNkM5isDi4LtCpNPDIlRFIZY2OtqAdH4OiPBPQvsKrj+6fw5wM+ZxVG41eBo
IhNXWQIqMYwRy3okRrvXyeqfflqrh7/afbMGJotislkAstYoyINSR60qMqkbkJKsGUkAkeO
tD6//2Q==
</binary><binary id="_51.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAKAAcBAREA/8QAFA
ABAAAAAAAAAAAAAAAAAAAABv/EACAQAAMBAAEEAwEAAAAAAAAAAAECAwQRAAYHEgUhMSL/2
gAIAQEAAD8Afw24MHkPThlp5r8rmFaSNG9UvEKOBz/JdpOhKrwQslJBDA9Bu/durB4e7W3Y
9Ns2tq57NojQpQvTPQuxYffsxZiT+ksef3r/2Q==
</binary><binary id="_32.jpg" content-type="image/jpeg">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
</binary><binary id="_100.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAeAHgBAREA/8QAGg
ABAQEBAQEBAAAAAAAAAAAAAAUGBAcCA//EADMQAAIBAwMCAggEBwAAAAAAAAECAwQFEQAGE
hMhMVEUFRYiQVaU0iMkMmEHVGKRlcHT/9oACAEBAAA/ANtdb9LdrjQW+2UldEq3lIDcGlME
LGHlJMgAPOQFY5I8FeBOe/ujXTbrmlDtCTdtVBNVS1VMK6cRcTIkJBdYxyIHGNGx2xkhmxy
c56o90xvtKTcrWuuSlSD0lYm6PVkh4huYAkIxxJOCQex7eGeXcN1gkp7lNTJMarbPCtMhjI
jZhGzNEGPYs0JKk4PETKe5HbT6aaaaaaaaaazB2PTG7U1w9bXEGlqZaiCIdELGZZRLIoPT5
8WIwfezxJXOCQfij2/NPteTadZXV0EdMrU4qIkj/MUjc1jXkUK5EeFbADBlz4EFqF2oakbc
NNisu9QksbqweGKYkSqwcHisfJMBgCAG4AHOTqSlmuK7cqbfWPU1FXuGrdaqWRUJghZOJ5G
NQqsIIguQCvVI8VOtZNNFTQSTzypFFEpeSR2CqigZJJPgAPjqT7Z7V+ZbR9dF92q00qwQST
OHKxqWIRC7EAZ7KoJJ/YDJ1Pse4rZuSlNVapZpqceEr00sSP3I90uoDYKkHGcfHVCOaKV5E
jlR2hbhIqsCUbAbB8jhgceRHnrLUlzuz3i31bXDlSVtyrKCSiaFOCCLrcHRgAwb8v7wYsDz
OAuANXdwV8tq25c7jAqNLSUks8auCVLKhYA4x2yNUNRbfU3I7qulFWVUM1PFTU81OkUHT6Y
d5wQxLEs2I1yew7dlHfNYTRNO8AlQyoqu0YYclUkgEj4AlWwf2PlqfWbjtNv9Yem1fo4tsS
S1LSxuqqr54FSRh8lSBxz3GPHtr8fYzavy1aPoYvt1M3JZdq7f27W3b2WsUnokXU6c1PFEr
/0huB94+AGO5IHbOdU/Yzavy1aPoYvt09jNq/LVo+hi+3VCK20VNbjb6WnSkpeLKI6X8EIG
znjwxxOSTkYOe+p/spbv5m7/AOZq/wDrqnWJVPSutFNDDUHHCSaIyoO/fKhlJ7Z+I/1qfte
zS7esFNaZJ6aZaVQkb09MYAVAHdhybLE5JPbJPh5044YonkeOJEaZucjKoBdsBcnzOFAz5A
eWo1Nt2WC4wu1aj0VLVzVsEIgIlEsvU5cpOWGX8aTACg/p7nB5N07Wt+4rVWo9uoZbhLSSQ
U9TUQqzRMVbieWCQAxz28NULdZrVaOp6stlHQ9XHU9GgWPnjOM8QM4yf7nXFTWm6w7mqLrL
cqN6eoiSFqdaJlcIhkZPf6pHLMpyeODjsBqsIYlnecRIJXVUaQKOTKCSAT8QCzYH7nz1kLj
SVtfut6OkEywvXU01ZJU0DnEcISVejPyCFOaqvDBYNJK3hnWz14rvrddos29LglVb3qrpT3
CknjnkQP0qeOKOVYo2Lfhlpc8iB+l2OGOBqvRXvat5/jbPG9rmevjiNHE0lPEY+vC0jPKTk
nkFjQIw74yCB216npppppppppppr//Z
</binary><binary id="_37.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAGAAcBAREA/8QAFA
ABAAAAAAAAAAAAAAAAAAAABf/EAB0QAAICAwADAAAAAAAAAAAAAAEEAwUCERIABjH/2gAIA
QEAAD8Afo/WaBy8rXpKOuMNsi27guVI+I8OlRCOdaGQjIJ+jvOTR0fP/9k=
</binary><binary id="_195.jpg" content-type="image/jpeg">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
AAAf/2Q==
</binary><binary id="_33.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAPAI0BAREA/8QAGQ
AAAgMBAAAAAAAAAAAAAAAAAwUCBAYA/8QALxAAAgICAQQBAwIEBwAAAAAAAQIDBAUREgAGE
yEUIjEyB0EjJFFiFTNDUmGBkf/aAAgBAQAAPwDWCvBa7Zi7hyXddzE28pwtVp5L5jhqlgHj
hERYRyKqjRDDb/UfW/Te0q9x5+KpHkbMePqVI7h+DZMYuGYyKm5EIbiojY6DaYuCfx9oslg
LOOt2ufcmRs1zZx6Va/8AiUyS1o5bXGRX4sC6sGIV222gRv6dlz8Obt/ufGfEtXJqGT51Zo
LV2SfxyqjSpInk5H8UkVhyA9qdeuoY7MRUsBSztitZuX880ZjhroHlbmC8cIJIULHGW2SVX
6Xc6LHb3E5NMvjxbSCav/FkiaKbjzRo3aNgeJI/JT9ies/lszPjO+GnarckxlLEGW9LFYBj
j5yEq7RMw/FYZSWQMxDa16HTPEfyWcyuJT3CvC9F/Z52k5p/U/xI3fZP+poABR0a53BSo2n
rTQZFnTWzDjLMqexv0yIVP3/Y9WqGQhyUDTQJZRVbiRYrSQNvQP4yKpI9/fWv/Osy9Wrla2
UzWYz17HVjPLUh8WRarFTWKRoeQKlVZmcFtuD91XRA9mllbNphMTDnXnimgezayNCURm2ID
GjIGT8AzyAkqdgIV/fY5O2ZK/cZiOfvSYuzUkIx8uQm8ySB4duknLmV0oB230ljr05HSmKp
Zpfp9ju6aeQyL36tGG/YWfJTPHaURhpkZXLqOSltEKNNxII10zFxzh+5O5L0Hk+N8uGrHHY
ZHSCHaMocAGNnkidiV9+09ngumHal20+Kr4zKQ2YMrRqQfKWw6u0m1K+TmrMCGZH+55etkD
Y3O93GamYXFwYbI3ZmiaQNCIkQheHLRkdN68iexsfVre1YDJd7d2v+nHcT5BMd86vnIlJj+
YycJofpZ+JVgOSNEPWv8v31pE7KqQwWaNXI3q2KtM5lxkZi8HFx9aLtC6K3v0rDRY8ddX8r
g0ydqpcjvXKFunzEc9V1BKuAGRldWVlPFT7HoqCNdU7faS3IVV81kVmMscs1gCAyTGNw8QO
4yAqMuwqhRssSCWJJqfbMMOYTLXb9zKXIYjFXkt+PVcH8iioiqGb0C2t6AG9eulmMwpajV7
emydyvcwEolrWIREWaBhLHCTyQqf4ZZDtQeSE/YhmNR7Zs9t4eni8FfuMi3onYzeEqkI15E
ICDSsqn8RyMj8ifbHq1f7Rx+Sys921NZlitLCtmk7K8E3iYtHsMCQAx3xUhSfuDs7nhP57J
ZPMn0JZfhRL/AGV3kUlh/uMrTfY648PQO+jXO2cBkLT2ruDx1qxJrnLNUjd20NDZI2fQA/6
6tUMZj8VA0GOo1qUTNzMdeJY1LaA3pQPegPf/AB0sPa0cORt3cXlL2KN1hJYhq+ExSSfvJx
kjbixGtldb0Cdn30a523SsYqjj4JbNFca0bU5a0ungKLxGi2ww4kqQwIIJ310eBdEkd8xel
uuvjS86wmWFNglUXx8ACR7PHZ9bP0rxXx9j1jRpY27lsjfxlLx8KNjwiJwg0gfhGrOo0Dok
gkDYPUBh4pEzHamQs2fjZRp7dVonCMInKmVQyge1lkJ0wIKyKNsOQFp8FZx/CXF2Jnv270M
l+7KsPKeJPTLJ9IHHxgqoRQQxU+tu3TNMTVXOS5nhu3JWStyIH0orM2gdbGy/v3o8V/p1ku
4+zqX6hZ2ymSt3IamH414o67Ip8zqJJGJKttSjwge/urev3P8A/9k=
</binary><binary id="_61.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAiAE4BAREA/8QAGg
ABAAMBAQEAAAAAAAAAAAAAAAQFBgMHAv/EADEQAAIBAwMBBwMCBwEAAAAAAAECAwQFEQASI
QYTFBYiVpTSIzFBUWEVMjM2QnWBs//aAAgBAQAAPwD2bTTTWf6wpI5qKhqWaYPBcqLYEmdU
O6qhB3KDtf8AbcDj8Y1oNNNNNUvjPpX1LaPfRfLTxn0r6ltHvovlp4z6V9S2j30Xy08Z9K+
pbR76L5ar7td+iL2kSV3UtCViYOqw3nsRuBDAnZIMkFQQTnBHGNTYerek4II4U6ntZWNQoL
3FHYgDHLMxJP7k5Ovvxn0r6ltHvovlp4z6V9S2j30Xy08Z9K+pbR76L5aeM+lfUto99F8td
qG8SVl8r7ZJb5qXucUUiySuh7YO0ihlCk4X6XGSDzyBjmb3jNd3ZGhbZFvlHafUTJwnlx/K
cPySOV4B5xmajrOqpo7zWvRW42yzVLQVE4uR3ttVWIVey2l/OF2Fh58rn861uotwr4rbTJP
MrsrzwwAIATukkWNTz+MuM/tnUrVXZbxJdmr1mt81A9FUiAxTOjOfpRyZOwlR/U+wJ+3/AA
SoZpZbjUoJaZ6aFUQKjEypLyzh/wAAbWiIH35P4I1nKHrOqno6S41VFbo6Crru5RSU9yMry
P2piBRTEodSw3cNnYC2DjGtbrP0b3DxnW1EllrIqSemhp0qWkgKZiedi2BIW2t2i48uf1A1
YUNXNPbpq/s3nEjPJTxRSxuHjHEZjYYGHVQ43HgvgnA488g6WvqWu13VrDMt6XqA19xplq0
eJ0ZnLPHG8pjDbWVQeHBX7/5a2dBXo3Xt4t/8U7YrQ0si0hlU9gd0ofCjkcGMknJ86842gc
OrLPcKyBZKa73FVauoyKWGKBkjAnjy4zEW8uC/JI458vGr2gpJqOBo57jU17FtwkqFjDAYH
H00UY4/TPP31TWSpq6auvdVc7VU2ylqJ+9ioqpoNiIsEUZDbJGwcxsf0wPv+NKE3Sj6NmuF
Jb3nvFar1gppQFYSynckchZlyIwVQkkHbHgAcLrMWPpK42St6MqqWz1KLSQTxXSKWqSXsHd
VG9A8hVAX3MTFglcgjnbq9sTzy9cXUUtx7xQwRFamPv4mXt2kJTZEWdotqhkbJUMQMIAutb
rnDDFTQRwQRJFFEoSONFCqigYAAH2AH4100001S9Z/2Pfv9bUf+bautNNf/9k=
</binary><binary id="_208.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCADLAZUBAREA/8QAGw
ABAQEBAQEBAQAAAAAAAAAAAAUGBAMHAgj/xABEEAABAwMDAAUHCQcEAgIDAAABAgMEAAURB
hIhExQxQXUHFRYiNZW0NlFUVVaUs9LTIzJhgZGT1BckM6RCcSXBJrHx/9oACAEBAAA/ANtp
PSem5OjrK+/p61uuu29hbji4TalLUW0kkkjkk99VvQzSv2atH3Fr8tPQzSv2atH3Fr8tPQz
Sv2atH3Fr8tPQzSv2atH3Fr8tfjRzLUawrYYaQ001cJyG20JCUoSJToAAHYAO6rtKUpSslp
mwRbhpW0zZUy7uSJMFl11fniWNylIBJwHMDk91U/RS3fSbv75l/q09FLd9Ju/vmX+rT0Ut3
0m7++Zf6tPRS3fSbv75l/q1xSrWzaL3YlxJVx/bzltOpeuUh5C09WfVgpWsj95KT2d1aelY
+76ku90vfo/pFpBU2pSLhdnWitiEQOUJ7At0bgdvIBwCP3tv49AJ8v8Ab3PXOo3Jav8AkVC
kpitHuG1pIITxjPPJye+vCZbNZaSirmWe8Pajhx8E2y4NhUhSM5WUvp9Za+3AIxg4AJAB02
ntQ23VFnaulre6RlzhSTwtpXehQ7lDP/6IyCDVSlZh6zWq764uHnO2Q53RW2J0fWWEubMuS
c43A4zgf0FdvoZpX7NWj7i1+WnoZpX7NWj7i1+WnoZpX7NWj7i1+WnoZpX7NWj7i1+Wpl/0
zYLfCiyoVjt0WQ3coOx1mI2hacymgcEDI4JH861tKUpSoWpWzJlWOGX5LTUm4KQ71eQtlS0
iM+oDcgg43JScZ7q/fopbvpN398y/1aeilu+k3f3zL/Vp6KW76Td/fMv9WnopbvpN398y/w
BWnopbvpN398y/1a/GmmzGlXyGH5LrUa4JQ11iQt5SEmMwojcsk43KUcZ76u1Pv17hacskm
73BSxGjJClbE7lKJIAAHzkkDnjnkgc1mGYWsNYMNv3OYvS9tdSFCFBVmaoEf+bqh+zIIBwk
ZwopVgivT/Tx9n9rF1vqlMhHrNKfnB1sKHYVIKcLTntSe0cV4I1LedHXiPbdYyGZdsl4RFv
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
0lfRoRhILxAwkAdqj/WvqdKUpSlKUpSv/2Q==
</binary><binary id="_34.jpg" content-type="image/jpeg">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
k=
</binary><binary id="_110.jpg" content-type="image/jpeg">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
5WkRERERERERERERERERERERERF/9k=
</binary><binary id="_174.jpg" content-type="image/jpeg">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
xSMbEhQqv9oCFu0a2fkP8zf6jv//Z
</binary><binary id="_53.jpg" content-type="image/jpeg">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
</binary><binary id="_36.jpg" content-type="image/jpeg">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
aJWZF2b6dqhnOd2dpDDHGfUDWgaNGjRr//2Q==
</binary><binary id="_70.jpg" content-type="image/jpeg">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
RM/bdMMHckYYA+TD/Ov/2Q==
</binary><binary id="_125.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAOAHkBAREA/8QAGQ
ABAAMBAQAAAAAAAAAAAAAABgADBQIE/8QAMRAAAgEDAwQCAAENAQAAAAAAAQIDBAURABIhB
hMxQRQiMhUWJDNCQ1FVYXGRlcHU/9oACAEBAAA/AGdw6ueHqu5Wn85LFbIqKKBgK+nbeWcM
SuTMgbACtkD94B5HKOw1VwrbJTVF0pUpqx1PcjTdtOCQGAYBlDDDbWG5c4PIOvZDNFUwRzw
SpLFKoeORGDK6kZBBHkEe9WarmmipoJJ55UiiiUvJI7BVRQMkknwAPejPU1ztfUHRN9gtVc
lzk+Iydu2ymZ97AhAREScFhyPBGc8Z0f6mtlXXS3eutVDXHqKqaJrPVGKVO1T9lFdQ7AJCf
tU5VirbiDjdsOkfSVDR0FVXRWagmobOYoO3HLTSQkzgMsh2yAOfosGT4Jyclt2tqW49q+Ut
s7WfkU00/c3fh7bRLjGOc93znjb/AF4l2qaqlt5eig71Q8scSAoWCb3VC5A5KqGLEZGQp5H
kZ9rvksVJcz1DPQ0zWyr+PLVI5ihdSqOjYc/QkSqCCx5BwTkaz+q6i09Q9KyNR/DvSCUxxp
HG9VF3CjD7mFHdNobdldrZ2jcN3KO2UstDaqSjnqnq5aeBI5Kh87pWVQC5yTySM+T51xQ3H
5tZcqftbPgVIg3bs78xRyZ8cfrMY58Z968vUFyuFsipJaOnppIpKuCCd5ZWDIsk0ceVUL9j
hz5ZccH7eNa+hlFausYo7tFVQWKf8rVxmeSaaSVIoSqR9sxCJRJiNMcsuffvKyipvh0MFL3
5p+xEsfdnfdJJgY3MfbHGSf467hMrQRmdESUqDIiOWVWxyASBkZ94H9hqzVFY9UlK7UUMM1
QMbI5pTEh55ywViOM+j/3WT0ZZ6jp/pejtFTT00LUi7P0ed5VkJ5Z8sqkFmLHbyB6Pobupo
fU9NUA6xtsIqLpte31bEm7VRbIkpwMN3MgfY5AODxnwMJpUqKS3CO3xJUSxKqxpVVLqGAwP
tJh2zj2QST5850cnsl7PSFwstLRW6D5cUsKRvcJpdndDl5WlaMs7Fn/CVHgnccgBBZ6Z6Kz
0tI9LDS/HiESwwztMiKvCgOyqT9QPI/z51dWUkddSvTTNMqPjJhmeJ+DnhkIYePR0ZsHT9E
l7vcgnuJNNco9gNzqSDimgb7Avh+T+1njA8ADWn1NSXWvo6entkFHJtqYZ5GqalosdqVJAB
tjbOdhGeMcHnU+V1V/JrR/tZf8Az6//2Q==
</binary><binary id="_38.jpg" content-type="image/jpeg">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
HHP/Z
</binary><binary id="_55.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAhAFIBAREA/8QAGQ
AAAwEBAQAAAAAAAAAAAAAABAUGAAID/8QANRAAAgICAAUDAgMECwAAAAAAAQIDBAURAAYSE
yEUIjFBYRUyUQcWIzMlNlRWdYGUlbPS0//aAAgBAQAAPwC5XnWc7dsfTREy8eMkVsgDIGft
a6QqFWde43Wgb2mNtM3zxQY/KwZKa9FAkymjZNaTuxlNsEV9qD5K6caP1+RsaJCyeS/Csfd
y8dL1dhpY60ESRdiSQ9YjRGdz5XuuxDeB0vsA/LIsPllrZvOZi/DWSSfIVMQY8aDOvcAGnk
l0uzufpJKr09sL5Ogbfjcec0jRQSSJC8zIpYRoQGcgfA6iBs/cgffiZxvOMt+fDg1aIiyk9
iBXhvmRuqEy7dB2x1xkRL7tj+YPH6mzc0xHlmTNUqNmwe+a0NZwIXkl73YVT1fkBfXz5A+R
vxwixuYkqZXmDNz4+GxYezFjzUxDpK7tDC0rN1OUMr6kZSoXqHbA0dEizpXIMhRgu1ZO5Xs
xLLE+iOpWGwdHyPB+vEzYyH7P7dWOrPm8Q8MdmS0qHJLoyOXL79/uVu44KnakMRrXjjxr8w
Yqg2dswc48uT2L8pnqo86xpE4iWNQ5EhLLqNNkAH836gAmTLciS4SHDHP4taUCxLEiZRUZB
GVKacOGBBVTve/HCmwnJsNN48JzZiKc01mCeWW3kDb6+1KZgNNMCNyEkkHz1N9TsXNO7VyF
VLVKzDaryb6JYZA6No6OiPB8gj/LhZ+9eO/s2X/2a3/5cM/WQCj62STs1xF3WecGLoXWyWD
aK6HzvWvrxMjIfs/H4b/TeIIxcXaqKckpVFHRoEdem0Y0I6t6KgjyN8C0b3Kwwc2Ly/N2Fu
LLbe111rgrFWabvDREpYESEkEMPAA+hJGtR8kLi7tLF8z4iv8AiGlttbykljup1OxXfqFZd
tIxOm0eptg74o4ebOUK0EcEHMOFiiiUJHGl2JVRQNAAA+AB9ODTzBhVnSA5eiJXnausZsp1
NKCAYwN+WBZdr8+R+vDDhel2IXclO+RQVaSpHNG6BFruFMjuXPyCkkf2HT9zoLCcwLm83lI
qdmtcxtVYBDYroenuMGLp3NlXIAQ+3WuvR8jh7wl/czlX+7WI/wBDF/14bQwxVoI4IIkiii
UJHGihVRQNAAD4AH04R2OZoJOZ8diMZep23eWZb8EQMskCohPUzK2o9OFUhh5L+NaPDmzdq
0+16qzDB35RDF3ZAvcc/Crv5Y68AeeOKGTx+VgafHXq12JW6DJXlWRQ2gdbUnzojx9+CuI+
XlPKR44V6NqtE0uZW7KpULEkEehAiqqDwgirkr7S3Qw6xvfHGOrVsXzVnM8R6KhVrP6lvST
RNZbraRpX9io/QAyqUDsQxLMdjgmTl+7c5Fhx8tas92aeK7arWX/gmQ2FsTRkgN7dl1HhvG
t7+eE2TwmWGGzBz1Kjfa/bM9eBI5rS9xo2jAftwdaKkYj0yAMWQ7cdehc4yrLRxVSnPae3L
XgSOSw++qVlUAudk+SRv5PzwVxuILDctZ3EPj/WxUYcZjsW1KVKE8rSsGHVLIipErdx3SI+
G2NNrbNsG4nCy5TlLlNGR6jUFr+rWaAxzdMShjGOtdgGaKIn42E8H42Fm8Fbjw2aOWhrZNr
2QeatAass6+YzGhftRF0CxhPyAN1J/M9+hZ4yrLRxVSnPae3LXgSOSw++qVlUAudk+SRv5P
zwVwl5z/qPnv8ADbH/ABtw643G43G43G43G4//2Q==
</binary><binary id="_197.jpg" content-type="image/jpeg">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
mFOJrdDUa2duzYqWtKY7hnyb68npftOk5SNkBPMudIBy0Wua7WtKCODKz4CtLWiyOVqMlve
HDBknQyzbnPozzOXtcYvDBG+Tth7DxdoEVsji+o5MjK+1icpdnOGgrG9jMqymH2mcy5waHt
20mTsXNPEtOmEFdzjI7sWKqR5GZk11kDG2JGDTXyBo5Edh2J37h/wClk2MBD96WbLa0wrMi
NiOtTbHB4tp7ZWSSCRrmvMpY4N24taOQOye7Of6PxvVdTqBs+erZF9SaJ7q7XZTxGY8+JLq
J48T9PtjmkSEEj2R7tt7m5Sq5Cq+rdrQ2q8mucU0Yex2jsbB7HuAf+F886we7pTpehmZszZ
ZmI7cN2zC+wIH5Ijw2SRmON3DQaGDsHgBnv5Fx034axi8J09i5bV7J5oZCCy+d1x8jmFpHp
D9uIIiEZezWtfpGgguds9usXpT9UT/1K/8A3cq2kREREREREREREREREREREREREWL1X+qI
P6lQ/u4ltIiIiIiIsXpT9UT/ANSv/wB3KtpERERERERERERERERERERERERFi9WB/wByNey
Gabwr1OVzYYnSP4ssxucQ1oJOmgnsPcnrXjv3bL/k1v8AxJ614792y/5Nb/xJ614792y/5N
b/AMSeteO/dsv+TW/8SeteO/dsv+TW/wDEq1Xr7p69PYgpy3rEtV3CeOLF2nuidsjTgI/ZO
wex/YVZ9a8d+7Zf8mt/4k9a8d+7Zf8AJrf+JPWvHfu2X/Jrf+JPWvHfu2X/ACa3/iT1rx37
tl/ya3/iTpMP+5HPfDND4t65K1s0To38X2ZXNJa4AjbSD3HvW0iIiIiIiIiIiIiIiIiIiIi
IiIiIiIoLtyDH0bF21J4detE6WV+ieLWjZOh3PYe5fI/sfly9frLLR5AMlGWqMyEllrCA+Q
iOTQOgN8bXtADsSNdvP7GiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIixcF+t+o/6kz+0rraR
ERERERERERERERERERERERERERERERERYuC/W/Uf9SZ/aV1tIiIiIiIiIiIiIiIiIiIiIiI
iIiIiIiIiIsXBfrfqP8AqTP7SutpERERERERERERERERERERERERERERERERFi4L9b9R/wB
SZ/aV1tIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiLl
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
Y9tIAJcOXL66iIiIiIiIiIiIiIi//2Q==
</binary><binary id="_71.jpg" content-type="image/jpeg">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
</binary><binary id="_39.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAfAaMBAREA/8QAGg
AAAgMBAQAAAAAAAAAAAAAAAAUDBAYCB//EADsQAAICAgEEAQMBBQUGBwEAAAECAwQFERIAB
hMhMRQiQRUHIzJRYSQzcYGRJTVCUnW0FyY0NkVjs8H/2gAIAQEAAD8A9WzWZr4OklidHlaa
eOvDBGyB5pHYKqryZQT738/AJ/HS/EZ+S33Fex8sczwySyvRn0gjKQ+KKVPnlyExf+JdEfB
I11oOjo6Rd4wxWcCkE8SSxS5CikkbqGV1NqIEEH5BH46cwwxVoI4IIkiiiUJHGihVRQNAAD
4AH464u3IMfRsXbUnjr1omllfRPFVGydD2fQ/HUOJjnWis1tZo7VnU00Uswk8LEDcakaXiv
pRoDetnZJJu9HVXJ34sVireRnV2iqQPPIqAFiqqWIG9e9DrLYqfJZPvO3ds0MdUv47EJEas
VnyuWncuEllCjjx8I+0K2vIWBO9dMO3cpkO8e12t3KL4aLIQMIGgtMZ1VuS8/ca8TrTKRy2
CD/jf7euT28PEl2Tnfq/2e6dBdzJ6ZtDWlb06+htXU6G+mnR0dKO5MjLRx0cNRnS7kJ0p1X
SIyGN3+ZNaIIRQ8hB0CEI2N9M4YlggjhQuVjUKC7l2IA17ZiST/UnZ6k6Ojo6Ojpfnco2Gx
Et2Oo9uUMkUNdHCmWR3VEXkfSgsw2fwNn38dZWlk7VRu8e5zUx0linwgkrVZzwf6eLyOWm4
bZ9SldcBrxhT/MOm/XO4O0JH8f6Hk54lmqiOdmaJgFdBJyjGvuHF14n1se99NsbfiymOguw
q6LMuzHIAHjb4ZGA3plIKkfggj8dWujo6S5647WsfhK8k0c2SlbnJEG3FBGOUp5D+Hf2xg7
BBlBB2OnXR0dHR0dHR1ku8+5p8ZVydWvjKdmKtjTZtS35wkIDlkjj46JkZijjj9oOgOW267
u3ch2bhu3cTQx6ZZpGhxvMzNCQwj9SEBH+3SMW/5QPz71dzEl2m+LzMs7wRVWKZGvFJziMc
gALElRsRuEbmeOkEh/OunvR0dHWf77pVbnY+Z+qrQz+CjPNF5Yw3jcRtpl38MN+iPfWg6Oj
rOZyS7L3p2xTghR6yNauWHJ0yBIvEuvfwTPojRPx+AenNXGY+jPYnp0a1eW03OeSKJUaVtk
7Ygfcdk+z/ADPWZ7ufKX+5MLgakd6KlOs09uzSsiCVVVRGpVuYJCtKrMCDv7dBtEdaa/kIc
bAs06WXVm4gV60k7b0T/DGrED1861/r1Vp9wUr1pK0MGRV33ozYyzEnob9s6BR8fk9Q91/7
og/6lQ/7uLpf33cykcGJx+MqWZjkMhHHO1ecQuIkBldUfmhVmWNgDvWgw2CRthlP9k9uV6p
/tyGWrSkN396Zkkljicv8cmKsT/In5H46tZjMRYaCB3rWbUtmdYIK9ZAzyuQTobIAAVWYli
AAp99GPzNe9iHyciPSiiaZZhaZFMRidkfkQxXQKH3vWuksPfGCPcd2F+5MX9ElSu0JNuIL5
C8wfTb9nSx7G/Xr+ft7mDjf0e0mYmhhoSxGKw00vjTi/wBpBbY1vevn89ZWH/w8gnmsR9yV
hPOpWSY9wyFyCU3pjLsE+KMEggkKB8eum/b2Q7UqRxYfB5unPv8Aua4yX1DgBfhQzsQoVfg
eho+vnqDCVrVXv/ujzT8q9qKlZhjDkhNo8TEj4DEw/j5AX/ASdzd14zExLXGbo1rqW6qywv
YjDrG00fPak7A8bMd69D3/AF6c0Mnj8rA0+OvVrsStwMleVZFDaB1tSfeiPX9eszefKZT9p
EOP8d6vi8dUSdpq1kRh5Xk5KXUP98ZELx6Kk7ZvWiGDDLRT2u9e3oVs+OvWit3Hi4A+VlVI
l9/I0LDH/wDnwR3nO66+EnmhOPvXWrVGu2TVROMEIJAZmdlGzxfSgknifXTa5dq4+q9q7Zh
q149c5ZpAiLs6GyfQ9kD/AD6z+H7yw93K5Kq/cGOl/tyRUkFmPbqYYjpdHbbkZx+fex+NdM
8rnExlqpTjo3L9u5zMcFVFJCoAWdmdlVVHJR7PssAN9ZzGd0NgO0cDZyFO9cbMz6rCKcTtG
ZnZ4YmeVlYkIwXkfX2HZHretlyFepjheyEiY+IKrSG1IiiInQ0zbK72deiRv4J6RYfvLD3c
rkqr9wY6X+3JFSQWY9uphiOl0dtuRnH597H410z7gbDfpfjztyGrUklTTy2vp/vVg68XDKQ
wKbGjv11mVh/ZutW1WGfp+K5/6gHPyEyjbkgny7KkyyEj4JYkgnrR4TK4GdBj8Rmq19olL8
Fv/Uyhd+ySWZiNkDZPrYH8ul/Zda1Sm7jq2p/Lwzc8kQDllRJUjlCjfx/ebIHrZPz89GY7y
w9LK42qncGOi/tzxXUNmPaKIZTptna6kVB+Peh+ddaCndq5CqlqlZhtV5N8JYZA6No6OiPR
9gj/AC6y2LfKZb9oWWntR3q1HFtHBVEdkCGRvGS4kjDnkWEyOp4+gi7IIILBIp7H7RZZms/
2ejiEVIOA9tPMxZuXz8V1Gvf+XvfdvuuvVyslFcfenWCeCvYtRoghhkmZQikswLH70J4htB
hvphkczisR4/1PJ06Pl34/qZ1j561vXIjetj/UdLO0O5aWdweOH6tTt5NqMUtqKKZDIrcV5
lkX+H7jo+honXVLvOK0kNi2uXmpy+KGHDxwWTGz3S76Vl/hkV/3S6fYADn7Rs9cd356Welk
sLi6l5rQaCqb0cprw1Z5mUR7kBDkjmjEIrDTAHWz0zl7pjj7tHbSYu9LaMC2fKnh8QhLBS+
zIDoMdEa36OgfXTDI5nFYjx/qeTp0fLvx/UzrHz1reuRG9bH+o6Wdody0s7g8cP1anbybUY
pbUUUyGRW4rzLIv8P3HR9DROuqufXsufKv+s5itWuosSyR/q7VmARjJHyRZF9gtyBI2N7HV
aab9n08dKM9x040x8SxVVhzzxCIKpUEBZR93FiOXyQdE9PMokXcvaWQgxVutOt+pNBDOkga
Isysm+S79A/Ot/B647Zu/wDkfE3r1n/42GaexPJ/9YLMzH/MknpfD3xgj3HdhfuTF/RJUrt
CTbiC+QvMH02/Z0sexv16/n70c9yCtNWhmk4valMUI0TyYIz69fH2ox9/y6EuQPelpLJuxD
Ekrpo+lcsFO/j2Ub/T/DpN3Xcgs9m9zwwycnq0bEUw0RxYwc9e/n7XU+v59M8vlYMLi5shZ
SaRIuIEcEZeSRmYKqKo+WZiAP6n8dZyrnLVWz3RnrePvRVKKwxtRayskqskfkkkC8/GgKSx
+lb3wJ/iOumFLui1kKMF2r2tl5K9mJZYn8lQclYbB0Z9j0fz0sF3FQftHy2ZyFn6BMfRr4x
Z7UixQyu5adgrH5YL4/WwRs+vg9bPpFjqd2z3PbzF+o9YRQfRVEaxzBUSuzyBVOgHUQfI5A
oR8AFmd/GY/KwLBkaNa7ErcxHYiWRQ2iN6YH3on3/XqrT7ZwGPtJapYPHVbEe+EsNSNHXY0
dEDY9Ej/PqHuv8A3RB/1Kh/3cXXElO7kO7q9mzUeGlillNdzY2tiSRIwHCKflR50PIf8QI3
s8e+7/3fbFu38/QcL3H/AJ/A6zcN/jl4+O/et70da6tZbEjKiqRds0pak/nimrhCwbg6Ead
WBHF2/HUHbXbtftfFDG1LNmeBW5J5yn2DiBoBVUAetn1sszEkkk9Wosd4s5ayfl39RWhg8f
H+HxtK297978vxr1x/r6u9ZzuXMZrGJes4+tWNbGVFuTfUo+rS7fnGjg6RlWPeyH2XXYA9n
R9IsUZbPd2etFESKBa1FdOSzsiNMWI16GrKgez/AAn46YZXHfqdOOv5fFwswT8uPLfilSTX
z+eGt/je/fV3pF25TumzkMzk6j1LmRaIfTvY8pgjSMAJsErryGVhx+Q4J0dgQ5mS7W747am
hhRqthbdOeRj7Qsiyrob+SYD70RoH+Y67z3Z9bP2JZZ8hcgSeKGOaCJYWjlEUjSJyEkbfDM
dj4I9EHpzSrfR0YKvnmn8ESx+Wd+Ukmhrkx/LHWyf59Q0cd9FcyVjy8/r7In48dcNRRx6+f
f8Ad736+dfjql3B2zD3Bx8l+5U/s01V/pvH+8il4c1PNG/5F9jR+eqw7P4QY+GHuDKRLjmZ
4OK1/TEON6MRAAWRkCjShQoAGt9aPqlRx30VzJWPLz+vsifjx1w1FHHr59/3e9+vnX46u9Z
zJZjNVMiZo61YY2HIV6UiTI4lmWXxjyxvvjoPKF48Tvg33A+ho+kXbBlnfNX5ESNbeUmEaq
5YhYgtfZ9DRJgLa96BHvphex31tzG2PLw+gsmfjx3z3FJHr59f3m9+/jX56muyzwUbE1Wt9
VYjiZooOYTysBsLyPobPrZ+N9L+3MdLQpWZbKutq/bmtzB5S7Lyb7FJ2QCsYjTSniOPon5N
MSXYP2mPGYU+iu4ZWEhP3GSGY7A9+hqwN7Hv1o+j1Hl+x62YuTWJMtka4lsrb8UHh4xzCIR
B1LRlgwUDR36PsaIBGn6pYbHfpGDoYzy+b6OtHB5OPHnwULvWzrevjfXF/G27k6yQZy9QUL
xMddICpOz7/eRsd+/569fHSXI9g1MjKzHMZSCMzpYWNHibhKsIhEgd42flwA+4sSG+4aOj0
zr4F4M/NlzmL0jTKI3rusPiKKXKL6jDaUyMQeWz62T036pYbHfpGDoYzy+b6OtHB5OPHnwU
LvWzrevjfXeTtS0cVbuQVXty14HkjrpvlKyqSEGgfZI18H56X4e9lTmMhissacr1ooZ4bFV
GjDpJzXTIzNpg0TewxBBHx76u5nI/pGDv5Pxeb6OtJP4+XHnwUtrejrevnXXHb9CXFduYzH
TsjS1KkUEjISVLKgUkb162Ou4sd4s5ayfl39RWhg8fH+HxtK297978vxr1x/r6u9HSXvP/A
Nj57/ptj/8ANuruWxiZfHmo881f97HKssPHmjRusikcgR/Eo+QekUfYcEWOydFM5lBHlWZr
RH04L8+fP14tAt5Pba5aVACAoHWjpwSVqqQzW5rbrvc0wQO3vfvgqr6+PQHx1nL/AGBRyME
az5K8ZwtlZbWoDLMJwA/ImMgHioQFQpCjiPXWmhjaKCON5nmZFCmRwAzkD5PEAbP9AB/TqT
o6OlHc1e1Zw6inWe1LFbqz+FGVWdY7EbsAWIG+Kn5I6ZwyNLBHI8Lws6hjG5BZCR8HiSNj+
hI/r1J1SxNN8dRWh44Ur1dRVREWP7kABA3LZDAfafZ3x5et8Rd6OjpLnqmRvSV44MbTt14Z
Y7AM2SlrHyo212qRsGUEKdE63+PQPTCaS7XxUkiQpduxQFhGh8KzyBfgcieAJ/mTrfyeqvb
+FTA4v6XzfUWJZXntWTGqNYmdizuQo0PZ0B+AANnXTTo6Ol+doS5LESwV2RbKMk9cyEhPLG
6yRhte+PJF3r3revfXeIyP6pi4bbReGVuSTQ8uXilVisictDlxdWXY9HWx6PV3o6Ojo6Ojp
FlKeWt5evPBQolabFq1ma/MDGzJxZ2gVArkBmABf4J0V2dMMv8AXnFzJjPVuTjHHJ9v7nkw
Uyab03AEvx/4uOvz0YfE1cFh6uLpJxr1YhGmwAW18sdAAsTsk69kk9Xejo6UdxVbstSvdxs
CWL2On+pgryScFmPFkZC2vRKSPo/AbiT62OmFK5BkKMF2rJ5K9mJZYn0RyVhsHR9j0fz1P0
dHR0dHR1HMZVgkMCI8oUmNHcqrNr0CQDob/Oj/AIHpTg6WRqWrclmnTqJalaeURXZbTyykK
N8nVeChUACgEfGuPHTHcGJkzslLGzJ/szyixcJCMJfGylISrA/azfcSPxGV/wCLYddHR0dJ
e74rlntXI0qNCa7Yu1pa6JE8a8S6MAzF2UcQdb1s+/jp10dHX//Z
</binary><binary id="_146.jpg" content-type="image/jpeg">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
wDjKSeOCOH7ayqUpSpczU1gt8pcWbfLdFkN422npbaFpyMjIJyOBB/jXML0nTczlrtN6Tcr
W5bywH5UgXJvZD7YUEE+XwIO5wBwODwOFV0nxz0r95bR+Oa/NVZl5qSw2+w6h1p1IW24hQU
laSMggjpBHXX0pSlKUpSlRbF531H2kj4SPVqlKUpSlKUqLF9OLp2bD95Kq1Soti876j7SR8
JHq1SlKVFsXnfUfaSPhI9UI9yhS5suExIQuTCUlMhofWbKkhScj1EHgejpHSDjKqLoz0HsP
Zsf3aatUpSlKUpSoti876j7SR8JHq1SlKUpSlKVFi+nF07Nh+8lV8dYx7rJtsZu0sPOr5yC
9uXlNrSjYXxGy8zteVsjBXjjnBwKaHbvLOmGWb/GeYntuu7Ydkb7IKypOyvbWSkJUEjaOfJ
/cT9rF531H2kj4SPVqlKUqLYvO+o+0kfCR61/Ulvu0nU1wkR7Hd32XLa2xHkwLsiId8kuKH
DeDKfpR5SknBScJUDW4Wxua1aojdxeQ9NQwhMhxAwlbgSNojgOBOeofuqfoz0HsPZsf3aat
UpSlKUpSoti876j7SR8JHq1SlKUpSlKVr8ldwt+qpc1myzJ8eTBjtJXGcYGypC3yoEOOJPQ
4noz119vDtx+6d3/mxP16eHbj907v/ADYn69NPNTN/eJcuA9B55ODrTTy21L2Qwy3k7ClD6
yFddWqUpStcZeuVqvF5IsE6a1Llofaejuxwkp5uygjC3UkHaQrqrJ8O3H7p3f8AmxP16eHb
j907v/Nifr19tMw37fpW0wpTe7kRoLLTqMg7KkoAIyOB4jqqpSlKUpSlKi2LzvqPtJHwker
VKUpSlKUpSlKUpSlKUpSlKUpSlKUqLYvO+o+0kfCR6tUpSlKUpSla5IgIuusZrEmTOS0xb4
q224855hIUpyQFHDa05JCE8T6qyfFS3fabv3zL/Vp4qW77Td++Zf6tT7bY4cyddmHH7oEwp
aWGym8zMlJYacyfpenLh9XDFUPFS3fabv3zL/Vp4qW77Td++Zf6tNJlfgRSFvPPbqdMaSp5
1Ti9lEl1KQVKJJwkAcT1VapWpaZsEW4aVtM2VMu7kiTBZddX4YljaUpAJOA5gcT1VT8VLd9
pu/fMv9Wp+oLHDtWnLncWH7op2JEdfbSu8zCkqSgqAOHRwyKoeKlu+03fvmX+rXh7TVpjMO
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
8A+nT+kJ/hb/P/AOnXTNGeg9h7Nj+7TVqlf//Z
</binary><binary id="_204.jpg" content-type="image/jpeg">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
</binary><binary id="_40.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAdAVQBAREA/8QAGg
ABAQADAQEAAAAAAAAAAAAAAAUDBAYHAv/EAC8QAAICAgEEAAYBAwUBAQAAAAECAwQFEQAGE
hMhFBUiMTJBUQcjYSQzQnGRgRb/2gAIAQEAAD8A6bGZl4Ou85kYoobVG9kq+IXwqyzrNFES
5KiPTqC7kuzDSxnWwFB9A444444444444444444444444444444444444444445yVjIf0/t
1Y6s+bxDwx2ZLSockujI5cvv6/qVvI4KnakMRrXrm0a1duusjeeglq1UxdVq5CIZVJe0CEZ
tdpYevuB/J5mg6wxEyV5JJHqxTY+PINNYAjigjkIWMO5PaGYkgDZ/Bv8bpy5PHwY4ZGa9Wj
pFVcWXlURFW12nuJ1o7Gj+9jkLD9ZYe7lclVfqDHS/65IqSCzHt1MMR0ujttyM4/fvY/WuU
+prk+P6Vy12rJ47FajNLE+ge1lQkHR9H2P3xfz9XGXmr3I5ookoy3Ws6DRhIiocaB7u4d6n
8dEH0SfXNqjfivQROFeGWSCOdq0wCzRK4Og6/8TsMP+1P8ck9X9S0sFg8iPm1Opk1oyy1Yp
ZkEjN2t2FUb8vqGh6OyNcp47M4rL+T5Zk6d7xa8nw06ydm9632k63o/wDh5z6RWq3V+PRsv
NLfmltTW6i2S0XwW3ETeNvSMreBdqASS/5fUeUIersfIlQzQ2arWWshlmVdV1rllleV1JRV
DADfcdll/wA6pxZPHz445GG9WkpBWc2UlUxBV33HuB1oaOz+tHnPw9cYI9R3YX6kxfwSVK7
Qk24gvkLzB9Nv2dLHsb9ev599Vzn6efkgxC27sc1nyZeal3RBB4wbbwxlgSPpH0KdbP70fZ
5uUuocbetSVkm8Uosy1olm/tmy0QHkMQPt1UkqSB91P698z5HM4rEeP5nk6dHy78fxM6x9+
tb13Eb1sf8Ao5M6Q6lpZ3B44fNqdvJtRiltRRTIZFbtXvLIv4/UdH0NE65pZqK1Bnasvzea
O9ZyUS4+pFZISWqqp8QrxH6Doed+7XcPoAbfavKbdT1UmkgkqXFmXJLjliEYdndkWQOO0kB
PG3eSdEBTsb9crRzRSvIkcqO0LdkiqwJRtBtH+DpgdfwR/POczHWWHpZXG1U6gx0X+ueK6h
sx7RRDKdNs7XUioP170P3rlo5jG/J5cwl2GahFE8rWIW8idqb7iCu960ft/HM09yCtNWhmk
7XtSmKEaJ7mCM+vX2+lGPv+OHuQJeipNJqxNE8qJo+1QqGO/t6Lr/7/AN8jdX9S0sFg8iPm
1Opk1oyy1YpZkEjN2t2FUb8vqGh6OyNcp47M4rL+T5Zk6d7xa8nw06ydm9632k63o/8Ah5z
6RWq3V+PRsvNLfmltTW6i2S0XwW3ETeNvSMreBdqASS/5fUeU6XU9W7JQhFS5FYvS2IxC0Y
Yw+BisjOykqFDAKDs7Lrr96tc1b+Tx+KgWfI3q1KJm7BJYlWNS2idbYj3oH1/ji/k8fioFn
yN6tSiZuwSWJVjUtonW2I96B9f45G6Z6rxmWiauc3Rs3Xt2lihSxGXaNZpOzSg7I8aqd69j
3/nm/wBQXJ6OOimrSdjteqRE6B+l7EaMPf8AKsR/95hyHU9XGSZJLNS5uhFBIBHGJDY8zMk
axhSSWLqV0wHvX698tccxwzRWYI54JUlilUPHIjBldSNggj7gj985mbrjBDqOlCnUmL+Cep
YaYi3EV8geEJtt+jppNDfv3/Hq1kszXx2AnzSI92rDB8R/pWRi8etllJYAjt9/f2B636HPu
rlYLmUvY+FJi9DxiaQxkR9zr3dgY/dgvaTr7B1/+eE/12hii66rvHEiNNj43kZVALt3yLs/
ydKBv+AP456zlep7uM6qoY5lrNFbtpXWpGvktSRtGzfEDTjtjVwVIKnQRm37A4yqls/mq0m
Ms3VyGGihiiVHWKdlNktGZgO2MkOo2SPyGuT06eyj3Is7kIbmSlhvRSJTtfDecQxxSqn4ds
XeJZ3ffd+IX33DXOm6dpz0cNHBYj8R8srxw7B8EbSM0cfr0OxCq6UlR26BIAPM9HHfBXMlY
8vf8fZE/b267NRRx6+/v/b3v199frml1D0nh+pqssV+pD5pIvELYgjaaNd70rOra+5/62SN
H3zn8h0laVRhMWlyvUs1kr2b0PwiRywmWQyRvGEHYwR37WjQbaT6vx3y7SqTQ9bZW2MY8Na
1UrL8WDH2zSRmTewG799siAEr/wACPsF3QzOO+b4O/jPL4fjK0kHk7e7s71K71sb1v7b5u8
l/KLLXvPLncjJD5fIKv9lIx72F7kjD9oOvXd7A02wSDAwGEyEffcu1sjXr1caadPGGzAZIe
7RkWOWPRK6jiVGdw21YnWweVuksVNjcdZmtq6XMjbkt2EaGOIK7aXQWNnAHaqn8mJJJJ2Tq
hFjvFnLWT8u/iK0MHj7fx8bStve/e/L9teu3/Pr7v4zH5WBYMjRrXYlbvEdiJZFDaI3pgfe
iff8AnnJDouHpqohw1e9ble2JfJVWnDNWPbLt13GiOP7hTtfYUP8ASB2jmG5gc7Dh6OLhpv
ZyELR3DlNwNC1lrHnljkUlHWLyKjbjG9Aej26bveaWGx3yjB0MZ5fN8HWjg8nb29/YoXetn
W9fbfMFzEWblp5PnuRhrvoNVh8KprWiA/j8g379hwRv0R61Dq4fKvn/AIpa9mrToT2rMFOe
eEwz2HLqjq6K0gVhJKzB/wAS6hQQuubvSwzfzLPSZjDpj1sW0mgdLazLKBEkR1oAgf2g31A
H69a9crXsd8bcxtjy9nwFkz9vbvv3FJHr7+v9ze/f21++bvHHNLM475vg7+M8vh+MrSQeTt
7uzvUrvWxvW/tvm7yX8oste88udyMkPl8gq/2UjHvYXuSMP2g69d3sDTbBIPLUsF1CuOtXK
pvY2zTxZq4mjLJVlMEh0zIGCkNH/bhRWc92g5OiQeXcfB1KK96Fr/a6XiK0+RrRytJAI1G+
2BowNv3kE+9fcfx8Zypm5enJq7lL92VmRGp1FVERkKkvFLOFkGi3pmI2VPae3lnGUIsViqm
OgZ2iqQJBGzkFiqqFBOte9Dnxisd8spyV/L5e+zPP3dvbryyvJr7/AK79b/et+uTOoOicJ1
F/cs1YYbLSpI9qKtC0r9utKzSI219DY/YGvsSDM/8Azd1szDRrx3KeLgs1555A1bw3BDHH2
EKF743744lKqFTtjJGi2ubOJr9Vw5N47l6zNAYLQEtqOs0SuJgK5CxBHJMYLMCQPqA2D6FN
K2X8FlctLRylZoHU1K9AxNKSPx3JMykEbGjoe/ZA46Ur2qfSWJp3az1rNapHBLE7KxDIoUn
akgg62Pf2I3o+ubUuO8ucq5Py6+HrTQePt/LyNE2979a8X2177v8AHvB1FBJYw0iQ05rkol
idI4JUjkUrIrB1L/T3JrvAb0Suj6PIEOF6jqU4rEeTyPxNy9NYviIVDKY/CViX6k7A4EUCn
t+nuZzsjRHmX9TsL1PmcxipThsjctwYivFdkhpuyef6mcBlXtP5f8dj9frnbT9V3bn9TH6J
tIjSJkI7VW/H9BrxrEspjCfcllDoW7vYlb1r6eelccccccccccccccccccccccccccccccc
ccccccccccc//2Q==
</binary><binary id="_56.jpg" content-type="image/jpeg">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
VgykgEj1z6Hxxxxxxxxxxxxxxxxxxxxz/2Q==
</binary><binary id="_172.jpg" content-type="image/jpeg">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
</binary><binary id="_73.jpg" content-type="image/jpeg">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
2kWgARarpxF7trO8pRaABFvPoPPbtqO7ULQAAiwXO9x7yR4SnFoAEWd53tzeS/CVAtAACLZ
nQeB3bT92kTLYuaAj7RhKWtnI6lqG42m02nqttC05aSZZIzyWoyP/wAxT5Z2rtLEdea8wcs
7V2liOvNeYOWdq7SxHXmvMJMNdlttSk+ty4YtCXpBC21KrWyJaeLMJyWvWWUmWfqR/QVuWd
q7SxHXmvMHLO1dpYjrzXmDlnau0sR15rzCTM3ZbbspALbuGLWlmQWtxSa1syQniz6cnr1Fl
RFn6mX1Fblnau0sR15rzByztXaWI6815g5Z2rtLEdea8wcs7V2liOvNeYSbTuy26azoVh+4
Ytp1qPYQ42utbSpCibSRkZGeoyP5CtyztXaWI6815g5Z2rtLEdea8wcs7V2liOvNeYSam7L
bVeMa+VwxZtIj6tCnCrW9FKjcpzIjPOozJKsF/Y/oK3LO1dpYjrzXmDlnau0sR15rzByztX
aWI6815hJuy7LbqbOmmGLhi3XXY99DbaK1tSlqNtRERER6zM/kK3LO1dpYjrzXmDlnau0sR
15rzByztXaWI6815g5Z2rtLEdea8wkw12W21KT63Lhi0JekELbUqtbIlp4swnJa9ZZSZZ+p
H9BW5Z2rtLEdea8wcs7V2liOvNeYOWdq7SxHXmvMJMzdltuykAtu4YtaWZBa3FJrWzJCeLP
pyevUWVEWfqZfUVuWdq7SxHXmvMHLO1dpYjrzXmDlnau0sR15rzByztXaWI6815gszoPA7t
p+7SJkLOMQlm2cmpL3JFqkoyXk/cUpgzTqIjzlSST8saWc6hWn7gat8o9x9hbjVXVlTuLSZ
FwCTQtZuKz/AMKSRlR5LCcn8sHhdtw8l7dqJVNLxx1rGhTE5oKd+asHg/6UEpZ6j1IM/gRm
NpyXaRcdPCloKddpHapWHC0m0pW2ksp+ijWrB/8AYP4/LVgud7j3kjwlOLQAIs7zvbm8l+E
qBaAAEWzOg8Du2n7tItAAi1XTiL3bWd5Si0ACLefQee3bUd2oWgABFgud7j3kjwlOLQAIs7
zvbm8l+EqBaAAEWzOg8Du2n7tI5+mo2JC0bFoqpvhKepaQ06jJlpJVHvkZZLWWo/kPeg/5Q
zj0TKf570VGvUMnn3OH4wpGgstHUWm2yazIj93hEkRmZHifUu1tywEk24S6uqiYaqpHuDRp
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
</binary><binary id="_6.jpg" content-type="image/jpeg">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
jYfQ/Ls9WSX1P679CL39u3xrZ264cOHDn/9k=
</binary><binary id="_62.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCABHAJkBAREA/8QAGw
ABAAMBAQEBAAAAAAAAAAAAAAUGBwgEAgP/xAA6EAABAwMBBAYHCAEFAAAAAAABAAIDBAURB
hITFCEHFiIxQZUVVVZ1lNLUFzI1NlSBs9O0I0JSYaT/2gAIAQEAAD8A2ZEREVP0npPTdTo6
yzz6etcsstvgfJI+ijc57jG0kkkcyT4qW6maV9mrR8DF8qjNQaY07Q26Kam07aGPdXUkRPo
+E9l9RGxw5t8WuI/dSfUzSvs1aPgYvlTqZpX2atHwMXyqMv8ApmwW+ipaqisdupaiO5UOxL
DSRse3NVEDggZHIkfuraiIqrRafst1v2op7jaKGtlbcGMElRTMkcG8LTnGXA8sk8v+1IdTN
K+zVo+Bi+VOpmlfZq0fAxfKuTV1lxWqvU1o81l+nTitVeprR5rL9OnFaq9TWjzWX6dOK1V6
mtHmsv06rmuavV7LA2amtz4amGdr4PQ9fLNK5+DgPZw2HR88uDiAdkDOSAfFo6t6WJ56dt6
o6EUUjmyyVFa1rJhGS3LGtiIw7GSA9vI5ye4K4aM/I9h920/8bVmdwuvSB9sdNC9lxhoBXN
ZHDBG4076QPa1zyBlruy8FzjzaXD7uABpmq/wiD3lQf5cSk63iuBqOB3PF7p243+d3t47O1
jns5xnHPCxzo/uPSf1ol46hrqmmqWufO27byCFh5kFji07BycbLWkEHuwMtvWpanUhtcImt
NrY30hREFlzkcdriYtkYMA5E4BPgCTg4wZbitVeprR5rL9OnFaq9TWjzWX6dOK1V6mtHmsv
06zmquHSXFqappdPUFxcxlS+onFZIJaWTJb2IpJYonBg5tw13Mc2/8jdtCyXeWO9SX6Gmhu
T7g108dMSWMJpYMAZJ5gYzzIznBwvx15dbdbZ7WyrqaltTUufFTwNub6CAjLC+SWVpGAwDk
OZJfgNJORY7NPxNjoKjjOO3tNG/it1u9/loO3sf7c9+PDOFyAuzERERVLTN/pbfpW00VVR3
eOopqGGKVnoerOy5rACMiPB5jwXxU6loDrG2zCnumyy31bSDaaoOyZKcjDd3kjsnJAwOWe8
Z+9QX+lrrdFDTUd3e9tdSSkeh6sdllRG9x5x+DWk/spPrXbv0138mq/6k61279Nd/Jqv+pR
96vVPdaWmo6OkujpXXCjf27VUxtDW1MbnEudGAAGtJyT4K1IiKsUt0htF7vrKuluP+vXMli
dDbaiZj28NA3IcxhH3muHf4L29a7d+mu/k1X/UnWu3fprv5NV/1LmbqZqr2au/wMvyrrNER
ERQtV+eLX7trP5KVTSIiIiIiIiIiIip82qbJJrW3vbXsAibWW1201zSanfUg3YBHaOSOYyM
ZOcAlXBERERERERERERZTc9Oy1nT/AERke+qoxALo6IvLW07mtEQcBnmduKInHfyBBAWrIi
IiIiIiIiIip+k9J6bqdHWWefT1rlllt8D5JH0UbnPcY2kkkjmSfFS3UzSvs1aPgYvlUZf9M
2C30VLVUVjt1LUR3Kh2JYaSNj25qogcEDI5Ej91bUREREREREREULoz8j2H3bT/AMbVGSMt
9D0jxVcFurBNU00sVXVR0E72PkcaYRAyBpbshsbu47LcOzgk5k9V/hEHvKg/y4lNIiIiIiI
iIiIs40z0paLt+lbTRVV53dRTUMMUrOFmOy5rACMhmDzHgpT7XdCevf8AyT/IvFc+kbSd+Z
RWy2Xbf1c9yot3Hw8rdrFTE483NA7gfFaAiIiIiIi//9k=
</binary><binary id="_181.jpg" content-type="image/jpeg">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
</binary><binary id="_41.jpg" content-type="image/jpeg">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
</binary><binary id="_213.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCABoAbYBAREA/8QAGg
ABAQEBAQEBAAAAAAAAAAAAAAUEAwYCB//EADsQAAICAgIBAwIDBQUIAgMAAAECAwQFEQASI
QYTMRQiMkF1FSM2UbMWMzVCtAckNFJhcYGRJcFDYnL/2gAIAQEAAD8A/SaOSUnJ5u3YeOoJ
zUgi8nQidoyeg3uR5S4HXZZRENdvHNK+oce+LjyUYuS15JWiAiozvIGVmVg0YQuuirA7A8j
/AKjmZPWnp+WeCGK68rTrAwMVaV1QTkCLuwXUZbY0HIPkc256W7Xwlmzjw72a6idYkTs04Q
hjEBo+XAKbAJHbYBI5shmiswRzwSpLFKoeORGDK6kbBBHyCPz5J9Z/wPnv02x/TblDJ34sV
ireRnV2iqQPPIqAFiqqWIG9edDk9Ms+Lxte1nTMlm9KAtWCu05hYoW9pRErFuqoxLedkMfA
IUfcXqbGz4434VvSQCdoD0x1guHXfYdAnbQIIJ1oEEb3458P6uwqWqtU2ZjNcikkgRasrF/
bDGRfC/jXqQU/ED4I2QOfY9T4p8dUvxyWZYrql66xU5nlkQfLiMIX6+R92tfcvn7hvbjclS
zGOgyGPsJYq2F7RyJ8Ef8A0QfBB8ggg8n3Lvb1EkL2fpamLrfW23aTord+6ICfgoAkrNvWi
IyD4PPuj6mxuSSZ6q3nWBXZ2bHWEH2Hqyjsg7MCCOo22wfHjn3B6ixlijZuLLMkVWUQyrNW
likVyFIURsoYse6aABJLADZPOmHzuOz0E82OmeRa87V5g8LxMkigFlKuAQRsflzhj7Fqy+V
xtiy6Wa07COdVVX9qQd43VSCNL2aMEghjCxPnYHx6YvX7NGxUyp738bZarPMEVFn0AySBQx
A7RujEeNEkaGuWuOOOORfSn+ET/qV//Vy87Y25Pkr1uysnSjBK9aFAB++ZSBJISfI6uGQDx
+Fm+4MvXNV9ZYW68SV2vOZ4GsQ//GWQJI1AJZSY/uGivx8llA2SAex9T4pMdbvySWYoqSh7
Cy05kljQ/DmMoH6+D92tfa3n7Tr4h9XYWft7dmYha0VrsasoVo5de31JXTMxOlUbYkEAbBA
1YvO47MvYjpTOZarBZ4ZoXhliJHZeyOAwBHkHWj518HjO35cbiJZ66o1l2SCuJASnuyOscZ
bXnr2dd6863rzzFRz2KqzxYKK3evWaqxwvL9LNPs7KdnlVOm+yMGYkAMrA6IOtsmcoxZePF
yfUpZmbpGWqSiJ26F9CXr0J6qTrt+RHyOcKHqjD5PKtjKlp3tCD6gKYJFV4uwX3EdlCupJG
mUkH5G+feTuT0cpjJPc/3OxK1adSAFRmXcchb8vuT2wPGzMPzABzUrWRqerbWKuzvaq24Dc
oytGimIKwWWElSNgF4ypK70xBJ1y7xxxxyLV/jjKfptP+pa595eaWfI0sNDK8P1ayzWJEYq
wgj6hlRh5Vi0kY2PIXuQVYKeY8j6zgx+bbEDFXrNrsixpE9cNN2APZEeVXZRsgsF6jq+z9p
12veraOMz8OIuxvDJYZFilaeDUhc9V1H7nukFvt300CCT4BPONX1lHasxVv2JlIZZMg2PdJ
lhUxSLGJSW/eeVKbYFd7CnXyu+GJ/wBomCzObr4qq7mS2rtWkEkTrKFHY7COzxkrsgSKp8E
eCNc9NNNFWgknnlSKKJS8kjsFVFA2SSfgAfnzyeKz4pUKFr9l3r1z1EwuH6dUCqzxlkj7SO
ikrFF12vz7e2ALjdDM+saeD+mjsVZpLdiL3Poo56/1C7+F6NKC7E7ACdtlSB+W2b9Y0sLJP
EtS5kpavtfUx0VR3gMrdYgVZgSzH4C7PwSACNrWXjz2HyUeBnmOTodXFd0evIJV1JGjq4Vg
j6APwGUsN/OuGVtOZMJ6nxVyaSpPLBBNAZmWKeCdgqOEIOnV3Rt6UlewJ+APT8cc8fFhWeC
96YqGjXrVLYtR1rVEWIZq0wZwrIGUACf3OuiCBEuwQdsX0BFHhMPRNmtkJcVA8CvlqYtRsr
lSSE7L1IKKF+49V2PPyMuYqWYPW9GswuWcdfySX7CwUJukLRwCOP3JlbqV9yONupXxrbEAD
fdbc2Pr+rPoluQWbGSRKc1mGTr7s0cMKOGkGmQS7+NgKvga6g+spU4MfRgpVY/br1oliiTZ
PVVGgNnyfA/Pkz1n/A+e/TbH9NuU7tODIUbFK1H7lezE0UqbI7Kw0RseR4P5c8s/p3PZX05
WxGTu1klx1tB9RLB9VFk4ET7TLGzDySw7AkkMnYH8JH2PQo/szFh3v+8sVlJ1imWWSrpAFW
IxNKWMQ0G6GTXcb/D9vPh/Q90+l0xFfNpQs17ctmpZo0/aWASe4GQIXPgCaQAhlI+3XlfO3
1B6Pr5h8Y8C0YhjVeKOvaoJZrmNgo6+3tepBRNFSNaI8g8p4HFDCYStjhKkpgUhnSukCsxJ
JIRAFUbJ8D/ySdk4pIYsZ6yjtpEka5mD2JnCjbzxAvEPHnZjM2ydjUaDY8BvgekoD6Oi9PS
z+/06SSTToZBPMJBKzyKxJZXkBLLvyGIBHyJ+Wow47HYejJVRZac7268lDCSS1I5F2AGgjZ
mU6lLL9w+5O2/HU8IKNvHj0k2RhsveOQsWbS1YZWhgadJmYN0LKAskqqGY/GyCB25Xx0s8v
7czlet9VYeV69SAuI2da/ZBGT8Dc3vEN58ON/GhQw9CWlBPLaZGuXJ2sWGQkqGICqo+NhUV
E3odunYgEnlDjjjjkX0p/hE/6lf/ANXLxjcfaxOctwV4e+Jud7fuPOWaCwzDugU/5H33Gvh
vc/JlAhYf/Z7Yx7l7GdcyvA8UtqhE9WewSHAeUiRkdl9xiGKd+wUljo7oelvSL+mr080cuO
SvNWigMFOg0HmMsVcsZXLMQ7Ak+TpfPg7zQegAnpe/g58s9kztEK1mWsjNBFD09iJlO1kVS
myNAN3fwCxPKfpr02MA92QtRDWmQ+3Rx6VIo1UaA0CWY7LHbMfnwB5329T41slhJPYrpPdq
Mtukra/4iM94xs/AJHU+R9rMNje+MLVqy2bfqCvaeyuYWGSF27AJAIx0QAnwNs7/AADuQ7+
ORrvpiliq2ZnkrJNVySyxTNRxva+BYk+8mQE91UuTrpsKo/F185atCaXF5a/lKsM9Roq1ap
UixEkSyxQsXUNAwldVLyMh+zYVOw+QR3xOOmr4v0x6esS+5rtfmUrIqiKJgyRL7hMg6SSwd
Q2j1iIbX4Tco1btnMzZXIwJAYlerThWTuRH7m2kJAHmQJEevnqEHnbMBX44445Fq/xxlP02
n/Utc+/UGIlyMENrH/TRZeixko2J4yyoxGmQ689XXanXxsEeVHJ+T9CY7LZC7YuXLkle9LH
LPScRPCWVBHteyFkYqNFkYN/IjQ13yXo+tfvWLcOQuUHtSwzWBWWE+7JCVMbEvGzeOq+Aev
g+PLb0w+m6UHqib1DHLZFmeAxSQmXcJJ6bcKfhiIo1JBAIUeN+eccT6Viw89cw5bKS1aiul
alLYBhiVj8eAGcKPCh2bqPj8jy7zzmCwcUc9c2oH93BNYqUiyDoIJCjRlCRslYgkZb52JAe
3yadjEiXKpkYLtmpL1SOZYghWwiMzKrd1bQBd/K9T9x8+Brz8uJyWUz4Jq3sZU/aC2rgMtd
4Lfske06n7pFZvbgJX7VCqw/F5YuEyGOwmVdIXgyGTaKnEalppVpwEiNDGBHH0WISO/UDfg
kt52LMuIlmyNSL/docPRWN4KsUZBaVewAYfh9tR0ZQBvuoOx1ANfjjk+hflvZG+EVPoqzLB
HJo7klGzKQfgqNqv8w6yA/A5Q45iy+R/ZOLmyDRe5FX6vN92ukXYe4/wd9U7NoeT10PJ5t5
F9Z/wPnv02x/TblaaaKtBJPPKkUUSl5JHYKqKBskk/AA/PmbEWbVzFw2rkHsSz9pFiKFWjQ
sSiuD8OEKhh8dt68c28cxWsj9JlKNSSL91d9xEm7fEqr2VOuvzQSNv4Ht6+WHNvHHHHHHHH
HHHIvpT/CJ/wBSv/6uXmqhflvZG+EVPoqzLBHJo7klGzKQfgqNqv8AMOsgPwOUOOSMnnWp5
FcXUx1m7ekqTWokXUcRCaAUyMQNlmVfHYjsCQB55QpXIMhRgu1ZPcr2YllifRHZWGwdHyPB
/PnfjjjjjjjjjjkWr/HGU/Taf9S1ztlbk4tVMXSk9uzd7s0oAJghQDvIAfBbs0agHei4bTB
SDxu+rcRj7U1aw9wvXlSGQxUJ5UV3ClV7IhXse6aG9/cOapc5RgyIozfUxyFlQSPUlEJZtd
R7pXpskgAdvJIHz45iq+s8FdeJK09l2mttSVfoZwVnUBmRtp9pAO/u0NBv+U67VfVGHu5GK
hDacT2FZ6/uQSRpYVdbMTsoWQaIO1J2PPx55X55XG+qKNepBbv2rLz5pvq69aGCWwYomX90
vVFYoTHGWI+C4lKkgHVbI+ocfiqMd24LiV5IjL3WjO/tqACS4VCY9A/5tfB/kefGb9UYf06
hfKWniVVDuyQSSiNSeql+inoCdgFtbIOt6PO+elu18JZs48O9muonWJE7NOEIYxAaPlwCmw
CR22ASOT8tkblO9ictTt/VYi1LHWsQxrGy6lOop0fYP42RSNsCrbA2Nn0HHHPELVt/2bvYB
YL2QkiyksdyWrJAkpSRjZDakAjcESRo6EAHs40QPONPS2W/sjhMfkMcjpCs0luljoakmp3f
sjAWAYwADIGCEAM4Cjr8cLmCr1PWFDGnGJEZ8hWGPuTukxiqVYFk9qIGTuh9yNgzddakJJJ
I5tN1q+Z9RzpYTKY+tUkjsUXviZbFl5G9uJIi0jRHW4iD1DsQFj8c9njKstHFVKc9p7cteB
I5LD77SsqgFzsnySN/J+eT/Wf8D579Nsf02529S4yfM+mcljKs/sTW6zxI51rZBGjsH7T8H
Q3onWjo88n6tq5D1ri8fLisTNPXsVoZ4GsyQfTH3WHcToT3VljHh4vuHdgCPzp2/Tr5D1qt
7J05rUMcsclOaOKr7cCooZVdyBP290M2lJUhlB8FhyF6PoR1Mra+piTDW8VhlXJWXaGSeSx
OxeSaSXu4IX2eyhx8OSQF0DXxt39r+lfR8cdn6i3Y+nme0snuSR+0naZifnyQYWOxozaO99
T7PjjjjjjjjjjjkX0p/hE/6lf/ANXLyZRjuVvTGXxMC3L1ytenhkkrzRwzMJ3E3uI56qHWO
cN8KOykDxo8i/2Luv6V+hepNFA2X+slq1UrRTzQhOqK8ezXLBwhIGlZUBI7kjmbE+k4Kmbw
mMt4Wy1iPIT5NbUxrgRQKGKRoY2BULJLCSgXp3LkbXzz1NT6lPWeXy+SxH0NOKjHBBkJpoS
CkbyPITpuyKe4Oj41Hs6Ohyh6Whlg9N0/eieBpVMwrupU1ldi6w6PwIwwQeB4QeB8Cvxxxx
xxxxxxyLV/jjKfptP+pa49Q4+1J9Pl8XD72Ux3YwQtOYksI2hJE35eQAVJ8B1QnwDuTlvQ1
jK+oLGTfLpGsrIYWWu62aYEfRhDOkikBtserBk2d9T5395r0Q+Tzj5avbppYaWvKklym1iS
AwsGVYm9xRGhI+4AbJZvPkaoQ+mmh9XTZs5B5K0qlxReIFY7BRIzKrfO/bjC6IOuz6IDEcm
enfQEeAyNSdLFF4qSyLEY8VDHYkDeF92byWKrsbUIW+TvyD6yaGKzBJBPEksUqlJI3UMrqR
ogg/II/LnmcBiVkfHxzTOD6ZaeklfZ0TpRBIxB6s305B+CNzN+EjQ25H0zFd9R180EovLGs
SN9ZSE7IqOzAxN2X2227bP3fC+PHmFNTmyXqaVMdBNXS3koZ8k1vFyK4FYjoY5yQjIxhjCq
Ox/es38wO+MtzY/0FcWktytaa9Yr1HuQyK6vPZYQO3ujsy/vY2JIJ+fkgjlaTEytPj8PBVS
DCY5YJQ5lLNK0ZPtxAfICMsTly3nQXRBbV3jjnBKcCXpbqx6sTRJE77PlULFRr48F2/8Af/
bnfmKzhsVcvRXrWMpz24Ne1YlgVpI9HY6sRsaJ2NfnztbpwXoVhsx90WWOUDZH3I4dT4/ky
g/+Od+RfWf8D579Nsf025a5ixf0CwzxY/8Auo7MvuEdiplZy8mifn72bevAO18FSBt5irYb
FU70t6rjKcFuffu2IoFWSTZ2ezAbOyNnf587PTge9FdaPdiGJ4kfZ8K5UsNfHkov/r/vzvx
xxzLDfinyNmlGrlqqoZJAB0DNs9N/8wADEfkHQ/nzVxzhduQY+jYu2pPbr1omllfRPVVGyd
DyfA/LnHK5ehhKq2slP9PXaVYjKUYohY6BYgaRd+OzaA2PPnm3jjkX0p/hE/6lf/1cvNqfQ
JnJen/Hy1k93XY6iRm6b/Jfud9b0W02t9TrbzLJjMfLkY8jJRrPdhXpHZaJTKi+fAbWwPuP
j/qf58+7tODIUbFK1H7lezE0UqbI7Kw0RseR4P5c78cccy3r8VBITIru086QRxxgFmZjrYH
5hRtj/JVY/lzVxxzKMjVYXSjO5ot0nVImZlbosmgANserqdLv518+OMbkqWYx0GQx9hLFWw
vaORPgj/6IPgg+QQQeauORav8AHGU/Taf9S1zVk78taelUqKj2rc4AVwSEiUhpXOvIAX7Qf
ju8YPzyhxxzFjcj9f8AVo8XszVLLwSx9u2taZDvWvujZH0Pjto+QebeOOOOOOOOOOOOORfW
f8D579Nsf025tzP1/wCw7/7L/wCP+mk+l/D/AHvU9PxePxa+fH8+eSz2WrUPR2JfDeoP7O9
vZr14Z/ZYovuRxuJFk2S0SluwDDRB7HxzvnLtz096ZqS0c7Nchu3l75K3LHqGOQMykSLCyK
hfoAWRlAfW1HUr5yX1jmIcdU971JWaSWe6teWGSOGK0sfQgGxLX6FgSygqixv/AM4I01O3Z
lmxnpXK5D1NepRm26SWbKVIh29mx+9H2smm+F0zKUZSNk9udsx6kCTwBvV74fHvhlt1Lr00
LXZCTtj3TRKqEPtIqsfd8a1oZcRkrvqLOR0bPrWanK1GvYkx9f6ZJY7RZ2khG0LBY/bAZG2
2m+462C9U+qM5T9RXqlPLU8e9WWuKtayWP1av18iIQPJLty6bjca6jwNbb9H54WW5lqnojI
2Ksn02abJTRyLEElkM0k5SBO0mh100GmZf7rWgNqRTz8+QwODRVys0z2LIRshdmgrrUXqW2
ziBkCkoEHZDsyAb+OQ816hyuKwjJP6jrQNHi5L1fIB4e16Zi5jhj7R9JFVQOzKAzdoyAuyD
6nE3MkuYs4fISQz/AEdGrItpB1ewz+4ruy/CbaPwo3r+fnQxYn6Af7OAuS84hKMiBz23JSU
MI3PXz2aEKx0Adk+AfAr+n4rsHpzGQ5EubsdSJbBd+7GQIA222dne/O/PKHHIvpT/AAif9S
v/AOrl5mw8wjgz6XpXx1xLc0tiw7INREahmXe16iJEXZGu0T7BIbcLCX8hcxeWzdT1XNnLm
O+sWtj4hA0bKGdYRIkShnZvbDBgV2DoeCd5cR6pyk8GZn/tHWu04cM1tZK4FqarJpirbEEM
YJAP7p/u2n5DfJ75jI5/0/6hRvUFyxXjxEs6GrJUnhYe3srIwhSRGbtoIyIf3bkMf8vo73q
COLDQvj/Vr2KpyiVruXaGGUVUMfbQZEEYBPtp3YMFMh38aEy56lt/2fmlj9apXZcp9LRvvB
Aq3ITJCryFWXUgi7yDtH1U9Nnm3N5G9gYMXXqepHkp5Fp5v2pesxRr2IVkjE3sPGFYGRlBU
b6gKwACn0fo+7dyXpTH3MjYhs2ZYttPDE8aSjZCuFdVI2uj8AHex41zjlPqm9X41P3McP0N
r6aWXbqLW4+u08DsI/cI03YqZR4AJOLAW8uPSknqOxayOSeStNYq4+VIFMibLQ/3Ue+7IE2
NkbY+PgCfWzWVgxRtv6jo261m3HVe4LcMsWPQKzSSGVIUXsR1VVddBimyQ3XnFfU+bxnpk5
dMtWy8cmQsR1hNXXtaRZhFHBG0JG5HCuwYRsDvz1A2fUp9vriX2Pu9zGp9Xv8A/H1kb2Nf/
wBdrG/n8C/H+b49MRLG+aeAuacuUmav2csAdKJtAnaj3xN48DeyPBB5d45Fq/xxlP02n/Ut
c+MhG1b1liLzzO0ViCegkQA0kjBZg3xvRWBgfJ8hNDyx55zE4P1E2cy2Wjofs2zaxsiwzX5
IZZYrUjduqvFvvCvVAPcBYBVCgDY5wl9L1MfiY7L4C4aovLLkq07Uq/uwRRSMhZYmSEosjK
x7HZ152AOUPRT3akXp+qJayUshi7OQNaCt7axyPNFIAPJ0qicqANfBJ3sBbuI/3jO5q7F9l
cyx1lC+UleNfvl38FtuIj+Y9jRPjS2uOOOOOOOOOOOOORfWf8D579Nsf025a5ixtPG1vq5s
bHCotWXlnMJ2rTDSOTrwG2mj/wBQd+d828ccccccxVcd9JlL1uOX91d9t3h6/Eqr1Z+2/wA
0Ea6+B7e/ljzbyRPgBayL2Z8pekrPPHOaLMhhDx9ShB6dwAyK2gwBO9jRIK96ehsPkrVWxZ
qZDIVDVNlbEhEY0QjKnbqCpJI1o7LefuO9U2HxtiOlFLShMWPlWWrGF0kLKpVSFHjwCdfy8
EeQObeOORfSn+ET/qV//Vy82/R41859aI4Tk4a3tFwf3ghdtgEf8pZDrf5htfnzbxxxxxxz
Fksd9f8ASOkvszVLKTxSde2tbVxrevujZ02fjtseQObeT8li5r08E0GXvY9oVdSKpjKyBip
+5ZEYEjr4OtjZ/nwuDoxwUIIvqYYscqpXjityooVQAAwVh3GlHh9/n/M75nBwTNlxdP1MWV
0jqQVKQ+0E9oMDvrv3G8a0ZG/PZNCGGKtBHBBEkUUShI40UKqKBoAAfAA/LnTjkWr/ABxlP
02n/Utc25b6AY8yZL/h4pY5QB22XV1aMAL5Zu4XSjZY6GjvXNvOFylVyFV6t2tDarya7xTR
h0bR2Ng+D5AP/jmav6fwtSeCetiKMEtZSkEkdZFaJSSSFIH2glm8D/mP8+aalOCjC0NaPoj
SySkbJ+53LsfP82Yn/wA878cc5zTRVoJJ55UiiiUvJI7BVRQNkkn4AH58+KVn6yjBa9iaD3
4lk9qdOskexvqw/JhvRH8+d+OcHuQJeipNJqxNE8qJo+VQqGO/jwXX/wB/9+cYsvQmzE+IW
fV6CJZnhdGUlG8Bl2NOu/BK7APg6PNvHHHHIvrP+B89+m2P6bc7epcq+E9M5LKRJ3lq1nkj
Uxs4LAHrsL5671s+NDZJAG+Sc3mF9C4SnXrU3tqFIM9mQxoW2BuWZUZVkkd99nCqSWJYfnq
t+pLK+olxWOxv1ojljjsyfvk9ktpm+72jEesbK+jICd6A3reLG+t5LkiPaxsNWvPjZcnAPr
kab2EZQpkUgJH3DbBLkDRBI0dfcuYiuz0czFWs1JcfkDjbsFhAJUWYqoXQJUgyNWk7KT9o8
HyVPquOOOOOOOOOOORfSn+ET/qV/wD1cvM2CvLJiMn6javZnlmnsH2khPumOB3jjjRG0wJC
Fuh/zyP8b0J/9v5v2H9cmH+osvkv2fFXqyySfcF7Ozj2hKnUB9qYy32ggEMDxj/XGVyP0Dx
+m+sVrJNj3Mlpo2Vk7l5EV4l7IERj56t2DL12NmLB6cyXqP1f6j/bVSEpLZhhinWTbVqiEk
xqwJKtMjAMqsCA7swG0V/c+nLk93BVntye5bi7V7MgAAeaJjHIwA/yl0YjwPBHgfHKnHHHH
HHHHHHItX+OMp+m0/6lrnxmZGi9SYKSxC7UQ0y+6CAsNllCxFjsHRVpkHyCzqNbK8hPZfK+
uLeGi9eTRQxxRypVrvV933/ckLRhum+qLEOyEEkN9x1sHF6p9UZyn6ivVKeWp496stcVa1k
sfq1fr5EQgeSXbl03G411Hga23FPU2Ru+qnx0HqK4Yv2lNVeKr9IZ4tP1A9iSPt0Gw3uK0v
2xsSqknpa9EWq0du1jT6jmu3Fs32ei/sn2wtpgZG6IGVj2B0To9zoaHiLR9VWZ/wBlm3609
ia37v7VrfSwxfsvWz8uhMXWQLD+97d/c2POjyn6auZOb0ZN6li9QzZ/JtjSxqKsRhScIZFj
9uNQwcdgp87bfkfhCvRGfyWWzk0T5ynlKJopMFif3pIXLeOzpXiRdje0b7wV38b5d9YGUYN
QqI1Y26wul3IC1veT3SRogr12GB0OhYk6Gjlufte96zfHV8vcp04aInkNaGDSln6xjciuzM
ek5JAAACD52W44vI5PJ+r542ykNWGrLKHxZsRSSsikxqxj9lXjViVkDe4w0QNaYEQj6xyqz
xZT9opO0GPt38hga7Qt7AQoscTMVDxsBJ2fts9o2Cr8Lz2HqLxNhni+62mSj+njP4X2jrLv
/tCZmHkeVHz+E+c/2o4/L5KDGw+mXspnVaRkNeyYG+m0ol+7sqkdzB4J3/L4PPe8cccci+s
/4Hz36bY/ptytNDFZgkgniSWKVSkkbqGV1I0QQfkEflzzlX0jTyOPrf2grTWrcESVpWktSF
Lawu3tySIG6v2/vNMG13IO9ctfsmmMp+0lE0dg/iEdiRI5D167eMN0dtaG2BOgvnwNef8AT
3pvKYPMZVoEp16E1aKvQ3bntPCIu/TssmvtPuE9VYAaAG9ludsb6ZfG2sVXWKEw1pbN6xZh
DKZbLDovbu7u20ll2SxO0XyB9p9PxxxxxxxxxxxyL6U/wif9Sv8A+rl58LglnnytC5C7Y21
PFchaOYxe3JsFlXoQykSRCXsNbaU/mCTp/s7jPofpPam6+773vfUy+/3117e929zt1+3fbf
X7fw+OTF9LtV9V467Ui/8AjqsUrOkmRnYidh1EgiO0LaLgsSCxlZjsjZ7t6brYajZtYStNY
vxRTS1Ird2aaP32DHepHIVmZiCw0dM3nyeVsZQixWKqY6BnaKpAkEbOQWKqoUE6150OauOO
OOOOOOOORav8cZT9Np/1LXKGSxtLMY6fH5CulirYXrJG/wAEf/RB8gjyCARzVxxxxxxzhdp
wZCjYpWo/cr2YmilTZHZWGiNjyPB/LnxjCzYqoz3UvsYEJtooCznqPvAXwA3z48eefd2t9Z
RsVffmg9+Jo/dgfrJHsa7KfyYb2D/Pkmf0tHax2Rq2spenlyUArT229kS+yO2kAWMIB97+e
u/vPnwNbTi2fI4+3NbecUoJE6yoNySN0AlOtAMFVx4UeJGA0Ng9q+NpVLtu7BXRLN1laxKP
xSFVCrs/yAHgfHyfknerjjjjkX1n/A+e/TbH9NuWuOOOOOOOOOOOOOOOORfSn+ET/qV//Vy
8tcccccccccccccccci1f44yn6bT/AKlrnxm5orObxeCsSokF1Z5pY2Yf70sYUezr8wTIHO
vlY2Ugqx5ls5r1O/qCxh6GFxx9iKOwbU2QcIY2kZQpURbDssb/ABtV/Mn4PHM+trONylmrS
wFzJJSljjn+nimaQllRz0CxNGdI4OmkQ7BGvgnjN65upnFxaY3HI81mWCBrOSeJZOjFdhvZ
KMxPUdEZ2BYAgabrT9K5HOZCCaTKVqaxLZtRrLFZZ32k7oE6+2o6gLoNvZ6gkbJ1iq+rczc
jxs8fp2FK+Y7fQPLkNH8JkT3QqHp2iV2HXvogKdb2PvE+p8vYwEvqXK4mtSxX7PNyOKG0Zr
GgC3kdVXTJogb2Pz+ft7+n/U97LZWajcwVmmqQCVLQjnELHtooTLFGQ3kEAAgjfnxzT6ruP
Vwwhjkmie9ZgpCWEN2iEsiozBh+BgrMVY+O3X52Ac1jM3aWfh9OYjEUSEqGaNZbvsBY0KL4
RI30u3CrvWyj+NAE/dT1JZv+omoU8b71GOWSOW5++ToU2G/FEEbUi9NLIx871oHU8+urT28
e9XBPZxuRWSSvN9UsMxRWSMN7coRdO8idR32QwOgft5pmysF6HCepqqTRItn6SeOaMpKqyu
IWjKHwGWcRFv5CNtE700P/AGlZKx6HeH1bho6wtW2FK3FMjlLA0WR2CsPuQIygkE6cjfgc/
Q+OOOORfWf8D579Nsf025a44444444444444445F9Kf4RP+pX/9XLy1xxxxxxxxxxxxxxxy
LV/jjKfptP8AqWuas3i2y2OMENt6VqNhLWtxoGaCQfDAH5BG1I/NWZfz5zg9PY+vmHy0Zuf
VyfjZr07Iw+7Q6F+vUd20NaG/AHOOQ9IYLKXpblyj7ks/t++oldY7Htnae5GGCya//YHx4+
OK3pHC1L0tyCtMrz2TbkjNqVonmJ33MRboW2AQdeCARrQ12pencZj8lJkK0Uy2JPd33syui
+44eTqjMVXswBPUD45jj9DenYZFkgpzQmPv7IiuTIK/dgz+0A4EWyPPTr4JHwSOUKGCx2Nx
TYqCF3pMvQwWJnnXp1C9P3hbS6Guvx/0884Yj0vh8HP79Cq6y+wtdZJZ5JmSJTsRqXY9V3/
lGh8fyHNWYx37Ww9qgJfZeeIrHMF7GF/lJB5H3K2mHkEEDRHFCD3OuTsU/pb9mtEliP3e/T
r2YJseD1aR/IHnf/bnCTEin9bcxI9u9NFJ7cc1iX6b3D52Yg3UbbyxUBjtjvZO41H0pcjku
Ww0OOsS1vpKsCXLFqGqhbchQdoinYBFCp1Ce2pB865tq4D6GbAUK9aGKhi4pJS1dei+/wBB
Go6lierLLMx8k7A23z2oQ4tlzc2UsW3nbqYqsZQKtaNgndRryxZowxLb1oAa87occccci+s
/4Hz36bY/pty1xxxxxxxxxxxxxxxxyL6U/wAIn/Ur/wDq5eWuOOOOOOOOOOOOOOORav8AHG
U/Taf9S1z7y00s2VxuJgleEzM1uaRGKn2oWQlQR+bO8QII0UMg2Drnevncdayr4yGZ3sort
/cuEYIyq/WTXRirMAQCSD4PkHmJ/WeCiSQzT2YGjaJPanozxyu0hYRhEZAzklG8KD+E/wAu
aaXqTDZCSGGvkYRYsd/brSn2pm6Myt+7fT+Cjg+P8p4xFyeS1kqNuTvNUsnoxAUyQuO8ZCj
/ACjbR789jEx3vYFTjjjjjjjjjjjjjkX1n/A+e/TbH9NuWuOOOOOOOOOOOOOOOORfSn+ET/
qV/wD1cvLXHHHHHHHHHHHHHHHItX+OMp+m0/6lrnxmIYqOfxecESBixx9mUqNiKUjp8eSfe
WJR8gCRzr8xMo+gmSfJzZHJpK2Ux5pWBRqCqsxYsWndezBpT2P3aAGz488XcJYweCitVBRi
nx1triRYvCv1mJiaLr7Ky7LHv+LsB4G9AE8n4fBT38X6XgkqZGGKH2rt6WxGCxsozyEH3n7
xsZWcsyxkuGUBgvPTYL/fL2VyzefesmrDvwyxQEx9SB4/vffYHySHG/jQtccccccccc//2Q
==
</binary><binary id="_57.jpg" content-type="image/jpeg">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
XZxtT3Y7h91eV1F/DlOobqma7NjR3EPpdRLYhluagBSTjipcCSQEhKSpslIx3nJPo3dM2B/
jcax25zpDoee3xGzxF8+0rI5q7SuZ59o/fUjWn7KwgoZtEFtJYVHKURkAFpRKlN8h9kkklP
cSTXblmtT0VUV22Q1x1NIZU0phJQUIJKE4xjakkkDuGeVTdCi9B6D0ZnonC4PR+GOHsxjbt
7tuOWO7FVmtP2VhBQzaILaSwqOUojIALSiVKb5D7JJJKe4kmjun7K/cRcXrRBcmhSViSuMg
uhScbTuIzkYGD7sCpotst8F+Q/Dgxo7spW99xppKFOqyTlRA7RyTzP3mqsbTNgh8XotjtzH
HaLLvCiNp4iD3pVgc0nHMHlR3TNgfisRXrHbnI8bdwWlxGyhrccq2jGBk8zjvq7MhRbhFXF
mxmZUdzG9p5sLQrByMg8jzAP+1UpOmbBM4XSrHbn+A0GWuLEbVw0DuSnI5JGeQHKpBp+ypf
W+LRBDq30yFOCMjcp0EkOE45qBUrCu/mfvqZu2W9q4uXFuDGRNeTsckpaSHVp5cirGSOyOX
5D7q4bs1qZipitWyGiOlpbKWksJCAhZBWnGMbVEAkdxxzqCPpmwRMdGsduZ2uoeHDiNpwtO
dquQ+0MnB7xk/fV2TCizOF0qMy/wHQ81xWwrhrHcpOe5QzyI51Wl6fss9CETbRBkpbUtaEv
RkLCVLO5ZGRyKjzJ957679jWr8Mh/wDpuif0E/0P/a7vsf8Ab3flRyzWp6KqK7bIa46mkMq
aUwkoKEElCcYxtSSSB3DPKuHNP2V23N25y0QVwmVb24yoyC0hXPmE4wD2jz/M/fRzT9ldW2
ty0QVqZY6O2pUZBKGsFPDHLknCiNvdgn76sw4UW3xURYUZmLHbzsaZbCEJycnAHIcyT/vU9
KUpWLYv731H/qSP/Ej1tUpSlKUpSsU6TtfEdWhdxZ4rq3VJZukltG5aipRCUuADKiTyHvp1
Ut3xN385l+rTqpbvibv5zL9WnVS3fE3fzmX6tOqlu+Ju/nMv1adVLd8Td/OZfq06qW74m7+
cy/Vp1Ut3xN385l+rTqpbvibv5zL9WnVS3fE3fzmX6tOqlu+Ju/nMv1adVLd8Td/OZfq06q
W74m7+cy/Vp1Ut3xN385l+rTqpbvibv5zL9WnVS3fE3fzmX6tOqlu+Ju/nMv1adVLd8Td/O
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
291p5/ZJdRlbe3YpOFDYobEc04J2jOcUjadtkSVHlMtPCRH4m11Ul1a17wkK3kqJc5IQBvz
jYnGMDEkCxW62IhoiMrSILC48fe8tZQ2opJTlRORlCcZ7gABgcqq3HSNlukqTJkxnkuzGg1
JLEp1gSEgEAOBtQC+RI7WeXLuqYadtglNSS08pbew4VJdUhxSAAla0lW1xY2pwtQKuynn2R
gnTtsTw9rTw4c5U9GJLvZeVu3Edrkk71ZR9k7jy5mq0zRen5xKnoSwpSXkLW1JdaU4h1Zcc
QooUCpJUSdpyBk4AqZWmLUtiUypuSUy1MreJmPbitoJCFhW/IUNiMqBBO0ZJrQYhsRnpLzL
e1cp0OvHJO5QQlGefd2UJHL7qnpSlKUpSlKUpSlKjeeajMOPvuoaaaSVuOLUEpQkDJJJ7gB
76yeuelfEto+ea+qnXPSviW0fPNfVTrnpXxLaPnmvqp1z0r4ltHzzX1U656V8S2j55r6qdc
9K+JbR8819VOuelfEto+ea+qnXPSviW0fPNfVTrnpXxLaPnmvqp1z0r4ltHzzX1U656V8S2
j55r6qdc9K+JbR8819VOuelfEto+ea+qnXPSviW0fPNfVTrnpXxLaPnmvqp1z0r4ltHzzX1
U656V8S2j55r6qdc9K+JbR8819VOuelfEto+ea+qnXPSviW0fPNfVTrnpXxLaPnmvqp1z0r
4ltHzzX1U656V8S2j55r6q04c2LcIqJUKSzKjuZ2OsuBaFYODgjkeYI/wBqnpSlKUpSlKUp
SlKVi6z/AMD37/TZH/GqtqlKVG2806txDbqFqZVscSlQJQrAVg/ccKBx9xH30aeafQVsuoc
SFKQVIUCApJKVDl7wQQR7iDUlKUpUZeaS+hguoDq0qWlsqG5SQQCQPeAVJyfzH31JSlKUpS
lKVi6U/uh//Up//lu1tUpSlKUpWL0XVX4zaPKnf3FOi6q/GbR5U7+4p0XVX4zaPKnf3FOi6
q/GbR5U7+4p0XVX4zaPKnf3FOi6q/GbR5U7+4p0XVX4zaPKnf3FOi6q/GbR5U7+4p0XVX4z
aPKnf3FZOrI2pE6OvRfu1rW0Le+XEItjiVKTw1ZAJfODj34P/wAGvYUqleX341jnyIrbzsh
qM4tpDGOIpQSSAnKVDcT3ZSefuPdXzyLqHWC35Ud1F6RGS/FBli28ZaWSV8VbQMdrJyWUkF
CiBvUAoDktku6RJ0pqMnUEK2ybo89JmiygyHMsNhCtga2hK1odJUlsq5I3bSvJ2dGR711ZZ
atziLW00/IHR7paFpeG55a0nCXG0gbFo5JTtByAfcIbtM1TH1jFhybpOYtQt/EfkWqyl1Lj
/EWAgZS6UHbtJySOz7t3KG93rU1s1I3GjIvUiGzLjNOuIih1LjO1CnXMIi8wRvBCXchWcJA
5VoaTcftsxVvkyL7JddnTElt63hEdsF51wOl0NJB3ADuURlzkkD7Ppry4+zY57sVTyZCIzi
mlMMh1wKCTgpQeS1Z7knvPKvGWWVrJy3vypsuY6IzsNRIihJeAWelANrjtr28MhQASTkAJU
o5TVKfdZVwuMeS5D1GhUS9rMWSiynjsRFxyhRTlop2cQ9xBWUgZBUBXoLCvV06LIcNxZajo
kuIiuXO0qTIfaB5LWlLqAnnlI7CSQkKIG7FZ92mapj6xiw5N0nMWoW/iPyLVZS6lx/iLAQM
pdKDt2k5JHZ927lDe71qa2akbjRkXqRDZlxmnXERQ6lxnahTrmEReYI3ghLuQrOEgcq0NJu
P22Yq3yZF9kuuzpiS29bwiO2C864HS6Gkg7gB3KIy5ySB9n2dRtupcW4hIWC0rarcgpBOAe
RI7QwRzGRnI7wRRp1LyCtAWAFKT20FJyCQeRA5ZHI9xGCMgg0ZdS+w28gLCXEhQC0FCgCM8
0qAIP5EZFSUpXkrBapsmFKeZ1DcYiFXKdhlluMUJ/tTo5b2lK59/MnvrT9hXHxZd/wBKJ6F
PYVx8WXf9KJ6FPYVx8WXf9KJ6FPYVx8WXf9KJ6FPYVx8WXf8ASiehT2FcfFl3/SiehT2Fcf
Fl3/SiehT2FcfFl3/SiehT2FcfFl3/AEonoVtUpSlKUpWLrP8AwPfv9Nkf8aqdc9K+JbR88
19VOuelfEto+ea+qnXPSviW0fPNfVTrnpXxLaPnmvqp1z0r4ltHzzX1U656V8S2j55r6qdc
9K+JbR8819VOuelfEto+ea+qnXPSviW0fPNfVTrnpXxLaPnmvqp1z0r4ltHzzX1U656V8S2
j55r6qdc9K+JbR8819VOuelfEto+ea+qnXPSviW0fPNfVTrnpXxLaPnmvqp1z0r4ltHzzX1
U656V8S2j55r6qdc9K+JbR8819VOuelfEto+ea+qnXPSviW0fPNfVTrnpXxLaPnmvqp1z0r
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
vibv5zL9WnVS3fE3fzmX6tOqlu+Ju/nMv1adVLd8Td/OZfq06qW74m7+cy/Vp1Ut3xN385l
+rTqpbvibv5zL9WnVS3fE3fzmX6tOqlu+Ju/nMv1adVLd8Td/OZfq1pwobFvgsQorfDjxmk
tNIyTtSkYAyeZ5D31PSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlK
Ur5reJsg66TFEi6R1Lv0dtuV09bcINpjsuLYUjcQVLyrCdo3FX2jhQr0971TItF9i29FtQ+
w8qOlbweXubLrpb5pS2oJA5EFakBXMJyQcQW2/XOYu1m5QIzZkXSXECo0xzCC0HgklJQN4I
aWDk4yEqAycJtR9TPvXiNHNsxAlyZERmWl8FYeZ37gtvAwk8J3aQpX2RkJzypRNYXJ6CzLk
2eGyiVaHbnGCbjnIQGzsWVtpSjPFHayQMGuIWpJd5mWziRlwFNXlcV5pK3QHU9CcdGQ422r
GVJ5FPekEZ5Gtm6XS4RrrDt1ugxpTslh58qkSlMpQltTacdlteSS6Pu7qyUa0lOWOdc02pn
+zWiPdUNmWf5iHErUpJPD7Kk8NWORCuX2cnE1x1NdY0qamJaIb8eHOYhFx2eptaluhnB2hp
QCQXk5555Hl7qz7hcLnOu1rUbdGRcrdeVxQyLg5wHAqCtwqKuH34WMZQSCCAQFGjmv7i+7C
g2jTK511dYeelwlzUMmKG3eCrtkFKwXErAwc4SDjnWpctRXdh+U1b7CiSqJb25rrLssoeJW
XMNpShCwpX8ojkrBJGM99XNN3s363OSlJjIU2+tlTbDq1lCk8ilYW22pCgc9kp7sH31k2jW
c25wbq8qyYkQIKJbTDDy3Okbw4QhKi2kKyW8BSN6VbuyTVqJqwv6Sud9UxGUq3pfKo7D6yQ
ppOShe9tCkKyCMFPIYPPNdt6intt3lqfamY8y1xhJSlM1JZfQpKyk8VSU7O02tJ3JAGM8wa
pWzVUm6zYTci1dG/8AyTkNREl5BSoRS8lRQtpBUkpKhhQGCEqGeRHE/WV2hQnLiLHGXb25c
iOp/pbylNpaU4kuOIQwranLR5jONwz7yPUwpHS4LEncyrjNJXlhziNnIz2VYG5P3HAyPdU9
KUpSlKUpSlKUpSlKUpSshzS9nfYubD8Vb7V2VvltvPuOJWrGAQFKOwgAYKcY2px9kYhk6Ms
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
f/9k=
</binary><binary id="_75.jpg" content-type="image/jpeg">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
</binary><binary id="_171.jpg" content-type="image/jpeg">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
=
</binary><binary id="_42.jpg" content-type="image/jpeg">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
kew/Laf+tdf/2Q==
</binary><binary id="_137.jpg" content-type="image/jpeg">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
</binary><binary id="_129.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAPAGgBAREA/8QAGQ
AAAwEBAQAAAAAAAAAAAAAAAwUGBAAC/8QAKhAAAgICAQMDAwQDAAAAAAAAAQIDEQQFEgATI
QYxQRQiURUWMpEjJEL/2gAIAQEAAD8AvJt3s8j1JucDD22rxcXUQQSzvlYMjmMursQzd1BQ
VQ1gVTV/ybZ+lttkbz03h7LKhSKWdST2w4RwGIDqHAYK4AYWLph7+/TOOaKV5EjlR2hbhIq
sCUag1H8GmBr8EfnonWLY7nVajt/qezw8Hu32/qZ1j51V1yIurH9jqc3mDDuPVGjysAoZOU
WQNgmPI3GFObcY5o04kSBirB5OPEghSWvqw67qc2W43WJsTNHjYw1sOwx8KRJkcSzLL2x3Y
3vjQeULx4m+DfcD4DOX1BpYNiNdNt8GPNLKgxnyUEpZq4jiTdmxQ+bHTDrFqtj+p4cmR2u1
wyZ4OPLlfaleO/b54XXxdeesuy2Www95qcWPHxjhZs7QyTNK3dDCGWSgnGq/xj7uR+Rx+ek
2l9HtPm7bN9W6nS5+TmZZnhlCCdo4+KqsRLRr4UIKPzZJAPub0hstdl7z1Xi4WQ8skG0DSh
+ZKkwxofLfHOOQADwAoqhXVNGZS8gkRFUNUZVySy0PJFCjdivPgA35oE6nPVGp2e2zdUcbB
wcnG1+Wmb/sZskLNIquFFLG3gFla781RFeeqPrFsdVjbPt/USZidu+P02bNj3de/bZb9vm6
8/nrxgaTE1s7TQTZzsy8SMjYTzrVg/xkdgD496v++sW0w9tl7fHngwMErhsWxsmbPmBjZk4
s7QKgVyAzAAv7E0Vs0HH1Oz/fU29yMHBETYgwo5UzZDKkYd3vh2wpLEpY5fbxNE3XTnP18O
ygWGd8lFVuQOPkyQNdEfyjZSR59rr+uk3pn0ymqiaaZs5Z1y8p0R9jNIhRppChKFypJRlNk
XZs/dfRt9i7rJ2Wsm12JgyxYM5yCcjLeJnYxSx8aWJqFSA3fxVfPX//2Q==
</binary><binary id="_178.jpg" content-type="image/jpeg">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
AzxlP8tp/6lrnwD+l3/qfl/8Aw/6MfP/Z
</binary><binary id="_43.jpg" content-type="image/jpeg">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
mdK/wC2rR/0Yv6df//Z
</binary><binary id="_90.jpg" content-type="image/jpeg">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
EHYxsGd2WNMly38fGMnP8A/9k=
</binary><binary id="_140.jpg" content-type="image/jpeg">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
pSlKUpSlf/9k=
</binary><binary id="_77.jpg" content-type="image/jpeg">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
</binary><binary id="_185.jpg" content-type="image/jpeg">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
</binary><binary id="_0.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAgEAyADIAAD/7QG4UGhvdG9zaG9wIDMuMAA4QklNA+kAAAAAAHgAAwA
AAEgASAAAAAAC2AIo/+H/4gL5AkYDRwUoA/wAAgAAAEgASAAAAAAC2AIoAAEAAABkAAAAAQ
ADAwMAAAABJw8AAQABAAAAAAAAAAAAAAAAaAgAGQGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAA4QklNA+0AAAAAABAAyAAAAAEAAQDIAAAAAQABOEJJTQPzAAAAAAAIAAAA
AAAAAAA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAA
AAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAA
AAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////
////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////
////////////////////////A+gAADhCSU0EBgAAAAAAAgAE/+4ADkFkb2JlAGQAAAAAAf/
bAIQABgQEBAUEBgUFBgkGBQYJCwgGBggLDAoKCwoKDBAMDAwMDAwQDAwMDAwMDAwMDAwMDA
wMDAwMDAwMDAwMDAwMDAEHBwcNDA0YEBAYFA4ODhQUDg4ODhQRDAwMDAwREQwMDAwMDBEMD
AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgCQwGQAwERAAIRAQMRAf/EAaIAAAAH
AQEBAQEAAAAAAAAAAAQFAwIGAQAHCAkKCwEAAgIDAQEBAQEAAAAAAAAAAQACAwQFBgcICQo
LEAACAQMDAgQCBgcDBAIGAnMBAgMRBAAFIRIxQVEGE2EicYEUMpGhBxWxQiPBUtHhMxZi8C
RygvElQzRTkqKyY3PCNUQnk6OzNhdUZHTD0uIIJoMJChgZhJRFRqS0VtNVKBry4/PE1OT0Z
XWFlaW1xdXl9WZ2hpamtsbW5vY3R1dnd4eXp7fH1+f3OEhYaHiImKi4yNjo+Ck5SVlpeYmZ
qbnJ2en5KjpKWmp6ipqqusra6voRAAICAQIDBQUEBQYECAMDbQEAAhEDBCESMUEFURNhIgZ
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
4wIba7B5fVmBCsonDLPY3H946yelI3rcJJmXeFLDfOH5hef/KGj6vrOj31rN5Y0rVzpEFlr
CtPfSPGKTJ6qNG31cEfuOfr3Xo/vpW9PJCET/WriWmOXepx+atL1HWPKkFrp+lFLW8m1LUJ
VtdO0+SWFf8AQI2iWT1LlJ2Zmiji/a+P95MqZZGdALaO8tfmMsUOo6DFNaTmW2mj1SKyuEu
LdRNCBHd2rJRnjUBxc81WaDh+8j+xkjC91D5yjttT0TXtYgvLwJc6IjIYJyT9YWOdI/SQ1I
FUczJv+zmDqtMM0TGR+n6XZdldqZNFnGSH+fD+HJD+b/xLMLW5iureO4hblFKoZT8+3zGch
kxmMiDzD7hpdTDPjjkgbhMcQZx+Tl6dO/MGDVpbF72y06yuJbtoQ0k9ukrRwG5SFAzzLEJK
SqnxrC7yLy4cc3HY0L4+/Z4T29nLhxR/hucv870vpAaH5X80XVp5o0+9a4V7Z7UXdhODBcW
zkkxyceQYKxb7PCRW+Fv5c3ImY7PnFsOtvLnk/Qr2Cy8rJf6/rWnsqraQTo0ELCZbj/S7lk
9G3UyRqXTl63++4Piy0ykR6qiFvvZD/gzzbrFLnzF5ovLGVlFNL8vuLS1i33HryI91cN4yM
0X+REmV8YHIf6ZbYX+eHkq/sfy6vryDzHqN3BZy2kz2OpNHdq5FwkYMcpRJoZKSNVubo6/D
w/ayvORPHIED6Zf8U7HsjLOGqxyj9XiR/wB08BPU5xxfenVAFTsB1OKLcCCKjcHocVBtmv5
TeRR5s167knQTWmh24vfqh/4+Lpi31WFv+K/UjZ5P5uKJ+02bjsjCOLxD/CeH/ingfbntKU
IR08eWX15P6sD6Yf6b6mC2kbx2sMcgZZI0VJFcUYMoowYHowIoc12oiRkkD3l7Ls6Ylp8ZB
4h4cN/81OtW8sHRvLXlzXqNHZ+YbeedpJG+ATRXDAMOW6rNbNBIv7P282Ot037uEgPVQhP/
AEv/AEm8p7Pdsxlqc+KUrx8cs2Kcvp4eL1sWvvM2jWiEtcCVx/uuH4z+Hwj78xMWgyz6UO+
Tudb7S6LTjeYyS/mYv3kv+I/2SSDVtS166hso4jaafdzpam4Joql2FTK+3wiPk3AMn+tm80
nZccZuQ45f7l8+7Y9rM+rBxwHg4T/ysn/Xl/vYvtb8lrfy/pfkuw0Ow1S1vr2BWnuooZ4pZ
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
</binary><binary id="_44.jpg" content-type="image/jpeg">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
3y1zH8N8vbJC3PevvuI31r+tfZ+/X/9k=
</binary><binary id="_81.jpg" content-type="image/jpeg">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
jIDc8Adu/z2UqiIiIiIiIiIiIiIv/2Q==
</binary><binary id="_179.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCABIAMABAREA/8QAGg
ABAQEBAQEBAAAAAAAAAAAAAAUDBgQCB//EADMQAAICAgIBAgMGBwACAwAAAAECAwQFEQASI
QYTIjFBFBZUYZXTFSMyNlF1s1JxJEKR/9oACAEBAAA/AP1bO35cbiJZ66o1l2SCuJASnuyO
scZbXnr2dd6863rzyRn7s/p+jThaxkUot7jXctFELMsGh32y9WCqx7bYIVUDqFUFSumCykd
SArlPVdHJrftsMXOZIUaaPSr0AQBXYP2B673sfLehfmMqwSGBEeUKTGjuVVm14BIB0N/XR/
8AR5yFer6jb1UMPJ6lyMleDGpYs20iqL2mdyqKqGElV1HIfm30Gxr4vS+WZvR1bMxZitkZ8
OqTX5KU4eKcpH/PX4dAnqzMqnqOwjJ0OUPWf9j57/W2P+bc+/UN+1Ugp1aKv9qyNtKsbqF/
lKQXkf4vG1jSQjwfiC+D8uTM/lGxFurRsXb2IxSwLrKRoJwZOwQRyySK/tjRU9nHxE/1DqQ
3twGREFKljst6ho5HKzq8sTxuiNaiLMUdUGvHQD5bHg+TrfKeSjuy46eLHzJBakXpHM42Ii
fHfWj2KjyFPgkAEjexyUVb1ReyXqGnU9RXo1x6xw0pplqFZbDRe43cCDYUd4h4H+fJ+Qr5u
7JBawWZpWZpqL2VrzrXkRopYpwFjcg/PUvtaKnYVm+YJ50HIuatTy5TG4SuJkF73ZLM0TBG
jgjUdtNvYZneJdqNgMxBUgMJPqDNzQ5exRuZmz6aiCqtG6a8b17DsjMS8jqVUqVI9slCdb2
3YdbmIvp7cGJu5SnZzVeshuxRSr37dV7P0GiFJII8D+oc3ysF+1VWDH2/sbvKvuWAFZ40B2
3VWUqWOuvnwOxbzrR5LH2M4ad7KXvUs1OpTy5gjN5qqxS145VjkLssQIZiJQBtfPUfmbU92
SH1XibUFmaxjMvWeuBHIjwiVR7sTj6/EgmBK7B0m/kDzoOOOOSPVFK7e9P2I8d0N2Fo7NdH
G1kkikWVUPkeGKBd7Gt75iY8nkbZyuEzVaOrPAkRgtU5JQjoz9iAJE6NturAjYKAHWtci5P
0tNWlvLj6D25b+PFaC8WjD1bHuyytM5JUqDJKkn8sHRTwo6qOdPirGQsPf+2xoscdt0qusT
Rl4gF8kMSdhu678BgoYDRHOff0fk2i9TyyZCjPaz9QwsUqSQhXEXtx+TK+lA2T8O9sfPgDm
F2pNJUyNOPGPios5BDi61NzGCr9ZRJN1jZk0sGiB2BYQBfHw7u+s/7Hz3+tsf8ANuPUte0Y
8dkKa93xt5LDxiMuXiKtFLoA77BJGYAbJKgAHeufC08vYs2LeP8AUFb+H32SaP8A+KZnjQx
ov8qT3OgB69htCNsSQ31kp6Zkx2Qlq47Fe2kl6nPXvo6agghSKMxMxb3OxRJVGgwIl0T8Ta
v4mbK3MEJbnsw3n9zoxrsqa7MInMRbsNr1YoWBGyDo/LwYT05Lg8dl4rZrZRchPNblhhqmM
zPJsupEkrKQR1UD4RoeSdk8n1q18+nfSnpyWH7JbT7PJbjlCuyRVejMylW6+ZBCo8k6k3rw
ddnyFmxLSzeLzfdFp1lnr3SyE+3FIFYSbB8APFGCdEBWYnQUkfDYHK2IbOPvZiGxi7Usxki
+ysJzFI7N7XumQgLpumwgPUeOp0R4sbhblTMQImO+z+zkrlyxeVowlmOb3CI/B7lttDsMoX
+T8z1XdbHS5q76fWSZ61bIOz9Heo/QoJD0YxFwylo+p6ltqT5+RHJ+JwNr0v6KXEVj9ulqa
NYVIzEzHsG2weYdvj2zDuoIJXQHg+PC4eSla9PYWGTSYmKTI3RJCiOJZhIiIAh6KpMlg6Xs
B7ajfkE9nzMCX33JdDEVUKgQ9g2zsk78gjroaGtHyd+EQlCETOjt2YgohUddnqNEnyBoE/U
gnQ3oIRKsEYndHlCgSOiFVZteSASdDf02f/Z5J+6mO/E5f9Zt/u8fdTHficv+s2/3ePupjv
xOX/Wbf7vH3Ux34nL/AKzb/d4+6mO/E5f9Zt/u8fdTHficv+s2/wB3kn1Z6aoQejs1MljKF
o8fOwD5a06kiNj5VpCCPyI0ee3I4PE4yk1qafNOAyRoiZm32kd2CIo3KBssyjZIA35IGzzy
2cZSq+1XEGdu32iEktWlnLLe0D47F5JkHXsCBvRbRIHwtr7wWMxOexEWRh+8FZZGdDDay1t
JUZHZGDKJTo7U+Ob5LB4nF46e7NPmnWFdiOPM2y8jfJUUGUbZiQoH1JA+vOfnv4uu+RSTD+
q+2LgE9xVzpYwoQzAnVv56QnXz1rx5G7N3EUKWXxtJlzTxZBpIhYXOWtRyKhdVKmXZDKsnk
fIqB9dih91Md+Jy/wCs2/3eeLJ4XHUI4Vjky81q1L7NaE5u2od+rN5b3D1UKrMTonSnQY6U
+bJU8bRedKtT1NlGrL2sLRy9hjF47BT2nXsxHnqu20RsDsu/bjMHicriqmRgnzSxW4EnjV8
zbDBWUMAdSnzo8zyuHxeLqrKTnbMskqxQ14MzZ9yVmPyUNMB4G2PnwqsT4B5Gr3MTYkkH8N
9UpFBejoTzHOuyQzOyKFPW0SdGRQdA68j5gjlY4ignqNMQ65oLLUazDZGctFWKuFdCPd2CO
8ZB+R7H5a80PupjvxOX/Wbf7vH3Ux34nL/rNv8Ad4+6mO/E5f8AWbf7vH3Ux34nL/rNv93l
rjjjjjkX1n/Y+e/1tj/m3MfVIgFz07Nbh9yvFl07ExF1RmilSMnQOv5rRgH6EjyOT80KN7N
ztLQzVPK02WGnexsEvaeMiOTqZOnslS+1KyEqNEnrs6oUp8zWzmHx+RuQze5iJXsiOLXexG
0AZ+3j4T7jaAVfrvfgLTqZanexbZKsZnrr7mx9nkEm0Yqw9sr37AqRrW9j5c5/0k1m5N6jv
tV+x3rt5mhknx80X8lUEcBYOFL+ELFVbx3/APqToY2rf8T9FelbF5ftN+5Zxs0bCHsxl7JJ
Iw6jS6jWUk+ABsc7PnP5QQL65wEtiHt2rXIq8hiLBZj7TABtaVjGkv8AjYDDkXIRjI3rVrE
1sviPUjSyQLLDXlWvP7ZkSN5mdPZdOpD78sBoKSQAejqWrrercnSmnR6sVSrNBGsfUoXaZW
2dnsSYx/gAaGvmTvFnKM+IOUh+0yVgzIQlSUyhlcow9oL32GBBHXxon5c5z0st37iSzyRTY
7J2LMtq8YKbxSKzy+4/VZImMjBCFHwtsr1DeOwzpT3bsvox8xWf+Me/ZlLPV6SLXEMqd3Cl
hGW7wdl3/UwGvGh2/MxKpneEB+yKrElCF0SQNNrRPwnYB2PG/mNopVmQugcAMy/GhU7BIPg
geNjwfkRojYIPEMqzwRzIHCyKGAdCjAEb8qwBB/IjY5pxxxxxyL6z/sfPf62x/wA25TuU4L
9V61mPvE+tgEqQQdggjyrAgEEaIIBBBHPuGNooI43meZkUKZHADOQPmeoA2fyAH5cxkxmPl
yMeRko1nuwr0jstEplRfPgNrYHxHx+Z/wA8+6dOChVStWj6RJvQJLEknZJJ8sxJJJOySSSS
Tz7mhiswSQTxJLFKpSSN1DK6kaIIPzBH0544cHj609N60CV4qKyCCtCipCjORtwoHhgOwBG
vEj/+XKHJ+bjpHHGW7M8AgYPFPENyxSf0qYxo7YluoXR7dupDBiD95HM4rEe3/E8nTo+7v2
/tM6x99a3rsRvWx/8Ao4q0sVJaOZqVqbWLUQ3dijUvMhA18Y8suguvOvA43jcBi9yTQ0qcH
9Us8vVQWbyWdj5ZmOySdknZJJ5Pl9QekMygx02Xwt9bDKgrPZilErbHUdSTs71of51zatHi
K/qM1YZkS7Dj41ipgALDX7sNxrrwCQA2v/CPYGhuvxxxxxxxxxyL6z/sfPf62x/zblrjjjj
jjkLJRtZ9ZYOFpnWKvBauCNQNPIojiXZI3oLPJ4BHkj/HJOXa1V/inqDGyU8tQs7r28bdjK
s5i7xGKGTRJ7SaURsrBmZipHfzQgy64XOY70ymOSKjIprUpVsEuDFCr6KOoJXrsd1ZxsANo
nQuWacFz2vtEfuCGUSopJ69h/SSPkdHyN70QD8wCOP9Oxm76PsZgVLNqXL5Q5CKC/I6Ff56
iDyisyqEjib5Muh8+vy3q5cZyz6U9QQd6zWJ7NGaASJKhX25GcBxsMBJWQqykbH/AL1zsOO
OOOOOOOORfWf9j57/AFtj/m3LXHHHHHHJeYxP22alfrpD9vxsrS1mlHwt2Qo6FgCVVlb5j5
EKdN16nSL0/hYMicjDiKMd0szmylZBKWbfY9gN7Ozs/XZ4jxEaZ+TMNO7yvB7Co0UOo02Do
OEEmtgnRYjZPj5awx3pzH0/T64WetWtVSzvJC0C+yWaQyELGdgKGPwjzoAeTrfPt/T+OTD2
MXj68OMr2d+4KleIA70G2rIUOwOp2p8cxr4BIsxRsyLC8OKo/Z6R6KHVm0JGIChV+FIwvTW
u0g1ojVrmYhiWd5xEgldVRpAo7MoJIBP1ALNofmf88RQxQIUhiSNSzOVRQAWYlmPj6kkkn6
kniGGKtBHBBEkUUShI40UKqKBoAAfIAfTmnHHHHHIvrP8AsfPf62x/zblrjjjjjjjjjjjjj
jjjjjjjjjkX1n/Y+e/1tj/m3LXHHHHHHHHHHHHHMxGwneQzOVZVURkDqpBOyPG9nY3s6+Ea
A87RRtGhV5nlJZm7OBsAkkDwB4AOh9dAbJOzxDG0UEcbzPMyKFMjgBnIHzPUAbP5AD8uf//
Z
</binary><binary id="_46.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCABJAJkBAREA/8QAGg
ABAAMBAQEAAAAAAAAAAAAAAAQFBgMCB//EADkQAAEDAwMBBAgEBQUBAAAAAAECAwQABREGE
iETFBYiVjFBUVWUldLUBxUykSM2YXGBJENidbPB/9oACAEBAAA/APs1KUpSlKUrOausNv1K
IVpmw40gPqc6jiikPx2ggkuNEnIIc6IOARhWCCDWbtt+hSJB1Fd4vUuOmbQWrgW2UOvl9Ti
kLHg4TtLDhHONr5J2jOfo9KUpSlKx85d0un4kM2/pzo9rt0RD6no0kNhbq3NyStIX42yGVt
4KScqVxghQ00+4M21hLz6JK0qVtAjxnH1ZwT+ltKiBx6cY/eosPUEKdKRGZYuKVrzgvWyS0
jgZ5UtASPR6zXe43m1Wjp/mdzhwernp9pfS3vxjONxGcZH7ioXfPSvmW0fHNfVTvnpXzLaP
jmvqp3z0r5ltHxzX1U756V8y2j45r6qd89K+ZbR8c19VO+elfMto+Oa+qozmotHuXFuerVM
EOtJ2pSm8bWiOfS2F7FHk8kE+j2CoV3uuk59mu8GHqqyxHbslSX3ly0OjKm0tk7eoOdiQBg
gZAODzmzZ1jptLDYf1TZVuhIDi0TG0pUrHJAKzgZ9WT/c17756V8y2j45r6qd89K+ZbR8c1
9VO+elfMto+Oa+qnfPSvmW0fHNfVTvnpXzLaPjmvqp3z0r5ltHxzX1U756V8y2j45r6q8ac
hzTJuF5ucRcSZcVNDs65HVLDaGwAjIJTjqF1Q2+kLBODkCzn2y33VhLFxgxprSVbw3IaS4k
KwRnCgecE8/1qLD0zYLfKRKhWO3RZDedjrMRtC05GDggZHBI/zVpSlKUpSlV97nTbdbjJgx
Y0p0KCQ1IldnCyeEpSopUNylFKQDgEq9IqsjapkTYlgkxragC6vqjyEPvLaXEcSlanE7S34
iktOJ528geo5GjpSlKUpSubzqWGHHlhZS2kqIQgrUQBnhKQST/QDJqmjazsUpcMIfktpnKS
iK7IgvstPKUCUhK1oCSSBwM8+rNXtc3HmmltocdQhTytjaVKAK1YKsD2nCScewH2V0pSlKq
7wlx9yDG/LnpcdUlDjymygBrYoKQokuIIwsJVwF5CFDHIqjGnJFvv94nKnojWoxH3GFuqWA
w4+UqfJV1AUpSpkOcbOXlYIxU3Q65T1kekOyFvRXpbq4IcmplrbYzgJU6kkKO4LP6lEAhJU
cVo6UpSlKVnPxAvjWn9E3OWt9bLrjCmI6m1hK+qsFKSnkcgndxyAkn1VCSq33G3WXT2nLnG
nxoL8YyXm1pfLTDGFp3KSQkKUtttPtIKiEkJOLy0XGVNmXdiU0y32Gd0Gukoq3I6TbgKiQP
EepyAMD0c4yaa/wAi/i92QItluUhNyc7OTcHAXP8ATP43Do+Dw5PBVyAPXkaaGuUuKhU1ll
mQc722XS6gc8YUUpJ4x6h/9qs7Vqr3NaPmrv29O1aq9zWj5q79vTtWqvc1o+au/b07Vqr3N
aPmrv29O1aq9zWj5q79vTtWqvc1o+au/b07Vqr3NaPmrv29O1aq9zWj5q79vTtWqvc1o+au
/b07Vqr3NaPmrv29O1aq9zWj5q79vV1SlKUqFBtMO3SpkmMHg7Od6r5ckOOBSsYyApRCeMD
w44CR6AMSXGWnVtrcaQtTKt7alJBKFYKcj2HCiM+wn210pSlKUqr1IhDmnZqFRYctamsMR5
oSWnnv9pCgogHK9oHI5IrE/ltshzW/w+fjoXG/NGZdvRK6bmyNtU8sJH6lDqMvNHdyEujJU
Dg7q3Xhq4y5cTs0mM/EV4kSEBJWjctCXE4J8Ki2vGcHAzjBBNhSlKUpSlKVnLldrmvWLFgt
k6CypVvXMdEiE46pIDiUJ5DiBhW5XHpGz/kMTLBPuEsXCNc0xu1W+WY6nIwUEOpKEOJUEqy
Una4kEZPIPNW9QrVcfzOG5I6XS2SX2Nu7dnpOrbz6PXszj1ZxzU2lRZ9vZuTCWX1yUJSrcD
HkuMKzgj9Takkjn0Zx+1e1w2Fzmpqm8yGWltIXk8JWUlQx6OShP7f3qmsum5UC8O3a4XBmV
MdjIjuuRoxjiRtxhbqd6kqWMYBATgKUORgJ0FKUpSlKUpWVZhasi6ou90Ee1yo0xLLMZtc5
bSmW29/pwwclRcUr+mcZIxVZqLSbKbbEgR20KuUyW46ZyYLh6DzrqVrfSppBUhSSAEBTiRt
AClKCK2c+3s3JhLL65KEpVuBjyXGFZwR+ptSSRz6M4/aqbTOmUWppTzypyX0y5S0IXcXnEF
CnnCglBWUklCknJGcnJ8Waazj2WJZJl+uNktdxdhMZHbkIG5IP6AtSVYJJO0Y5UQOM5qrRZ
rZGu8GFddBafZanqW01IiBt4IcSgrCVJU0ggFKF4IzynBxnNXvczSvlq0fAtfTUZzTmkG7r
Htx0xa+rIYdfSoQGtoS2ptJB49OXE4/sf8ye5mlfLVo+Ba+mnczSvlq0fAtfTXaHpmwW+Ui
VCsduiyG87HWYjaFpyMHBAyOCR/mrSlKUpSlKUpSsxrli5zrfBgwLN+Zx3ZzLk5BLWOg2tK
1JAWtIKlFIGORjdnHFdy25cLpGvd0jPWqJaWnVIalSEcrUkAuq6aygJSjeASSf4i+E4BU0v
cJ7j1xtF1eeem251ADzzCWlSGlIBDo2eDaVh0ADkBICvEDmFIsF0OqoCxqK7qQIMkGR0Y38
MlbGEZ6O3xYJ5GfBxjnOjehKftTkFcySFOMFoykKCHgSnG8FIACvXkDAPqr2/G670ZzrvN9
ndLm1teEueBSdqx60+LOPalJ9VERts52V13j1GkN9Ir/hp2lR3AepR34J9YSn2V3pSlKUpS
lKUpVLrP8Ake/f9bI/81VjPwF/keZ/2S//ADar6bSlKV//2Q==
</binary><binary id="_176.jpg" content-type="image/jpeg">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
k=
</binary><binary id="_101.jpg" content-type="image/jpeg">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
</binary><binary id="_79.jpg" content-type="image/jpeg">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
niSWKVSkkbqGV1IwQQfcEfFUpSlKV//Z
</binary><binary id="_47.jpg" content-type="image/jpeg">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
</binary><binary id="_63.jpg" content-type="image/jpeg">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
AEKO8+cNqUKyCE7lfQ6UpSlKUpSlKV/9k=
</binary><binary id="_163.jpg" content-type="image/jpeg">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
l0g4ZKEFzCC2nKRyQrOVAmtHChsW+CxCit9OPGaS00jJO1KRgDJ5PA9dcbtcfJsFTrbXaJK
8ojRgraqQ7glKAcHGcHJ8EgFRwATXyb/o9//FP/AKD/APpX2asZpj5T9b/YP0TWzpSlKUpW
Y+EO49g0bcEqa3NSo0hhbpVhLOWHCknj1rCUAcZKx68A3VquPlOG5I6XS2SX2Nu7dnpOrbz
4evZnHqzjmptKUpSlKUpSlKUpSlVD2mba8+48FTmC4orUiNcZDCNxOSQhCwkEnJJA5JJPJN
ePNS3fSbv+cy/e081Ld9Ju/wCcy/e081Ld9Ju/5zL97TzUt30m7/nMv3tPNS3fSbv+cy/e0
81Ld9Ju/wCcy/e1WaZsEW4aVtM2VMu7kiTBZddX5YljcpSAScBzA5Pqqz81Ld9Ju/5zL97T
zUt30m7/AJzL97TzUt30m7/nMv3tPNS3fSbv+cy/e081Ld9Ju/5zL97TzUt30m7/AJzL97U
qBY4NtfU+z2lx0p2ByVLdkKSkkEhJcUraCQMgYztGc4GLClYzTHyn63+wfomtnSqXzjL/AH
7ZZrjco/qkMBpttX/hLq0FacYIUkFJB4J5w8u3H2Tu/wB7E9/Ty7cfZO7/AHsT39PLtx9k7
v8AexPf08u3H2Tu/wB7E9/Ty7cfZO7/AHsT39U2sE3HU+lLhZhpe7trktfFqL8QALSQpGT1
j3dyRnjOM4qZZplxtFjgWzzYu73Y4zbHU3xE79iQnOO0HGceGam+Xbj7J3f72J7+nl24+yd
3+9ie/p5duPsnd/vYnv6eXbj7J3f72J7+nl24+yd3+9ie/p5duPsnd/vYnv67Q7/FkSkQpL
b1vnLzsiywErcwMnYoEocwOTsUrbkbsHirSlKUpSlKUpSlKUpSqXRn9x7D/wANj/ppq6pSl
KUpSsZpj5T9b/YP0TWzql1D8c/Z4DneizpxZktHwdQGHnNp/wB0qQnI8CMg5BIPHU+pJVh/
stvZmbIMma71ZJZ2oZ2ZCcIVlR6nGcDjxqsb19Mk3C7tRNOPPRLe7IitPiU2FyJLSCstBr0
ucHBTuPgceO2TYtfW7Ul7Nutja3ElKn0PrSttLkdISnqJCkjJ6qlIx/3azkcA9/OxTOpH7H
OgojOMJMpT5kgtdiCVfHkkDBC0hCkHw3ZBUATUKDqWRe5FndCERk+VOkoR5C1ofbVAW+k95
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
BmT1EJcbTHUVMowEBCkpJUe+lWScnOE46N6It6bJItLkyc60/b2repwupQsNNlwowUJHIDh
ByCCAAQeckaKidifiv3GdJD7ExhS3C0FBMlSVukbUAZ3JyOONx8RgDnP0HbblFuEGTOuJgT
3VvqhiRhtp1RyVp43ellWxRKNxJ2+GLNyxokWObapc6ZKE5pxt591aeoQtO07QEhCcDGAEg
Z5IJJJjW7Ske3TUyPKE6SlD65KGH1oKEPrSUrcGEggq3OEpzsy4ohI4x4umlTdtQRbm/eJi
WY2CmGlDWzIcZcA3bN23cykkEkn1FIyDYLtI3znmJsmPJmqQTIQEKW0lIACEb0qATwo4IPL
iyME17tlsRbW3vj3pL0h3qvvvbd7qtqUgkJCUjCUJHAHo/PkmbSqu+XbydFDMZbKrnK+LhR
3DnqLJA3FIO4oTuCllPISCaw3+gXSv8AELv9817uvptYzTHyn63+wfomtnSlKUpSlKUpSlK
UpSlKpfM3TA/q9P25o/7TMZDaiPWCUgEpIyCPBQJBBBIqVA0/ZbU+p+3WiDCdUnYXI8ZDai
nIOMpA4yBx9VWFKUpVXM05aZspctcToy3MdSVFcXHeWAMAKcbKVFPA4JxwOOBXHzUt30m7/
nMv3tPNS3fSbv8AnMv3tPNS3fSbv+cy/e081Ld9Ju/5zL97TzUt30m7/nMv3tPNS3fSbv8A
nMv3tVmmbBFuGlbTNlTLu5IkwWXXV+WJY3KUgEnAcwOT6qs/NS3fSbv+cy/e081Ld9Ju/wC
cy/e081Ld9Ju/5zL97TzUt30m7/nMv3tPNS3fSbv+cy/e081Ld9Ju/wCcy/e1Nt1nttp6hg
QmWFvY6zqU/GPEZ5Ws95auScqJJJJzzU2lYzTHyn63+wfomtnSlKUpSlKUpSlKUpSlV8+9w
oD6YpUuRNWnc3Djp6jygSQFbR6KcjG9WEA+KhUXyjqGR34un2WUDgpuE8NOE/OA0h1O36yo
HOePAl5cnxOLnYJjaU/1kiEpMpofNtCcPK9QPxXBz/hG6rCBcoV0YU9CkIeShWxwDhTawAS
haTylQyMpIBHrFSqUpSlKUpSqXRn9x7D/AMNj/ppq6pSlKUpSsZpj5T9b/YP0TWzpSlKUpS
lKUpSlKUpVXOmPyJxtFvc6UjpJdkSCAeztqKgkpB4UtRQoJ4KRtJVnASuVAtsK1sKZhR0Mp
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
UpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSv/9k=
</binary><binary id="_48.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCABGAJIBAREA/8QAGg
ABAQADAQEAAAAAAAAAAAAAAAUCAwQGB//EADQQAAEDAwMBBAgHAAMAAAAAAAECAwQABREGE
iExExRBVRUWIlaUldLUIzJRYYGT0wckcf/aAAgBAQAAPwD7E080+grZdQ4kKUgqQoEBSSUq
HHiCCCPAg1spSlKUpSla3nFNMOOIZW8pCSoNoIClkDoNxAyf3IH715PQenGLKbk+vT67bKk
y3nUuOiOcNLWShpBbUSlKUpRlJ43E4z4ewpSlKV8/sN1TaLdeSL1MnOwfSb7zRaYcbjlEhZ
BWEBCgtfKgkqAUAvG0AYkq10s2S8Qp2pYzM5u3onwHWZ7Ly+1SVEslaG0Nk5Q2C3gkhauVA
+z6zSOo4lyuV3tKNQIu7sR9K2XCWipTCmmzkFtKUqAcKwSBkcA9Rnm01d3rxrG8pb1YzOgR
nU9zhsLjqK0ltJWVbUbihKnEpSQrqkhRPjZ1DJvsfu/oSL2+7d2v/XQ7jpj80hrHj03fx46
bBM1LInLReYfYxw0SlXdW2sqyMDKZTp6Z42j/AN8DQns3px9Jt1wgx2tuCiRCW8oqyecpdR
xjHGP5rl7rqrzm0fKnfuKd11V5zaPlTv3FO66q85tHyp37inddVec2j5U79xTuuqvObR8qd
+4p3XVXnNo+VO/cU7rqrzm0fKnfuKnxbneZl1kWpq/2tM2Oneth2ySGlFG4p3p3PjenII3J
yOnPIqh3XVXnNo+VO/cU7rqrzm0fKnfuKd11V5zaPlTv3FO66q85tHyp37irVKUpSlKUpSl
efcv119c1WCPZ2XI6IyJS5qpSkhKFLKcbQ2RvylZCd2CE9RzjO2WR1jUc26yWUNgpLURDUo
qQhCllbh7MNoCVLUEqUSVknxAHN2lKUpSlKVF1LJuUNiHIgymWWu/RmpCVsb1uJcfbQQlW4
BPClZylXXjB5q1SlKUqWxp63x7wu7NmZ3tz86lTn1IUPawNhXt2jerAxgZ4AqpSlKUpSlKV
I1Da7hdozDEKdGiJbfbfWXoqnipTbiHEAYcTgZRz1yDxiu12C1Otwh3VmNNStKQ8hbILTih
g52KKsDIyASccc1xM6T03GfbfY09a2nWlBbbiITaVIUDkEEDgg+Nds+2W+6sJYuMGNNaSre
G5DSXEhWCM4UDzgnn96n+pmlfdq0fAtfTT1M0r7tWj4Fr6aepmlfdq0fAtfTT1M0r7tWj4F
r6aepmlfdq0fAtfTUbVdgsFnsbk+LY9ORexypx6bbG1tIASojdtKVDKtqRtCjlQwk54oWzS
+m51qiTH9IWuI7IYQ45HXBb3NKUkEoOUjkE46DpXT6maV92rR8C19NVmWWozDbDDSGmmkhD
baEhKUJAwAAOgA8K2UpSlKUpWt55qMw4++6hpppJW44tQSlCQMkknoAPGsIc2LcIqJUKSzK
juZ2OsuBaFYODgjg8gj+K30pULWjrjekrgiOJxlOsLTG7ih5Toe2ko5aGUjcBycDwPXFYWe
yxX9MxYzs27v4wtx96TLjvOOAbVKIUoLSkkE7Py85A8a9BSlKUpSlKUqXf3YCLe23OkMsl+
SyiKXQpQMjeC17KSCrC0pJAI4ByQMmuDRkV2Axd4cmUuRKbujy31DIaSpwJdAaSSSlO1xJI
JOFFfJ6np9O3H3Tu/9sT/AHqg7LebtwlIt0l10pSruiFN9qCcZGSsIyM8+1jg4J4qf6duPu
nd/wC2J/vT07cfdO7/ANsT/enp24+6d3/tif709O3H3Tu/9sT/AHrNm8z3X2216YujKVqCS
4tyKUoBPU7XicD9gT+1V6UpSlKUpWiZCi3CKuLNjMyo7mN7TzYWhWDkZB4PIB/ikOFFt8VE
WFGZix287GmWwhCcnJwBwOST/Nb64rzcfRFjn3Psu27nGcf7Pdt37ElWM4OM464rOBLemMK
cft0mAoK2huQpsqIwOfw1qGOf1zx0rqpWtp1LyCtAWAFKT7aCk5BIPBA4yOD0IwRkEGtlKU
pSlKUpSlKl6mk9z0rdpXYMv9hBec7J9G5tzCCdqh4pOMEfpUD/AI9uVqvfpC6afhej7Srso
6YnZJaw+jcpxexBKfaS40M5ydmDwBV+ZapsmUt5nUNxiIVjDLLcYoTxjje0pXPXknrXVAiP
Q2FNv3GTPUVbg5IS2FAYHH4aEjHH6Z561udaS8gIWVgBSVewspOQQRyCOMjkdCMg5BIoS72
6AEILRSoqWVncFZGABjkEbsnIxgcHPGyv/9k=
</binary><binary id="_111.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAATAM8BAREA/8QAGg
ABAQEBAQEBAAAAAAAAAAAAAAUDBgcCBP/EADAQAAIBAwMCAwUJAQAAAAAAAAECAwQFEQAGE
hMhFDFBFRYiI4EHJDJRVmFxlNIz/9oACAEBAAA/APZtNNNNNNNS3vkA3VFt9RyqGoXrHOSO
Ch1RfTB5Et69uHl3GqmmmmmmmmmmmuYttmtW4vF3i6Wyjr/FVL+FNVAs3TgTEacGYHKPwMo
x2+acZ8zP3Tb9t7aohX+5llqaWJTJUsaeOJkQMi/BmPgzfH2RnUtjC574u+5m1f01aP6MX+
dY0m2NnV0LTU23bQ6LLJET7PjHxI5Rh3X0ZSPprb3M2r+mrR/Ri/zqFNb9t0u6qazT7Msog
rWeOnqFp4+ZdIxIcxtGuVwSOaFwCADgnA021EareN5rpKm+9FpVehp6tKyKFF6a9RgJMIcu
7AIR8PDKjHlZ3DTX2o8P7Equhx5dX7wkWfLH4qeXPr5cfr6Y2Cj3LT1zveazrU5iIVfFRy4
bIwcLSxHyz35H+PUYVlnqbnvN+vPcUt0VCGJir5oEaR3wqqI+IPERuSSS3zl9AuOn15/T+1
RtyS5Qe8cV9poo0uFO3JxIeqhmeBJcws3GOQp0+2HAx3AH5a95hdVitMu64bXLBxqZJ6asm
RZuRaPAYrUAcRIGMbAZMWcgkHo7NcKmx7Kpqi60lxnqvmEwwpNVyuSzsoGRzCkY4iTBUFVY
5BOucmt99pftC2tU3UJWsrVMtXPb7XKscLyxhFDyDIcDiqAkKQqAt5516VppppprOaNpYJI
0meFnUqJEALISPMcgRkfuCP21A2ba56e0QXCvNclbVK8jQVNfUTiFHcukZWQ45KvFSeIOQf
zOfu/0e5aiuR7NWdGnEQDL4qOLLZOThqWU+WO/Ifx6nbb1NfafxHtuq6/Lj0vvCS488/hp4
senny+nrJv95vFrvtbQwyP0rjb0Ntmbp8aaqMqwYxxyV5TwuS2cYbAPkG9aTwm0aazWiS6U
UitBFSy26KolaCNXRWLGPuQIyxwx+LHbJHasbFS11La2SorFp6SVamOOpUTO7Z5AuahWkVh
kjsVYZI7YGKFfHcJIFFuqaanl5ZL1FO0ylcHthXTvnHfP01z+zob0tK7z3ChelFwrhJElE6
uzeJlBIcykAcu+OJ7dsnz1ju+41dnq6qvhauiY2t4KPoxSzxTVTt8sFFBRGVgoBYfH1sZ+D
GrNv2/HQXFK5q6pq5Y6RaRWqUhZ+C47mQIJCSQWOWIyxOPLFfTTTTTTTTTTTTTTTTTTUK/Q
xNftszmJDKlwlRZCo5KppZyQD6AlVyP2H5au6aaan1Fit1VdUuc0LvUoqL/2cIwRmZOUeeD
FWYkEgkHuO4GqGv/Z
</binary><binary id="_80.jpg" content-type="image/jpeg">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
</binary><binary id="_49.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAiAG8BAREA/8QAGg
ABAQADAQEAAAAAAAAAAAAAAAUDBAYCB//EADcQAAICAgICAgECAgQPAAAAAAECAwQFEQASB
iETMUEUIhZhBxUjUSQyNUJUVnF1gZGUlbTS0//aAAgBAQAAPwD7NxxxxxxxxzHNNFWgknnl
SKKJS8kjsFVFA2SSfoAfnnMt55XaC/LBirzLUxbZSKaQIsM8Oj00wZipfqSAyg6B2PWue7e
TTwXxBcnloJrky/G2RmqdWZ5mAVpP3ldr20oA+h1AAUaDNvP8mCz4pTVZq15a80E04V/hnY
QkH4yyN+8wyaJ/zPsHnT85LIZjJXP6Qa2AozXKVarWWzZnSp8kczGRSImZk0qmNJQHDD9x1
9r1NbETS5K3byLyuII55alaEMQAsbdJGZfosZEbR96QLoKS+8NPPYryuC9j8dbvIyrJBNMl
WaBoH11YB3QBZF7A6+x969c3cFflyWIinsKi2UZ4LAjBCfLG7RyFd++vZG1v3rW/fNX+M/F
f9ZcR/wBdF/7crQzRWYI54JUlilUPHIjBldSNggj7BH55Mw/k+Kz088OOksyNXZkmL05olR
1IDIWdAAw2P273/Llfjk/PI02EswDGvklnUQy1UlEbSRuQr6YkAEKWP2N61sb3yLjPHbd6p
mmzdm8xy0ApqtgwCaKuFYe/iXp27ySkEdvRTfsEczjFXs9hKdXJ5G9TuUmj/VNBHEFnnjKO
JAXjYFeyhh10PZDAEFRmy9K1dnw2LE1loo51t27JRf7RYCrKrELoM0pjbQC7VH0RrRu85/x
sT3shk89YhuV1u/DFWgtRCJ44Y03oprsG+WSYHZO9DX7dEsKlqhJlcPJNClg2Z7VB3iOnil
b5CxHb93SWRlIBB0EJ691JYeg/ieLydnJ3aclcyzX5pa9JoWBZmeRm/e5fQ0B+QFA983PHa
c9LDRraj+KxPLLZli2G+JpZGlMex6bqX67H3rfreuYf4Ux3+k5f/vNv/wCvKfwPDR/T1ZOr
pF0ieftLogaBbbdn/nttn+/88meN4S1hIbcdm1TsfqbMlktXpmBi8jszFiXbt9gD6ICge+Z
rnjOAyFp7V3B461Yk13lmqRu7aGhskbPoAf8ADm1QxmPxUDQY6jWpRM3cx14ljUtoDelA96
A9/wAuclksRhYPI4MLjvDfGbUstR7R+fpCyKrqvtVhf0Sw0fz1b+73tYPBeO5OO3Hc8MxFK
3SstXmiFaGVCequrK3UbUo6n2ARsgj1z3msH4hhqSTP4zhWlnnjrV4mqRJ8ssjBVXfU+tnZ
0CQoY6Otc3YfC/G1gjE/juFeUKBI6Y6NVZteyAQdDf42f9p5MqYPxt/KMhhbXjPj6mKCK1U
6VI+8kTdlbspX7V0PsetOn0fvsOOOOOOOOOcfC+ag82y+VseLWbEDQQ1KM8D1u5jQuzlu0o
IDMwI1rYVdgEcW8Lar45KxkezZvZB8hk6cE6tJai+jCnykAxruCNv8QFFI0C3UzMJUr4zAY
HL1MY9arbzz3XiQoCkdkSwwN17aA6ywAqv0N+vR5Q8h8fizXnOKuXPGZrlSjFLHJORWaOUv
0Cdld+zIm5TrWw2iAd+60kjT+fV40hfrSxcrTSEjqDNLH0A97J/weTfrQ9e/fLvHHHHHHHH
HNLI4bFZf4/6zxlO98W/j/UwLJ03reuwOt6H/ACHNmaGKzBJBPEksUqlJI3UMrqRogg/YI/
HJnic0tnw7CzzyvLLLj4HkkdizOxjUkkn7JP554wX+V/I/95J/4lfn/9k=
</binary><binary id="_58.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAAiAFkBAREA/8QAGg
AAAgMBAQAAAAAAAAAAAAAAAAUDBAYCB//EADgQAAIBAwMCAwcCAQ0AAAAAAAECAwQFEQAGE
hMhFCIxFRYyQVaU0iNRJQcXJDZCYWNxdYGCkbP/2gAIAQEAAD8A38dzSmt933XVwTVPhZai
JIouJeCCFzG4XkVHmaJpD6E5VfNwXUkO8o3KrPZLpSMWpQUnWEMq1DtHG5AkJA5Lgj4hkdv
XE1VumOlgq5PZddK1JcEoHjTo8i7hODDMgHFurH88jl3AwcUv5wrSlqjr6mnqaQzLDJBBUP
DG0qSqzRtzMnTUERydmdT5MYyVB4X+US3T2JrzR2y41tPFUmlmWmWJ3il5KqrjqYfkXXBjL
A5+WntDcK6pt01TVWapo542cJStLE7yqPhIKtxBYY7EjByM48xq23cZudcaRLNcYTHkVDzC
ILTsCwCNhySxChhxDeWRG9GB0bZ/o1PWWhe8VpqfCwt/hdNJI1/4pIqZJJPDke5060azjby
jS61VC1kugWkq4aSaqKw9EPKyhCD1MkHmhOASAwyBrR6zCWKSSlvW3KqorEo7lLNPBURKh4
RSkGWLkVIDc2kxyGeLjiSVbjPVbSWsqJ6ia9XEyzRUyFgIBxMEgkjcfp/Fz5E5yDzIxgLjh
tn9SCqjfcF0ZqqrhrJJCtPy6kQXjjEWMfpx5GP7A/dswQbBpKeCJFvF0MtMtOlLUc4lemWE
OEC8YwGBWV1IcNkN31an2mZ7elI24Lv2qfFSStJFI8kgdZE+OMhVVkGFQKv7g5056EngfD+
Lm6vS4eJwnUzjHPHHjy+fw4z8sdtJrbtCG2Xw3iO7XGWpkiMdUJXj41fmZlaQBBll5cVIxh
VVR2yDZ27DL4SouNRE8M90nNW0LqVMSlVSNSp7hhGich38/LBxjXdZuawW+qelrb5bqWojx
zimq40dcjIyCcjsQf8AfVqgudvusDT26upq2JW4GSnlWRQ2AcZUnvgjt/fpTU7SWp8b/Grj
H42uirW4CDyPHx4Bcxnyjpx+uT+mO/duWg1krfYtq3S6V0dLtyxNSW+U00rCiiZnn4qxAIG
AqhsHOSWJHl4+aaDb+0p7xWWz3St0ctJFFKXehg4SLJzAK4yexjYHIHp8x31d9zNq/TVo+x
i/HR7mbV+mrR9jF+Oj3M2r9NWj7GL8dHuZtX6atH2MX46Pczav01aPsYvx1W2StvNollprZ
a6CtSeSlr0tqKqdWJ2Q+gBwfiAbuA4/zN+s2/RV1U9TNPcVd8ZENzqYk7DHZUcKPT5DVqgt
8NtgaGB6l1ZuRNRUyTtnAHxSMxA7emcf96TXqzbYoylbWbXoatqurjiklFFCzB5XCh3LYJH
JhkjJ75x66s+5m1fpq0fYxfjpFJR1ty2ffrNT0jvVU90nEtO1R0RUxvOKgoJFJ4iSGUL3xg
sQcaXzWK6SruCO0bT9iw1VNSCCNJaaMVPSlZ5UYIXVWdXKDkGUgebscarNsqU2S5Urbbrp6
aruFJItJLUUisFQgyyLHFwjiLJyTKsWbtniMnTCp23Uha2mp9r/AMLS9xVfs9JYYY6yAQrG
eKq3E4kQS8H4hgBnuSAsvG0LhVWF6en2pgSV1ZNSUnWgfwMb0zRqMs4CcpiJeMZKrj9wBrY
WKheC2XiKawvTUUs7GmtbdEgxdGMMgVXMYDOJDgkAliTjJ0o21ZKmg3UaiXaMNLRSRMaObn
C0lt88pMXZz5X5M+U+Ey8O6qOL3bMjVNTfa3ovHFUXR1iLkZcRRxwMexOBzifGe+ADjvp7o
15xW2C4Q1k0o2d7Qr2vaVntYVEDOadZlkUKZGDqwRRFw7L2JB79/R9Jajyb4oOHl61tqerj
tz4SQcM/vx6j4z6c2x6nTrRo0aNGkuzP6j2H/Taf/wA1060aNGv/2Q==
</binary><binary id="_72.jpg" content-type="image/jpeg">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
</binary><binary id="_50.jpg" content-type="image/jpeg">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
TX//Z
</binary><binary id="_91.jpg" content-type="image/jpeg">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
Ov//Z
</binary></FictionBook>
